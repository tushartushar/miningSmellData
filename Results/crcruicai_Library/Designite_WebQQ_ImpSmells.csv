Implementation smell,Namespace,Class,File,Method,Description
Long Method,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The method has 102 lines of code.
Long Method,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The method has 162 lines of code.
Long Method,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The method has 105 lines of code.
Complex Method,CWebQQ,FrmMain,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMain.cs,QQMangers_ReciveMessage,Cyclomatic complexity of the method is 14
Complex Method,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,GetFriend,Cyclomatic complexity of the method is 8
Complex Method,CWebQQ.Froms,FrmLogin,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmLogin.cs,Logon,Cyclomatic complexity of the method is 40
Complex Method,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,Cyclomatic complexity of the method is 19
Complex Method,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,Cyclomatic complexity of the method is 15
Complex Method,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,Cyclomatic complexity of the method is 10
Complex Method,CRC.Controls,ChatListItemConverter,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListItemConverter.cs,ConvertTo,Cyclomatic complexity of the method is 8
Complex Method,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,Cyclomatic complexity of the method is 14
Complex Method,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,Cyclomatic complexity of the method is 12
Complex Method,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,Cyclomatic complexity of the method is 16
Complex Method,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnMouseMove,Cyclomatic complexity of the method is 9
Complex Method,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,Cyclomatic complexity of the method is 36
Complex Method,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,Cyclomatic complexity of the method is 12
Complex Method,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,Cyclomatic complexity of the method is 39
Complex Method,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,Cyclomatic complexity of the method is 34
Complex Method,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,Cyclomatic complexity of the method is 12
Complex Method,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGradientRoundRect,Cyclomatic complexity of the method is 13
Complex Method,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,Cyclomatic complexity of the method is 15
Long Parameter List,CWebQQ,FrmMain,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMain.cs,DealFriend,The method has 5 parameters.
Long Parameter List,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,ChatListSubItem,The method has 6 parameters.
Long Parameter List,CRC.Controls,ListCellEditEventArgs,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\EditListView.cs,ListCellEditEventArgs,The method has 5 parameters.
Long Parameter List,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The method has 9 parameters.
Long Parameter List,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The method has 10 parameters.
Long Parameter List,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The method has 11 parameters.
Long Parameter List,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The method has 5 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The method has 5 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The method has 6 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The method has 7 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The method has 8 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawScrollBarTrack,The method has 5 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawScrollBarThumb,The method has 8 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawScrollBarArraw,The method has 10 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGradientRect,The method has 10 parameters.
Long Parameter List,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGradientRoundRect,The method has 12 parameters.
Long Statement,CWebQQ,FrmMain,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMain.cs,QQMangers_ReciveMessage,The length of the statement  "			if (MessageBox.Show (string.Format ("你的QQ帐号:{0} {1} {2}'\r\n是否重新登录'选择【是】'重新登录.\r\n选择【否】'将关闭QQ."' arg1' m.Reason' m.ShowReason)' "警告! QQ下线通知"' MessageBoxButtons.YesNo) == System.Windows.Forms.DialogResult.Yes) { " is 210.
Long Statement,CWebQQ.Froms,FrmLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmLogon.cs,FrmLogon_Load,The length of the statement  "		ChannelFactory<IService> factory = new ChannelFactory<IService> (BasicBinding' new EndpointAddress (new Uri (address))); " is 120.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The length of the statement  "							this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height)); " is 170.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The length of the statement  "						this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height)); " is 158.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The length of the statement  "					this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height)); " is 158.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The length of the statement  "		g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf); " is 185.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The length of the statement  "				g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11)); " is 137.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The length of the statement  "				g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11)); " is 138.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The length of the statement  "				g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11)); " is 138.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The length of the statement  "				g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11)); " is 146.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The length of the statement  "			g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5); " is 124.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The length of the statement  "		g.DrawString (subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem.Height' rectSubItem.Top + 5 + this.Font.Height); " is 120.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,ClearItemMouseOn,The length of the statement  "		this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height)); " is 158.
Long Statement,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,ClearSubItemMouseOn,The length of the statement  "		this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height)); " is 170.
Long Statement,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The length of the statement  "	BitmapData bmpData = bmp.LockBits (new Rectangle (0' 0' bmp.Width' bmp.Height)' ImageLockMode.ReadWrite' bmp.PixelFormat); " is 122.
Long Statement,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The length of the statement  "			byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]); " is 279.
Long Statement,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The length of the statement  "	this.value = (int)((double)(sliderBounds.Y - 11) / (ctrl.Height - 22 - SliderBounds.Height) * (virtualHeight - ctrl.Height)); " is 125.
Long Statement,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The length of the statement  "	this.value = (int)((double)(sliderBounds.Y - 11) / (ctrl.Height - 22 - SliderBounds.Height) * (virtualHeight - ctrl.Height)); " is 125.
Long Statement,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The length of the statement  "	sliderBounds.Y = 11 + (int)(((double)value / (virtualHeight - ctrl.Height)) * (ctrl.Height - 22 - sliderBounds.Height)); " is 120.
Long Statement,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,ClearItemMouseOn,The length of the statement  "		this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height)); " is 158.
Long Statement,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,ClearSubItemMouseOn,The length of the statement  "		this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height)); " is 170.
Long Statement,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The length of the statement  "						this.Invalidate (new Rectangle (subitem.Bounds.X' subitem.Bounds.Y - chatVScroll.Value' subitem.Bounds.Width' subitem.Bounds.Height)); " is 134.
Long Statement,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The length of the statement  "					this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height)); " is 158.
Long Statement,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The length of the statement  "				this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height)); " is 158.
Long Statement,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The length of the statement  "	//                            //   // OnMouseEnterHead(new ChatListEventArgs(this.m_mouseOnSubItem' this.selectSubItem)); " is 121.
Long Statement,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The length of the statement  "				g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height)); " is 141.
Long Statement,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The length of the statement  "				g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height)); " is 144.
Long Statement,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The length of the statement  "	using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) { " is 146.
Long Statement,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnMouseMove,The length of the statement  "		if (_histTest == HistTest.Button || (_collapsePanel != CollapsePanel.None && _spliterPanelState == SpliterPanelState.Collapsed)) { " is 130.
Long Statement,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnMouseDown,The length of the statement  "	if (collapseRect.Contains (mousePoint) || (_collapsePanel != CollapsePanel.None && _spliterPanelState == SpliterPanelState.Collapsed)) { " is 136.
Long Statement,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The length of the statement  "	RenderBackgroundInternal (g' rect' baseColor' borderColor' innerBorderColor' style' 8' 0.45f' drawBorder' drawGlass' mode); " is 123.
Long Statement,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The length of the statement  "	DrawBackgroundImage (g' backgroundImage' backColor' backgroundImageLayout' bounds' clipRect' Point.Empty' RightToLeft.No); " is 122.
Long Statement,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The length of the statement  "	DrawBackgroundImage (g' backgroundImage' backColor' backgroundImageLayout' bounds' clipRect' scrollOffset' RightToLeft.No); " is 123.
Long Statement,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The length of the statement  "			g.DrawImage (backgroundImage' destRect' rectangle3.X' rectangle3.Y' rectangle3.Width' rectangle3.Height' GraphicsUnit.Pixel); " is 125.
Long Statement,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The length of the statement  "			g.DrawImage (backgroundImage' rectangle4' rectangle5.X' rectangle5.Y' rectangle5.Width' rectangle5.Height' GraphicsUnit.Pixel); " is 127.
Long Statement,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawBackgroundImage,The length of the statement  "		g.DrawImage (backgroundImage' rect' 0' 0' backgroundImage.Width' backgroundImage.Height' GraphicsUnit.Pixel' imageAttr); " is 120.
Empty Catch Block,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,WriteKey,The method has an empty catch block.
Magic Number,CWebQQ,FrmInputCode,C:\repos\crcruicai_Library\QQSDK1.4\QQ\FrmInputCode.cs,button1_Click,The following statement contains a magic number: if (_Text.Length == 4) {  	this.DialogResult = System.Windows.Forms.DialogResult.OK;  }  
Magic Number,CWebQQ,FrmMain,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMain.cs,MessageIn,The following statement contains a magic number: if (listBoxNewMessage.Items.Count > 100) {  	listBoxNewMessage.Items.RemoveAt (100);  }  
Magic Number,CWebQQ,FrmMain,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMain.cs,MessageIn,The following statement contains a magic number: if (listBoxNewMessage.Items.Count > 100) {  	listBoxNewMessage.Items.RemoveAt (100);  }  
Magic Number,CWebQQ,FrmMain,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMain.cs,MessageIn,The following statement contains a magic number: listBoxNewMessage.Items.RemoveAt (100);  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,listView1_SelectedIndexChanged,The following statement contains a magic number: if (listView1.SelectedItems.Count > 0) {  	Person item = listView1.SelectedItems [0].Tag as Person;  	if (!item.IsLogin) {  		item = _QQManager.Login (item);  		if (item.IsLogin)  			listView1.SelectedItems [0].SubItems [2].Text = "在线";  	}  }  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,listView1_SelectedIndexChanged,The following statement contains a magic number: if (!item.IsLogin) {  	item = _QQManager.Login (item);  	if (item.IsLogin)  		listView1.SelectedItems [0].SubItems [2].Text = "在线";  }  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,listView1_SelectedIndexChanged,The following statement contains a magic number: if (item.IsLogin)  	listView1.SelectedItems [0].SubItems [2].Text = "在线";  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,listView1_SelectedIndexChanged,The following statement contains a magic number: listView1.SelectedItems [0].SubItems [2].Text = "在线";  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,buttonAutoLogin_Click,The following statement contains a magic number: for (int i = 0; i < _QQManager.PersonList.Count; i++) {  	item = _QQManager.PersonList [i];  	item = _QQManager.AutoLogin (item' image =>  {  		string num = "";  		FrmInputCode code = new FrmInputCode (image);  		if (code.ShowDialog () == System.Windows.Forms.DialogResult.OK) {  			num = code.InputText;  		}  		code.Close ();  		return num;  	});  	if (item.IsLogin) {  		listView1.Items [0].SubItems [2].Text = "在线";  	}  }  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,buttonAutoLogin_Click,The following statement contains a magic number: if (item.IsLogin) {  	listView1.Items [0].SubItems [2].Text = "在线";  }  
Magic Number,CWebQQ,FrmMulLogon,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmMulLogon.cs,buttonAutoLogin_Click,The following statement contains a magic number: listView1.Items [0].SubItems [2].Text = "在线";  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: if (_QQMap.ContainsKey (myQQ) && _SendMap.ContainsKey (myQQ)) {  	SendQueue sq = _SendMap [myQQ];  	WebQQ qq = _QQMap [myQQ];  	Task tast = new Task (() =>  {  		SendMsg sm;  		while (true) {  			if (sq.Dequeue (out sm)) {  				bool result = false;  				for (int i = 0; i < 3; i++) {  					if (qq.SendMessage (sm.FriendQQ' sm.Context' new Font ("宋体"' 12F)' Color.Black)) {  						result = true;  						break;  					}  				}  				if (!result) {  					if (SendError != null)  						SendError (myQQ' sm.FriendQQ' sm.Context);  				}  			}  			Thread.Sleep (200);  		}  	});  	tast.Start ();  }  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: if (_QQMap.ContainsKey (myQQ) && _SendMap.ContainsKey (myQQ)) {  	SendQueue sq = _SendMap [myQQ];  	WebQQ qq = _QQMap [myQQ];  	Task tast = new Task (() =>  {  		SendMsg sm;  		while (true) {  			if (sq.Dequeue (out sm)) {  				bool result = false;  				for (int i = 0; i < 3; i++) {  					if (qq.SendMessage (sm.FriendQQ' sm.Context' new Font ("宋体"' 12F)' Color.Black)) {  						result = true;  						break;  					}  				}  				if (!result) {  					if (SendError != null)  						SendError (myQQ' sm.FriendQQ' sm.Context);  				}  			}  			Thread.Sleep (200);  		}  	});  	tast.Start ();  }  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: while (true) {  	if (sq.Dequeue (out sm)) {  		bool result = false;  		for (int i = 0; i < 3; i++) {  			if (qq.SendMessage (sm.FriendQQ' sm.Context' new Font ("宋体"' 12F)' Color.Black)) {  				result = true;  				break;  			}  		}  		if (!result) {  			if (SendError != null)  				SendError (myQQ' sm.FriendQQ' sm.Context);  		}  	}  	Thread.Sleep (200);  }  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: while (true) {  	if (sq.Dequeue (out sm)) {  		bool result = false;  		for (int i = 0; i < 3; i++) {  			if (qq.SendMessage (sm.FriendQQ' sm.Context' new Font ("宋体"' 12F)' Color.Black)) {  				result = true;  				break;  			}  		}  		if (!result) {  			if (SendError != null)  				SendError (myQQ' sm.FriendQQ' sm.Context);  		}  	}  	Thread.Sleep (200);  }  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: if (sq.Dequeue (out sm)) {  	bool result = false;  	for (int i = 0; i < 3; i++) {  		if (qq.SendMessage (sm.FriendQQ' sm.Context' new Font ("宋体"' 12F)' Color.Black)) {  			result = true;  			break;  		}  	}  	if (!result) {  		if (SendError != null)  			SendError (myQQ' sm.FriendQQ' sm.Context);  	}  }  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: for (int i = 0; i < 3; i++) {  	if (qq.SendMessage (sm.FriendQQ' sm.Context' new Font ("宋体"' 12F)' Color.Black)) {  		result = true;  		break;  	}  }  
Magic Number,CWebQQ,Manager,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Manager.cs,StartTask,The following statement contains a magic number: Thread.Sleep (200);  
Magic Number,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,ReadKey,The following statement contains a magic number: try {  	object obj;  	try {  		RegistryKey runKey = Registry.LocalMachine.OpenSubKey (@"Software\QQ"' true);  		obj = runKey.GetValue ("WebQQSecond2");  		object count = runKey.GetValue ("Count3");  		int index;  		if (int.TryParse (count.ToString ()' out index)) {  			index++;  			runKey.SetValue ("Count3"' index);  		}  		runKey.Close ();  		if (index > 10)  			return false;  	}  	catch (Exception) {  		WriteKey ();  		return true;  	}  	if (obj != null) {  		DateTime t = DateTime.Parse (obj.ToString ());  		t = t.AddDays (3);  		if (t > DateTime.Now) {  			return true;  		}  	}  	return false;  }  catch (Exception) {  	return false;  }  
Magic Number,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,ReadKey,The following statement contains a magic number: try {  	object obj;  	try {  		RegistryKey runKey = Registry.LocalMachine.OpenSubKey (@"Software\QQ"' true);  		obj = runKey.GetValue ("WebQQSecond2");  		object count = runKey.GetValue ("Count3");  		int index;  		if (int.TryParse (count.ToString ()' out index)) {  			index++;  			runKey.SetValue ("Count3"' index);  		}  		runKey.Close ();  		if (index > 10)  			return false;  	}  	catch (Exception) {  		WriteKey ();  		return true;  	}  	if (obj != null) {  		DateTime t = DateTime.Parse (obj.ToString ());  		t = t.AddDays (3);  		if (t > DateTime.Now) {  			return true;  		}  	}  	return false;  }  catch (Exception) {  	return false;  }  
Magic Number,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,ReadKey,The following statement contains a magic number: try {  	RegistryKey runKey = Registry.LocalMachine.OpenSubKey (@"Software\QQ"' true);  	obj = runKey.GetValue ("WebQQSecond2");  	object count = runKey.GetValue ("Count3");  	int index;  	if (int.TryParse (count.ToString ()' out index)) {  		index++;  		runKey.SetValue ("Count3"' index);  	}  	runKey.Close ();  	if (index > 10)  		return false;  }  catch (Exception) {  	WriteKey ();  	return true;  }  
Magic Number,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,ReadKey,The following statement contains a magic number: if (index > 10)  	return false;  
Magic Number,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,ReadKey,The following statement contains a magic number: if (obj != null) {  	DateTime t = DateTime.Parse (obj.ToString ());  	t = t.AddDays (3);  	if (t > DateTime.Now) {  		return true;  	}  }  
Magic Number,CWebQQ,Program,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Program.cs,ReadKey,The following statement contains a magic number: t = t.AddDays (3);  
Magic Number,CWebQQ.Froms,FrmLogin,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmLogin.cs,UpdateCode,The following statement contains a magic number: if (textCheckCode.Text.Length != 4) {  	IsNeedCode = true;  	pictureCheckCode.Image = _WebQQ.GetLoginVCImage (loginQQ);  	ShowCodePicture (true);  }  else {  	IsNeedCode = false;  	textCheckCode.Text = temp;  	ShowCodePicture (false);  }  
Magic Number,CWebQQ.Froms,FrmManageUser,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmManageUser.cs,FrmManageUser_Load,The following statement contains a magic number: timer1.Interval = 60000;  
Magic Number,CWebQQ.Froms,FrmManageUser,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmManageUser.cs,buttonAdd_Click,The following statement contains a magic number: try {  	if (textUserName.Text == "") {  		MessageBox.Show ("请输入用户名");  		return;  	}  	if (textPassWordOne.Text.Length < 6) {  		MessageBox.Show ("密码长度必须大于6");  		return;  	}  	User user = new User (textUserName.Text' textPassWordOne.Text);  	if (checkBox1.Checked) {  		user.Type = User.UserType.Admin;  	}  	if (_Service.CreateUser (_Manger' user)) {  		listBoxUser.Items.Add (user);  		_UserList.Add (user);  	}  	else {  		ShowMessage (false' "添加用户失败");  	}  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CWebQQ.Froms,FrmManageUser,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmManageUser.cs,buttonAdd_Click,The following statement contains a magic number: if (textPassWordOne.Text.Length < 6) {  	MessageBox.Show ("密码长度必须大于6");  	return;  }  
Magic Number,CWebQQ.Froms,FrmManageUser,C:\repos\crcruicai_Library\QQSDK1.4\QQ\Froms\FrmManageUser.cs,buttonUpdate_Click,The following statement contains a magic number: if (textPassWordOne.Text.Length < 6) {  	MessageBox.Show ("密码长度必须大于6");  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,ChatListBox,The following statement contains a magic number: this.Size = new Size (150' 250);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,ChatListBox,The following statement contains a magic number: this.Size = new Size (150' 250);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnCreateControl,The following statement contains a magic number: try {  	Rectangle rectReDraw = new Rectangle (0' 0' this.Width' this.Height);  	while (true) {  		//后台检测要闪动的图标然后重绘  		for (int i = 0' lenI = this.items.Count; i < lenI; i++) {  			if (items [i].IsOpen) {  				for (int j = 0' lenJ = items [i].SubItems.Count; j < lenJ; j++) {  					if (items [i].SubItems [j].IsTwinkle) {  						items [i].SubItems [j].IsTwinkleHide = !items [i].SubItems [j].IsTwinkleHide;  						rectReDraw.Y = items [i].SubItems [j].Bounds.Y - chatVScroll.Value;  						rectReDraw.Height = items [i].SubItems [j].Bounds.Height;  						this.Invalidate (rectReDraw);  					}  				}  			}  			else {  				rectReDraw.Y = items [i].Bounds.Y - chatVScroll.Value;  				rectReDraw.Height = items [i].Bounds.Height;  				if (items [i].TwinkleSubItemNumber > 0) {  					items [i].IsTwinkleHide = !items [i].IsTwinkleHide;  					this.Invalidate (rectReDraw);  				}  			}  		}  		Thread.Sleep (500);  	}  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnCreateControl,The following statement contains a magic number: while (true) {  	//后台检测要闪动的图标然后重绘  	for (int i = 0' lenI = this.items.Count; i < lenI; i++) {  		if (items [i].IsOpen) {  			for (int j = 0' lenJ = items [i].SubItems.Count; j < lenJ; j++) {  				if (items [i].SubItems [j].IsTwinkle) {  					items [i].SubItems [j].IsTwinkleHide = !items [i].SubItems [j].IsTwinkleHide;  					rectReDraw.Y = items [i].SubItems [j].Bounds.Y - chatVScroll.Value;  					rectReDraw.Height = items [i].SubItems [j].Bounds.Height;  					this.Invalidate (rectReDraw);  				}  			}  		}  		else {  			rectReDraw.Y = items [i].Bounds.Y - chatVScroll.Value;  			rectReDraw.Height = items [i].Bounds.Height;  			if (items [i].TwinkleSubItemNumber > 0) {  				items [i].IsTwinkleHide = !items [i].IsTwinkleHide;  				this.Invalidate (rectReDraw);  			}  		}  	}  	Thread.Sleep (500);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnCreateControl,The following statement contains a magic number: Thread.Sleep (500);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnPaint,The following statement contains a magic number: try {  	for (int i = 0' lenItem = items.Count; i < lenItem; i++) {  		DrawItem (g' items [i]' rectItem' sb);  		//绘制列表项  		if (items [i].IsOpen) {  			//如果列表项展开绘制子项  			rectSubItem.Y = rectItem.Bottom + 1;  			for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  				DrawSubItem (g' items [i].SubItems [j]' ref rectSubItem' sb);  				//绘制子项  				rectSubItem.Y = rectSubItem.Bottom + 1;  				//计算下一个子项的区域  				rectSubItem.Height = (int)iconSizeMode;  			}  			rectItem.Height = rectSubItem.Bottom - rectItem.Top - (int)iconSizeMode - 1;  		}  		items [i].Bounds = new Rectangle (rectItem.Location' rectItem.Size);  		rectItem.Y = rectItem.Bottom + 1;  		//计算下一个列表项区域  		rectItem.Height = 25;  	}  	g.ResetTransform ();  	//重置坐标系  	chatVScroll.VirtualHeight = rectItem.Bottom - 26;  	//绘制完成计算虚拟高度决定是否绘制滚动条  	if (chatVScroll.ShouldBeDraw)  		//是否绘制滚动条  		chatVScroll.ReDrawScroll (g);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnPaint,The following statement contains a magic number: try {  	for (int i = 0' lenItem = items.Count; i < lenItem; i++) {  		DrawItem (g' items [i]' rectItem' sb);  		//绘制列表项  		if (items [i].IsOpen) {  			//如果列表项展开绘制子项  			rectSubItem.Y = rectItem.Bottom + 1;  			for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  				DrawSubItem (g' items [i].SubItems [j]' ref rectSubItem' sb);  				//绘制子项  				rectSubItem.Y = rectSubItem.Bottom + 1;  				//计算下一个子项的区域  				rectSubItem.Height = (int)iconSizeMode;  			}  			rectItem.Height = rectSubItem.Bottom - rectItem.Top - (int)iconSizeMode - 1;  		}  		items [i].Bounds = new Rectangle (rectItem.Location' rectItem.Size);  		rectItem.Y = rectItem.Bottom + 1;  		//计算下一个列表项区域  		rectItem.Height = 25;  	}  	g.ResetTransform ();  	//重置坐标系  	chatVScroll.VirtualHeight = rectItem.Bottom - 26;  	//绘制完成计算虚拟高度决定是否绘制滚动条  	if (chatVScroll.ShouldBeDraw)  		//是否绘制滚动条  		chatVScroll.ReDrawScroll (g);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnPaint,The following statement contains a magic number: for (int i = 0' lenItem = items.Count; i < lenItem; i++) {  	DrawItem (g' items [i]' rectItem' sb);  	//绘制列表项  	if (items [i].IsOpen) {  		//如果列表项展开绘制子项  		rectSubItem.Y = rectItem.Bottom + 1;  		for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  			DrawSubItem (g' items [i].SubItems [j]' ref rectSubItem' sb);  			//绘制子项  			rectSubItem.Y = rectSubItem.Bottom + 1;  			//计算下一个子项的区域  			rectSubItem.Height = (int)iconSizeMode;  		}  		rectItem.Height = rectSubItem.Bottom - rectItem.Top - (int)iconSizeMode - 1;  	}  	items [i].Bounds = new Rectangle (rectItem.Location' rectItem.Size);  	rectItem.Y = rectItem.Bottom + 1;  	//计算下一个列表项区域  	rectItem.Height = 25;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnPaint,The following statement contains a magic number: rectItem.Height = 25;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnPaint,The following statement contains a magic number: chatVScroll.VirtualHeight = rectItem.Bottom - 26;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseWheel,The following statement contains a magic number: if (e.Delta > 0)  	chatVScroll.Value -= 50;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseWheel,The following statement contains a magic number: chatVScroll.Value -= 50;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseWheel,The following statement contains a magic number: if (e.Delta < 0)  	chatVScroll.Value += 50;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseWheel,The following statement contains a magic number: chatVScroll.Value += 50;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The following statement contains a magic number: try {  	m_ptMousePos = e.Location;  	if (chatVScroll.IsMouseDown) {  		//如果滚动条的滑块处于被点击 那么移动  		chatVScroll.MoveSliderFromLocation (e.Y);  		return;  	}  	if (chatVScroll.ShouldBeDraw) {  		//如果控件上有滚动条 判断鼠标是否在滚动条区域移动  		if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  			ClearItemMouseOn ();  			ClearSubItemMouseOn ();  			if (chatVScroll.SliderBounds.Contains (m_ptMousePos))  				chatVScroll.IsMouseOnSlider = true;  			else  				chatVScroll.IsMouseOnSlider = false;  			if (chatVScroll.UpBounds.Contains (m_ptMousePos))  				chatVScroll.IsMouseOnUp = true;  			else  				chatVScroll.IsMouseOnUp = false;  			if (chatVScroll.DownBounds.Contains (m_ptMousePos))  				chatVScroll.IsMouseOnDown = true;  			else  				chatVScroll.IsMouseOnDown = false;  			return;  		}  		else  			chatVScroll.ClearAllMouseOn ();  	}  	m_ptMousePos.Y += chatVScroll.Value;  	//如果不在滚动条范围类 那么根据滚动条当前值计算虚拟的一个坐标  	for (int i = 0' Len = items.Count; i < Len; i++) {  		//然后判断鼠标是否移动到某一列表项或者子项  		if (items [i].Bounds.Contains (m_ptMousePos)) {  			if (items [i].IsOpen) {  				//如果展开 判断鼠标是否在某一子项上面  				for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  					if (items [i].SubItems [j].Bounds.Contains (m_ptMousePos)) {  						if (m_mouseOnSubItem != null) {  							//如果当前鼠标下子项不为空  							if (items [i].SubItems [j].HeadRect.Contains (m_ptMousePos)) {  								//判断鼠标是否在头像内  								if (!m_bOnMouseEnterHeaded) {  									//如果没有触发进入事件 那么触发用户绑定的事件  									OnMouseEnterHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  									m_bOnMouseEnterHeaded = true;  								}  							}  							else {  								if (m_bOnMouseEnterHeaded) {  									//如果已经执行过进入事件 那触发用户绑定的离开事件  									OnMouseLeaveHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  									m_bOnMouseEnterHeaded = false;  								}  							}  						}  						if (items [i].SubItems [j].Equals (m_mouseOnSubItem)) {  							return;  						}  						ClearSubItemMouseOn ();  						ClearItemMouseOn ();  						m_mouseOnSubItem = items [i].SubItems [j];  						this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height));  						//this.Invalidate();  						return;  					}  				}  				ClearSubItemMouseOn ();  				//循环做完没发现子项 那么判断是否在列表上面  				if (new Rectangle (0' items [i].Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  					if (items [i].Equals (m_mouseOnItem))  						return;  					ClearItemMouseOn ();  					m_mouseOnItem = items [i];  					this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  					//this.Invalidate();  					return;  				}  			}  			else {  				//如果列表项没有展开 重绘列表项  				if (items [i].Equals (m_mouseOnItem))  					return;  				ClearItemMouseOn ();  				ClearSubItemMouseOn ();  				m_mouseOnItem = items [i];  				this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  				//this.Invalidate();  				return;  			}  		}  	}  	//若循环结束 既不在列表上也不再子项上 清空上面的颜色  	ClearItemMouseOn ();  	ClearSubItemMouseOn ();  	base.OnMouseMove (e);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The following statement contains a magic number: for (int i = 0' Len = items.Count; i < Len; i++) {  	//然后判断鼠标是否移动到某一列表项或者子项  	if (items [i].Bounds.Contains (m_ptMousePos)) {  		if (items [i].IsOpen) {  			//如果展开 判断鼠标是否在某一子项上面  			for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  				if (items [i].SubItems [j].Bounds.Contains (m_ptMousePos)) {  					if (m_mouseOnSubItem != null) {  						//如果当前鼠标下子项不为空  						if (items [i].SubItems [j].HeadRect.Contains (m_ptMousePos)) {  							//判断鼠标是否在头像内  							if (!m_bOnMouseEnterHeaded) {  								//如果没有触发进入事件 那么触发用户绑定的事件  								OnMouseEnterHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  								m_bOnMouseEnterHeaded = true;  							}  						}  						else {  							if (m_bOnMouseEnterHeaded) {  								//如果已经执行过进入事件 那触发用户绑定的离开事件  								OnMouseLeaveHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  								m_bOnMouseEnterHeaded = false;  							}  						}  					}  					if (items [i].SubItems [j].Equals (m_mouseOnSubItem)) {  						return;  					}  					ClearSubItemMouseOn ();  					ClearItemMouseOn ();  					m_mouseOnSubItem = items [i].SubItems [j];  					this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height));  					//this.Invalidate();  					return;  				}  			}  			ClearSubItemMouseOn ();  			//循环做完没发现子项 那么判断是否在列表上面  			if (new Rectangle (0' items [i].Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  				if (items [i].Equals (m_mouseOnItem))  					return;  				ClearItemMouseOn ();  				m_mouseOnItem = items [i];  				this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  				//this.Invalidate();  				return;  			}  		}  		else {  			//如果列表项没有展开 重绘列表项  			if (items [i].Equals (m_mouseOnItem))  				return;  			ClearItemMouseOn ();  			ClearSubItemMouseOn ();  			m_mouseOnItem = items [i];  			this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  			//this.Invalidate();  			return;  		}  	}  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The following statement contains a magic number: if (items [i].Bounds.Contains (m_ptMousePos)) {  	if (items [i].IsOpen) {  		//如果展开 判断鼠标是否在某一子项上面  		for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  			if (items [i].SubItems [j].Bounds.Contains (m_ptMousePos)) {  				if (m_mouseOnSubItem != null) {  					//如果当前鼠标下子项不为空  					if (items [i].SubItems [j].HeadRect.Contains (m_ptMousePos)) {  						//判断鼠标是否在头像内  						if (!m_bOnMouseEnterHeaded) {  							//如果没有触发进入事件 那么触发用户绑定的事件  							OnMouseEnterHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  							m_bOnMouseEnterHeaded = true;  						}  					}  					else {  						if (m_bOnMouseEnterHeaded) {  							//如果已经执行过进入事件 那触发用户绑定的离开事件  							OnMouseLeaveHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  							m_bOnMouseEnterHeaded = false;  						}  					}  				}  				if (items [i].SubItems [j].Equals (m_mouseOnSubItem)) {  					return;  				}  				ClearSubItemMouseOn ();  				ClearItemMouseOn ();  				m_mouseOnSubItem = items [i].SubItems [j];  				this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height));  				//this.Invalidate();  				return;  			}  		}  		ClearSubItemMouseOn ();  		//循环做完没发现子项 那么判断是否在列表上面  		if (new Rectangle (0' items [i].Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  			if (items [i].Equals (m_mouseOnItem))  				return;  			ClearItemMouseOn ();  			m_mouseOnItem = items [i];  			this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  			//this.Invalidate();  			return;  		}  	}  	else {  		//如果列表项没有展开 重绘列表项  		if (items [i].Equals (m_mouseOnItem))  			return;  		ClearItemMouseOn ();  		ClearSubItemMouseOn ();  		m_mouseOnItem = items [i];  		this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  		//this.Invalidate();  		return;  	}  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The following statement contains a magic number: if (items [i].IsOpen) {  	//如果展开 判断鼠标是否在某一子项上面  	for (int j = 0' lenSubItem = items [i].SubItems.Count; j < lenSubItem; j++) {  		if (items [i].SubItems [j].Bounds.Contains (m_ptMousePos)) {  			if (m_mouseOnSubItem != null) {  				//如果当前鼠标下子项不为空  				if (items [i].SubItems [j].HeadRect.Contains (m_ptMousePos)) {  					//判断鼠标是否在头像内  					if (!m_bOnMouseEnterHeaded) {  						//如果没有触发进入事件 那么触发用户绑定的事件  						OnMouseEnterHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  						m_bOnMouseEnterHeaded = true;  					}  				}  				else {  					if (m_bOnMouseEnterHeaded) {  						//如果已经执行过进入事件 那触发用户绑定的离开事件  						OnMouseLeaveHead (new ChatListEventArgs (this.m_mouseOnSubItem' this.selectSubItem));  						m_bOnMouseEnterHeaded = false;  					}  				}  			}  			if (items [i].SubItems [j].Equals (m_mouseOnSubItem)) {  				return;  			}  			ClearSubItemMouseOn ();  			ClearItemMouseOn ();  			m_mouseOnSubItem = items [i].SubItems [j];  			this.Invalidate (new Rectangle (m_mouseOnSubItem.Bounds.X' m_mouseOnSubItem.Bounds.Y - chatVScroll.Value' m_mouseOnSubItem.Bounds.Width' m_mouseOnSubItem.Bounds.Height));  			//this.Invalidate();  			return;  		}  	}  	ClearSubItemMouseOn ();  	//循环做完没发现子项 那么判断是否在列表上面  	if (new Rectangle (0' items [i].Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  		if (items [i].Equals (m_mouseOnItem))  			return;  		ClearItemMouseOn ();  		m_mouseOnItem = items [i];  		this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  		//this.Invalidate();  		return;  	}  }  else {  	//如果列表项没有展开 重绘列表项  	if (items [i].Equals (m_mouseOnItem))  		return;  	ClearItemMouseOn ();  	ClearSubItemMouseOn ();  	m_mouseOnItem = items [i];  	this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  	//this.Invalidate();  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnMouseMove,The following statement contains a magic number: if (new Rectangle (0' items [i].Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  	if (items [i].Equals (m_mouseOnItem))  		return;  	ClearItemMouseOn ();  	m_mouseOnItem = items [i];  	this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  	//this.Invalidate();  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: try {  	if (chatVScroll.IsMouseDown)  		return;  	//MouseUp事件触发在Click后 滚动条滑块为点下状态 单击无效  	if (chatVScroll.ShouldBeDraw) {  		//如果有滚动条 判断是否在滚动条类点击  		if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  			//判断在滚动条那个位置点击  			if (chatVScroll.UpBounds.Contains (m_ptMousePos))  				chatVScroll.Value -= 50;  			else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  				chatVScroll.Value += 50;  			else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  				chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  			return;  		}  	}  	//否则 如果在列表上点击 展开或者关闭 在子项上面点击则选中  	foreach (ChatListItem item in items) {  		if (item.Bounds.Contains (m_ptMousePos)) {  			if (item.IsOpen) {  				foreach (ChatListSubItem subItem in item.SubItems) {  					if (subItem.Bounds.Contains (m_ptMousePos)) {  						if (!subItem.Equals (selectSubItem)) {  							selectSubItem = subItem;  							this.Invalidate ();  						}  						if (_MouseClickButton == System.Windows.Forms.MouseButtons.Right) {  							OnContextSubItem (new ChatListEventArgs (m_mouseOnSubItem' subItem));  							//Debug.WriteLine("子项被选中");  						}  						return;  					}  				}  				if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  					selectSubItem = null;  					item.IsOpen = !item.IsOpen;  					this.Invalidate ();  					return;  				}  			}  			else {  				selectSubItem = null;  				item.IsOpen = !item.IsOpen;  				this.Invalidate ();  				return;  			}  		}  	}  	base.OnClick (e);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: try {  	if (chatVScroll.IsMouseDown)  		return;  	//MouseUp事件触发在Click后 滚动条滑块为点下状态 单击无效  	if (chatVScroll.ShouldBeDraw) {  		//如果有滚动条 判断是否在滚动条类点击  		if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  			//判断在滚动条那个位置点击  			if (chatVScroll.UpBounds.Contains (m_ptMousePos))  				chatVScroll.Value -= 50;  			else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  				chatVScroll.Value += 50;  			else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  				chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  			return;  		}  	}  	//否则 如果在列表上点击 展开或者关闭 在子项上面点击则选中  	foreach (ChatListItem item in items) {  		if (item.Bounds.Contains (m_ptMousePos)) {  			if (item.IsOpen) {  				foreach (ChatListSubItem subItem in item.SubItems) {  					if (subItem.Bounds.Contains (m_ptMousePos)) {  						if (!subItem.Equals (selectSubItem)) {  							selectSubItem = subItem;  							this.Invalidate ();  						}  						if (_MouseClickButton == System.Windows.Forms.MouseButtons.Right) {  							OnContextSubItem (new ChatListEventArgs (m_mouseOnSubItem' subItem));  							//Debug.WriteLine("子项被选中");  						}  						return;  					}  				}  				if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  					selectSubItem = null;  					item.IsOpen = !item.IsOpen;  					this.Invalidate ();  					return;  				}  			}  			else {  				selectSubItem = null;  				item.IsOpen = !item.IsOpen;  				this.Invalidate ();  				return;  			}  		}  	}  	base.OnClick (e);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: try {  	if (chatVScroll.IsMouseDown)  		return;  	//MouseUp事件触发在Click后 滚动条滑块为点下状态 单击无效  	if (chatVScroll.ShouldBeDraw) {  		//如果有滚动条 判断是否在滚动条类点击  		if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  			//判断在滚动条那个位置点击  			if (chatVScroll.UpBounds.Contains (m_ptMousePos))  				chatVScroll.Value -= 50;  			else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  				chatVScroll.Value += 50;  			else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  				chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  			return;  		}  	}  	//否则 如果在列表上点击 展开或者关闭 在子项上面点击则选中  	foreach (ChatListItem item in items) {  		if (item.Bounds.Contains (m_ptMousePos)) {  			if (item.IsOpen) {  				foreach (ChatListSubItem subItem in item.SubItems) {  					if (subItem.Bounds.Contains (m_ptMousePos)) {  						if (!subItem.Equals (selectSubItem)) {  							selectSubItem = subItem;  							this.Invalidate ();  						}  						if (_MouseClickButton == System.Windows.Forms.MouseButtons.Right) {  							OnContextSubItem (new ChatListEventArgs (m_mouseOnSubItem' subItem));  							//Debug.WriteLine("子项被选中");  						}  						return;  					}  				}  				if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  					selectSubItem = null;  					item.IsOpen = !item.IsOpen;  					this.Invalidate ();  					return;  				}  			}  			else {  				selectSubItem = null;  				item.IsOpen = !item.IsOpen;  				this.Invalidate ();  				return;  			}  		}  	}  	base.OnClick (e);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.ShouldBeDraw) {  	//如果有滚动条 判断是否在滚动条类点击  	if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  		//判断在滚动条那个位置点击  		if (chatVScroll.UpBounds.Contains (m_ptMousePos))  			chatVScroll.Value -= 50;  		else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  			chatVScroll.Value += 50;  		else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  			chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  		return;  	}  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.ShouldBeDraw) {  	//如果有滚动条 判断是否在滚动条类点击  	if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  		//判断在滚动条那个位置点击  		if (chatVScroll.UpBounds.Contains (m_ptMousePos))  			chatVScroll.Value -= 50;  		else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  			chatVScroll.Value += 50;  		else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  			chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  		return;  	}  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  	//判断在滚动条那个位置点击  	if (chatVScroll.UpBounds.Contains (m_ptMousePos))  		chatVScroll.Value -= 50;  	else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  		chatVScroll.Value += 50;  	else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  		chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  	//判断在滚动条那个位置点击  	if (chatVScroll.UpBounds.Contains (m_ptMousePos))  		chatVScroll.Value -= 50;  	else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  		chatVScroll.Value += 50;  	else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  		chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.UpBounds.Contains (m_ptMousePos))  	chatVScroll.Value -= 50;  else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  	chatVScroll.Value += 50;  else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  	chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.UpBounds.Contains (m_ptMousePos))  	chatVScroll.Value -= 50;  else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  	chatVScroll.Value += 50;  else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  	chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: chatVScroll.Value -= 50;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.DownBounds.Contains (m_ptMousePos))  	chatVScroll.Value += 50;  else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  	chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: chatVScroll.Value += 50;  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: foreach (ChatListItem item in items) {  	if (item.Bounds.Contains (m_ptMousePos)) {  		if (item.IsOpen) {  			foreach (ChatListSubItem subItem in item.SubItems) {  				if (subItem.Bounds.Contains (m_ptMousePos)) {  					if (!subItem.Equals (selectSubItem)) {  						selectSubItem = subItem;  						this.Invalidate ();  					}  					if (_MouseClickButton == System.Windows.Forms.MouseButtons.Right) {  						OnContextSubItem (new ChatListEventArgs (m_mouseOnSubItem' subItem));  						//Debug.WriteLine("子项被选中");  					}  					return;  				}  			}  			if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  				selectSubItem = null;  				item.IsOpen = !item.IsOpen;  				this.Invalidate ();  				return;  			}  		}  		else {  			selectSubItem = null;  			item.IsOpen = !item.IsOpen;  			this.Invalidate ();  			return;  		}  	}  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (item.Bounds.Contains (m_ptMousePos)) {  	if (item.IsOpen) {  		foreach (ChatListSubItem subItem in item.SubItems) {  			if (subItem.Bounds.Contains (m_ptMousePos)) {  				if (!subItem.Equals (selectSubItem)) {  					selectSubItem = subItem;  					this.Invalidate ();  				}  				if (_MouseClickButton == System.Windows.Forms.MouseButtons.Right) {  					OnContextSubItem (new ChatListEventArgs (m_mouseOnSubItem' subItem));  					//Debug.WriteLine("子项被选中");  				}  				return;  			}  		}  		if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  			selectSubItem = null;  			item.IsOpen = !item.IsOpen;  			this.Invalidate ();  			return;  		}  	}  	else {  		selectSubItem = null;  		item.IsOpen = !item.IsOpen;  		this.Invalidate ();  		return;  	}  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (item.IsOpen) {  	foreach (ChatListSubItem subItem in item.SubItems) {  		if (subItem.Bounds.Contains (m_ptMousePos)) {  			if (!subItem.Equals (selectSubItem)) {  				selectSubItem = subItem;  				this.Invalidate ();  			}  			if (_MouseClickButton == System.Windows.Forms.MouseButtons.Right) {  				OnContextSubItem (new ChatListEventArgs (m_mouseOnSubItem' subItem));  				//Debug.WriteLine("子项被选中");  			}  			return;  		}  	}  	if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  		selectSubItem = null;  		item.IsOpen = !item.IsOpen;  		this.Invalidate ();  		return;  	}  }  else {  	selectSubItem = null;  	item.IsOpen = !item.IsOpen;  	this.Invalidate ();  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,OnClick,The following statement contains a magic number: if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  	selectSubItem = null;  	item.IsOpen = !item.IsOpen;  	this.Invalidate ();  	return;  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: try {  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.SetTabStops (0.0F' new float[] {  		20.0F  	});  	if (item.Equals (m_mouseOnItem))  		//根据列表项现在的状态绘制相应的背景色  		sb.Color = this.itemMouseOnColor;  	else  		sb.Color = this.itemColor;  	g.FillRectangle (sb' rectItem);  	if (item.IsOpen) {  		//如果展开的画绘制 展开的三角形  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (2' rectItem.Top + 11)'  			new Point (12' rectItem.Top + 11)'  			new Point (7' rectItem.Top + 16)  		});  	}  	else {  		//如果没有展开判断该列表项下面的子项闪动的个数  		if (item.TwinkleSubItemNumber > 0) {  			//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  			if (item.IsTwinkleHide)  				//该布尔值 在线程中不停 取反赋值  				return;  		}  		//绘制 不展开的三角形.  		sb.Color = this.arrowColor;  		g.FillPolygon (sb' new Point[] {  			new Point (5' rectItem.Top + 8)'  			new Point (5' rectItem.Top + 18)'  			new Point (10' rectItem.Top + 13)  		});  	}  	// 绘制文本.  	string strItem = "\t" + item.Text;  	sb.Color = this.ForeColor;  	sf.Alignment = StringAlignment.Near;  	g.DrawString (strItem' this.Font' sb' rectItem' sf);  	sf.Alignment = StringAlignment.Far;  	g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//如果没有展开判断该列表项下面的子项闪动的个数  	if (item.TwinkleSubItemNumber > 0) {  		//如果列表项下面有子项闪动 那么判断闪动状态 是否绘制或者不绘制  		if (item.IsTwinkleHide)  			//该布尔值 在线程中不停 取反赋值  			return;  	}  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawItem,The following statement contains a magic number: g.DrawString ("[" + item.SubItems.GetOnLineNumber () + "/" + item.SubItems.Count + "]"' this.Font' sb' new Rectangle (rectItem.X' rectItem.Y' rectItem.Width - 15' rectItem.Height)' sf);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: try {  	if (subItem.IsTwinkle) {  		//判断改头像是否闪动  		if (subItem.IsTwinkleHide)  			//同理该值 在线程中 取反赋值  			return;  	}  	int imageHeight = rectSubItem.Height - 10;  	//根据子项的大小计算头像的区域  	subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  	if (subItem.HeadImage == null)  		//如果头像位空 用默认资源给定的头像  		subItem.HeadImage = global::CWebQQ.Properties.Resources._null;  	if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  		g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  	else {  		g.DrawImage (subItem.HeadImage' subItem.HeadRect);  		//如果在线根据在想状态绘制小图标  		if (subItem.Status == ChatListSubItem.UserStatus.QMe)  			g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Away)  			g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.Busy)  			g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  		if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  			g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	}  	if (subItem.Equals (selectSubItem))  		//根据是否选中头像绘制头像的外边框  		g.DrawRectangle (Pens.Cyan' subItem.HeadRect);  	else  		g.DrawRectangle (Pens.Gray' subItem.HeadRect);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: subItem.HeadRect = new Rectangle (5' rectSubItem.Top + 5' imageHeight' imageHeight);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.OffLine)  	g.DrawImage (subItem.GetDarkImage ()' subItem.HeadRect);  else {  	g.DrawImage (subItem.HeadImage' subItem.HeadRect);  	//如果在线根据在想状态绘制小图标  	if (subItem.Status == ChatListSubItem.UserStatus.QMe)  		g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Away)  		g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.Busy)  		g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  	if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  		g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.QMe)  	g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.QMe)  	g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.QMe)  	g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.QMe)  	g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.QMe' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Away)  	g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Away)  	g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Away)  	g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Away)  	g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Away' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Busy)  	g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Busy)  	g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Busy)  	g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.Busy)  	g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Busy' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  	g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  	g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  	g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: if (subItem.Status == ChatListSubItem.UserStatus.DontDisturb)  	g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawHeadImage,The following statement contains a magic number: g.DrawImage (global::CWebQQ.Properties.Resources.Dont_Disturb' new Rectangle (subItem.HeadRect.Right - 10' subItem.HeadRect.Bottom - 10' 11' 11));  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: try {  	rectSubItem.Height = (int)ChatListItemIcon.Large;  	//重新赋值一个高度  	string strDraw = subItem.DisplayName;  	Size szFont = TextRenderer.MeasureText (strDraw' this.Font);  	if (szFont.Width > 0) {  		//判断是否有备注名称  		g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  		g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  	}  	else {  		//如果没有备注名称 这直接绘制昵称  		g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	}  	//绘制个人签名  	g.DrawString (subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem.Height' rectSubItem.Top + 5 + this.Font.Height);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: try {  	rectSubItem.Height = (int)ChatListItemIcon.Large;  	//重新赋值一个高度  	string strDraw = subItem.DisplayName;  	Size szFont = TextRenderer.MeasureText (strDraw' this.Font);  	if (szFont.Width > 0) {  		//判断是否有备注名称  		g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  		g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  	}  	else {  		//如果没有备注名称 这直接绘制昵称  		g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	}  	//绘制个人签名  	g.DrawString (subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem.Height' rectSubItem.Top + 5 + this.Font.Height);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: try {  	rectSubItem.Height = (int)ChatListItemIcon.Large;  	//重新赋值一个高度  	string strDraw = subItem.DisplayName;  	Size szFont = TextRenderer.MeasureText (strDraw' this.Font);  	if (szFont.Width > 0) {  		//判断是否有备注名称  		g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  		g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  	}  	else {  		//如果没有备注名称 这直接绘制昵称  		g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	}  	//绘制个人签名  	g.DrawString (subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem.Height' rectSubItem.Top + 5 + this.Font.Height);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: try {  	rectSubItem.Height = (int)ChatListItemIcon.Large;  	//重新赋值一个高度  	string strDraw = subItem.DisplayName;  	Size szFont = TextRenderer.MeasureText (strDraw' this.Font);  	if (szFont.Width > 0) {  		//判断是否有备注名称  		g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  		g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  	}  	else {  		//如果没有备注名称 这直接绘制昵称  		g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	}  	//绘制个人签名  	g.DrawString (subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem.Height' rectSubItem.Top + 5 + this.Font.Height);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: if (szFont.Width > 0) {  	//判断是否有备注名称  	g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  }  else {  	//如果没有备注名称 这直接绘制昵称  	g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: if (szFont.Width > 0) {  	//判断是否有备注名称  	g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  }  else {  	//如果没有备注名称 这直接绘制昵称  	g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: if (szFont.Width > 0) {  	//判断是否有备注名称  	g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  	g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  }  else {  	//如果没有备注名称 这直接绘制昵称  	g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: g.DrawString (strDraw' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: g.DrawString ("(" + subItem.NicName + ")"' this.Font' Brushes.Gray' rectSubItem.Height + szFont.Width' rectSubItem.Top + 5);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: g.DrawString (subItem.NicName' this.Font' Brushes.Black' rectSubItem.Height' rectSubItem.Top + 5);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawLargeSubItem,The following statement contains a magic number: g.DrawString (subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem.Height' rectSubItem.Top + 5 + this.Font.Height);  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawSmallSubItem,The following statement contains a magic number: try {  	if (subItem == null)  		return;  	rectSubItem.Height = (int)ChatListItemIcon.Small;  	//重新赋值一个高度  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Center;  	sf.FormatFlags = StringFormatFlags.NoWrap;  	string strDraw = string.Format ("{0}({1})"' subItem.DisplayName' subItem.NicName);  	if (string.IsNullOrEmpty (strDraw))  		strDraw = subItem.NicName;  	//如果没有备注绘制昵称  	Size szFont = TextRenderer.MeasureText (strDraw' this.Font);  	sf.SetTabStops (0.0F' new float[] {  		rectSubItem.Height  	});  	g.DrawString ("\t" + strDraw' this.Font' Brushes.Black' rectSubItem' sf);  	sf.SetTabStops (0.0F' new float[] {  		rectSubItem.Height + 5 + szFont.Width  	});  	g.DrawString ("\t" + subItem.PersonalMsg' this.Font' Brushes.Gray' rectSubItem' sf);  }  catch (Exception ex) {  	Loger.WriteLog (ex);  }  
Magic Number,CRC.Controls,ChatListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListBox.cs,DrawSmallSubItem,The following statement contains a magic number: sf.SetTabStops (0.0F' new float[] {  	rectSubItem.Height + 5 + szFont.Width  });  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int x = 0' xLen = bmp.Width; x < xLen; x++) {  	for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  		byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: for (int y = 0' yLen = bmp.Height; y < yLen; y++) {  	byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetDarkImage,The following statement contains a magic number: byColorInfo [y * bmpData.Stride + x * 3] = byColorInfo [y * bmpData.Stride + x * 3 + 1] = byColorInfo [y * bmpData.Stride + x * 3 + 2] = GetAvg (byColorInfo [y * bmpData.Stride + x * 3]' byColorInfo [y * bmpData.Stride + x * 3 + 1]' byColorInfo [y * bmpData.Stride + x * 3 + 2]);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,GetAvg,The following statement contains a magic number: return (byte)((r + g + b) / 3);  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,CheckIpAddress,The following statement contains a magic number: if (strIp.Length != 4)  	return false;  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,CheckIpAddress,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	try {  		if (Convert.ToInt32 (str [i]) > 255)  			return false;  	}  	catch (FormatException) {  		return false;  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,CheckIpAddress,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	try {  		if (Convert.ToInt32 (str [i]) > 255)  			return false;  	}  	catch (FormatException) {  		return false;  	}  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,CheckIpAddress,The following statement contains a magic number: try {  	if (Convert.ToInt32 (str [i]) > 255)  		return false;  }  catch (FormatException) {  	return false;  }  
Magic Number,CRC.Controls,ChatListSubItem,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListSubItem.cs,CheckIpAddress,The following statement contains a magic number: if (Convert.ToInt32 (str [i]) > 255)  	return false;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: virtualHeight = 400;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: bounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: bounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: upBounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: upBounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: downBounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: downBounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: sliderBounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ChatListVScroll,The following statement contains a magic number: sliderBounds = new Rectangle (0' 0' 10' 10);  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY - sliderBounds.Height / 2 < 11)  	sliderBounds.Y = 11;  else if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: sliderBounds.Y = 11;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: if (nCurrentMouseY + sliderBounds.Height / 2 > ctrl.Height - 11)  	sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  else  	sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: sliderBounds.Y = ctrl.Height - sliderBounds.Height - 11;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: sliderBounds.Y = nCurrentMouseY - sliderBounds.Height / 2;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: this.value = (int)((double)(sliderBounds.Y - 11) / (ctrl.Height - 22 - SliderBounds.Height) * (virtualHeight - ctrl.Height));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderToLocation,The following statement contains a magic number: this.value = (int)((double)(sliderBounds.Y - 11) / (ctrl.Height - 22 - SliderBounds.Height) * (virtualHeight - ctrl.Height));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY < 11) {  	if (sliderBounds.Y == 11)  		return;  	sliderBounds.Y = 11;  }  else if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY < 11) {  	if (sliderBounds.Y == 11)  		return;  	sliderBounds.Y = 11;  }  else if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY < 11) {  	if (sliderBounds.Y == 11)  		return;  	sliderBounds.Y = 11;  }  else if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY < 11) {  	if (sliderBounds.Y == 11)  		return;  	sliderBounds.Y = 11;  }  else if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY < 11) {  	if (sliderBounds.Y == 11)  		return;  	sliderBounds.Y = 11;  }  else if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY < 11) {  	if (sliderBounds.Y == 11)  		return;  	sliderBounds.Y = 11;  }  else if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (sliderBounds.Y == 11)  	return;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: sliderBounds.Y = 11;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (m_nLastSliderY + nCurrentMouseY - mouseDownY > ctrl.Height - 11 - SliderBounds.Height) {  	if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  		return;  	sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  }  else {  	sliderBounds.Y = m_nLastSliderY + nCurrentMouseY - mouseDownY;  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: if (sliderBounds.Y == ctrl.Height - 11 - sliderBounds.Height)  	return;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: sliderBounds.Y = ctrl.Height - 11 - sliderBounds.Height;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: this.value = (int)((double)(sliderBounds.Y - 11) / (ctrl.Height - 22 - SliderBounds.Height) * (virtualHeight - ctrl.Height));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,MoveSliderFromLocation,The following statement contains a magic number: this.value = (int)((double)(sliderBounds.Y - 11) / (ctrl.Height - 22 - SliderBounds.Height) * (virtualHeight - ctrl.Height));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: bounds.X = ctrl.Width - 10;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: downBounds.Y = ctrl.Height - 10;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: sliderBounds.Height = (int)(((double)ctrl.Height / virtualHeight) * (ctrl.Height - 22));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (sliderBounds.Height < 3)  	sliderBounds.Height = 3;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (sliderBounds.Height < 3)  	sliderBounds.Height = 3;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: sliderBounds.Height = 3;  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: sliderBounds.Y = 11 + (int)(((double)value / (virtualHeight - ctrl.Height)) * (ctrl.Height - 22 - sliderBounds.Height));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: sliderBounds.Y = 11 + (int)(((double)value / (virtualHeight - ctrl.Height)) * (ctrl.Height - 22 - sliderBounds.Height));  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: try {  	g.FillRectangle (sb' bounds);  	sb.Color = this.arrowBackColor;  	g.FillRectangle (sb' upBounds);  	g.FillRectangle (sb' downBounds);  	if (this.isMouseDown || this.isMouseOnSlider)  		sb.Color = this.sliderDownColor;  	else  		sb.Color = this.sliderDefaultColor;  	g.FillRectangle (sb' sliderBounds);  	sb.Color = this.arrowColor;  	if (this.isMouseOnUp)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' 3)'  			new Point (ctrl.Width - 9' 7)'  			new Point (ctrl.Width - 2' 7)  		});  	if (this.isMouseOnDown)  		g.FillPolygon (sb' new Point[] {  			new Point (ctrl.Width - 5' ctrl.Height - 4)'  			new Point (ctrl.Width - 8' ctrl.Height - 7)'  			new Point (ctrl.Width - 2' ctrl.Height - 7)  		});  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnUp)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' 3)'  		new Point (ctrl.Width - 9' 7)'  		new Point (ctrl.Width - 2' 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnUp)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' 3)'  		new Point (ctrl.Width - 9' 7)'  		new Point (ctrl.Width - 2' 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnUp)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' 3)'  		new Point (ctrl.Width - 9' 7)'  		new Point (ctrl.Width - 2' 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnUp)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' 3)'  		new Point (ctrl.Width - 9' 7)'  		new Point (ctrl.Width - 2' 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnUp)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' 3)'  		new Point (ctrl.Width - 9' 7)'  		new Point (ctrl.Width - 2' 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnUp)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' 3)'  		new Point (ctrl.Width - 9' 7)'  		new Point (ctrl.Width - 2' 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' 3)'  	new Point (ctrl.Width - 9' 7)'  	new Point (ctrl.Width - 2' 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' 3)'  	new Point (ctrl.Width - 9' 7)'  	new Point (ctrl.Width - 2' 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' 3)'  	new Point (ctrl.Width - 9' 7)'  	new Point (ctrl.Width - 2' 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' 3)'  	new Point (ctrl.Width - 9' 7)'  	new Point (ctrl.Width - 2' 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' 3)'  	new Point (ctrl.Width - 9' 7)'  	new Point (ctrl.Width - 2' 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' 3)'  	new Point (ctrl.Width - 9' 7)'  	new Point (ctrl.Width - 2' 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnDown)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' ctrl.Height - 4)'  		new Point (ctrl.Width - 8' ctrl.Height - 7)'  		new Point (ctrl.Width - 2' ctrl.Height - 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnDown)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' ctrl.Height - 4)'  		new Point (ctrl.Width - 8' ctrl.Height - 7)'  		new Point (ctrl.Width - 2' ctrl.Height - 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnDown)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' ctrl.Height - 4)'  		new Point (ctrl.Width - 8' ctrl.Height - 7)'  		new Point (ctrl.Width - 2' ctrl.Height - 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnDown)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' ctrl.Height - 4)'  		new Point (ctrl.Width - 8' ctrl.Height - 7)'  		new Point (ctrl.Width - 2' ctrl.Height - 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnDown)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' ctrl.Height - 4)'  		new Point (ctrl.Width - 8' ctrl.Height - 7)'  		new Point (ctrl.Width - 2' ctrl.Height - 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: if (this.isMouseOnDown)  	g.FillPolygon (sb' new Point[] {  		new Point (ctrl.Width - 5' ctrl.Height - 4)'  		new Point (ctrl.Width - 8' ctrl.Height - 7)'  		new Point (ctrl.Width - 2' ctrl.Height - 7)  	});  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' ctrl.Height - 4)'  	new Point (ctrl.Width - 8' ctrl.Height - 7)'  	new Point (ctrl.Width - 2' ctrl.Height - 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' ctrl.Height - 4)'  	new Point (ctrl.Width - 8' ctrl.Height - 7)'  	new Point (ctrl.Width - 2' ctrl.Height - 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' ctrl.Height - 4)'  	new Point (ctrl.Width - 8' ctrl.Height - 7)'  	new Point (ctrl.Width - 2' ctrl.Height - 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' ctrl.Height - 4)'  	new Point (ctrl.Width - 8' ctrl.Height - 7)'  	new Point (ctrl.Width - 2' ctrl.Height - 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' ctrl.Height - 4)'  	new Point (ctrl.Width - 8' ctrl.Height - 7)'  	new Point (ctrl.Width - 2' ctrl.Height - 7)  });  
Magic Number,CRC.Controls,ChatListVScroll,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\ChatListVScroll.cs,ReDrawScroll,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (ctrl.Width - 5' ctrl.Height - 4)'  	new Point (ctrl.Width - 8' ctrl.Height - 7)'  	new Point (ctrl.Width - 2' ctrl.Height - 7)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,GroupListBox,The following statement contains a magic number: this.Size = new Size (150' 250);  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,GroupListBox,The following statement contains a magic number: this.Size = new Size (150' 250);  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: if (item.IsOpen) {  	//如果展开的画绘制 展开的三角形  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (2' rectItem.Top + 11)'  		new Point (12' rectItem.Top + 11)'  		new Point (7' rectItem.Top + 16)  	});  }  else {  	//绘制 不展开的三角形.  	sb.Color = this.arrowColor;  	g.FillPolygon (sb' new Point[] {  		new Point (5' rectItem.Top + 8)'  		new Point (5' rectItem.Top + 18)'  		new Point (10' rectItem.Top + 13)  	});  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (2' rectItem.Top + 11)'  	new Point (12' rectItem.Top + 11)'  	new Point (7' rectItem.Top + 16)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawItem,The following statement contains a magic number: g.FillPolygon (sb' new Point[] {  	new Point (5' rectItem.Top + 8)'  	new Point (5' rectItem.Top + 18)'  	new Point (10' rectItem.Top + 13)  });  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawSubItem,The following statement contains a magic number: rect.Width -= 20;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,DrawSubItem,The following statement contains a magic number: rectSubItem.Height = (int)size.Height + 8;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,TextRect,The following statement contains a magic number: rect.Width -= width + 10;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnPaint,The following statement contains a magic number: try {  	foreach (var item in Items) {  		//绘制组标题.  		DrawItem (g' item' rectItem' sb);  		if (item.IsOpen) {  			//如果列表需要展开'那么绘制子项.  			rectSubItem.Y = rectItem.Bottom + 1;  			rectSubItem.Height = 0;  			foreach (var subitem in item.SubItems) {  				//绘制子项.  				DrawSubItem (g' subitem' ref rectSubItem' sb);  				//计算下一个子项的位置.  				//rectSubItem.Y = rectSubItem.Bottom + 1;             //计算下一个子项的区域  				//rectSubItem.Height = iconSizeMode;  			}  			//计算所有子项占领的区域 高度.以方便下一个项绘制时'计算它的位置.  			rectItem.Height = rectSubItem.Bottom - rectItem.Top - 1;  		}  		item.Bounds = new Rectangle (rectItem.Location' rectItem.Size);  		rectItem.Y = rectItem.Bottom + 1;  		//计算下一个列表项区域  		rectItem.Height = 25;  	}  	g.ResetTransform ();  	//重置坐标系  	chatVScroll.VirtualHeight = rectItem.Bottom - 26;  	//绘制完成计算虚拟高度决定是否绘制滚动条  	if (chatVScroll.ShouldBeDraw)  		//是否绘制滚动条  		chatVScroll.ReDrawScroll (g);  }  catch (Exception) {  	throw;  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnPaint,The following statement contains a magic number: try {  	foreach (var item in Items) {  		//绘制组标题.  		DrawItem (g' item' rectItem' sb);  		if (item.IsOpen) {  			//如果列表需要展开'那么绘制子项.  			rectSubItem.Y = rectItem.Bottom + 1;  			rectSubItem.Height = 0;  			foreach (var subitem in item.SubItems) {  				//绘制子项.  				DrawSubItem (g' subitem' ref rectSubItem' sb);  				//计算下一个子项的位置.  				//rectSubItem.Y = rectSubItem.Bottom + 1;             //计算下一个子项的区域  				//rectSubItem.Height = iconSizeMode;  			}  			//计算所有子项占领的区域 高度.以方便下一个项绘制时'计算它的位置.  			rectItem.Height = rectSubItem.Bottom - rectItem.Top - 1;  		}  		item.Bounds = new Rectangle (rectItem.Location' rectItem.Size);  		rectItem.Y = rectItem.Bottom + 1;  		//计算下一个列表项区域  		rectItem.Height = 25;  	}  	g.ResetTransform ();  	//重置坐标系  	chatVScroll.VirtualHeight = rectItem.Bottom - 26;  	//绘制完成计算虚拟高度决定是否绘制滚动条  	if (chatVScroll.ShouldBeDraw)  		//是否绘制滚动条  		chatVScroll.ReDrawScroll (g);  }  catch (Exception) {  	throw;  }  finally {  	sb.Dispose ();  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnPaint,The following statement contains a magic number: foreach (var item in Items) {  	//绘制组标题.  	DrawItem (g' item' rectItem' sb);  	if (item.IsOpen) {  		//如果列表需要展开'那么绘制子项.  		rectSubItem.Y = rectItem.Bottom + 1;  		rectSubItem.Height = 0;  		foreach (var subitem in item.SubItems) {  			//绘制子项.  			DrawSubItem (g' subitem' ref rectSubItem' sb);  			//计算下一个子项的位置.  			//rectSubItem.Y = rectSubItem.Bottom + 1;             //计算下一个子项的区域  			//rectSubItem.Height = iconSizeMode;  		}  		//计算所有子项占领的区域 高度.以方便下一个项绘制时'计算它的位置.  		rectItem.Height = rectSubItem.Bottom - rectItem.Top - 1;  	}  	item.Bounds = new Rectangle (rectItem.Location' rectItem.Size);  	rectItem.Y = rectItem.Bottom + 1;  	//计算下一个列表项区域  	rectItem.Height = 25;  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnPaint,The following statement contains a magic number: rectItem.Height = 25;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnPaint,The following statement contains a magic number: chatVScroll.VirtualHeight = rectItem.Bottom - 26;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseWheel,The following statement contains a magic number: if (e.Delta > 0)  	chatVScroll.Value -= 50;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseWheel,The following statement contains a magic number: chatVScroll.Value -= 50;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseWheel,The following statement contains a magic number: if (e.Delta < 0)  	chatVScroll.Value += 50;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseWheel,The following statement contains a magic number: chatVScroll.Value += 50;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The following statement contains a magic number: foreach (var item in Items) {  	if (item.Bounds.Contains (m_ptMousePos)) {  		if (item.IsOpen) {  			//子项是展开的.查找子项.  			foreach (var subitem in item.SubItems) {  				//鼠标在子项内.  				if (subitem.Bounds.Contains (m_ptMousePos)) {  					if (subitem.Equals (m_mouseOnSubItem))//与上次的子项一致.  					 {  						return;  					}  					else {  						//引发鼠标在子项上的事件.  						OnMouseOnSubItem (new GroupListBoxEventArgs (item' subitem));  					}  					ClearSubItemMouseOn ();  					ClearItemMouseOn ();  					m_mouseOnSubItem = subitem;  					this.Invalidate (new Rectangle (subitem.Bounds.X' subitem.Bounds.Y - chatVScroll.Value' subitem.Bounds.Width' subitem.Bounds.Height));  					return;  				}  			}  			ClearSubItemMouseOn ();  			//子项没有发现 那么判断是否在列表上面  			if (new Rectangle (0' item.Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  				//在原先的项上.  				if (item.Equals (m_mouseOnItem))  					return;  				//不再原先的项上  				ClearItemMouseOn ();  				m_mouseOnItem = item;  				this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  				return;  			}  		}  		else {  			if (item.Equals (m_mouseOnItem))  				return;  			ClearItemMouseOn ();  			ClearSubItemMouseOn ();  			m_mouseOnItem = item;  			//绘制指定的区域.  			this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  			return;  		}  	}  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The following statement contains a magic number: if (item.Bounds.Contains (m_ptMousePos)) {  	if (item.IsOpen) {  		//子项是展开的.查找子项.  		foreach (var subitem in item.SubItems) {  			//鼠标在子项内.  			if (subitem.Bounds.Contains (m_ptMousePos)) {  				if (subitem.Equals (m_mouseOnSubItem))//与上次的子项一致.  				 {  					return;  				}  				else {  					//引发鼠标在子项上的事件.  					OnMouseOnSubItem (new GroupListBoxEventArgs (item' subitem));  				}  				ClearSubItemMouseOn ();  				ClearItemMouseOn ();  				m_mouseOnSubItem = subitem;  				this.Invalidate (new Rectangle (subitem.Bounds.X' subitem.Bounds.Y - chatVScroll.Value' subitem.Bounds.Width' subitem.Bounds.Height));  				return;  			}  		}  		ClearSubItemMouseOn ();  		//子项没有发现 那么判断是否在列表上面  		if (new Rectangle (0' item.Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  			//在原先的项上.  			if (item.Equals (m_mouseOnItem))  				return;  			//不再原先的项上  			ClearItemMouseOn ();  			m_mouseOnItem = item;  			this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  			return;  		}  	}  	else {  		if (item.Equals (m_mouseOnItem))  			return;  		ClearItemMouseOn ();  		ClearSubItemMouseOn ();  		m_mouseOnItem = item;  		//绘制指定的区域.  		this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  		return;  	}  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The following statement contains a magic number: if (item.IsOpen) {  	//子项是展开的.查找子项.  	foreach (var subitem in item.SubItems) {  		//鼠标在子项内.  		if (subitem.Bounds.Contains (m_ptMousePos)) {  			if (subitem.Equals (m_mouseOnSubItem))//与上次的子项一致.  			 {  				return;  			}  			else {  				//引发鼠标在子项上的事件.  				OnMouseOnSubItem (new GroupListBoxEventArgs (item' subitem));  			}  			ClearSubItemMouseOn ();  			ClearItemMouseOn ();  			m_mouseOnSubItem = subitem;  			this.Invalidate (new Rectangle (subitem.Bounds.X' subitem.Bounds.Y - chatVScroll.Value' subitem.Bounds.Width' subitem.Bounds.Height));  			return;  		}  	}  	ClearSubItemMouseOn ();  	//子项没有发现 那么判断是否在列表上面  	if (new Rectangle (0' item.Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  		//在原先的项上.  		if (item.Equals (m_mouseOnItem))  			return;  		//不再原先的项上  		ClearItemMouseOn ();  		m_mouseOnItem = item;  		this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  		return;  	}  }  else {  	if (item.Equals (m_mouseOnItem))  		return;  	ClearItemMouseOn ();  	ClearSubItemMouseOn ();  	m_mouseOnItem = item;  	//绘制指定的区域.  	this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  	return;  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnMouseMove,The following statement contains a magic number: if (new Rectangle (0' item.Bounds.Top - chatVScroll.Value' this.Width' 20).Contains (e.Location)) {  	//在原先的项上.  	if (item.Equals (m_mouseOnItem))  		return;  	//不再原先的项上  	ClearItemMouseOn ();  	m_mouseOnItem = item;  	this.Invalidate (new Rectangle (m_mouseOnItem.Bounds.X' m_mouseOnItem.Bounds.Y - chatVScroll.Value' m_mouseOnItem.Bounds.Width' m_mouseOnItem.Bounds.Height));  	return;  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.ShouldBeDraw) {  	//如果有滚动条 判断是否在滚动条类点击  	if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  		//判断在滚动条那个位置点击  		if (chatVScroll.UpBounds.Contains (m_ptMousePos))  			chatVScroll.Value -= 50;  		else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  			chatVScroll.Value += 50;  		else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  			chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  		return;  	}  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.ShouldBeDraw) {  	//如果有滚动条 判断是否在滚动条类点击  	if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  		//判断在滚动条那个位置点击  		if (chatVScroll.UpBounds.Contains (m_ptMousePos))  			chatVScroll.Value -= 50;  		else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  			chatVScroll.Value += 50;  		else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  			chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  		return;  	}  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  	//判断在滚动条那个位置点击  	if (chatVScroll.UpBounds.Contains (m_ptMousePos))  		chatVScroll.Value -= 50;  	else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  		chatVScroll.Value += 50;  	else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  		chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  	return;  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.Bounds.Contains (m_ptMousePos)) {  	//判断在滚动条那个位置点击  	if (chatVScroll.UpBounds.Contains (m_ptMousePos))  		chatVScroll.Value -= 50;  	else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  		chatVScroll.Value += 50;  	else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  		chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  	return;  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.UpBounds.Contains (m_ptMousePos))  	chatVScroll.Value -= 50;  else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  	chatVScroll.Value += 50;  else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  	chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.UpBounds.Contains (m_ptMousePos))  	chatVScroll.Value -= 50;  else if (chatVScroll.DownBounds.Contains (m_ptMousePos))  	chatVScroll.Value += 50;  else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  	chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: chatVScroll.Value -= 50;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (chatVScroll.DownBounds.Contains (m_ptMousePos))  	chatVScroll.Value += 50;  else if (!chatVScroll.SliderBounds.Contains (m_ptMousePos))  	chatVScroll.MoveSliderToLocation (m_ptMousePos.Y);  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: chatVScroll.Value += 50;  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: foreach (var item in Items) {  	if (item.Bounds.Contains (m_ptMousePos)) {  		if (item.IsOpen) {  			foreach (var subItem in item.SubItems) {  				if (subItem.Bounds.Contains (m_ptMousePos)) {  					if (subItem.Equals (SelectSubItem))  						return;  					SelectSubItem = subItem;  					this.Invalidate ();  					OnClickSubItem (new GroupListBoxEventArgs (m_mouseOnItem' SelectSubItem));  					return;  				}  			}  			if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  				SelectSubItem = null;  				item.IsOpen = !item.IsOpen;  				this.Invalidate ();  				return;  			}  		}  		else {  			SelectSubItem = null;  			item.IsOpen = !item.IsOpen;  			this.Invalidate ();  			return;  		}  	}  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (item.Bounds.Contains (m_ptMousePos)) {  	if (item.IsOpen) {  		foreach (var subItem in item.SubItems) {  			if (subItem.Bounds.Contains (m_ptMousePos)) {  				if (subItem.Equals (SelectSubItem))  					return;  				SelectSubItem = subItem;  				this.Invalidate ();  				OnClickSubItem (new GroupListBoxEventArgs (m_mouseOnItem' SelectSubItem));  				return;  			}  		}  		if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  			SelectSubItem = null;  			item.IsOpen = !item.IsOpen;  			this.Invalidate ();  			return;  		}  	}  	else {  		SelectSubItem = null;  		item.IsOpen = !item.IsOpen;  		this.Invalidate ();  		return;  	}  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (item.IsOpen) {  	foreach (var subItem in item.SubItems) {  		if (subItem.Bounds.Contains (m_ptMousePos)) {  			if (subItem.Equals (SelectSubItem))  				return;  			SelectSubItem = subItem;  			this.Invalidate ();  			OnClickSubItem (new GroupListBoxEventArgs (m_mouseOnItem' SelectSubItem));  			return;  		}  	}  	if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  		SelectSubItem = null;  		item.IsOpen = !item.IsOpen;  		this.Invalidate ();  		return;  	}  }  else {  	SelectSubItem = null;  	item.IsOpen = !item.IsOpen;  	this.Invalidate ();  	return;  }  
Magic Number,CRC.Controls,GroupListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\GroupListBox.cs,OnClick,The following statement contains a magic number: if (new Rectangle (0' item.Bounds.Top' this.Width' 20).Contains (m_ptMousePos)) {  	SelectSubItem = null;  	item.IsOpen = !item.IsOpen;  	this.Invalidate ();  	return;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (e.Index > -1) {  	//设置文本绘制的方式.  	StringFormat sf = new StringFormat ();  	sf.LineAlignment = StringAlignment.Near;  	sf.FormatFlags = StringFormatFlags.FitBlackBox;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h + Font.Height + 5;  		e.ItemWidth = Width;  	}  	else {  		// 测量文本的区域.  		string text = Items [e.Index].ToString ();  		SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  		//重新调整文本的子项的区域大小.  		int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  		e.ItemHeight = (int)size.Height + h;  		e.ItemWidth = Width;  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: if (cm != null) {  	SizeF size = e.Graphics.MeasureString (cm.Text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h + Font.Height + 5;  	e.ItemWidth = Width;  }  else {  	// 测量文本的区域.  	string text = Items [e.Index].ToString ();  	SizeF size = e.Graphics.MeasureString (text' Font' Width - padWidth' sf);  	//重新调整文本的子项的区域大小.  	int h = e.Index == 0 ? padHeigth * 2 + 5 : padHeigth * 2;  	e.ItemHeight = (int)size.Height + h;  	e.ItemWidth = Width;  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnMeasureItem,The following statement contains a magic number: e.ItemHeight = (int)size.Height + h + Font.Height + 5;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (e.Index > -1) {  	Graphics g = e.Graphics;  	Rectangle rect = e.Bounds;  	string text = string.Empty;  	string title = string.Empty;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  		}  	}  	else {  		rect = GetBounds (rect);  		text = Items [e.Index].ToString ();  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  		}  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (e.Index > -1) {  	Graphics g = e.Graphics;  	Rectangle rect = e.Bounds;  	string text = string.Empty;  	string title = string.Empty;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  		}  	}  	else {  		rect = GetBounds (rect);  		text = Items [e.Index].ToString ();  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  		}  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (e.Index > -1) {  	Graphics g = e.Graphics;  	Rectangle rect = e.Bounds;  	string text = string.Empty;  	string title = string.Empty;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  		}  	}  	else {  		rect = GetBounds (rect);  		text = Items [e.Index].ToString ();  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  		}  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (e.Index > -1) {  	Graphics g = e.Graphics;  	Rectangle rect = e.Bounds;  	string text = string.Empty;  	string title = string.Empty;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  		}  	}  	else {  		rect = GetBounds (rect);  		text = Items [e.Index].ToString ();  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  		}  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (e.Index > -1) {  	Graphics g = e.Graphics;  	Rectangle rect = e.Bounds;  	string text = string.Empty;  	string title = string.Empty;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  		}  	}  	else {  		rect = GetBounds (rect);  		text = Items [e.Index].ToString ();  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  		}  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (e.Index > -1) {  	Graphics g = e.Graphics;  	Rectangle rect = e.Bounds;  	string text = string.Empty;  	string title = string.Empty;  	ChatMessage cm = Items [e.Index] as ChatMessage;  	if (cm != null) {  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  			g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  		}  	}  	else {  		rect = GetBounds (rect);  		text = Items [e.Index].ToString ();  		if ((e.State & DrawItemState.Focus) == 0) {  			//子项处于焦点状态   			g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  			g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		}  		else {  			//子项处于非焦点状态.  			g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  			g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  		}  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (cm != null) {  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  	}  }  else {  	rect = GetBounds (rect);  	text = Items [e.Index].ToString ();  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (cm != null) {  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  	}  }  else {  	rect = GetBounds (rect);  	text = Items [e.Index].ToString ();  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (cm != null) {  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  	}  }  else {  	rect = GetBounds (rect);  	text = Items [e.Index].ToString ();  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (cm != null) {  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  	}  }  else {  	rect = GetBounds (rect);  	text = Items [e.Index].ToString ();  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (cm != null) {  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  	}  }  else {  	rect = GetBounds (rect);  	text = Items [e.Index].ToString ();  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if (cm != null) {  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  		g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  	}  }  else {  	rect = GetBounds (rect);  	text = Items [e.Index].ToString ();  	if ((e.State & DrawItemState.Focus) == 0) {  		//子项处于焦点状态   		g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.WindowText)' rect);  		g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	}  	else {  		//子项处于非焦点状态.  		g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  		g.DrawString (text' Font' new SolidBrush (SystemColors.HighlightText)' rect);  	}  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if ((e.State & DrawItemState.Focus) == 0) {  	//子项处于焦点状态   	g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  	g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  }  else {  	//子项处于非焦点状态.  	g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if ((e.State & DrawItemState.Focus) == 0) {  	//子项处于焦点状态   	g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  	g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  }  else {  	//子项处于非焦点状态.  	g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if ((e.State & DrawItemState.Focus) == 0) {  	//子项处于焦点状态   	g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  	g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  }  else {  	//子项处于非焦点状态.  	g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if ((e.State & DrawItemState.Focus) == 0) {  	//子项处于焦点状态   	g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  	g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  }  else {  	//子项处于非焦点状态.  	g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if ((e.State & DrawItemState.Focus) == 0) {  	//子项处于焦点状态   	g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  	g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  }  else {  	//子项处于非焦点状态.  	g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: if ((e.State & DrawItemState.Focus) == 0) {  	//子项处于焦点状态   	g.FillRectangle (new SolidBrush (SystemColors.Window)' e.Bounds);  	g.DrawRectangle (new Pen (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.WindowText)' GetTextBounds (rect));  }  else {  	//子项处于非焦点状态.  	g.FillRectangle (new SolidBrush (SystemColors.Highlight)' e.Bounds);  	g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  	g.DrawString (cm.Text' Font' new SolidBrush (SystemColors.HighlightText)' GetTextBounds (rect));  }  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.WindowText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,OnDrawItem,The following statement contains a magic number: g.DrawString (cm.Title' Font' new SolidBrush (SystemColors.HighlightText)' new Rectangle (rect.X + 2' rect.Y + 3' rect.Width - 2' Font.Height));  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetBounds,The following statement contains a magic number: rect.X += padWidth / 2;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetBounds,The following statement contains a magic number: rect.Width -= padWidth / 2;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetBounds,The following statement contains a magic number: rect.Y += padHeigth / 2;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetBounds,The following statement contains a magic number: rect.Height -= padHeigth / 2;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetTextBounds,The following statement contains a magic number: rect.X += padWidth / 2;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetTextBounds,The following statement contains a magic number: rect.Width -= padWidth / 2;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetTextBounds,The following statement contains a magic number: rect.Y += padHeigth / 2 + 3 + Font.Height;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetTextBounds,The following statement contains a magic number: rect.Y += padHeigth / 2 + 3 + Font.Height;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetTextBounds,The following statement contains a magic number: rect.Height -= padHeigth / 2 + 3 + Font.Height;  
Magic Number,CRC.Controls,ChatTextListBox,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\MultiTextListBox.cs,GetTextBounds,The following statement contains a magic number: rect.Height -= padHeigth / 2 + 3 + Font.Height;  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) {  	Blend blend = new Blend ();  	blend.Positions = new float[] {  		0f'  		.5f'  		1f  	};  	blend.Factors = new float[] {  		.5F'  		1F'  		.5F  	};  	brush.Blend = blend;  	g.FillRectangle (brush' rect);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) {  	Blend blend = new Blend ();  	blend.Positions = new float[] {  		0f'  		.5f'  		1f  	};  	blend.Factors = new float[] {  		.5F'  		1F'  		.5F  	};  	brush.Blend = blend;  	g.FillRectangle (brush' rect);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) {  	Blend blend = new Blend ();  	blend.Positions = new float[] {  		0f'  		.5f'  		1f  	};  	blend.Factors = new float[] {  		.5F'  		1F'  		.5F  	};  	brush.Blend = blend;  	g.FillRectangle (brush' rect);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) {  	Blend blend = new Blend ();  	blend.Positions = new float[] {  		0f'  		.5f'  		1f  	};  	blend.Factors = new float[] {  		.5F'  		1F'  		.5F  	};  	brush.Blend = blend;  	g.FillRectangle (brush' rect);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) {  	Blend blend = new Blend ();  	blend.Positions = new float[] {  		0f'  		.5f'  		1f  	};  	blend.Factors = new float[] {  		.5F'  		1F'  		.5F  	};  	brush.Blend = blend;  	g.FillRectangle (brush' rect);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.FromArgb (206' 238' 255)' Color.FromArgb (105' 200' 254)' gradientMode)) {  	Blend blend = new Blend ();  	blend.Positions = new float[] {  		0f'  		.5f'  		1f  	};  	blend.Factors = new float[] {  		.5F'  		1F'  		.5F  	};  	brush.Blend = blend;  	g.FillRectangle (brush' rect);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (SmoothingModeGraphics sg = new SmoothingModeGraphics (g)) {  	//绘制网格点.  	RenderHelper.RenderGrid (g' topLeftRect' new Size (3' 3)' foreColor);  	RenderHelper.RenderGrid (g' bottomRightRect' new Size (3' 3)' foreColor);  	using (Brush brush = new SolidBrush (foreColor)) {  		//渲染箭头.  		RenderHelper.RenderArrowInternal (g' arrowRect' direction' brush);  	}  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (SmoothingModeGraphics sg = new SmoothingModeGraphics (g)) {  	//绘制网格点.  	RenderHelper.RenderGrid (g' topLeftRect' new Size (3' 3)' foreColor);  	RenderHelper.RenderGrid (g' bottomRightRect' new Size (3' 3)' foreColor);  	using (Brush brush = new SolidBrush (foreColor)) {  		//渲染箭头.  		RenderHelper.RenderArrowInternal (g' arrowRect' direction' brush);  	}  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (SmoothingModeGraphics sg = new SmoothingModeGraphics (g)) {  	//绘制网格点.  	RenderHelper.RenderGrid (g' topLeftRect' new Size (3' 3)' foreColor);  	RenderHelper.RenderGrid (g' bottomRightRect' new Size (3' 3)' foreColor);  	using (Brush brush = new SolidBrush (foreColor)) {  		//渲染箭头.  		RenderHelper.RenderArrowInternal (g' arrowRect' direction' brush);  	}  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: using (SmoothingModeGraphics sg = new SmoothingModeGraphics (g)) {  	//绘制网格点.  	RenderHelper.RenderGrid (g' topLeftRect' new Size (3' 3)' foreColor);  	RenderHelper.RenderGrid (g' bottomRightRect' new Size (3' 3)' foreColor);  	using (Brush brush = new SolidBrush (foreColor)) {  		//渲染箭头.  		RenderHelper.RenderArrowInternal (g' arrowRect' direction' brush);  	}  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: RenderHelper.RenderGrid (g' topLeftRect' new Size (3' 3)' foreColor);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: RenderHelper.RenderGrid (g' topLeftRect' new Size (3' 3)' foreColor);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: RenderHelper.RenderGrid (g' bottomRightRect' new Size (3' 3)' foreColor);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following statement contains a magic number: RenderHelper.RenderGrid (g' bottomRightRect' new Size (3' 3)' foreColor);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: if (base.Orientation == Orientation.Horizontal) {  	width = (collapseRect.Width - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X + width' collapseRect.Y' DefaultArrowWidth' collapseRect.Height);  	topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  	bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  }  else {  	width = (collapseRect.Height - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X' collapseRect.Y + width' collapseRect.Width' DefaultArrowWidth);  	topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  	bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: if (base.Orientation == Orientation.Horizontal) {  	width = (collapseRect.Width - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X + width' collapseRect.Y' DefaultArrowWidth' collapseRect.Height);  	topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  	bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  }  else {  	width = (collapseRect.Height - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X' collapseRect.Y + width' collapseRect.Width' DefaultArrowWidth);  	topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  	bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: if (base.Orientation == Orientation.Horizontal) {  	width = (collapseRect.Width - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X + width' collapseRect.Y' DefaultArrowWidth' collapseRect.Height);  	topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  	bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  }  else {  	width = (collapseRect.Height - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X' collapseRect.Y + width' collapseRect.Width' DefaultArrowWidth);  	topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  	bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: if (base.Orientation == Orientation.Horizontal) {  	width = (collapseRect.Width - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X + width' collapseRect.Y' DefaultArrowWidth' collapseRect.Height);  	topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  	bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  }  else {  	width = (collapseRect.Height - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X' collapseRect.Y + width' collapseRect.Width' DefaultArrowWidth);  	topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  	bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: if (base.Orientation == Orientation.Horizontal) {  	width = (collapseRect.Width - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X + width' collapseRect.Y' DefaultArrowWidth' collapseRect.Height);  	topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  	bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  }  else {  	width = (collapseRect.Height - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X' collapseRect.Y + width' collapseRect.Width' DefaultArrowWidth);  	topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  	bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: if (base.Orientation == Orientation.Horizontal) {  	width = (collapseRect.Width - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X + width' collapseRect.Y' DefaultArrowWidth' collapseRect.Height);  	topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  	bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  }  else {  	width = (collapseRect.Height - DefaultArrowWidth) / 2;  	arrowRect = new Rectangle (collapseRect.X' collapseRect.Y + width' collapseRect.Width' DefaultArrowWidth);  	topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  	bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  }  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: width = (collapseRect.Width - DefaultArrowWidth) / 2;  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: topLeftRect = new Rectangle (collapseRect.X' collapseRect.Y + 1' width' collapseRect.Height - 2);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: bottomRightRect = new Rectangle (arrowRect.Right' collapseRect.Y + 1' width' collapseRect.Height - 2);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: width = (collapseRect.Height - DefaultArrowWidth) / 2;  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: topLeftRect = new Rectangle (collapseRect.X + 1' collapseRect.Y' collapseRect.Width - 2' width);  
Magic Number,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateRect,The following statement contains a magic number: bottomRightRect = new Rectangle (collapseRect.X + 1' arrowRect.Bottom' collapseRect.Width - 2' width);  
Magic Number,CWebQQ.UI,RegionHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateRegion,The following statement contains a magic number: CreateRegion (control' bounds' 8' RoundStyle.All);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: RenderBackgroundInternal (g' rect' baseColor' borderColor' innerBorderColor' style' 8' drawBorder' drawGlass' mode);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: RenderBackgroundInternal (g' rect' baseColor' borderColor' innerBorderColor' style' 8' 0.45f' drawBorder' drawGlass' mode);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (LinearGradientBrush brush = new LinearGradientBrush (rect' Color.Transparent' Color.Transparent' mode)) {  	Color[] colors = new Color[4];  	colors [0] = GetColor (baseColor' 0' 35' 24' 9);  	colors [1] = GetColor (baseColor' 0' 13' 8' 3);  	colors [2] = baseColor;  	colors [3] = GetColor (baseColor' 0' 35' 24' 9);  	ColorBlend blend = new ColorBlend ();  	blend.Positions = new float[] {  		0.0f'  		basePosition'  		basePosition + 0.05f'  		1.0f  	};  	blend.Colors = colors;  	brush.InterpolationColors = blend;  	if (style != RoundStyle.None) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			g.FillPath (brush' path);  		}  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  				using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  					g.FillPath (brushAlpha' pathTop);  				}  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  		}  		if (drawBorder) {  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (borderColor)) {  					g.DrawPath (pen' path);  				}  			}  			rect.Inflate (-1' -1);  			using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  				using (Pen pen = new Pen (innerBorderColor)) {  					g.DrawPath (pen' path);  				}  			}  		}  	}  	else {  		g.FillRectangle (brush' rect);  		if (baseColor.A > 80) {  			Rectangle rectTop = rect;  			if (mode == LinearGradientMode.Vertical) {  				rectTop.Height = (int)(rectTop.Height * basePosition);  			}  			else {  				rectTop.Width = (int)(rect.Width * basePosition);  			}  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillRectangle (brushAlpha' rectTop);  			}  		}  		if (drawGlass) {  			RectangleF glassRect = rect;  			if (mode == LinearGradientMode.Vertical) {  				glassRect.Y = rect.Y + rect.Height * basePosition;  				glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  			}  			else {  				glassRect.X = rect.X + rect.Width * basePosition;  				glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  			}  			ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  		}  		if (drawBorder) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawRectangle (pen' rect);  			}  			rect.Inflate (-1' -1);  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawRectangle (pen' rect);  			}  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [0] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [0] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [0] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [1] = GetColor (baseColor' 0' 13' 8' 3);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [1] = GetColor (baseColor' 0' 13' 8' 3);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [1] = GetColor (baseColor' 0' 13' 8' 3);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [2] = baseColor;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [3] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [3] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [3] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: colors [3] = GetColor (baseColor' 0' 35' 24' 9);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (style != RoundStyle.None) {  	using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  		g.FillPath (brush' path);  	}  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  			using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  				g.FillPath (brushAlpha' pathTop);  			}  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  	}  	if (drawBorder) {  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (borderColor)) {  				g.DrawPath (pen' path);  			}  		}  		rect.Inflate (-1' -1);  		using (GraphicsPath path = GraphicsPathHelper.CreatePath (rect' roundWidth' style' false)) {  			using (Pen pen = new Pen (innerBorderColor)) {  				g.DrawPath (pen' path);  			}  		}  	}  }  else {  	g.FillRectangle (brush' rect);  	if (baseColor.A > 80) {  		Rectangle rectTop = rect;  		if (mode == LinearGradientMode.Vertical) {  			rectTop.Height = (int)(rectTop.Height * basePosition);  		}  		else {  			rectTop.Width = (int)(rect.Width * basePosition);  		}  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillRectangle (brushAlpha' rectTop);  		}  	}  	if (drawGlass) {  		RectangleF glassRect = rect;  		if (mode == LinearGradientMode.Vertical) {  			glassRect.Y = rect.Y + rect.Height * basePosition;  			glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  		}  		else {  			glassRect.X = rect.X + rect.Width * basePosition;  			glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  		}  		ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  	}  	if (drawBorder) {  		using (Pen pen = new Pen (borderColor)) {  			g.DrawRectangle (pen' rect);  		}  		rect.Inflate (-1' -1);  		using (Pen pen = new Pen (innerBorderColor)) {  			g.DrawRectangle (pen' rect);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillPath (brushAlpha' pathTop);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillPath (brushAlpha' pathTop);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillPath (brushAlpha' pathTop);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillPath (brushAlpha' pathTop);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  		using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  			g.FillPath (brushAlpha' pathTop);  		}  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillPath (brushAlpha' pathTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillPath (brushAlpha' pathTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillPath (brushAlpha' pathTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (GraphicsPath pathTop = GraphicsPathHelper.CreatePath (rectTop' roundWidth' RoundStyle.Top' false)) {  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillPath (brushAlpha' pathTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillPath (brushAlpha' pathTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillPath (brushAlpha' pathTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillPath (brushAlpha' pathTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillPath (brushAlpha' pathTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (drawGlass) {  	RectangleF glassRect = rect;  	if (mode == LinearGradientMode.Vertical) {  		glassRect.Y = rect.Y + rect.Height * basePosition;  		glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  	}  	else {  		glassRect.X = rect.X + rect.Width * basePosition;  		glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  	}  	ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (drawGlass) {  	RectangleF glassRect = rect;  	if (mode == LinearGradientMode.Vertical) {  		glassRect.Y = rect.Y + rect.Height * basePosition;  		glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  	}  	else {  		glassRect.X = rect.X + rect.Width * basePosition;  		glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  	}  	ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (drawGlass) {  	RectangleF glassRect = rect;  	if (mode == LinearGradientMode.Vertical) {  		glassRect.Y = rect.Y + rect.Height * basePosition;  		glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  	}  	else {  		glassRect.X = rect.X + rect.Width * basePosition;  		glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  	}  	ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (mode == LinearGradientMode.Vertical) {  	glassRect.Y = rect.Y + rect.Height * basePosition;  	glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  }  else {  	glassRect.X = rect.X + rect.Width * basePosition;  	glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (mode == LinearGradientMode.Vertical) {  	glassRect.Y = rect.Y + rect.Height * basePosition;  	glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  }  else {  	glassRect.X = rect.X + rect.Width * basePosition;  	glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: ControlPaintEx.DrawGlass (g' glassRect' 170' 0);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillRectangle (brushAlpha' rectTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillRectangle (brushAlpha' rectTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillRectangle (brushAlpha' rectTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillRectangle (brushAlpha' rectTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (baseColor.A > 80) {  	Rectangle rectTop = rect;  	if (mode == LinearGradientMode.Vertical) {  		rectTop.Height = (int)(rectTop.Height * basePosition);  	}  	else {  		rectTop.Width = (int)(rect.Width * basePosition);  	}  	using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  		g.FillRectangle (brushAlpha' rectTop);  	}  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillRectangle (brushAlpha' rectTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillRectangle (brushAlpha' rectTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillRectangle (brushAlpha' rectTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: using (SolidBrush brushAlpha = new SolidBrush (Color.FromArgb (128' 255' 255' 255))) {  	g.FillRectangle (brushAlpha' rectTop);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (drawGlass) {  	RectangleF glassRect = rect;  	if (mode == LinearGradientMode.Vertical) {  		glassRect.Y = rect.Y + rect.Height * basePosition;  		glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  	}  	else {  		glassRect.X = rect.X + rect.Width * basePosition;  		glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  	}  	ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (drawGlass) {  	RectangleF glassRect = rect;  	if (mode == LinearGradientMode.Vertical) {  		glassRect.Y = rect.Y + rect.Height * basePosition;  		glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  	}  	else {  		glassRect.X = rect.X + rect.Width * basePosition;  		glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  	}  	ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (drawGlass) {  	RectangleF glassRect = rect;  	if (mode == LinearGradientMode.Vertical) {  		glassRect.Y = rect.Y + rect.Height * basePosition;  		glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  	}  	else {  		glassRect.X = rect.X + rect.Width * basePosition;  		glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  	}  	ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (mode == LinearGradientMode.Vertical) {  	glassRect.Y = rect.Y + rect.Height * basePosition;  	glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  }  else {  	glassRect.X = rect.X + rect.Width * basePosition;  	glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: if (mode == LinearGradientMode.Vertical) {  	glassRect.Y = rect.Y + rect.Height * basePosition;  	glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  }  else {  	glassRect.X = rect.X + rect.Width * basePosition;  	glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: glassRect.Height = (rect.Height - rect.Height * basePosition) * 2;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: glassRect.Width = (rect.Width - rect.Width * basePosition) * 2;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderBackgroundInternal,The following statement contains a magic number: ControlPaintEx.DrawGlass (g' glassRect' 200' 0);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: switch (direction) {  case ArrowDirection.Left:  	points = new Point[] {  		new Point (point.X + 1' point.Y - 4)'  		new Point (point.X + 1' point.Y + 4)'  		new Point (point.X - 2' point.Y)  	};  	break;  case ArrowDirection.Up:  	points = new Point[] {  		new Point (point.X - 4' point.Y + 1)'  		new Point (point.X + 4' point.Y + 1)'  		new Point (point.X' point.Y - 2)  	};  	break;  case ArrowDirection.Right:  	points = new Point[] {  		new Point (point.X - 2' point.Y - 4)'  		new Point (point.X - 2' point.Y + 4)'  		new Point (point.X + 1' point.Y)  	};  	break;  default:  	points = new Point[] {  		new Point (point.X - 4' point.Y - 1)'  		new Point (point.X + 4' point.Y - 1)'  		new Point (point.X' point.Y + 2)  	};  	break;  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X + 1' point.Y - 4)'  	new Point (point.X + 1' point.Y + 4)'  	new Point (point.X - 2' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X + 1' point.Y - 4)'  	new Point (point.X + 1' point.Y + 4)'  	new Point (point.X - 2' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X + 1' point.Y - 4)'  	new Point (point.X + 1' point.Y + 4)'  	new Point (point.X - 2' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 4' point.Y + 1)'  	new Point (point.X + 4' point.Y + 1)'  	new Point (point.X' point.Y - 2)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 4' point.Y + 1)'  	new Point (point.X + 4' point.Y + 1)'  	new Point (point.X' point.Y - 2)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 4' point.Y + 1)'  	new Point (point.X + 4' point.Y + 1)'  	new Point (point.X' point.Y - 2)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 2' point.Y - 4)'  	new Point (point.X - 2' point.Y + 4)'  	new Point (point.X + 1' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 2' point.Y - 4)'  	new Point (point.X - 2' point.Y + 4)'  	new Point (point.X + 1' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 2' point.Y - 4)'  	new Point (point.X - 2' point.Y + 4)'  	new Point (point.X + 1' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 2' point.Y - 4)'  	new Point (point.X - 2' point.Y + 4)'  	new Point (point.X + 1' point.Y)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 4' point.Y - 1)'  	new Point (point.X + 4' point.Y - 1)'  	new Point (point.X' point.Y + 2)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 4' point.Y - 1)'  	new Point (point.X + 4' point.Y - 1)'  	new Point (point.X' point.Y + 2)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderArrowInternal,The following statement contains a magic number: points = new Point[] {  	new Point (point.X - 4' point.Y - 1)'  	new Point (point.X + 4' point.Y - 1)'  	new Point (point.X' point.Y + 2)  };  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderAlphaImage,The following statement contains a magic number: using (ImageAttributes imageAttributes = new ImageAttributes ()) {  	ColorMap colorMap = new ColorMap ();  	colorMap.OldColor = Color.FromArgb (255' 0' 255' 0);  	colorMap.NewColor = Color.FromArgb (0' 0' 0' 0);  	ColorMap[] remapTable =  {  		colorMap  	};  	imageAttributes.SetRemapTable (remapTable' ColorAdjustType.Bitmap);  	float[][] colorMatrixElements =  {  		new float[] {  			1.0f'  			0.0f'  			0.0f'  			0.0f'  			0.0f  		}'  		new float[] {  			0.0f'  			1.0f'  			0.0f'  			0.0f'  			0.0f  		}'  		new float[] {  			0.0f'  			0.0f'  			1.0f'  			0.0f'  			0.0f  		}'  		new float[] {  			0.0f'  			0.0f'  			0.0f'  			alpha'  			0.0f  		}'  		new float[] {  			0.0f'  			0.0f'  			0.0f'  			0.0f'  			1.0f  		}  	};  	ColorMatrix wmColorMatrix = new ColorMatrix (colorMatrixElements);  	imageAttributes.SetColorMatrix (wmColorMatrix' ColorMatrixFlag.Default' ColorAdjustType.Bitmap);  	g.DrawImage (image' imageRect' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' imageAttributes);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderAlphaImage,The following statement contains a magic number: using (ImageAttributes imageAttributes = new ImageAttributes ()) {  	ColorMap colorMap = new ColorMap ();  	colorMap.OldColor = Color.FromArgb (255' 0' 255' 0);  	colorMap.NewColor = Color.FromArgb (0' 0' 0' 0);  	ColorMap[] remapTable =  {  		colorMap  	};  	imageAttributes.SetRemapTable (remapTable' ColorAdjustType.Bitmap);  	float[][] colorMatrixElements =  {  		new float[] {  			1.0f'  			0.0f'  			0.0f'  			0.0f'  			0.0f  		}'  		new float[] {  			0.0f'  			1.0f'  			0.0f'  			0.0f'  			0.0f  		}'  		new float[] {  			0.0f'  			0.0f'  			1.0f'  			0.0f'  			0.0f  		}'  		new float[] {  			0.0f'  			0.0f'  			0.0f'  			alpha'  			0.0f  		}'  		new float[] {  			0.0f'  			0.0f'  			0.0f'  			0.0f'  			1.0f  		}  	};  	ColorMatrix wmColorMatrix = new ColorMatrix (colorMatrixElements);  	imageAttributes.SetColorMatrix (wmColorMatrix' ColorMatrixFlag.Default' ColorAdjustType.Bitmap);  	g.DrawImage (image' imageRect' 0' 0' image.Width' image.Height' GraphicsUnit.Pixel' imageAttributes);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderAlphaImage,The following statement contains a magic number: colorMap.OldColor = Color.FromArgb (255' 0' 255' 0);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,RenderAlphaImage,The following statement contains a magic number: colorMap.OldColor = Color.FromArgb (255' 0' 255' 0);  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (a + a0 > 255) {  	a = 255;  }  else {  	a = Math.Max (0' a + a0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (a + a0 > 255) {  	a = 255;  }  else {  	a = Math.Max (0' a + a0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: a = 255;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (r + r0 > 255) {  	r = 255;  }  else {  	r = Math.Max (0' r + r0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (r + r0 > 255) {  	r = 255;  }  else {  	r = Math.Max (0' r + r0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: r = 255;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (g + g0 > 255) {  	g = 255;  }  else {  	g = Math.Max (0' g + g0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (g + g0 > 255) {  	g = 255;  }  else {  	g = Math.Max (0' g + g0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: g = 255;  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (b + b0 > 255) {  	b = 255;  }  else {  	b = Math.Max (0' b + b0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: if (b + b0 > 255) {  	b = 255;  }  else {  	b = Math.Max (0' b + b0);  }  
Magic Number,CWebQQ.UI,RenderHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,GetColor,The following statement contains a magic number: b = 255;  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following statement contains a magic number: path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,The following statement contains a magic number: switch (arrowDirection) {  case ThumbArrowDirection.Left:  case ThumbArrowDirection.Right:  	offset = rect.Width / 2f - 4;  	break;  case ThumbArrowDirection.Up:  case ThumbArrowDirection.Down:  	offset = rect.Height / 2f - 4;  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,The following statement contains a magic number: switch (arrowDirection) {  case ThumbArrowDirection.Left:  case ThumbArrowDirection.Right:  	offset = rect.Width / 2f - 4;  	break;  case ThumbArrowDirection.Up:  case ThumbArrowDirection.Down:  	offset = rect.Height / 2f - 4;  	break;  }  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,The following statement contains a magic number: offset = rect.Width / 2f - 4;  
Magic Number,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,The following statement contains a magic number: offset = rect.Height / 2f - 4;  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawCheckedFlag,The following statement contains a magic number: points [2] = new PointF (rect.Right - rect.Width / 4.0f' rect.Y + rect.Height / 4.5f);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	path.AddEllipse (glassRect);  	//绘制一个椭圆  	using (PathGradientBrush brush = new PathGradientBrush (path)) {  		//设置中心的颜色  		brush.CenterColor = Color.FromArgb (alphaCenter' glassColor);  		//设置周边的颜色.  		brush.SurroundColors = new Color[] {  			Color.FromArgb (alphaSurround' glassColor)  		};  		//指定中心点.  		brush.CenterPoint = new PointF (glassRect.X + glassRect.Width / 2' glassRect.Y + glassRect.Height / 2);  		//绘制.  		g.FillPath (brush' path);  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath ()) {  	path.AddEllipse (glassRect);  	//绘制一个椭圆  	using (PathGradientBrush brush = new PathGradientBrush (path)) {  		//设置中心的颜色  		brush.CenterColor = Color.FromArgb (alphaCenter' glassColor);  		//设置周边的颜色.  		brush.SurroundColors = new Color[] {  			Color.FromArgb (alphaSurround' glassColor)  		};  		//指定中心点.  		brush.CenterPoint = new PointF (glassRect.X + glassRect.Width / 2' glassRect.Y + glassRect.Height / 2);  		//绘制.  		g.FillPath (brush' path);  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The following statement contains a magic number: using (PathGradientBrush brush = new PathGradientBrush (path)) {  	//设置中心的颜色  	brush.CenterColor = Color.FromArgb (alphaCenter' glassColor);  	//设置周边的颜色.  	brush.SurroundColors = new Color[] {  		Color.FromArgb (alphaSurround' glassColor)  	};  	//指定中心点.  	brush.CenterPoint = new PointF (glassRect.X + glassRect.Width / 2' glassRect.Y + glassRect.Height / 2);  	//绘制.  	g.FillPath (brush' path);  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The following statement contains a magic number: using (PathGradientBrush brush = new PathGradientBrush (path)) {  	//设置中心的颜色  	brush.CenterColor = Color.FromArgb (alphaCenter' glassColor);  	//设置周边的颜色.  	brush.SurroundColors = new Color[] {  		Color.FromArgb (alphaSurround' glassColor)  	};  	//指定中心点.  	brush.CenterPoint = new PointF (glassRect.X + glassRect.Width / 2' glassRect.Y + glassRect.Height / 2);  	//绘制.  	g.FillPath (brush' path);  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The following statement contains a magic number: brush.CenterPoint = new PointF (glassRect.X + glassRect.Width / 2' glassRect.Y + glassRect.Height / 2);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawGlass,The following statement contains a magic number: brush.CenterPoint = new PointF (glassRect.X + glassRect.Width / 2' glassRect.Y + glassRect.Height / 2);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawScrollBarThumb,The following statement contains a magic number: DrawGradientRoundRect (g' rect' begin' end' border' innerBorder' blend' mode' 4' RoundStyle.All' true' true);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,DrawScrollBarArraw,The following statement contains a magic number: DrawGradientRoundRect (g' rect' begin' end' border' innerBorder' blend' mode' 4' RoundStyle.All' true' true);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (backgroundImage != null) {  	switch (imageLayout) {  	case ImageLayout.None:  		//无   		rectangle.Size = backgroundImage.Size;  		return rectangle;  	case ImageLayout.Tile:  		//  		return rectangle;  	case ImageLayout.Center://图片居中显示.  	 {  		rectangle.Size = backgroundImage.Size;  		Size size = bounds.Size;  		if (size.Width > rectangle.Width) {  			rectangle.X = (size.Width - rectangle.Width) / 2;  		}  		if (size.Height > rectangle.Height) {  			rectangle.Y = (size.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	case ImageLayout.Stretch:  		//图片拉伸.  		rectangle.Size = bounds.Size;  		return rectangle;  	case ImageLayout.Zoom://图片放大.  	 {  		Size size2 = backgroundImage.Size;  		float num = ((float)bounds.Width) / ((float)size2.Width);  		float num2 = ((float)bounds.Height) / ((float)size2.Height);  		if (num >= num2) {  			rectangle.Height = bounds.Height;  			rectangle.Width = (int)((size2.Width * num2) + 0.5);  			if (bounds.X >= 0) {  				rectangle.X = (bounds.Width - rectangle.Width) / 2;  			}  			return rectangle;  		}  		rectangle.Width = bounds.Width;  		rectangle.Height = (int)((size2.Height * num) + 0.5);  		if (bounds.Y >= 0) {  			rectangle.Y = (bounds.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (backgroundImage != null) {  	switch (imageLayout) {  	case ImageLayout.None:  		//无   		rectangle.Size = backgroundImage.Size;  		return rectangle;  	case ImageLayout.Tile:  		//  		return rectangle;  	case ImageLayout.Center://图片居中显示.  	 {  		rectangle.Size = backgroundImage.Size;  		Size size = bounds.Size;  		if (size.Width > rectangle.Width) {  			rectangle.X = (size.Width - rectangle.Width) / 2;  		}  		if (size.Height > rectangle.Height) {  			rectangle.Y = (size.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	case ImageLayout.Stretch:  		//图片拉伸.  		rectangle.Size = bounds.Size;  		return rectangle;  	case ImageLayout.Zoom://图片放大.  	 {  		Size size2 = backgroundImage.Size;  		float num = ((float)bounds.Width) / ((float)size2.Width);  		float num2 = ((float)bounds.Height) / ((float)size2.Height);  		if (num >= num2) {  			rectangle.Height = bounds.Height;  			rectangle.Width = (int)((size2.Width * num2) + 0.5);  			if (bounds.X >= 0) {  				rectangle.X = (bounds.Width - rectangle.Width) / 2;  			}  			return rectangle;  		}  		rectangle.Width = bounds.Width;  		rectangle.Height = (int)((size2.Height * num) + 0.5);  		if (bounds.Y >= 0) {  			rectangle.Y = (bounds.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (backgroundImage != null) {  	switch (imageLayout) {  	case ImageLayout.None:  		//无   		rectangle.Size = backgroundImage.Size;  		return rectangle;  	case ImageLayout.Tile:  		//  		return rectangle;  	case ImageLayout.Center://图片居中显示.  	 {  		rectangle.Size = backgroundImage.Size;  		Size size = bounds.Size;  		if (size.Width > rectangle.Width) {  			rectangle.X = (size.Width - rectangle.Width) / 2;  		}  		if (size.Height > rectangle.Height) {  			rectangle.Y = (size.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	case ImageLayout.Stretch:  		//图片拉伸.  		rectangle.Size = bounds.Size;  		return rectangle;  	case ImageLayout.Zoom://图片放大.  	 {  		Size size2 = backgroundImage.Size;  		float num = ((float)bounds.Width) / ((float)size2.Width);  		float num2 = ((float)bounds.Height) / ((float)size2.Height);  		if (num >= num2) {  			rectangle.Height = bounds.Height;  			rectangle.Width = (int)((size2.Width * num2) + 0.5);  			if (bounds.X >= 0) {  				rectangle.X = (bounds.Width - rectangle.Width) / 2;  			}  			return rectangle;  		}  		rectangle.Width = bounds.Width;  		rectangle.Height = (int)((size2.Height * num) + 0.5);  		if (bounds.Y >= 0) {  			rectangle.Y = (bounds.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (backgroundImage != null) {  	switch (imageLayout) {  	case ImageLayout.None:  		//无   		rectangle.Size = backgroundImage.Size;  		return rectangle;  	case ImageLayout.Tile:  		//  		return rectangle;  	case ImageLayout.Center://图片居中显示.  	 {  		rectangle.Size = backgroundImage.Size;  		Size size = bounds.Size;  		if (size.Width > rectangle.Width) {  			rectangle.X = (size.Width - rectangle.Width) / 2;  		}  		if (size.Height > rectangle.Height) {  			rectangle.Y = (size.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	case ImageLayout.Stretch:  		//图片拉伸.  		rectangle.Size = bounds.Size;  		return rectangle;  	case ImageLayout.Zoom://图片放大.  	 {  		Size size2 = backgroundImage.Size;  		float num = ((float)bounds.Width) / ((float)size2.Width);  		float num2 = ((float)bounds.Height) / ((float)size2.Height);  		if (num >= num2) {  			rectangle.Height = bounds.Height;  			rectangle.Width = (int)((size2.Width * num2) + 0.5);  			if (bounds.X >= 0) {  				rectangle.X = (bounds.Width - rectangle.Width) / 2;  			}  			return rectangle;  		}  		rectangle.Width = bounds.Width;  		rectangle.Height = (int)((size2.Height * num) + 0.5);  		if (bounds.Y >= 0) {  			rectangle.Y = (bounds.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (backgroundImage != null) {  	switch (imageLayout) {  	case ImageLayout.None:  		//无   		rectangle.Size = backgroundImage.Size;  		return rectangle;  	case ImageLayout.Tile:  		//  		return rectangle;  	case ImageLayout.Center://图片居中显示.  	 {  		rectangle.Size = backgroundImage.Size;  		Size size = bounds.Size;  		if (size.Width > rectangle.Width) {  			rectangle.X = (size.Width - rectangle.Width) / 2;  		}  		if (size.Height > rectangle.Height) {  			rectangle.Y = (size.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	case ImageLayout.Stretch:  		//图片拉伸.  		rectangle.Size = bounds.Size;  		return rectangle;  	case ImageLayout.Zoom://图片放大.  	 {  		Size size2 = backgroundImage.Size;  		float num = ((float)bounds.Width) / ((float)size2.Width);  		float num2 = ((float)bounds.Height) / ((float)size2.Height);  		if (num >= num2) {  			rectangle.Height = bounds.Height;  			rectangle.Width = (int)((size2.Width * num2) + 0.5);  			if (bounds.X >= 0) {  				rectangle.X = (bounds.Width - rectangle.Width) / 2;  			}  			return rectangle;  		}  		rectangle.Width = bounds.Width;  		rectangle.Height = (int)((size2.Height * num) + 0.5);  		if (bounds.Y >= 0) {  			rectangle.Y = (bounds.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (backgroundImage != null) {  	switch (imageLayout) {  	case ImageLayout.None:  		//无   		rectangle.Size = backgroundImage.Size;  		return rectangle;  	case ImageLayout.Tile:  		//  		return rectangle;  	case ImageLayout.Center://图片居中显示.  	 {  		rectangle.Size = backgroundImage.Size;  		Size size = bounds.Size;  		if (size.Width > rectangle.Width) {  			rectangle.X = (size.Width - rectangle.Width) / 2;  		}  		if (size.Height > rectangle.Height) {  			rectangle.Y = (size.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	case ImageLayout.Stretch:  		//图片拉伸.  		rectangle.Size = bounds.Size;  		return rectangle;  	case ImageLayout.Zoom://图片放大.  	 {  		Size size2 = backgroundImage.Size;  		float num = ((float)bounds.Width) / ((float)size2.Width);  		float num2 = ((float)bounds.Height) / ((float)size2.Height);  		if (num >= num2) {  			rectangle.Height = bounds.Height;  			rectangle.Width = (int)((size2.Width * num2) + 0.5);  			if (bounds.X >= 0) {  				rectangle.X = (bounds.Width - rectangle.Width) / 2;  			}  			return rectangle;  		}  		rectangle.Width = bounds.Width;  		rectangle.Height = (int)((size2.Height * num) + 0.5);  		if (bounds.Y >= 0) {  			rectangle.Y = (bounds.Height - rectangle.Height) / 2;  		}  		return rectangle;  	}  	}  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (size.Width > rectangle.Width) {  	rectangle.X = (size.Width - rectangle.Width) / 2;  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: rectangle.X = (size.Width - rectangle.Width) / 2;  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (size.Height > rectangle.Height) {  	rectangle.Y = (size.Height - rectangle.Height) / 2;  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: rectangle.Y = (size.Height - rectangle.Height) / 2;  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (num >= num2) {  	rectangle.Height = bounds.Height;  	rectangle.Width = (int)((size2.Width * num2) + 0.5);  	if (bounds.X >= 0) {  		rectangle.X = (bounds.Width - rectangle.Width) / 2;  	}  	return rectangle;  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (num >= num2) {  	rectangle.Height = bounds.Height;  	rectangle.Width = (int)((size2.Width * num2) + 0.5);  	if (bounds.X >= 0) {  		rectangle.X = (bounds.Width - rectangle.Width) / 2;  	}  	return rectangle;  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: rectangle.Width = (int)((size2.Width * num2) + 0.5);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (bounds.X >= 0) {  	rectangle.X = (bounds.Width - rectangle.Width) / 2;  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: rectangle.X = (bounds.Width - rectangle.Width) / 2;  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: rectangle.Height = (int)((size2.Height * num) + 0.5);  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: if (bounds.Y >= 0) {  	rectangle.Y = (bounds.Height - rectangle.Height) / 2;  }  
Magic Number,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following statement contains a magic number: rectangle.Y = (bounds.Height - rectangle.Height) / 2;  
Missing Default,CWebQQ.UI,SplitContainerEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,OnPaint,The following switch statement is missing a default case: switch (_collapsePanel) {  case CollapsePanel.Panel1:  	if (bHorizontal) {  		direction = _spliterPanelState == SpliterPanelState.Collapsed ? ArrowDirection.Down : ArrowDirection.Up;  	}  	else {  		direction = _spliterPanelState == SpliterPanelState.Collapsed ? ArrowDirection.Right : ArrowDirection.Left;  	}  	break;  case CollapsePanel.Panel2:  	if (bHorizontal) {  		direction = _spliterPanelState == SpliterPanelState.Collapsed ? ArrowDirection.Up : ArrowDirection.Down;  	}  	else {  		direction = _spliterPanelState == SpliterPanelState.Collapsed ? ArrowDirection.Left : ArrowDirection.Right;  	}  	break;  }  
Missing Default,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreatePath,The following switch statement is missing a default case: switch (style) {  case RoundStyle.None:  	path.AddRectangle (rect);  	break;  case RoundStyle.All:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Left:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	break;  case RoundStyle.Right:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	break;  case RoundStyle.Top:  	path.AddArc (rect.X' rect.Y' radius' radius' 180' 90);  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Y' radius' radius' 270' 90);  	path.AddLine (rect.Right - radiusCorrection' rect.Bottom - radiusCorrection' rect.X' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.Bottom:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  case RoundStyle.BottomLeft:  	path.AddArc (rect.X' rect.Bottom - radius - radiusCorrection' radius' radius' 90' 90);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	path.AddLine (rect.Right - radiusCorrection' rect.Y' rect.Right - radiusCorrection' rect.Bottom - radiusCorrection);  	break;  case RoundStyle.BottomRight:  	path.AddArc (rect.Right - radius - radiusCorrection' rect.Bottom - radius - radiusCorrection' radius' radius' 0' 90);  	path.AddLine (rect.X' rect.Bottom - radiusCorrection' rect.X' rect.Y);  	path.AddLine (rect.X' rect.Y' rect.Right - radiusCorrection' rect.Y);  	break;  }  
Missing Default,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,The following switch statement is missing a default case: switch (arrowDirection) {  case ThumbArrowDirection.Left:  case ThumbArrowDirection.Right:  	offset = rect.Width / 2f - 4;  	break;  case ThumbArrowDirection.Up:  case ThumbArrowDirection.Down:  	offset = rect.Height / 2f - 4;  	break;  }  
Missing Default,CWebQQ.UI,GraphicsPathHelper,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CreateTrackBarThumbPath,The following switch statement is missing a default case: switch (arrowDirection) {  case ThumbArrowDirection.Left:  	path.AddLine (rect.X' centerPoint.Y' rect.X + offset' rect.Y);  	path.AddLine (rect.Right' rect.Y' rect.Right' rect.Bottom);  	path.AddLine (rect.X + offset' rect.Bottom' rect.X' centerPoint.Y);  	break;  case ThumbArrowDirection.Right:  	path.AddLine (rect.Right' centerPoint.Y' rect.Right - offset' rect.Bottom);  	path.AddLine (rect.X' rect.Bottom' rect.X' rect.Y);  	path.AddLine (rect.Right - offset' rect.Y' rect.Right' centerPoint.Y);  	break;  case ThumbArrowDirection.Up:  	path.AddLine (centerPoint.X' rect.Y' rect.X' rect.Y + offset);  	path.AddLine (rect.X' rect.Bottom' rect.Right' rect.Bottom);  	path.AddLine (rect.Right' rect.Y + offset' centerPoint.X' rect.Y);  	break;  case ThumbArrowDirection.Down:  	path.AddLine (centerPoint.X' rect.Bottom' rect.X' rect.Bottom - offset);  	path.AddLine (rect.X' rect.Y' rect.Right' rect.Y);  	path.AddLine (rect.Right' rect.Bottom - offset' centerPoint.X' rect.Bottom);  	break;  case ThumbArrowDirection.LeftRight:  	break;  case ThumbArrowDirection.UpDown:  	break;  case ThumbArrowDirection.None:  	path.AddRectangle (rect);  	break;  }  
Missing Default,CWebQQ.UI,ControlPaintEx,C:\repos\crcruicai_Library\QQSDK1.4\QQ\UI\SplitContainerEx.cs,CalculateBackgroundImageRectangle,The following switch statement is missing a default case: switch (imageLayout) {  case ImageLayout.None:  	//无   	rectangle.Size = backgroundImage.Size;  	return rectangle;  case ImageLayout.Tile:  	//  	return rectangle;  case ImageLayout.Center://图片居中显示.   {  	rectangle.Size = backgroundImage.Size;  	Size size = bounds.Size;  	if (size.Width > rectangle.Width) {  		rectangle.X = (size.Width - rectangle.Width) / 2;  	}  	if (size.Height > rectangle.Height) {  		rectangle.Y = (size.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  case ImageLayout.Stretch:  	//图片拉伸.  	rectangle.Size = bounds.Size;  	return rectangle;  case ImageLayout.Zoom://图片放大.   {  	Size size2 = backgroundImage.Size;  	float num = ((float)bounds.Width) / ((float)size2.Width);  	float num2 = ((float)bounds.Height) / ((float)size2.Height);  	if (num >= num2) {  		rectangle.Height = bounds.Height;  		rectangle.Width = (int)((size2.Width * num2) + 0.5);  		if (bounds.X >= 0) {  			rectangle.X = (bounds.Width - rectangle.Width) / 2;  		}  		return rectangle;  	}  	rectangle.Width = bounds.Width;  	rectangle.Height = (int)((size2.Height * num) + 0.5);  	if (bounds.Y >= 0) {  		rectangle.Y = (bounds.Height - rectangle.Height) / 2;  	}  	return rectangle;  }  }  
