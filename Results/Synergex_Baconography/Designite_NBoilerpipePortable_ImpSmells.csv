Implementation smell,Namespace,Class,File,Method,Description
Long Method,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The method has 180 lines of code.
Long Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,Read,The method has 132 lines of code.
Long Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseStartTag,The method has 107 lines of code.
Long Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseCData,The method has 154 lines of code.
Complex Method,NBoilerpipePortable,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,HandleText,Cyclomatic complexity of the method is 18
Complex Method,NBoilerpipePortable,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,NBoilerpipePortable.Filters.English,KeepLargestFulltextBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\KeepLargestFulltextBlockFilter.cs,Process,Cyclomatic complexity of the method is 8
Complex Method,NBoilerpipePortable.Filters.Heuristics,BlockProximityFusion,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\BlockProximityFusion.cs,Process,Cyclomatic complexity of the method is 14
Complex Method,NBoilerpipePortable.Filters.Heuristics,KeepLargestBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\KeepLargestBlockFilter.cs,Process,Cyclomatic complexity of the method is 13
Complex Method,Sharpen,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,HandleText,Cyclomatic complexity of the method is 18
Complex Method,Sharpen,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,FlushBlock,Cyclomatic complexity of the method is 8
Complex Method,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,Cyclomatic complexity of the method is 28
Complex Method,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindBaseUrl,Cyclomatic complexity of the method is 10
Complex Method,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ScanToEnd,Cyclomatic complexity of the method is 8
Complex Method,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ExpandCharEntity,Cyclomatic complexity of the method is 8
Complex Method,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SniffMeta,Cyclomatic complexity of the method is 11
Complex Method,Sgml,Group,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,CanContain,Cyclomatic complexity of the method is 10
Complex Method,Sgml,SgmlDtd,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ParseElementDecl,Cyclomatic complexity of the method is 11
Complex Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseStartTag,Cyclomatic complexity of the method is 15
Complex Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseDocType,Cyclomatic complexity of the method is 9
Complex Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseCData,Cyclomatic complexity of the method is 10
Complex Method,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ValidateContent,Cyclomatic complexity of the method is 10
Long Parameter List,NBoilerpipePortable.Document,TextBlock,C:\repos\Synergex_Baconography\NBoilerpipePortable\Document\TextBlock.cs,TextBlock,The method has 8 parameters. Parameters: text' containedTextElements' numWords' numWordsInAnchorText' numWordsInWrappedLines' numWrappedLines' offsetBlocks' imageSrc
Long Parameter List,NBoilerpipePortable.Filters.Simple,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,RegionMatches,The method has 6 parameters. Parameters: str' ignoreCase' toOffset' other' ooffset' len
Long Parameter List,Sharpen,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,RegionMatches,The method has 6 parameters. Parameters: str' ignoreCase' toOffset' other' ooffset' len
Long Parameter List,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,Sgml,ElementDecl,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ElementDecl,The method has 6 parameters. Parameters: name' sto' eto' cm' inclusions' exclusions
Long Parameter List,Sgml,SgmlDtd,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,Parse,The method has 7 parameters. Parameters: baseUri' name' pubid' url' subset' proxy' nt
Long Parameter List,Sgml,SgmlDtd,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,Parse,The method has 6 parameters. Parameters: baseUri' name' input' subset' proxy' nt
Long Identifier,NBoilerpipePortable.Filters.Heuristics,BlockProximityFusion,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\BlockProximityFusion.cs,,The length of the parameter MAX_DISTANCE_1_CONTENT_ONLY_SAME_TAGLEVEL is 41.
Long Identifier,NBoilerpipePortable.Filters.Heuristics,KeepLargestBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\KeepLargestBlockFilter.cs,,The length of the parameter INSTANCE_EXPAND_TO_SAME_TAGLEVEL is 32.
Long Identifier,NBoilerpipePortable.Filters.Heuristics,KeepLargestBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\KeepLargestBlockFilter.cs,,The length of the parameter INSTANCE_EXPAND_TO_SAME_TAGLEVEL_MIN_WORDS is 42.
Long Statement,NBoilerpipePortable,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,IsHidden,The length of the statement  "                return atts["class"].Value.Split(' ').Any(str => str == "hidden" || str.StartsWith("promo") || str.Contains("comment")); " is 120.
Long Statement,NBoilerpipePortable.Filters.English,TerminatingBlocksFinder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\TerminatingBlocksFinder.cs,Process,The length of the statement  "							"reader comments") || textLC.Contains("r√§tta artikeln") || textLC.Equals("thanks for your comments - this feedback is now closed" " is 130.
Long Statement,NBoilerpipePortable.Filters.Simple,BoilerplateBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\BoilerplateBlockFilter.cs,Process,The length of the statement  "            var removeMe = textBlocks.Where(tb => !tb.IsContent() && (labelToKeep == null || !tb.HasLabel(DefaultLabels.TITLE))).ToList(); " is 126.
Long Statement,Sharpen,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,IsHidden,The length of the statement  "                return atts["class"].Value.Split(' ').Any(str => str == "hidden" || str.StartsWith("promo") || str.Contains("comment")); " is 120.
Long Statement,Sharpen,UnicodeTokenizer,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Tokenize,The length of the statement  "			return PAT_NOT_WORD_BOUNDARY.Matcher(PAT_WORD_BOUNDARY.Matcher(text.ToString().ReplaceAll ("\u00A0"'"'\u00A0'")).ReplaceAll("\u2063" " is 132.
Long Statement,Sharpen,UnicodeTokenizer,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Tokenize,The length of the statement  "			return PAT_NOT_WORD_BOUNDARY.Matcher(PAT_WORD_BOUNDARY.Matcher(text.ToString().ReplaceAll ("\u00A0"'"'\u00A0'")).ReplaceAll("\u2063" " is 132.
Long Statement,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The length of the statement  "                            var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src); " is 128.
Long Statement,NBoilerpipePortable.Parser,_TagAction_97,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The length of the statement  "					//System.Console.Error.WriteLine ("Warning: SAX input contains nested A elements -- You have probably hit a bug in your HTML parser (e.g.' NekoHTML bug #2909310). Please clean the HTML externally and feed it to boilerpipe again. Trying to recover somehow..." " is 258.
Long Statement,NBoilerpipePortable.Util,HttpUtility,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\HttpUtility.cs,HtmlDecode,The length of the statement  "                                    ushort.TryParse (entity.Substring (2)' NumberStyles.AllowHexSpecifier' (IFormatProvider)NumberFormatInfo.InvariantInfo' out num4); " is 130.
Long Statement,NBoilerpipePortable.Util,HttpUtility,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\HttpUtility.cs,HtmlDecode,The length of the statement  "                                    ushort.TryParse (entity.Substring (1)' NumberStyles.Integer' (IFormatProvider)NumberFormatInfo.InvariantInfo' out num4); " is 120.
Long Statement,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The length of the statement  "                /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */ " is 124.
Long Statement,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The length of the statement  "                 * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html " is 126.
Long Statement,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The length of the statement  "                    if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId))) " is 137.
Long Statement,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The length of the statement  "                    string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' ""); " is 181.
Long Statement,NBoilerpipePortable.Util,UnicodeTokenizer,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Tokenize,The length of the statement  "			return PAT_NOT_WORD_BOUNDARY.Matcher(PAT_WORD_BOUNDARY.Matcher(text.ToString().ReplaceAll ("\u00A0"'"'\u00A0'")).ReplaceAll("\u2063" " is 132.
Long Statement,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,Context,The length of the statement  "                    msg = string.Format(CultureInfo.InvariantCulture' "\nReferenced on line {0}' position {1} of internal entity '{2}'"' p.m_line' p.LinePosition' p.m_name); " is 153.
Long Statement,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,Context,The length of the statement  "                    msg = string.Format(CultureInfo.InvariantCulture' "\nReferenced on line {0}' position {1} of '{2}' entity at [{3}]"' p.m_line' p.LinePosition' p.m_name' p.ResolvedUri.AbsolutePath); " is 181.
Long Statement,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The length of the statement  "                uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3]; " is 128.
Long Statement,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The length of the statement  "                    throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code)); " is 121.
Long Statement,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The length of the statement  "                        throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code)); " is 121.
Long Statement,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The length of the statement  "                    throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code)); " is 121.
Long Statement,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The length of the statement  "                        throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code)); " is 121.
Long Statement,Sgml,ContentModel,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SetDeclaredContent,The length of the statement  "                    throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Declared content type '{0}' is not supported"' dc)); " is 126.
Long Statement,Sgml,Group,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AddConnector,The length of the statement  "                throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Connector '{0}' is inconsistent with {1} group."' c' m_groupType.ToString())); " is 152.
Long Statement,Sgml,AttDef,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SetEnumeratedType,The length of the statement  "                throw new ArgumentException(string.Format(CultureInfo.CurrentUICulture' "AttributeType {0} is not valid for an attribute definition with an enumerated value."' type)); " is 167.
Long Statement,Sgml,AttDef,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SetType,The length of the statement  "                    throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Attribute type '{0}' is not supported"' type)); " is 121.
Long Statement,Sgml,AttDef,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SetPresence,The length of the statement  "                throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Attribute value '{0}' not supported"' token)); " is 120.
Long Statement,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,Log,The length of the statement  "                    ErrorLog.WriteLine("### Error in {0}#{1}' line {2}' position {3}: {4}"' path' this.m_current.Name' this.m_current.Line' this.m_current.LinePosition' err); " is 154.
Long Statement,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ValidateContent,The length of the statement  "                            if ((i == 2) && string.Equals(f.Name' "BODY"' StringComparison.OrdinalIgnoreCase)) // NOTE (steveb): never close the BODY tag too early " is 135.
Complex Conditional,NBoilerpipePortable.Filters.English,TerminatingBlocksFinder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\TerminatingBlocksFinder.cs,Process,The conditional expression  "textLC.StartsWith("references") || StartsWithNumber(textLC' len' " comments"' " users responded in"  							) || textLC.StartsWith("¬© reuters") || textLC.StartsWith("please rate this") ||  							 textLC.StartsWith("post a comment") || textLC.Contains("what you think...") ||   							textLC.Contains("add your comment") || textLC.Contains("add comment") || textLC.  							Contains("reader views") || textLC.Contains("have your say") || textLC.Contains(  							"reader comments") || textLC.Contains("r√§tta artikeln") || textLC.Equals("thanks for your comments - this feedback is now closed"  							)"  is complex.
Complex Conditional,NBoilerpipePortable.Filters.Heuristics,ListAtEndFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\ListAtEndFilter.cs,Process,The conditional expression  "tb.GetTagLevel() > tagLevel  						&& tb.HasLabel(DefaultLabels.MIGHT_BE_CONTENT)  						&& tb.HasLabel(DefaultLabels.LI)  						&& tb.GetLinkDensity() == 0"  is complex.
Complex Conditional,NBoilerpipePortable.Filters.Simple,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,RegionMatches,The conditional expression  "toOffset < 0 || ooffset < 0 || toOffset + len > str.Length || ooffset + len > other.Length"  is complex.
Complex Conditional,NBoilerpipePortable.Filters.Simple,SurroundingToContentFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\SurroundingToContentFilter.cs,Process,The conditional expression  "!b.IsContent() && a.IsContent() && c.IsContent() && cond.MeetsCondition(b)"  is complex.
Complex Conditional,Sharpen,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,RegionMatches,The conditional expression  "toOffset < 0 || ooffset < 0 || toOffset + len > str.Length || ooffset + len > other.Length"  is complex.
Complex Conditional,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The conditional expression  "instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org")))"  is complex.
Complex Conditional,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SkipWhitespace,The conditional expression  "ch != Entity.EOF && (ch == ' ' || ch == '\r' || ch == '\n' || ch == '\t')"  is complex.
Complex Conditional,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ScanToken,The conditional expression  "!nmtoken || ch == '_' || ch == '.' || ch == '-' || ch == ':' || char.IsLetterOrDigit(ch)"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SniffWhitespace,The conditional expression  "ch == ' ' || ch == '\t' || ch == '\r' || ch == '\n'"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SniffWhitespace,The conditional expression  "ch != ' ' && ch != '\t' && ch != '\r' && ch != '\n'"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SniffName,The conditional expression  "pos < used - 1 && (char.IsLetterOrDigit(ch) || ch == '-' || ch == '_' || ch == ':')"  is complex.
Complex Conditional,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SkipWhitespace,The conditional expression  "pos < used - 1 && (ch == ' ' || ch == '\r' || ch == '\n')"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,Read,The conditional expression  "!m_foundRoot && (this.NodeType == XmlNodeType.Element ||                      this.NodeType == XmlNodeType.Text ||                      this.NodeType == XmlNodeType.CDATA)"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseStartTag,The conditional expression  "string.Equals(aname' "'"' StringComparison.OrdinalIgnoreCase) ||                      string.Equals(aname' "="' StringComparison.OrdinalIgnoreCase) ||                      string.Equals(aname' ":"' StringComparison.OrdinalIgnoreCase) ||                      string.Equals(aname' ";"' StringComparison.OrdinalIgnoreCase)"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseText,The conditional expression  "ch == '/' || ch == '!' || ch == '?' || char.IsLetter(ch)"  is complex.
Complex Conditional,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ExpandEntity,The conditional expression  "ch != Entity.EOF &&                      (char.IsLetter(ch) || ch == '_' || ch == '-') || ((this.m_name.Length > 0) && char.IsDigit(ch))"  is complex.
Virtual Method Call from Constructor,NBoilerpipePortable.Document,TextDocumentStatistics,C:\repos\Synergex_Baconography\NBoilerpipePortable\Document\TextDocumentStatistics.cs,TextDocumentStatistics,The constructor "TextDocumentStatistics" calls a virtual method "GetTextBlocks".
Virtual Method Call from Constructor,NBoilerpipePortable.Document,TextDocumentStatistics,C:\repos\Synergex_Baconography\NBoilerpipePortable\Document\TextDocumentStatistics.cs,TextDocumentStatistics,The constructor "TextDocumentStatistics" calls a virtual method "IsContent".
Virtual Method Call from Constructor,NBoilerpipePortable.Document,TextDocumentStatistics,C:\repos\Synergex_Baconography\NBoilerpipePortable\Document\TextDocumentStatistics.cs,TextDocumentStatistics,The constructor "TextDocumentStatistics" calls a virtual method "GetNumWords".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Virtual Method Call from Constructor,NBoilerpipePortable.Parser,DefaultTagActionMap,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\DefaultTagActionMap.cs,DefaultTagActionMap,The constructor "DefaultTagActionMap" calls a virtual method "SetTagAction".
Empty Catch Block,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SniffEncoding,The method has an empty catch block.
Empty Catch Block,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SniffMeta,The method has an empty catch block.
Empty Catch Block,Sgml,SgmlDtd,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,Parse,The method has an empty catch block.
Magic Number,NBoilerpipePortable,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,FlushBlock,The following statement contains a magic number: int maxLineLength = 80;
Magic Number,NBoilerpipePortable,BitSet,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,ToStringOfHalfWords,The following statement contains a magic number: for (int i = 0; i < dataBits.Length; i++)              {                  if (i != 0)                      s += "' ";                  long tmp = dataBits[i];                  tmp &= 0xFFFFFFFFL;                  s += (tmp + "UL");                  s += "' ";                  tmp = (uint)dataBits[i] >> 32;                  tmp &= 0xFFFFFFFFL;                  s += (tmp + "UL");              }
Magic Number,NBoilerpipePortable.Estimators,SimpleEstimator,C:\repos\Synergex_Baconography\NBoilerpipePortable\Estimators\SimpleEstimator.cs,IsLowQuality,The following statement contains a magic number: if (dsBefore.GetNumWords() < 90 || dsAfter.GetNumWords() < 70)  			{  				return true;  			}
Magic Number,NBoilerpipePortable.Estimators,SimpleEstimator,C:\repos\Synergex_Baconography\NBoilerpipePortable\Estimators\SimpleEstimator.cs,IsLowQuality,The following statement contains a magic number: if (dsBefore.GetNumWords() < 90 || dsAfter.GetNumWords() < 70)  			{  				return true;  			}
Magic Number,NBoilerpipePortable.Estimators,SimpleEstimator,C:\repos\Synergex_Baconography\NBoilerpipePortable\Estimators\SimpleEstimator.cs,IsLowQuality,The following statement contains a magic number: if (dsAfter.AvgNumWords() < 25)  			{  				return true;  			}
Magic Number,NBoilerpipePortable.Extractors,_BoilerpipeFilter_56,C:\repos\Synergex_Baconography\NBoilerpipePortable\Extractors\CanolaExtractor.cs,Classify,The following statement contains a magic number: bool isContent = (curr.GetLinkDensity() > 0 && next.GetNumWords() > 11) || (curr.  					GetNumWords() > 19 || (next.GetNumWords() > 6 && next.GetLinkDensity() == 0 && prev  					.GetLinkDensity() == 0 && (curr.GetNumWords() > 6 || prev.GetNumWords() > 7 || next  					.GetNumWords() > 19)));
Magic Number,NBoilerpipePortable.Extractors,_BoilerpipeFilter_56,C:\repos\Synergex_Baconography\NBoilerpipePortable\Extractors\CanolaExtractor.cs,Classify,The following statement contains a magic number: bool isContent = (curr.GetLinkDensity() > 0 && next.GetNumWords() > 11) || (curr.  					GetNumWords() > 19 || (next.GetNumWords() > 6 && next.GetLinkDensity() == 0 && prev  					.GetLinkDensity() == 0 && (curr.GetNumWords() > 6 || prev.GetNumWords() > 7 || next  					.GetNumWords() > 19)));
Magic Number,NBoilerpipePortable.Extractors,_BoilerpipeFilter_56,C:\repos\Synergex_Baconography\NBoilerpipePortable\Extractors\CanolaExtractor.cs,Classify,The following statement contains a magic number: bool isContent = (curr.GetLinkDensity() > 0 && next.GetNumWords() > 11) || (curr.  					GetNumWords() > 19 || (next.GetNumWords() > 6 && next.GetLinkDensity() == 0 && prev  					.GetLinkDensity() == 0 && (curr.GetNumWords() > 6 || prev.GetNumWords() > 7 || next  					.GetNumWords() > 19)));
Magic Number,NBoilerpipePortable.Extractors,_BoilerpipeFilter_56,C:\repos\Synergex_Baconography\NBoilerpipePortable\Extractors\CanolaExtractor.cs,Classify,The following statement contains a magic number: bool isContent = (curr.GetLinkDensity() > 0 && next.GetNumWords() > 11) || (curr.  					GetNumWords() > 19 || (next.GetNumWords() > 6 && next.GetLinkDensity() == 0 && prev  					.GetLinkDensity() == 0 && (curr.GetNumWords() > 6 || prev.GetNumWords() > 7 || next  					.GetNumWords() > 19)));
Magic Number,NBoilerpipePortable.Extractors,_BoilerpipeFilter_56,C:\repos\Synergex_Baconography\NBoilerpipePortable\Extractors\CanolaExtractor.cs,Classify,The following statement contains a magic number: bool isContent = (curr.GetLinkDensity() > 0 && next.GetNumWords() > 11) || (curr.  					GetNumWords() > 19 || (next.GetNumWords() > 6 && next.GetLinkDensity() == 0 && prev  					.GetLinkDensity() == 0 && (curr.GetNumWords() > 6 || prev.GetNumWords() > 7 || next  					.GetNumWords() > 19)));
Magic Number,NBoilerpipePortable.Extractors,_BoilerpipeFilter_56,C:\repos\Synergex_Baconography\NBoilerpipePortable\Extractors\CanolaExtractor.cs,Classify,The following statement contains a magic number: bool isContent = (curr.GetLinkDensity() > 0 && next.GetNumWords() > 11) || (curr.  					GetNumWords() > 19 || (next.GetNumWords() > 6 && next.GetLinkDensity() == 0 && prev  					.GetLinkDensity() == 0 && (curr.GetNumWords() > 6 || prev.GetNumWords() > 7 || next  					.GetNumWords() > 19)));
Magic Number,NBoilerpipePortable.Filters.English,DensityRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\DensityRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetTextDensity() <= 9)  					{  						if (next.GetTextDensity() <= 10)  						{  							if (prev.GetTextDensity() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						if (next.GetTextDensity() == 0)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  				}  				else  				{  					if (next.GetTextDensity() <= 11)  					{  						isContent = false;  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,DensityRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\DensityRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetTextDensity() <= 9)  					{  						if (next.GetTextDensity() <= 10)  						{  							if (prev.GetTextDensity() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						if (next.GetTextDensity() == 0)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  				}  				else  				{  					if (next.GetTextDensity() <= 11)  					{  						isContent = false;  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,DensityRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\DensityRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetTextDensity() <= 9)  					{  						if (next.GetTextDensity() <= 10)  						{  							if (prev.GetTextDensity() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						if (next.GetTextDensity() == 0)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  				}  				else  				{  					if (next.GetTextDensity() <= 11)  					{  						isContent = false;  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,DensityRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\DensityRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetTextDensity() <= 9)  					{  						if (next.GetTextDensity() <= 10)  						{  							if (prev.GetTextDensity() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						if (next.GetTextDensity() == 0)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  				}  				else  				{  					if (next.GetTextDensity() <= 11)  					{  						isContent = false;  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,DensityRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\DensityRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetTextDensity() <= 9)  					{  						if (next.GetTextDensity() <= 10)  						{  							if (prev.GetTextDensity() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						if (next.GetTextDensity() == 0)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  				}  				else  				{  					if (next.GetTextDensity() <= 11)  					{  						isContent = false;  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,DensityRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\DensityRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetTextDensity() <= 9)  					{  						if (next.GetTextDensity() <= 10)  						{  							if (prev.GetTextDensity() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						if (next.GetTextDensity() == 0)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  				}  				else  				{  					if (next.GetTextDensity() <= 11)  					{  						isContent = false;  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,HeuristicFilterBase,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\HeuristicFilterBase.cs,GetNumFullTextWords,The following statement contains a magic number: return GetNumFullTextWords(tb' 9);
Magic Number,NBoilerpipePortable.Filters.English,IgnoreBlocksAfterContentFromEndFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\IgnoreBlocksAfterContentFromEndFilter.cs,Process,The following statement contains a magic number: if (blocks.Count > 0)  			{  				foreach(var tb in blocks.Reverse())  				{  					if (tb.HasLabel(DefaultLabels.INDICATES_END_OF_TEXT))  					{  						tb.AddLabel(DefaultLabels.STRICTLY_NOT_CONTENT);  						tb.RemoveLabel(DefaultLabels.MIGHT_BE_CONTENT);  						tb.SetIsContent(false);  						changes = true;  					}  					else  					{  						if (tb.IsContent())  						{  							words += tb.GetNumWords();  							if (words > 200)  							{  								break;  							}  						}  					}  				}  			}
Magic Number,NBoilerpipePortable.Filters.English,KeepLargestFulltextBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\KeepLargestFulltextBlockFilter.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,NumWordsRulesClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\NumWordsRulesClassifier.cs,Classify,The following statement contains a magic number: if (curr.GetLinkDensity() <= 0.333333)  			{  				if (prev.GetLinkDensity() <= 0.555556)  				{  					if (curr.GetNumWords() <= 16)  					{  						if (next.GetNumWords() <= 15)  						{  							if (prev.GetNumWords() <= 4)  							{  								isContent = false;  							}  							else  							{  								isContent = true;  							}  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  				else  				{  					if (curr.GetNumWords() <= 40)  					{  						if (next.GetNumWords() <= 17)  						{  							isContent = false;  						}  						else  						{  							isContent = true;  						}  					}  					else  					{  						isContent = true;  					}  				}  			}  			else  			{  				isContent = false;  			}
Magic Number,NBoilerpipePortable.Filters.English,TerminatingBlocksFinder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\TerminatingBlocksFinder.cs,Process,The following statement contains a magic number: foreach (TextBlock tb in doc.GetTextBlocks())  			{  				int numWords = tb.GetNumWords();  				if (numWords < 15)  				{  					string text = tb.GetText().Trim();  					int len = text.Length;  					if (len >= 8)  					{  						string textLC = text.ToLower();  						if (textLC.StartsWith("references") || StartsWithNumber(textLC' len' " comments"' " users responded in"  							) || textLC.StartsWith("¬© reuters") || textLC.StartsWith("please rate this") ||  							 textLC.StartsWith("post a comment") || textLC.Contains("what you think...") ||   							textLC.Contains("add your comment") || textLC.Contains("add comment") || textLC.  							Contains("reader views") || textLC.Contains("have your say") || textLC.Contains(  							"reader comments") || textLC.Contains("r√§tta artikeln") || textLC.Equals("thanks for your comments - this feedback is now closed"  							))  						{  							tb.AddLabel(DefaultLabels.INDICATES_END_OF_TEXT);  							changes = true;  						}  					}                      else if (tb.GetLinkDensity() == 1.0)                      {                          if (text == "Comment")                          {                              tb.AddLabel(DefaultLabels.INDICATES_END_OF_TEXT);                              changes = true;                          }                      }  				}  			}
Magic Number,NBoilerpipePortable.Filters.English,TerminatingBlocksFinder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\English\TerminatingBlocksFinder.cs,Process,The following statement contains a magic number: foreach (TextBlock tb in doc.GetTextBlocks())  			{  				int numWords = tb.GetNumWords();  				if (numWords < 15)  				{  					string text = tb.GetText().Trim();  					int len = text.Length;  					if (len >= 8)  					{  						string textLC = text.ToLower();  						if (textLC.StartsWith("references") || StartsWithNumber(textLC' len' " comments"' " users responded in"  							) || textLC.StartsWith("¬© reuters") || textLC.StartsWith("please rate this") ||  							 textLC.StartsWith("post a comment") || textLC.Contains("what you think...") ||   							textLC.Contains("add your comment") || textLC.Contains("add comment") || textLC.  							Contains("reader views") || textLC.Contains("have your say") || textLC.Contains(  							"reader comments") || textLC.Contains("r√§tta artikeln") || textLC.Equals("thanks for your comments - this feedback is now closed"  							))  						{  							tb.AddLabel(DefaultLabels.INDICATES_END_OF_TEXT);  							changes = true;  						}  					}                      else if (tb.GetLinkDensity() == 1.0)                      {                          if (text == "Comment")                          {                              tb.AddLabel(DefaultLabels.INDICATES_END_OF_TEXT);                              changes = true;                          }                      }  				}  			}
Magic Number,NBoilerpipePortable.Filters.Heuristics,AddPrecedingLabelsFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\AddPrecedingLabelsFilter.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.Heuristics,ArticleMetadataFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\ArticleMetadataFilter.cs,Process,The following statement contains a magic number: foreach (TextBlock tb in doc.GetTextBlocks())  			{  				if (tb.GetNumWords() > 10)  				{  					continue;  				}  				string text = tb.GetText();  				foreach (Sharpen.Pattern p in PATTERNS_SHORT)  				{  					if (p.Matcher(text).Find())  					{  						changed = true;  						tb.SetIsContent(true);  						tb.AddLabel(DefaultLabels.ARTICLE_METADATA);  					}  				}  			}
Magic Number,NBoilerpipePortable.Filters.Heuristics,BlockProximityFusion,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\BlockProximityFusion.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.Heuristics,ContentFusion,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\ContentFusion.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)              {                  return false;              }
Magic Number,NBoilerpipePortable.Filters.Heuristics,ContentFusion,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\ContentFusion.cs,Process,The following statement contains a magic number: do              {                  foreach (var b2 in new List<TextBlock>(textBlocks.Skip(1)))                  {                      if (b1.IsContent() && b2.GetLinkDensity() < 0.56 && !b2.HasLabel(DefaultLabels  						    .STRICTLY_NOT_CONTENT))  				    {                          b1.MergeNext(b2);                          textBlocks.Remove(b2);  					    changes = true;  				    }  				    else  				    {                          b1 = b2;  				    }  				                  }              }              while (changes);
Magic Number,NBoilerpipePortable.Filters.Heuristics,DocumentTitleMatchClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\DocumentTitleMatchClassifier.cs,DocumentTitleMatchClassifier,The following statement contains a magic number: if (title == null)              {                  this.potentialTitles = null;              }              else              {                  title = title.Replace('\u00a0'' ' ');  			    title = title.Replace("'"' "");                  title = title.Trim().ToLower();                  if (title.Length == 0)                  {                      this.potentialTitles = null;                  }                  else                  {                      this.potentialTitles = new HashSet<string>();                      potentialTitles.Add(title);                      string p;                      p = GetLongestPart(title' "[ ]*[\\|»|-][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|:][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|:\\(\\)][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|:\\(\\)\\-][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|'|:\\(\\)\\-][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                        AddPotentialTitles(potentialTitles as HashSet<string>' title' "[ ]+[\\|][ ]+"' 4);                      AddPotentialTitles(potentialTitles as HashSet<string>' title' "[ ]+[\\-][ ]+"' 4);                        potentialTitles.Add(new Regex(" - [^\\-]+$").Replace(title' ""' 1));                      potentialTitles.Add(new Regex("^[^\\-]+ - ").Replace(title' ""' 1));                  }              }
Magic Number,NBoilerpipePortable.Filters.Heuristics,DocumentTitleMatchClassifier,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\DocumentTitleMatchClassifier.cs,DocumentTitleMatchClassifier,The following statement contains a magic number: if (title == null)              {                  this.potentialTitles = null;              }              else              {                  title = title.Replace('\u00a0'' ' ');  			    title = title.Replace("'"' "");                  title = title.Trim().ToLower();                  if (title.Length == 0)                  {                      this.potentialTitles = null;                  }                  else                  {                      this.potentialTitles = new HashSet<string>();                      potentialTitles.Add(title);                      string p;                      p = GetLongestPart(title' "[ ]*[\\|»|-][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|:][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|:\\(\\)][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|:\\(\\)\\-][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                      p = GetLongestPart(title' "[ ]*[\\|»|'|:\\(\\)\\-][ ]*");                      if (p != null)                      {                          potentialTitles.Add(p);                      }                        AddPotentialTitles(potentialTitles as HashSet<string>' title' "[ ]+[\\|][ ]+"' 4);                      AddPotentialTitles(potentialTitles as HashSet<string>' title' "[ ]+[\\-][ ]+"' 4);                        potentialTitles.Add(new Regex(" - [^\\-]+$").Replace(title' ""' 1));                      potentialTitles.Add(new Regex("^[^\\-]+ - ").Replace(title' ""' 1));                  }              }
Magic Number,NBoilerpipePortable.Filters.Heuristics,KeepLargestBlockFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\KeepLargestBlockFilter.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.Heuristics,LabelFusion,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\LabelFusion.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.Heuristics,LargeBlockSameTagLevelToContentFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\LargeBlockSameTagLevelToContentFilter.cs,Process,The following statement contains a magic number: foreach (var tb in doc.GetTextBlocks())              {                  if (!tb.IsContent())                  {                        if (tb.GetNumWords() >= 100 && tb.GetTagLevel() == tagLevel)                      {                          tb.SetIsContent(true);                          changes = true;                      }                  }              }
Magic Number,NBoilerpipePortable.Filters.Heuristics,SimpleBlockFusionProcessor,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Heuristics\SimpleBlockFusionProcessor.cs,Process,The following statement contains a magic number: if (textBlocks.Count < 2)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.Simple,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,Extensions,The following statement contains a magic number: DateTime time = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,NBoilerpipePortable.Filters.Simple,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,BitCount,The following statement contains a magic number: for (int i = 0; i < 32; i++)              {                  if ((num & 1) != 0)                  {                      count++;                  }                  num >>= 1;              }
Magic Number,NBoilerpipePortable.Filters.Simple,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,CreateDate,The following statement contains a magic number: long num = EPOCH_TICKS + (milliSecondsSinceEpoch * 10000);
Magic Number,NBoilerpipePortable.Filters.Simple,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,MillisToDateTimeOffset,The following statement contains a magic number: long num = EPOCH_TICKS + (milliSecondsSinceEpoch * 10000);
Magic Number,NBoilerpipePortable.Filters.Simple,SplitParagraphBlocksFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\SplitParagraphBlocksFilter.cs,Process,The following statement contains a magic number: foreach (TextBlock tb in blocks)  			{  				string text = tb.GetText();  				string[] paragraphs = text.Split('['' '\n'' '\r'' ']'' '+');  				if (paragraphs.Length < 2)  				{  					blocksNew.Add(tb);  					continue;  				}  				bool isContent = tb.IsContent();  				ICollection<string> labels = tb.GetLabels();  				foreach (string p in paragraphs)  				{  					TextBlock tbP = new TextBlock(p);  					tbP.SetIsContent(isContent);  					tbP.AddLabels(labels);                      blocksNew.Add(tbP);  					changes = true;  				}  			}
Magic Number,NBoilerpipePortable.Filters.Simple,SurroundingToContentFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\SurroundingToContentFilter.cs,Process,The following statement contains a magic number: if (tbs.Count < 3)  			{  				return false;  			}
Magic Number,NBoilerpipePortable.Filters.Simple,SurroundingToContentFilter,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\SurroundingToContentFilter.cs,Process,The following statement contains a magic number: var it = tbs.Skip(2).GetEnumerator();
Magic Number,NBoilerpipePortable.Filters.Simple,_TextBlockCondition_13,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\SurroundingToContentFilter.cs,MeetsCondition,The following statement contains a magic number: return tb.GetLinkDensity() == 0 && tb.GetNumWords() > 6;
Magic Number,Sharpen,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,Extensions,The following statement contains a magic number: DateTime time = new DateTime(1970' 1' 1' 0' 0' 0' DateTimeKind.Utc);
Magic Number,Sharpen,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,BitCount,The following statement contains a magic number: for (int i = 0; i < 32; i++)              {                  if ((num & 1) != 0)                  {                      count++;                  }                  num >>= 1;              }
Magic Number,Sharpen,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,CreateDate,The following statement contains a magic number: long num = EPOCH_TICKS + (milliSecondsSinceEpoch * 10000);
Magic Number,Sharpen,Extensions,C:\repos\Synergex_Baconography\NBoilerpipePortable\Filters\Simple\InvertedFilter.cs,MillisToDateTimeOffset,The following statement contains a magic number: long num = EPOCH_TICKS + (milliSecondsSinceEpoch * 10000);
Magic Number,Sharpen,MarkupTagAction,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\MarkupTagAction.cs,Start,The following statement contains a magic number: IList<string> labels = new List<string> (5);
Magic Number,Sharpen,NBoilerpipeContentHandler,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,FlushBlock,The following statement contains a magic number: int maxLineLength = 80;
Magic Number,Sharpen,BitSet,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\NBoilerpipeContentHandler.cs,ToStringOfHalfWords,The following statement contains a magic number: for (int i = 0; i < dataBits.Length; i++)              {                  if (i != 0)                      s += "' ";                  long tmp = dataBits[i];                  tmp &= 0xFFFFFFFFL;                  s += (tmp + "UL");                  s += "' ";                  tmp = (uint)dataBits[i] >> 32;                  tmp &= 0xFFFFFFFFL;                  s += (tmp + "UL");              }
Magic Number,Sharpen,Pattern,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Compile,The following statement contains a magic number: if ((flags & 2) != DOTALL)              {                  compiled |= RegexOptions.Singleline;              }
Magic Number,Sharpen,Pattern,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Compile,The following statement contains a magic number: if ((flags & 4) != MULTILINE)              {                  compiled |= RegexOptions.Multiline;              }
Magic Number,Sharpen,Pattern,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Compile,The following statement contains a magic number: if ((flags & 2) != DOTALL)              {                  compiled |= RegexOptions.Singleline;              }
Magic Number,Sharpen,Pattern,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Compile,The following statement contains a magic number: if ((flags & 4) != MULTILINE)              {                  compiled |= RegexOptions.Multiline;              }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,FindAlternateWidthHieght,The following statement contains a magic number: if (match.Groups.Count == 3)                  {                      return Tuple.Create(int.Parse(match.Groups[1].Value)' int.Parse(match.Groups[2].Value));                  }                  else                      return Tuple.Create(0' 0);
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,FindAlternateWidthHieght,The following statement contains a magic number: if (match.Groups.Count == 3)                  {                      return Tuple.Create(int.Parse(match.Groups[1].Value)' int.Parse(match.Groups[2].Value));                  }                  else                      return Tuple.Create(0' 0);
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_Img,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: try                  {                      var alt = atts.Contains("alt") ? atts["alt"].Value : "";                      if (alt.Length < 5)                      {                          alt = (atts.Contains("title") ? atts["title"].Value : alt);                      }                        int width = Math.Max(atts.Contains("width") ? int.Parse(atts["width"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      int height = Math.Max(atts.Contains("height") ? int.Parse(atts["height"].Value.TrimEnd('p'' 'x'' ';')) : 0' 1);                      var src = atts.Contains("src") ? atts["src"].Value : FindAlternateSrc(atts);                      bool isWikimedia = false;                      if (instance.inIgnorableElement <= 0 && !string.IsNullOrWhiteSpace(src) &&                          (alt.Length > 5 || width > 400 || height > 320 || (isWikimedia = src.StartsWith("//upload.wikimedia.org"))))                      {                          var altWidthHeight = FindAlternateWidthHieght(src);                          width = Math.Max(altWidthHeight.Item1' width);                          height = Math.Max(altWidthHeight.Item2' height);                            if (src.StartsWith("//"))                              src = "http:" + src;                            if (width > 400 || height > 320 || isWikimedia)                          {                              var tb = new Document.TextBlock(""' new Sharpen.BitSet()' Math.Max((Math.Max(width' height) / 6)' alt.Length)' 0' 0' 0' 0' src);                              tb.SetIsContent(true);                              instance.textBlocks.Add(tb);                          }                      }                      instance.inIgnorableElement++;                      return true;                  }                  catch(Exception ex)                  {                      Debug.WriteLine("during boilerpipe parsing: " + ex.ToString());                  }
Magic Number,NBoilerpipePortable.Parser,_TagAction_240,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: if (sizeAttr != null)  				{  					var m = CommonTagActions.PAT_FONT_SIZE.Matcher(sizeAttr);  					if (m.Matches())  					{  						string rel = m.Group(1);  						int val = System.Convert.ToInt32(m.Group(2));  						int size;  						if (rel.Length == 0)  						{  							// absolute  							size = val;  						}  						else  						{  							// relative  							int? prevSize;  							if (instance.fontSizeStack.Count == 0)  							{  								prevSize = 3;  							}  							else  							{  								prevSize = 3;  								foreach (int? s in instance.fontSizeStack)  								{  									if (s != null)  									{  										prevSize = s;  										break;  									}  								}  							}  							if (rel[0] == '+')  							{  								size = (int)prevSize + val;  							}  							else  							{  								size = (int)prevSize - val;  							}  						}  						instance.fontSizeStack.Insert(0' size);  					}  					else  					{                          instance.fontSizeStack.Insert(0' null);  					}  				}  				else  				{                      instance.fontSizeStack.Insert(0' null);  				}
Magic Number,NBoilerpipePortable.Parser,_TagAction_240,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: if (sizeAttr != null)  				{  					var m = CommonTagActions.PAT_FONT_SIZE.Matcher(sizeAttr);  					if (m.Matches())  					{  						string rel = m.Group(1);  						int val = System.Convert.ToInt32(m.Group(2));  						int size;  						if (rel.Length == 0)  						{  							// absolute  							size = val;  						}  						else  						{  							// relative  							int? prevSize;  							if (instance.fontSizeStack.Count == 0)  							{  								prevSize = 3;  							}  							else  							{  								prevSize = 3;  								foreach (int? s in instance.fontSizeStack)  								{  									if (s != null)  									{  										prevSize = s;  										break;  									}  								}  							}  							if (rel[0] == '+')  							{  								size = (int)prevSize + val;  							}  							else  							{  								size = (int)prevSize - val;  							}  						}  						instance.fontSizeStack.Insert(0' size);  					}  					else  					{                          instance.fontSizeStack.Insert(0' null);  					}  				}  				else  				{                      instance.fontSizeStack.Insert(0' null);  				}
Magic Number,NBoilerpipePortable.Parser,_TagAction_240,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\CommonTagActions.cs,Start,The following statement contains a magic number: if (sizeAttr != null)  				{  					var m = CommonTagActions.PAT_FONT_SIZE.Matcher(sizeAttr);  					if (m.Matches())  					{  						string rel = m.Group(1);  						int val = System.Convert.ToInt32(m.Group(2));  						int size;  						if (rel.Length == 0)  						{  							// absolute  							size = val;  						}  						else  						{  							// relative  							int? prevSize;  							if (instance.fontSizeStack.Count == 0)  							{  								prevSize = 3;  							}  							else  							{  								prevSize = 3;  								foreach (int? s in instance.fontSizeStack)  								{  									if (s != null)  									{  										prevSize = s;  										break;  									}  								}  							}  							if (rel[0] == '+')  							{  								size = (int)prevSize + val;  							}  							else  							{  								size = (int)prevSize - val;  							}  						}  						instance.fontSizeStack.Insert(0' size);  					}  					else  					{                          instance.fontSizeStack.Insert(0' null);  					}  				}  				else  				{                      instance.fontSizeStack.Insert(0' null);  				}
Magic Number,NBoilerpipePortable.Parser,MarkupTagAction,C:\repos\Synergex_Baconography\NBoilerpipePortable\Parser\MarkupTagAction.cs,Start,The following statement contains a magic number: IList<string> labels = new List<string> (5);
Magic Number,NBoilerpipePortable.Util,HttpUtility,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\HttpUtility.cs,HtmlDecode,The following statement contains a magic number: if (value != null) {                  if (output == null) {                      throw new ArgumentNullException ("output");                  }                  if (value.IndexOf ('&') < 0) {                      output.Write (value);                  } else {                      int length = value.Length;                      for (int i = 0; i < length; i++) {                          char ch = value [i];                          if (ch == '&') {                          int num3 = value.IndexOfAny (_htmlEntityEndingChars' i + 1);                          if ((num3 > 0) && (value [num3] == ';')) {                              string entity = value.Substring (i + 1' (num3 - i) - 1);                              if ((entity.Length > 1) && (entity [0] == '#')) {                                  ushort num4;                                  if ((entity [1] == 'x') || (entity [1] == 'X')) {                                      ushort.TryParse (entity.Substring (2)' NumberStyles.AllowHexSpecifier' (IFormatProvider)NumberFormatInfo.InvariantInfo' out num4);                                  } else {                                      ushort.TryParse (entity.Substring (1)' NumberStyles.Integer' (IFormatProvider)NumberFormatInfo.InvariantInfo' out num4);                                  }                                  if (num4 != 0) {                                      ch = (char)num4;                                     i = num3;                                  }                            } else {                                  i = num3;                                  char ch2 = HtmlEntities.Lookup (entity);                                  if (ch2 != '\0') {                                      ch = ch2;                                  } else {                                      output.Write ('&');                                      output.Write (entity);                                      output.Write (';');                                      continue;                                  }                              }                          }                      }                      output.Write (ch);                  }              }          }
Magic Number,NBoilerpipePortable.Util,HtmlEntities,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\HttpUtility.cs,GenerateLookupTable,The following statement contains a magic number: foreach (string str in _entitiesList) {                  dictionary.Add (str.Substring (2)' str [0]);              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)              {                  string linkHref = (string)linkElement.Attribute("href");                    if (string.IsNullOrEmpty(linkHref)                   || _MailtoHrefRegex.IsMatch(linkHref))                  {                      continue;                  }                    linkHref = Regex.Replace(linkHref' "#.*$"' "");                  linkHref = Regex.Replace(linkHref' "/$"' "");                    /* If we've already seen this page' then ignore it. */                  // This leaves out an already-checked page check' because                   // the web transcoder is seperate from the original transcoder                  if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)                  {                      continue;                  }                    /* If it's on a different domain' skip it. */                  Uri linkHrefUri;                    if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)                  {                      continue;                  }                    string linkText = GetInnerText(linkElement);                    /* If the linktext looks like it's not the next page' then skip it */                  if (_Extraneous.IsMatch(linkText))                  {                      continue;                  }                    /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */                  string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");                    if (!Regex.IsMatch(linkHrefLeftover' @"\d"))                  {                      continue;                  }                    if (!possiblePagesByLink.Keys.Contains(linkHref))                  {                      possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };                  }                  else                  {                      possiblePagesByLink[linkHref].LinkText += " | " + linkText;                  }                    LinkData linkObj = possiblePagesByLink[linkHref];                    /*                   * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.                   * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html                   */                  if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)                  {                      linkObj.Score -= 50;                  }                    string linkData = linkText + " " + GetClass(linkElement) + " " + GetId(linkElement);                    if (_NextLink.IsMatch(linkData)                  && !_NextStoryLink.IsMatch(linkData))                  {                      linkObj.Score += 50;                  }                    if (_PageRegex.IsMatch(linkData))                  {                      linkObj.Score += 25;                  }                    /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */                  /* -65 is enough to negate any bonuses gotten from a > or � in the text */                  if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)                   && !_NextLink.IsMatch(linkObj.LinkText))                  {                      linkObj.Score -= 65;                  }                    if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))                  {                      linkObj.Score -= 50;                  }                    if (_PrevLink.IsMatch(linkData))                  {                      linkObj.Score -= 200;                  }                    /* If any ancestor node contains page or paging or paginat */                  XElement parentNode = linkElement.Parent;                  bool positiveNodeMatch = false;                  bool negativeNodeMatch = false;                    while (parentNode != null)                  {                      string parentNodeClassAndId = GetClass(parentNode) + " " + GetId(parentNode);                        if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))                      {                          positiveNodeMatch = true;                          linkObj.Score += 25;                      }                        if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))                      {                          if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))                          {                              linkObj.Score -= 25;                              negativeNodeMatch = true;                          }                      }                        parentNode = parentNode.Parent;                  }                    /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */                  bool positiveDescendantMatch = false;                  bool negativeDescendantMatch = false;                    foreach (XElement descendantElement in linkElement.Descendants())                  {                      string descendantData = GetInnerText(descendantElement) + " " + GetClass(descendantElement) + " " + GetId(descendantElement) + " " + GetAttributeValue(descendantElement' "alt"' "");                        if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))                      {                          linkObj.Score += 12.5f;                          positiveDescendantMatch = true;                      }                        if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))                      {                          linkObj.Score -= 100;                          negativeDescendantMatch = true;                      }                  }                    /*                  * If the URL looks like it has paging in it' add to the score.                  * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34                  */                  if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)                   || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))                  {                      linkObj.Score += 25;                  }                    /* If the URL contains negative values' give a slight decrease. */                  if (_Extraneous.IsMatch(linkHref))                  {                      linkObj.Score -= 15;                  }                    /*                   * If the link text can be parsed as a number' give it a minor bonus' with a slight                   * bias towards lower numbered pages. This is so that pages that might not have 'next'                   * in their text can still get scored' and sorted properly by score.                   */                  int linkTextAsNumber;                  bool isInt = int.TryParse(linkText' out linkTextAsNumber);                    if (isInt)                  {                      /* Punish 1 since we're either already there' or it's probably before what we want anyways. */                      if (linkTextAsNumber == 1)                      {                          linkObj.Score -= 10;                      }                      else                      {                          linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);                      }                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindNextPageLink,The following statement contains a magic number: foreach (string page in possiblePagesByLink.Keys)              {                  if (possiblePagesByLink[page].Score >= 50 && (topPage == null || topPage.Score < possiblePagesByLink[page].Score))                  {                      topPage = possiblePagesByLink[page];                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindBaseUrl,The following statement contains a magic number: for (int i = 0; i < slashLen; i++)              {                  string segment = urlSlashes[i];                    /* Split off and save anything that looks like a file type. */                  if (segment.IndexOf('.') != -1)                  {                      string possibleType = segment.Split('.')[1];                        /* If the type isn't alpha-only' it's probably not actually a file extension. */                      if (!Regex.IsMatch(possibleType' "[a-zA-Z]"))                      {                          segment = segment.Split('.')[0];                      }                  }                    /*                   * EW-CMS specific segment replacement. Ugly.                   * Example: http://www.ew.com/ew/article/0''20313460_20369436'00.html                  */                  if (segment.IndexOf("'00") != -1)                  {                      segment = segment.Replace("'00"' "");                  }                    /* If our first or second segment has anything looking like a page number' remove it. */                  var pageNumRegex = new Regex("((_|-)?p[a-z]*|(_|-))[0-9]{1'2}$"' RegexOptions.IgnoreCase);                    if (pageNumRegex.IsMatch(segment) && ((i == 1) || (i == 0)))                  {                      segment = pageNumRegex.Replace(segment' "");                  }                    /* If this is purely a number' and it's the first or second segment' it's probably a page number. Remove it. */                  bool del = (i < 2 && Regex.IsMatch(segment' @"^[\d]{1'2}$"));                    /* If this is the first segment and it's just "index'" remove it. */                  if (i == 0 && segment.ToLower() == "index")                  {                      del = true;                  }                    /* If tour first or second segment is smaller than 3 characters' and the first segment was purely alphas' remove it. */                  // TODO: Check these "purely alpha" regexes.  They don't seem right.                  if (i < 2 && segment.Length < 3 && !Regex.IsMatch(urlSlashes[0]' "[a-z]"' RegexOptions.IgnoreCase))                  {                      del = true;                  }                    /* If it's not marked for deletion' push it to cleanedSegments */                  if (!del)                  {                      cleanedSegments.Add(segment);                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindBaseUrl,The following statement contains a magic number: for (int i = 0; i < slashLen; i++)              {                  string segment = urlSlashes[i];                    /* Split off and save anything that looks like a file type. */                  if (segment.IndexOf('.') != -1)                  {                      string possibleType = segment.Split('.')[1];                        /* If the type isn't alpha-only' it's probably not actually a file extension. */                      if (!Regex.IsMatch(possibleType' "[a-zA-Z]"))                      {                          segment = segment.Split('.')[0];                      }                  }                    /*                   * EW-CMS specific segment replacement. Ugly.                   * Example: http://www.ew.com/ew/article/0''20313460_20369436'00.html                  */                  if (segment.IndexOf("'00") != -1)                  {                      segment = segment.Replace("'00"' "");                  }                    /* If our first or second segment has anything looking like a page number' remove it. */                  var pageNumRegex = new Regex("((_|-)?p[a-z]*|(_|-))[0-9]{1'2}$"' RegexOptions.IgnoreCase);                    if (pageNumRegex.IsMatch(segment) && ((i == 1) || (i == 0)))                  {                      segment = pageNumRegex.Replace(segment' "");                  }                    /* If this is purely a number' and it's the first or second segment' it's probably a page number. Remove it. */                  bool del = (i < 2 && Regex.IsMatch(segment' @"^[\d]{1'2}$"));                    /* If this is the first segment and it's just "index'" remove it. */                  if (i == 0 && segment.ToLower() == "index")                  {                      del = true;                  }                    /* If tour first or second segment is smaller than 3 characters' and the first segment was purely alphas' remove it. */                  // TODO: Check these "purely alpha" regexes.  They don't seem right.                  if (i < 2 && segment.Length < 3 && !Regex.IsMatch(urlSlashes[0]' "[a-z]"' RegexOptions.IgnoreCase))                  {                      del = true;                  }                    /* If it's not marked for deletion' push it to cleanedSegments */                  if (!del)                  {                      cleanedSegments.Add(segment);                  }              }
Magic Number,NBoilerpipePortable.Util,MultiPageUtils,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\MultiPageUtils.cs,FindBaseUrl,The following statement contains a magic number: for (int i = 0; i < slashLen; i++)              {                  string segment = urlSlashes[i];                    /* Split off and save anything that looks like a file type. */                  if (segment.IndexOf('.') != -1)                  {                      string possibleType = segment.Split('.')[1];                        /* If the type isn't alpha-only' it's probably not actually a file extension. */                      if (!Regex.IsMatch(possibleType' "[a-zA-Z]"))                      {                          segment = segment.Split('.')[0];                      }                  }                    /*                   * EW-CMS specific segment replacement. Ugly.                   * Example: http://www.ew.com/ew/article/0''20313460_20369436'00.html                  */                  if (segment.IndexOf("'00") != -1)                  {                      segment = segment.Replace("'00"' "");                  }                    /* If our first or second segment has anything looking like a page number' remove it. */                  var pageNumRegex = new Regex("((_|-)?p[a-z]*|(_|-))[0-9]{1'2}$"' RegexOptions.IgnoreCase);                    if (pageNumRegex.IsMatch(segment) && ((i == 1) || (i == 0)))                  {                      segment = pageNumRegex.Replace(segment' "");                  }                    /* If this is purely a number' and it's the first or second segment' it's probably a page number. Remove it. */                  bool del = (i < 2 && Regex.IsMatch(segment' @"^[\d]{1'2}$"));                    /* If this is the first segment and it's just "index'" remove it. */                  if (i == 0 && segment.ToLower() == "index")                  {                      del = true;                  }                    /* If tour first or second segment is smaller than 3 characters' and the first segment was purely alphas' remove it. */                  // TODO: Check these "purely alpha" regexes.  They don't seem right.                  if (i < 2 && segment.Length < 3 && !Regex.IsMatch(urlSlashes[0]' "[a-z]"' RegexOptions.IgnoreCase))                  {                      del = true;                  }                    /* If it's not marked for deletion' push it to cleanedSegments */                  if (!del)                  {                      cleanedSegments.Add(segment);                  }              }
Magic Number,NBoilerpipePortable.Util,Pattern,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Compile,The following statement contains a magic number: if ((flags & 2) != DOTALL)              {                  compiled |= RegexOptions.Singleline;              }
Magic Number,NBoilerpipePortable.Util,Pattern,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\UnicodeTokenizer.cs,Compile,The following statement contains a magic number: if ((flags & 4) != MULTILINE)              {                  compiled |= RegexOptions.Multiline;              }
Magic Number,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ReadNumericEntityCode,The following statement contains a magic number: if (ch == 'x')              {                  bool sawHexDigit = false;                  value += "x";                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      int p = 0;                      if (ch >= '0' && ch <= '9')                      {                          p = (int)(ch - '0');                          sawHexDigit = true;                      }                       else if (ch >= 'a' && ch <= 'f')                      {                          p = (int)(ch - 'a') + 10;                          sawHexDigit = true;                      }                       else if (ch >= 'A' && ch <= 'F')                      {                          p = (int)(ch - 'A') + 10;                          sawHexDigit = true;                      }                      else                      {                          break; //we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      value += ch;                      v = (v*16) + p;                  }                  if (!sawHexDigit)                  {                      return -1;                  }              }               else              {                  bool sawDigit = false;                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      if (ch >= '0' && ch <= '9')                      {                          v = (v*10) + (int)(ch - '0');                          sawDigit = true;                      }                       else                      {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                      value += ch;                  }                  if (!sawDigit)                  {                      return -1;                  }              }
Magic Number,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ReadNumericEntityCode,The following statement contains a magic number: if (ch == 'x')              {                  bool sawHexDigit = false;                  value += "x";                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      int p = 0;                      if (ch >= '0' && ch <= '9')                      {                          p = (int)(ch - '0');                          sawHexDigit = true;                      }                       else if (ch >= 'a' && ch <= 'f')                      {                          p = (int)(ch - 'a') + 10;                          sawHexDigit = true;                      }                       else if (ch >= 'A' && ch <= 'F')                      {                          p = (int)(ch - 'A') + 10;                          sawHexDigit = true;                      }                      else                      {                          break; //we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      value += ch;                      v = (v*16) + p;                  }                  if (!sawHexDigit)                  {                      return -1;                  }              }               else              {                  bool sawDigit = false;                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      if (ch >= '0' && ch <= '9')                      {                          v = (v*10) + (int)(ch - '0');                          sawDigit = true;                      }                       else                      {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                      value += ch;                  }                  if (!sawDigit)                  {                      return -1;                  }              }
Magic Number,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ReadNumericEntityCode,The following statement contains a magic number: if (ch == 'x')              {                  bool sawHexDigit = false;                  value += "x";                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      int p = 0;                      if (ch >= '0' && ch <= '9')                      {                          p = (int)(ch - '0');                          sawHexDigit = true;                      }                       else if (ch >= 'a' && ch <= 'f')                      {                          p = (int)(ch - 'a') + 10;                          sawHexDigit = true;                      }                       else if (ch >= 'A' && ch <= 'F')                      {                          p = (int)(ch - 'A') + 10;                          sawHexDigit = true;                      }                      else                      {                          break; //we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      value += ch;                      v = (v*16) + p;                  }                  if (!sawHexDigit)                  {                      return -1;                  }              }               else              {                  bool sawDigit = false;                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      if (ch >= '0' && ch <= '9')                      {                          v = (v*10) + (int)(ch - '0');                          sawDigit = true;                      }                       else                      {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                      value += ch;                  }                  if (!sawDigit)                  {                      return -1;                  }              }
Magic Number,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ReadNumericEntityCode,The following statement contains a magic number: if (ch == 'x')              {                  bool sawHexDigit = false;                  value += "x";                  ch = ReadChar();                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      int p = 0;                      if (ch >= '0' && ch <= '9')                      {                          p = (int)(ch - '0');                          sawHexDigit = true;                      }                       else if (ch >= 'a' && ch <= 'f')                      {                          p = (int)(ch - 'a') + 10;                          sawHexDigit = true;                      }                       else if (ch >= 'A' && ch <= 'F')                      {                          p = (int)(ch - 'A') + 10;                          sawHexDigit = true;                      }                      else                      {                          break; //we must be done!                          //Error("Hex digit out of range '{0}'"' (int)ch);                      }                      value += ch;                      v = (v*16) + p;                  }                  if (!sawHexDigit)                  {                      return -1;                  }              }               else              {                  bool sawDigit = false;                  for (; ch != Entity.EOF && ch != ';'; ch = ReadChar())                  {                      if (ch >= '0' && ch <= '9')                      {                          v = (v*10) + (int)(ch - '0');                          sawDigit = true;                      }                       else                      {                          break; // we must be done!                          //Error("Decimal digit out of range '{0}'"' (int)ch);                      }                      value += ch;                  }                  if (!sawDigit)                  {                      return -1;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,HtmlStream,The following statement contains a magic number: rawUsed = stm.Read(rawBuffer' 0' 4);
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,HtmlStream,The following statement contains a magic number: if (this.m_decoder == null)              {                  this.m_decoder = defaultEncoding.GetDecoder();                  rawUsed += stm.Read(rawBuffer' 4' BUFSIZE-4);                                  DecodeBlock();                  // Now sniff to see if there is an XML declaration or HTML <META> tag.                  Decoder sd = SniffEncoding();                  if (sd != null) {                      this.m_decoder = sd;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,HtmlStream,The following statement contains a magic number: if (this.m_decoder == null)              {                  this.m_decoder = defaultEncoding.GetDecoder();                  rawUsed += stm.Read(rawBuffer' 4' BUFSIZE-4);                                  DecodeBlock();                  // Now sniff to see if there is an XML declaration or HTML <META> tag.                  Decoder sd = SniffEncoding();                  if (sd != null) {                      this.m_decoder = sd;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,CopyToMemoryStream,The following statement contains a magic number: int size = 100000;
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following statement contains a magic number: if (4 <= (length - index)) {                  uint w = (uint)buffer[index + 0] << 24 | (uint)buffer[index + 1] << 16 | (uint)buffer[index + 2] << 8 | (uint)buffer[index + 3];                  // see if it's a 4-byte encoding                  switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }                  w >>= 8;                  if (w == 0xefbbbf) {                      index += 3;                      return Encoding.UTF8.GetDecoder();                  }                  w >>= 8;                  switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }              }
Magic Number,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,ReadToEnd,The following statement contains a magic number: char[] buffer = new char[100000];
Magic Number,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetCharCount,The following statement contains a magic number: return (count + tempBytes) / 4;
Magic Number,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetChars,The following statement contains a magic number: if (tempBytes > 0) {                  for (; i < 4; i++) {                      temp[i] = bytes[byteIndex];                      byteIndex++;                      byteCount--;                  }                  i = 1;                  GetFullChars(temp' 0' 4' chars' charIndex);                  charIndex++;              } else                  i = 0;
Magic Number,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetChars,The following statement contains a magic number: if (tempBytes > 0) {                  for (; i < 4; i++) {                      temp[i] = bytes[byteIndex];                      byteIndex++;                      byteCount--;                  }                  i = 1;                  GetFullChars(temp' 0' 4' chars' charIndex);                  charIndex++;              } else                  i = 0;
Magic Number,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetChars,The following statement contains a magic number: int j = (tempBytes + byteCount) % 4;
Magic Number,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,UnicodeToUTF16,The following statement contains a magic number: lowerByte = (byte)(0xD7C0 + (code >> 10));
Magic Number,Sgml,Ucs4Decoder,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,UnicodeToUTF16,The following statement contains a magic number: return ((char)((higherByte << 8) | lowerByte));
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderBigEngian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i + 3]) << 24) | (bytes[i + 2] << 16) | (bytes[i + 1] << 8) | (bytes[i]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,Ucs4DecoderLittleEndian,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,GetFullChars,The following statement contains a magic number: for (i = byteIndex' j = charIndex; i + 3 < byteCount; ) {                  code = (UInt32)(((bytes[i]) << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] << 8) | (bytes[i + 3]));                  if (code > 0x10FFFF) {                      throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                  } else if (code > 0xFFFF) {                      chars[j] = UnicodeToUTF16(code);                      j++;                  } else {                      if (code >= 0xD800 && code <= 0xDFFF) {                          throw new SgmlParseException(string.Format(CultureInfo.CurrentUICulture' "Invalid character 0x{0:x} in encoding"' code));                      } else {                          chars[j] = (char)code;                      }                  }                  j++;                  i += 4;              }
Magic Number,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,Init,The following statement contains a magic number: this.m_stack = new HWStack(10);
Magic Number,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseComment,The following statement contains a magic number: while (i >= 0)              {                  int j = i + 2;                  while (j < value.Length && value[j] == '-')                      j++;                    if (i > 0)                  {                      value = value.Substring(0' i - 1) + "-" + value.Substring(j);                  }                   else                  {                      value = "-" + value.Substring(j);                  }                    i = value.IndexOf("--");              }
Magic Number,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ValidateContent,The following statement contains a magic number: if (this.m_dtd != null)              {                  // See if this element is allowed inside the current element.                  // If it isn't' then auto-close elements until we find one                  // that it is allowed to be in.                                                    string name = node.Name.ToUpperInvariant(); // DTD is in upper case                  int i = 0;                  int top = this.m_stack.Count - 2;                  if (node.DtdType != null) {                       // it is a known element' let's see if it's allowed in the                      // current context.                      for (i = top; i > 0; i--)                      {                          Node n = (Node)this.m_stack[i];                          if (n.IsEmpty)                              continue; // we'll have to pop this one                          ElementDecl f = n.DtdType;                          if (f != null)                          {                              if ((i == 2) && string.Equals(f.Name' "BODY"' StringComparison.OrdinalIgnoreCase)) // NOTE (steveb): never close the BODY tag too early                                  break;                              else if (string.Equals(f.Name' this.m_dtd.Name' StringComparison.OrdinalIgnoreCase))                                  break; // can't pop the root element.                              else if (f.CanContain(name' this.m_dtd))                              {                                  break;                              }                              else if (!f.EndTagOptional)                              {                                  // If the end tag is not optional then we can't                                  // auto-close it.  We'll just have to live with the                                  // junk we've found and move on.                                  break;                              }                          }                           else                          {                              // Since we don't understand this tag anyway'                              // we might as well allow this content!                              break;                          }                      }                  }                    if (i == 0)                  {                      // Tag was not found or is not allowed anywhere' ignore it and                       // continue on.                      return;                  }                  else if (i < top)                  {                      Node n = (Node)this.m_stack[top];                      if (i == top - 1 && string.Equals(name' n.Name' StringComparison.OrdinalIgnoreCase))                      {                          // e.g. p not allowed inside p' not an interesting error.                      }                      else                      {  #if DEBUG                          string closing = "";                          for (int k = top; k >= i+1; k--) {                              if (closing != "") closing += "'";                              Node n2 = (Node)this.m_stack[k];                              closing += "<" + n2.Name + ">";                          }                          Log("Element '{0}' not allowed inside '{1}'' closing {2}."' name' n.Name' closing);  #endif                      }                        this.m_state = State.AutoClose;                      this.m_newnode = node;                      Pop(); // save this new node until we pop the others                      this.m_poptodepth = i + 1;                  }              }
Magic Number,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ValidateContent,The following statement contains a magic number: if (this.m_dtd != null)              {                  // See if this element is allowed inside the current element.                  // If it isn't' then auto-close elements until we find one                  // that it is allowed to be in.                                                    string name = node.Name.ToUpperInvariant(); // DTD is in upper case                  int i = 0;                  int top = this.m_stack.Count - 2;                  if (node.DtdType != null) {                       // it is a known element' let's see if it's allowed in the                      // current context.                      for (i = top; i > 0; i--)                      {                          Node n = (Node)this.m_stack[i];                          if (n.IsEmpty)                              continue; // we'll have to pop this one                          ElementDecl f = n.DtdType;                          if (f != null)                          {                              if ((i == 2) && string.Equals(f.Name' "BODY"' StringComparison.OrdinalIgnoreCase)) // NOTE (steveb): never close the BODY tag too early                                  break;                              else if (string.Equals(f.Name' this.m_dtd.Name' StringComparison.OrdinalIgnoreCase))                                  break; // can't pop the root element.                              else if (f.CanContain(name' this.m_dtd))                              {                                  break;                              }                              else if (!f.EndTagOptional)                              {                                  // If the end tag is not optional then we can't                                  // auto-close it.  We'll just have to live with the                                  // junk we've found and move on.                                  break;                              }                          }                           else                          {                              // Since we don't understand this tag anyway'                              // we might as well allow this content!                              break;                          }                      }                  }                    if (i == 0)                  {                      // Tag was not found or is not allowed anywhere' ignore it and                       // continue on.                      return;                  }                  else if (i < top)                  {                      Node n = (Node)this.m_stack[top];                      if (i == top - 1 && string.Equals(name' n.Name' StringComparison.OrdinalIgnoreCase))                      {                          // e.g. p not allowed inside p' not an interesting error.                      }                      else                      {  #if DEBUG                          string closing = "";                          for (int k = top; k >= i+1; k--) {                              if (closing != "") closing += "'";                              Node n2 = (Node)this.m_stack[k];                              closing += "<" + n2.Name + ">";                          }                          Log("Element '{0}' not allowed inside '{1}'' closing {2}."' name' n.Name' closing);  #endif                      }                        this.m_state = State.AutoClose;                      this.m_newnode = node;                      Pop(); // save this new node until we pop the others                      this.m_poptodepth = i + 1;                  }              }
Missing Default,Sgml,Entity,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,SetLiteralType,The following switch statement is missing a default case: switch (token)              {                  case "CDATA":                      this.m_literalType = LiteralType.CDATA;                      break;                  case "SDATA":                      this.m_literalType = LiteralType.SDATA;                      break;                  case "PI":                      this.m_literalType = LiteralType.PI;                      break;              }
Missing Default,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following switch statement is missing a default case: switch (w) {                      case 0xfefffeff:                           index += 4;                           return new Ucs4DecoderBigEngian();                        case 0xfffefffe:                           index += 4;                           return new Ucs4DecoderLittleEndian();                        case 0x3c000000:                           goto case 0xfefffeff;                        case 0x0000003c:                           goto case 0xfffefffe;                  }
Missing Default,Sgml,HtmlStream,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AutoDetectEncoding,The following switch statement is missing a default case: switch (w) {                      case 0xfeff:                           index += 2;                           return UnicodeEncoding.BigEndianUnicode.GetDecoder();                        case 0xfffe:                           index += 2;                           return new UnicodeEncoding(false' false).GetDecoder();                        case 0x3c00:                           goto case 0xfeff;                        case 0x003c:                           goto case 0xfffe;                  }
Missing Default,Sgml,Group,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AddConnector,The following switch statement is missing a default case: switch (c)               {                  case ''':                       gt = GroupType.Sequence;                      break;                  case '|':                      gt = GroupType.Or;                      break;                  case '&':                      gt = GroupType.And;                      break;              }
Missing Default,Sgml,Group,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlParser.cs,AddOccurrence,The following switch statement is missing a default case: switch (c)               {                  case '?':                       o = Occurrence.Optional;                      break;                  case '+':                      o = Occurrence.OneOrMore;                      break;                  case '*':                      o = Occurrence.ZeroOrMore;                      break;              }
Missing Default,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,Read,The following switch statement is missing a default case: switch (this.m_state)                  {                      case State.Initial:                          this.m_state = State.Markup;                          this.m_current.ReadChar();                          goto case State.Markup;                      case State.Eof:                          if (this.m_current.Parent != null)                          {                              this.m_current.Close();                              this.m_current = this.m_current.Parent;                          }                          else                          {                                                         return false;                          }                          break;                      case State.EndTag:                          if (string.Equals(this.m_endTag' this.m_node.Name' StringComparison.OrdinalIgnoreCase))                          {                              Pop(); // we're done!                              this.m_state = State.Markup;                              goto case State.Markup;                          }                                               Pop(); // close one element                          foundnode = true;// return another end element.                          break;                      case State.Markup:                          if (this.m_node.IsEmpty)                          {                              Pop();                          }                          foundnode = ParseMarkup();                          break;                      case State.PartialTag:                          Pop(); // remove text node.                          this.m_state = State.Markup;                          foundnode = ParseTag(this.m_partial);                          break;                      case State.PseudoStartTag:                          foundnode = ParseStartTag('<');                                                  break;                      case State.AutoClose:                          Pop(); // close next node.                          if (this.m_stack.Count <= this.m_poptodepth)                          {                              this.m_state = State.Markup;                              if (this.m_newnode != null)                              {                                  Push(this.m_newnode); // now we're ready to start the new node.                                  this.m_newnode = null;                                  this.m_state = State.Markup;                              }                              else if (this.m_node.NodeType == XmlNodeType.Document)                              {                                  this.m_state = State.Eof;                                  goto case State.Eof;                              }                          }                           foundnode = true;                          break;                      case State.CData:                          foundnode = ParseCData();                          break;                      case State.Attr:                          goto case State.AttrValue;                      case State.AttrValue:                          this.m_state = State.Markup;                          goto case State.Markup;                      case State.Text:                          Pop();                          goto case State.Markup;                      case State.PartialText:                          if (ParseText(this.m_current.Lastchar' false))                          {                              this.m_node.NodeType = XmlNodeType.Whitespace;                          }                            foundnode = true;                          break;                  }
Missing Default,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ScanName,The following switch statement is missing a default case: switch (this.m_folding)              {                  case CaseFolding.ToUpper:                      name = name.ToUpperInvariant();                      break;                  case CaseFolding.ToLower:                      name = name.ToLowerInvariant();                      break;              }
Missing Default,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ParseCData,The following switch statement is missing a default case: switch (this.m_partial)                  {                      case '!':                          this.m_partial = ' '; // and pop the comment next time around                          return ParseComment();                      case '?':                          this.m_partial = ' '; // and pop the PI next time around                          return ParsePI();                      case '/':                          this.m_state = State.EndTag;                          return true;    // we are done!                      case ' ':                          break; // means we just needed to pop the Comment' PI or CDATA.                  }
Missing Default,Sgml,SgmlReader,C:\repos\Synergex_Baconography\NBoilerpipePortable\Util\SGML\SgmlReader.cs,ExpandEntity,The following switch statement is missing a default case: switch(name) {                  case "amp":                      sb.Append("&");                      if(ch != terminator && ch != '&' && ch != Entity.EOF)                          ch = this.m_current.ReadChar();                      return;                  case "lt":                      sb.Append("<");                      if(ch != terminator && ch != '&' && ch != Entity.EOF)                          ch = this.m_current.ReadChar();                      return;                  case "gt":                      sb.Append(">");                      if(ch != terminator && ch != '&' && ch != Entity.EOF)                          ch = this.m_current.ReadChar();                      return;                  case "quot":                      sb.Append("\"");                      if(ch != terminator && ch != '&' && ch != Entity.EOF)                          ch = this.m_current.ReadChar();                      return;                  case "apos":                      sb.Append("'");                      if(ch != terminator && ch != '&' && ch != Entity.EOF)                          ch = this.m_current.ReadChar();                      return;                  }
