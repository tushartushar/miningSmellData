Implementation smell,Namespace,Class,File,Method,Description
Long Method,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The method has 179 lines of code.
Long Method,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The method has 119 lines of code.
Long Method,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The method has 117 lines of code.
Long Method,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The method has 199 lines of code.
Complex Method,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,CheckArguments,Cyclomatic complexity of the method is 8
Complex Method,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetCommentsOnPost,Cyclomatic complexity of the method is 8
Complex Method,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,SendPost,Cyclomatic complexity of the method is 11
Complex Method,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,Cyclomatic complexity of the method is 38
Complex Method,BaconographyPortable.Services.Impl,SmartOfflineImageService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineImageService.cs,_smartOfflineService_OffliningOpportunity,Cyclomatic complexity of the method is 10
Complex Method,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,Cyclomatic complexity of the method is 9
Complex Method,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadOneImpl,Cyclomatic complexity of the method is 8
Complex Method,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,UpdateImpl,Cyclomatic complexity of the method is 11
Long Parameter List,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,CheckArguments,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,Encode32,The method has 6 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength
Long Parameter List,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,Decode32,The method has 5 parameters. Parameters: input' inputLength' output' outputLength' knownOutputLength
Long Parameter List,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,Decode32,The method has 7 parameters. Parameters: input' inputOffset' inputLength' output' outputOffset' outputLength' knownOutputLength
Long Parameter List,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The method has 5 parameters. Parameters: hash_table' src' dst' src_len' dst_maxlen
Long Parameter List,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The method has 5 parameters. Parameters: hash_table' src' dst' src_len' dst_maxlen
Long Parameter List,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,Initialize,The method has 5 parameters. Parameters: settingsService' simpleHttpService' userService' notificationService' baconProvider
Long Parameter List,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,AddPost,The method has 5 parameters. Parameters: kind' url' text' subreddit' title
Long Parameter List,BaconographyPortable.Services,IImagesService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\IImagesService.cs,GenerateResizedImage,The method has 6 parameters. Parameters: inputFile' width' height' edgePadding' bottomPadding' replaceIfExists
Long Parameter List,BaconographyPortable.Services,IRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\IRedditService.cs,AddPost,The method has 5 parameters. Parameters: kind' url' text' subreddit' title
Long Parameter List,BaconographyPortable.Services.Impl,SmartOfflineImageService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineImageService.cs,Initialize,The method has 7 parameters. Parameters: imagesService' offlineService' oomService' settingsService' suspensionService' smartOfflineService' simpleHttpService
Long Parameter List,BaconographyPortable.Services.Impl,SmartOfflineImageService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineImageService.cs,GenerateResizedImage,The method has 6 parameters. Parameters: inputFile' width' height' edgePadding' bottomPadding' replaceIfExists
Long Parameter List,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,Initialize,The method has 9 parameters. Parameters: smartOfflineService' suspensionService' redditService' settingsService' systemServices' offlineService' notificationService' userService' suspendableWorkQueue
Long Parameter List,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,AddPost,The method has 5 parameters. Parameters: kind' url' text' subreddit' title
Long Parameter List,BaconographyPortable.Services.Impl,SmartOfflineService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineService.cs,Initialize,The method has 9 parameters. Parameters: viewModelContextService' oomService' settingsService' suspensionService' dynamicViewLocator' offlineService' imagesService' systemServices' suspendableWorkQueue
Long Parameter List,BaconographyPortable.ViewModel,CommentViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentViewModel.cs,CommentViewModel,The method has 5 parameters. Parameters: baconProvider' comment' linkId' oddNesting' depth
Long Parameter List,BaconographyPortable.ViewModel,MoreViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\MoreViewModel.cs,MoreViewModel,The method has 8 parameters. Parameters: baconProvider' ids' targetName' subreddit' loadMore' parent' depth' oddNesting
Long Parameter List,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,ReplyViewModel,The method has 5 parameters. Parameters: baconProvider' replyTargetThing' cancel' convertIntoUIReply' isEdit
Long Parameter List,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,CommentViewModelCollection,The method has 6 parameters. Parameters: baconProvider' permaLink' subreddit' subredditId' targetName' sourceLink
Long Identifier,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The length of the parameter src_end_LASTLITERALS_STEPSIZE_1 is 31.
Long Identifier,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The length of the parameter src_end_LASTLITERALS_STEPSIZE_1 is 31.
Long Identifier,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,,The length of the parameter NOTCOMPRESSIBLE_DETECTIONLEVEL is 30.
Long Identifier,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The length of the parameter maxTopLevelOfflineCommentsString is 32.
Long Identifier,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The length of the parameter highlightAlreadyClickedLinksString is 34.
Long Identifier,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The length of the parameter predictiveOffliningOnMeteredConnection is 38.
Long Statement,BaconographyPortable.Common,LinkGlyphUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\LinkGlyphUtility.cs,GetLinkGlyph,The length of the statement  "                if (UtilityCommandImpl.UserMultiredditRegex.IsMatch(uri.AbsoluteUri) || UtilityCommandImpl.SubredditRegex.IsMatch(uri.AbsoluteUri)) " is 131.
Long Statement,BaconographyPortable.Common,LinkGlyphUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\LinkGlyphUtility.cs,GetLinkGlyph,The length of the statement  "                else if (UtilityCommandImpl.CommentRegex.IsMatch(uri.AbsoluteUri) || UtilityCommandImpl.CommentsPageRegex.IsMatch(uri.AbsoluteUri)) " is 131.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,RepositionContextScroll,The length of the statement  "            var firstRedditViewModel = viewModelContextService.ContextStack.FirstOrDefault(context => context is RedditViewModel) as RedditViewModel; " is 137.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,Previous,The length of the statement  "                var firstRedditViewModel = viewModelContextService.ContextStack.FirstOrDefault(context => context is RedditViewModel) as RedditViewModel; " is 137.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,Next,The length of the statement  "                var firstRedditViewModel = viewModelContextService.ContextStack.FirstOrDefault(context => context is RedditViewModel) as RedditViewModel; " is 137.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                if (vm is LinkViewModel && imagesService.MightHaveImagesFromUrl(((LinkViewModel)vm).Url) && (!settingsService.OnlyFlipViewUnread || !offlineService.HasHistory(((LinkViewModel)vm).Url))) " is 185.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                    var imageResults = await ServiceLocator.Current.GetInstance<IImagesService>().GetImagesFromUrl(targetViewModel.LinkThing == null ? "" : targetViewModel.LinkThing.Data.Title' targetViewModel.Url); " is 195.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                        var imageTuple = new Tuple<string' IEnumerable<Tuple<string' string>>' string>(targetViewModel.LinkThing != null ? targetViewModel.LinkThing.Data.Title : ""' imageResults' targetViewModel.LinkThing != null ? targetViewModel.LinkThing.Data.Id : ""); " is 248.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                        Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = targetViewModel.Url }); " is 126.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                            LinkTitle = imageTuple.Item1.Replace("&amp;"' "&").Replace("&lt;"' "<").Replace("&gt;"' ">").Replace("&quot;"' "\"").Replace("&apos;"' "'").Trim()' " is 147.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                                Title = tpl.Item1.Replace("&amp;"' "&").Replace("&lt;"' "<").Replace("&gt;"' ">").Replace("&quot;"' "\"").Replace("&apos;"' "'").Trim()' " is 136.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                else if (vm is LinkViewModel && LinkGlyphUtility.GetLinkGlyph(vm) == LinkGlyphUtility.WebGlyph && !settingsService.OnlyFlipViewImages && settingsService.ApplyReadabliltyToLinks && (!settingsService.OnlyFlipViewUnread || !offlineService.HasHistory(((LinkViewModel)vm).Url))) " is 273.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                    var result = await ReadableArticleViewModel.LoadAtLeastOne(ServiceLocator.Current.GetInstance<ISimpleHttpService>()' targetViewModel.Url' targetViewModel.LinkThing.Data.Id); " is 173.
Long Statement,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The length of the statement  "                else if (vm is LinkViewModel && ((LinkViewModel)vm).IsSelfPost && !settingsService.OnlyFlipViewImages && (!settingsService.OnlyFlipViewUnread || !offlineService.HasHistory(((LinkViewModel)vm).Url))) " is 198.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoUserDetails,The length of the statement  "            var getAccount = await ServiceLocator.Current.GetInstance<IBaconProvider>().GetService<IRedditService>().GetAccountInfo(str); " is 125.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoUserDetails,The length of the statement  "            ServiceLocator.Current.GetInstance<INavigationService>().Navigate(ServiceLocator.Current.GetInstance<IDynamicViewLocator>().AboutUserView'accountMessage); " is 154.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        new Thing { Kind = "t3"' Data = new Link { Permalink = str' Url = str' Title = str' Name = ""' Author = ""' Selftext = "" } }; " is 126.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = new TypedThing<Link>(targetLinkThing) }); " is 173.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str }); " is 149.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                    var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) : sourceLink; " is 123.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing }); " is 150.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str }); " is 149.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                    var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetThingById(thingId) : sourceLink; " is 127.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing }); " is 150.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str }); " is 149.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit }); " is 141.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode"); " is 129.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit }); " is 141.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode"); " is 129.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                            navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().AboutUserView' new SelectUserAccountMessage { Account = account }); " is 142.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("Cannot access user info in offline mode."); " is 122.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                    var imageResults = await baconProvider.GetService<IImagesService>().GetImagesFromUrl(sourceLink == null ? "" : sourceLink.Data.Title' str); " is 139.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                        var imageTuple = new Tuple<string' IEnumerable<Tuple<string' string>>' string>(sourceLink != null ? sourceLink.Data.Title : ""' imageResults' sourceLink != null ? sourceLink.Data.Id : ""); " is 188.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                            navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedReadabilityView' Tuple.Create<string' string>(str' sourceLink != null ? sourceLink.Data.Id : "")); " is 179.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                            navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str }); " is 149.
Long Statement,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The length of the statement  "                ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification(string.Format("failed to navigate to {0}' due to {1}"' str' ex.ToString())); " is 154.
Long Statement,BaconographyPortable.Model.KitaroDB.ListingHelpers,SubredditInfo,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\SubredditInfo.cs,GetInitialListing,The length of the statement  "            var orderedThings = await _offlineService.RetrieveOrderedThings("sublist:" + (await _userService.GetUser()).Username' TimeSpan.FromDays(1024)); " is 143.
Long Statement,BaconographyPortable.Model.KitaroDB.ListingHelpers,SubredditSubscriptions,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\SubredditSubscriptions.cs,GetInitialListing,The length of the statement  "            var orderedThings = await _offlineService.RetrieveOrderedThings("sublist:" + (await _userService.GetUser()).Username' TimeSpan.FromDays(1024)); " is 143.
Long Statement,BaconographyPortable.Model.KitaroDB.ListingHelpers,SubredditSubscriptions,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\SubredditSubscriptions.cs,GetInitialListing,The length of the statement  "            return new Listing { Data = new ListingData { Children = orderedThings != null ? new List<Thing>(orderedThings) : new List<Thing>() } }; " is 136.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,Search,The length of the statement  "                targetUri = string.Format("http://www.reddit.com/r/{2}/search.json?limit={0}&q={1}&restrict_sr=on"' guardedLimit' query' restrictedToSubreddit); " is 144.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddit,The length of the statement  "                return new TypedThing<Subreddit>(new Thing { Kind = "t5"' Data = new Subreddit { Headertitle = "all"' Url = "/r/all"' Name = "all"' DisplayName="all"' Title="all"' Id="t5_fakeid" } }); " is 184.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddit,The length of the statement  "                        return new TypedThing<Subreddit>(new Thing { Kind = "t5"' Data = new Subreddit { Headertitle = name' Title = name' Url = string.Format("r/{0}"' name)' Created = DateTime.Now' CreatedUTC = DateTime.UtcNow' DisplayName = name' Description = "there doesnt seem to be anything here"' Name = name' Over18 = false' PublicDescription = "there doesnt seem to be anything here"' Subscribers = 0 } }); " is 391.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddit,The length of the statement  "                    return new TypedThing<Subreddit>(new Thing { Kind = "t5"' Data = new Subreddit { Headertitle = name' Title = name' Url = string.Format("r/{0}"' name)' Created = DateTime.Now' CreatedUTC = DateTime.UtcNow' DisplayName = name' Description = "there doesnt seem to be anything here"' Name = name' Over18 = false' PublicDescription = "there doesnt seem to be anything here"' Subscribers = 0 } }); " is 391.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddit,The length of the statement  "                        return new TypedThing<Subreddit>(new Thing { Kind = "t5"' Data = new Subreddit { Headertitle = name' Title = name' Url = string.Format("r/{0}"' name)' Created = DateTime.Now' CreatedUTC = DateTime.UtcNow' DisplayName = name' Description = "there doesnt seem to be anything here"' Name = name' Over18 = false' PublicDescription = "there doesnt seem to be anything here"' Subscribers = 0 } }); " is 391.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddit,The length of the statement  "                        return new TypedThing<Subreddit>(new Thing { Kind = "t5"' Data = new Subreddit { DisplayName = labeledMulti.Data.Name' Title = labeledMulti.Data.Name' Url = multiPath' Headertitle = labeledMulti.Data.Name' Over18 = false } }); " is 226.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddit,The length of the statement  "                    return new TypedThing<Subreddit>(new Thing { Kind = "t5"' Data = new Subreddit { Headertitle = name' Title = name' Url = string.Format("r/{0}"' name)' Created = DateTime.Now' CreatedUTC = DateTime.UtcNow' DisplayName = name' Description = "there doesnt seem to be anything here"' Name = name' Over18 = false' PublicDescription = "there doesnt seem to be anything here"' Subscribers = 0 } }); " is 391.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetLinkByUrl,The length of the statement  "                    _lastCommentsOnPostRequest = Tuple.Create(DateTime.Now' ((Link)requestedLinkInfo.Data).Subreddit' ((Link)requestedLinkInfo.Data).Permalink' result); " is 148.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetCommentsOnPost,The length of the statement  "                    targetUri = string.Format("http://www.reddit.com{0}.json{1}"' permalink.Remove(queryPos)' permalink.Substring(queryPos)); " is 121.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,AddVote,The length of the statement  "            ProcessJsonErrors(await _simpleHttpService.SendPost(await GetCurrentLoginCookie()' arguments' "http://www.reddit.com/api/vote")); " is 129.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,EditPost,The length of the statement  "            ProcessJsonErrors(await this.SendPost(await GetCurrentLoginCookie()' arguments' "http://www.reddit.com/api/editusertext")); " is 123.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,ReadMessage,The length of the statement  "            ProcessJsonErrors(await this.SendPost(await GetCurrentLoginCookie()' arguments' "http://www.reddit.com/api/read_message")); " is 123.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,EditComment,The length of the statement  "            ProcessJsonErrors(await this.SendPost(await GetCurrentLoginCookie()' arguments' "http://www.reddit.com/api/editusertext")); " is 123.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetUsernameModifiers,The length of the statement  "                if (_subredditToModMap.TryGetValue(subreddit' out subredditMods) && subredditMods != null && subredditMods.Contains(username)) " is 126.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetUserMultis,The length of the statement  "                        listing.Data.Children.Insert(0' (new Thing { Kind = "t5"' Data = new Subreddit { DisplayName = labeledMulti.Data.Name' HeaderImage = "/Assets/multireddit.png"' Title = labeledMulti.Data.Name' Url = multiPath' Headertitle = labeledMulti.Data.Name' Over18 = false } })); " is 268.
Long Statement,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetDefaultSubreddits,The length of the statement  "            return JsonConvert.DeserializeObject<Listing>(Resources.DefaultSubreddits1 + Resources.DefaultSubreddits2 + Resources.DefaultSubreddits3); " is 138.
Long Statement,BaconographyPortable.Model.Reddit.ListingHelpers,SearchResults,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\SearchResults.cs,GetAdditionalListing,The length of the statement  "                return _redditService.GetAdditionalFromListing(string.Format("http://www.reddit.com/subreddits/search.json?q={0}"' _query)' after' null); " is 137.
Long Statement,BaconographyPortable.Model.Reddit.ListingHelpers,SearchResults,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\SearchResults.cs,GetAdditionalListing,The length of the statement  "                return _redditService.GetAdditionalFromListing(string.Format("http://www.reddit.com/search.json?q={0}"' _query)' after' null); " is 126.
Long Statement,BaconographyPortable.Model.Reddit.ListingHelpers,SearchResults,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\SearchResults.cs,GetAdditionalListing,The length of the statement  "                return _redditService.GetAdditionalFromListing(string.Format("http://www.reddit.com/r/{1}/search.json?q={0}"' _query' _restrictedToSubreddit)' after' null); " is 156.
Long Statement,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The length of the statement  "                var predictiveOffliningOnMeteredConnection = await offlineService.GetSetting("AllowPredictiveOffliningOnMeteredConnection"); " is 124.
Long Statement,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Persist,The length of the statement  "            await offlineService.StoreSetting("AllowPredictiveOffliningOnMeteredConnection"' AllowPredictiveOffliningOnMeteredConnection.ToString()); " is 137.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineImageService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineImageService.cs,_smartOfflineService_OffliningOpportunity,The length of the statement  "                //otherwise just download the thumbnails and make the api calls since the platform default behavior would have been to download them anyway " is 139.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetMe,The length of the statement  "                var thing = await _offlineService.RetrieveThing(string.Format("account-user:{0}"' user.Username)' TimeSpan.FromDays(1024)); " is 123.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,MaybeStoreSubscribedSubredditListing,The length of the statement  "                if (user != null && user.Username != null && listing != null && listing.Data.Children != null && listing.Data.Children.Count > 0) " is 129.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetUsernameModifiers,The length of the statement  "                if (_subredditToModMap.TryGetValue(subreddit' out subredditMods) && subredditMods != null && subredditMods.Contains(username)) " is 126.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,AddComment,The length of the statement  "                await _offlineService.EnqueueAction("AddComment"' new Dictionary<string' string> { { "parentId"' parentId }' { "content"' content } }); " is 135.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,EditComment,The length of the statement  "                await _offlineService.EnqueueAction("EditComment"' new Dictionary<string' string> { { "thingId"' thingId }' { "text"' text } }); " is 128.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,AddMessage,The length of the statement  "                await _offlineService.EnqueueAction("AddMessage"' new Dictionary<string' string> { { "recipient"' recipient }' { "subject"' subject }' { "message"' message } }); " is 161.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,AddVote,The length of the statement  "                await _offlineService.EnqueueAction("AddVote"' new Dictionary<string' string> { { "thingId"' thingId }' { "direction"' direction.ToString() } }); " is 145.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,AddSubredditSubscription,The length of the statement  "                await _offlineService.EnqueueAction("AddVote"' new Dictionary<string' string> { { "subreddit"' subreddit }' { "direcunsubtion"' unsub.ToString() } }); " is 150.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,RunPeriodic,The length of the statement  "                                        await AddPost(actionTpl.Item2["kind"]' actionTpl.Item2["url"]' actionTpl.Item2["text"]' actionTpl.Item2["subreddit"]' actionTpl.Item2["title"]); " is 144.
Long Statement,BaconographyPortable.Services.Impl,SmartOfflineService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineService.cs,NavigatedToView,The length of the statement  "            OffliningOpportunity(priority' onMeteredConnection ? NetworkConnectivityStatus.Metered : NetworkConnectivityStatus.Unmetered' _cancelationTokenSource.Token); " is 157.
Long Statement,BaconographyPortable.Services.Impl,SuspendableWorkQueueImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SuspendableWorkQueueImpl.cs,QueueLowImportanceRestartableWork,The length of the statement  "                Task.Factory.StartNew(RunWorkQueue' _cancelationTokenSource.Token' TaskCreationOptions.LongRunning' TaskScheduler.Default); " is 123.
Long Statement,BaconographyPortable.ViewModel,CombinedSearchViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CombinedSearchViewModel.cs,queryTimer_Tick,The length of the statement  "                    SearchResults.UpdateRealItems(new SearchResultsViewModelCollection(_baconProvider' _query' false' SearchOnlySubreddit ? TargetSubreddit : null)); " is 145.
Long Statement,BaconographyPortable.ViewModel,CommentsViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentsViewModel.cs,LoadLink,The length of the statement  "            //Comments = new CommentViewModelCollection(_baconProvider' _linkThing.Data.Permalink' _linkThing.Data.Subreddit' _linkThing.Data.SubredditId' _linkThing.Data.Name); " is 165.
Long Statement,BaconographyPortable.ViewModel,CommentsViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentsViewModel.cs,GotoSubredditImpl,The length of the statement  "            _navigationService.Navigate(_dynamicViewLocator.RedditView' new SelectSubredditMessage { Subreddit = await _redditService.GetSubreddit(_linkThing.Data.Subreddit) }); " is 165.
Long Statement,BaconographyPortable.ViewModel,CommentsViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentsViewModel.cs,GotoReplyImpl,The length of the statement  "            Action<Thing> uiResponse = (madeComment) => Comments.Add(new CommentViewModel(_baconProvider' madeComment' _linkThing.Data.Name' false)); " is 137.
Long Statement,BaconographyPortable.ViewModel,CommentViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentViewModel.cs,GotoContextImpl,The length of the statement  "                var parentThing = await _redditService.GetLinkByUrl("http://www.reddit.com/" + linkThing.Data.Permalink + _comment.Data.ParentId.Substring(3)); " is 143.
Long Statement,BaconographyPortable.ViewModel,MessagesViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\MessagesViewModel.cs,Messages_CollectionChanged,The length of the statement  "            if ((e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) && " is 169.
Long Statement,BaconographyPortable.ViewModel,MessagesViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\MessagesViewModel.cs,MaybeToastNewMessage,The length of the statement  "                    _notificationService.CreateNotificationWithNavigation("New Message: " + viewModel.Preview' _baconProvider.GetService<IDynamicViewLocator>().MessagesView' null); " is 160.
Long Statement,BaconographyPortable.ViewModel,LinkViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LinkViewModel.cs,GotoSubredditImpl,The length of the statement  "            Messenger.Default.Send<SelectSubredditMessage>(new SelectSubredditMessage { Subreddit = await _redditService.GetSubreddit(_linkThing.Data.Subreddit) }); " is 152.
Long Statement,BaconographyPortable.ViewModel,LinkViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LinkViewModel.cs,NavigateToCommentsImpl,The length of the statement  "            if (vm == null || vm._linkThing == null || vm._linkThing.Data == null || string.IsNullOrWhiteSpace(vm._linkThing.Data.Url)) " is 123.
Long Statement,BaconographyPortable.ViewModel,LinkViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LinkViewModel.cs,NavigateToCommentsImpl,The length of the statement  "                vm._baconProvider.GetService<INotificationService>().CreateNotification("Invalid link data' please PM /u/hippiehunter with details"); " is 133.
Long Statement,BaconographyPortable.ViewModel,LinkViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LinkViewModel.cs,NavigateToCommentsImpl,The length of the statement  "                vm._navigationService.Navigate(vm._dynamicViewLocator.CommentsView' new SelectCommentTreeMessage { LinkThing = vm._linkThing }); " is 128.
Long Statement,BaconographyPortable.ViewModel,LoginViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LoginViewModel.cs,OnUserLoggedIn,The length of the statement  "            if (userMessage != null && userMessage.CurrentUser != null && !string.IsNullOrWhiteSpace(userMessage.CurrentUser.Username)) " is 123.
Long Statement,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadAtLeastOne,The length of the statement  "            var articleViewModel = new ReadableArticleViewModel { ArticleUrl = url' ArticleParts = new ObservableCollection<object>()' LinkId = linkId' ContentIsFocused = true }; " is 166.
Long Statement,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadFully,The length of the statement  "            return new ReadableArticleViewModel { LinkId = linkId' ArticleUrl = url' ArticleParts = new ObservableCollection<object>(resultTpl.Item2)' Title = resultTpl.Item1 }; " is 165.
Long Statement,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadOneImpl,The length of the statement  "            Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true' Percentage = 0' Message = "loading from " + domain }); " is 130.
Long Statement,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadOneImpl,The length of the statement  "            Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true' Percentage = 50' Message = "processing page from " + domain }); " is 139.
Long Statement,BaconographyPortable.ViewModel,RedditPickerViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\RedditPickerViewModel.cs,GotoSubredditImpl,The length of the statement  "            _navigationService.Navigate(_dynamicViewLocator.RedditView' new SelectSubredditMessage { Subreddit = await _redditService.GetSubreddit(TargetSubreddit) }); " is 155.
Long Statement,BaconographyPortable.ViewModel,RedditViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\RedditViewModel.cs,DownloadForOfflineImpl,The length of the statement  "            await _offlineService.StoreLinks(await _redditService.GetPostsBySubreddit(_selectedSubreddit != null ? _selectedSubreddit.Data.Url : "/"' _settingsService.DefaultOfflineLinkCount)); " is 181.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,SurroundSelection,The length of the statement  "            var selectedText = string.IsNullOrEmpty(startText) ? "" : startText.Substring(startPosition' endPosition - startPosition); " is 122.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,SurroundSelection,The length of the statement  "            var postText = (string.IsNullOrEmpty(startText) || endPosition == startText.Length) ? "" : startText.Substring(endPosition + 1); " is 128.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddBoldImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _boldFormattingString); " is 126.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddItalicImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _italicFormattingString); " is 128.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddStrikeImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _strikeFormattingString); " is 128.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddSuperImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _superFormattingString); " is 127.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddLinkImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _linkFormattingString); " is 126.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddQuoteImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _quoteFormattingString); " is 127.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddCodeImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _codeFormattingString); " is 126.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddBulletsImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _bulletFormattingString); " is 128.
Long Statement,BaconographyPortable.ViewModel,ReplyViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReplyViewModel.cs,AddNumbersImpl,The length of the statement  "            var surroundedTextTpl = SurroundSelection(SelectionStart' SelectionStart + SelectionLength' ReplyBody' _numberFormattingString); " is 128.
Long Statement,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,MapThing,The length of the statement  "				var more = new MoreViewModel(_baconProvider' ((More)thing.Data).Children' _targetName' _subreddit' RunLoadMore' parent as CommentViewModel' depth' oddNesting); " is 159.
Long Statement,BaconographyPortable.ViewModel.Collections,ImageSearchViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ImageSearchViewModelCollection.cs,MapListing,The length of the statement  "                .Select(async (thing) => MapImage(await _imagesService.GetImagesFromUrl(((Link)thing.Data).Title' ((Link)thing.Data).Url))); " is 124.
Long Statement,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,LoadAdditional,The length of the statement  "                //asking for 500 of anything is probably unreasonable but reddit will sort it out on the other side in the most efficiant way possible " is 134.
Long Statement,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,UpdateImpl,The length of the statement  "                        await _suspendableWorkQueue.QueueLowImportanceRestartableWork(async (token2) => await ((ICachedListingProvider)_onlineListingProvider).CacheIt(targetListing)); " is 159.
Complex Conditional,BaconographyPortable.Common,LinkGlyphUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\LinkGlyphUtility.cs,GetLinkGlyph,The conditional expression  "subreddit == "videos" ||                      targetHost == "www.youtube.com" ||                      targetHost == "www.youtu.be" ||                      targetHost == "youtu.be" ||                      targetHost == "youtube.com" ||                      targetHost == "vimeo.com" ||                      targetHost == "www.vimeo.com" ||                      targetHost == "liveleak.com" ||                      targetHost == "www.liveleak.com""  is complex.
Complex Conditional,BaconographyPortable.Common,LinkGlyphUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\LinkGlyphUtility.cs,GetLinkGlyph,The conditional expression  "targetHost == "www.imgur.com" ||                      targetHost == "imgur.com" ||                      targetHost == "i.imgur.com" ||                      targetHost == "min.us" ||                      targetHost == "www.quickmeme.com" ||                      targetHost == "i.qkme.me" ||                      targetHost == "quickmeme.com" ||                      targetHost == "qkme.me" ||                      targetHost == "memecrunch.com" ||                      targetHost == "flickr.com" ||                      targetHost == "www.flickr.com" ||                      filename.EndsWith(".jpg") ||                      filename.EndsWith(".gif") ||                      filename.EndsWith(".png") ||                      filename.EndsWith(".jpeg")"  is complex.
Complex Conditional,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The conditional expression  "vm is LinkViewModel && imagesService.MightHaveImagesFromUrl(((LinkViewModel)vm).Url) && (!settingsService.OnlyFlipViewUnread || !offlineService.HasHistory(((LinkViewModel)vm).Url))"  is complex.
Complex Conditional,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The conditional expression  "vm is LinkViewModel && LinkGlyphUtility.GetLinkGlyph(vm) == LinkGlyphUtility.WebGlyph && !settingsService.OnlyFlipViewImages && settingsService.ApplyReadabliltyToLinks && (!settingsService.OnlyFlipViewUnread || !offlineService.HasHistory(((LinkViewModel)vm).Url))"  is complex.
Complex Conditional,BaconographyPortable.Common,StreamViewUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\StreamViewUtility.cs,MakeContextedTuple,The conditional expression  "vm is LinkViewModel && ((LinkViewModel)vm).IsSelfPost && !settingsService.OnlyFlipViewImages && (!settingsService.OnlyFlipViewUnread || !offlineService.HasHistory(((LinkViewModel)vm).Url))"  is complex.
Complex Conditional,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,Login,The conditional expression  "loginResultThing == null || loginResultThing.Json == null ||                  (loginResultThing.Json.Errors != null && loginResultThing.Json.Errors.Length != 0)"  is complex.
Complex Conditional,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetCommentsOnPost,The conditional expression  "_lastCommentsOnPostRequest != null &&                  (DateTime.Now - _lastCommentsOnPostRequest.Item1).TotalMinutes < 5 &&                  _lastCommentsOnPostRequest.Item2 == subreddit &&                  _lastCommentsOnPostRequest.Item3 == permalink"  is complex.
Complex Conditional,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The conditional expression  "(user != null && user.Me != null && user.Me.HasMail)                      || !(await _offlineService.UserHasOfflineMessages(user))"  is complex.
Complex Conditional,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,MaybeStoreSubscribedSubredditListing,The conditional expression  "user != null && user.Username != null && listing != null && listing.Data.Children != null && listing.Data.Children.Count > 0"  is complex.
Complex Conditional,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,AddPost,The conditional expression  "kind == null || url == null || text == null || subreddit == null || title == null"  is complex.
Complex Conditional,BaconographyPortable.ViewModel,MessagesViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\MessagesViewModel.cs,Messages_CollectionChanged,The conditional expression  "(e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add || e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Replace) &&                  e.NewItems != null && e.NewItems.Count == 1 && e.NewItems[0] is MessageViewModel"  is complex.
Complex Conditional,BaconographyPortable.ViewModel,LinkViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LinkViewModel.cs,LinkViewModel,The conditional expression  "_imagesService.MightHaveImagesFromUrl(Url) && !Url.EndsWith(".jpg") && !Url.EndsWith(".gif") && !Url.EndsWith(".png")"  is complex.
Complex Conditional,BaconographyPortable.ViewModel,LinkViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LinkViewModel.cs,NavigateToCommentsImpl,The conditional expression  "vm == null || vm._linkThing == null || vm._linkThing.Data == null || string.IsNullOrWhiteSpace(vm._linkThing.Data.Url)"  is complex.
Empty Catch Block,BaconographyPortable.Common,LinkGlyphUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Common\LinkGlyphUtility.cs,GetLinkGlyph,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,ProcessJsonErrors,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetUserMultis,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineImageService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineImageService.cs,_smartOfflineService_OffliningOpportunity,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,MaybeStoreSubscribedSubredditListing,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,MaybeStoredSubredditListing,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,UpdateCachedSubreddit,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,MaybeStorePostsBySubreddit,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,MaybeStoreCommentsOnPost,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,RunPeriodic,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,RunPeriodic,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineService.cs,NavigatedToOfflineableThingImpl,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SmartOfflineService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineService.cs,NavigatedToView,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SuspendableWorkQueueImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SuspendableWorkQueueImpl.cs,RunUIWorkQueue,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SuspensionService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SuspensionService.cs,FireSuspending,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.Services.Impl,SuspensionService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SuspensionService.cs,FireResuming,The method has an empty catch block.
Empty Catch Block,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,UpdateImpl,The method has an empty catch block.
Magic Number,BaconographyPortable.Common,NeverEndingRedditView,C:\repos\Synergex_Baconography\BaconographyPortable\Common\NeverEndingRedditEnumerator.cs,Next,The following statement contains a magic number: if (_forward)              {                  _currentLinkPos++;                  if (_context.Links.Count <= _currentLinkPos)                  {                      await _context.Links.LoadMoreItemsAsync(100);                  }              }              else                  _currentLinkPos--;
Magic Number,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The following statement contains a magic number: try              {                  var settingsService = ServiceLocator.Current.GetInstance<ISettingsService>();                  _longNavWatcher.ClearInFlight();                  var baconProvider = ServiceLocator.Current.GetInstance<IBaconProvider>();                  var navigationService = baconProvider.GetService<INavigationService>();                    if (CommentRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) :                          new Thing { Kind = "t3"' Data = new Link { Permalink = str' Url = str' Title = str' Name = ""' Author = ""' Selftext = "" } };                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null && targetLinkThing.Data is Link)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = new TypedThing<Link>(targetLinkThing) });                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (CommentsPageRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) : sourceLink;                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null)                      {                          var typedLinkThing = new TypedThing<Link>(targetLinkThing);                          await baconProvider.GetService<IOfflineService>().StoreHistory(typedLinkThing.Data.Permalink);                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing });                      }                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (ShortCommentsPageRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var thingId = "t3_" + str.Split(new char[] { '/' }' StringSplitOptions.RemoveEmptyEntries).Last();                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetThingById(thingId) : sourceLink;                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null)                      {                          var typedLinkThing = new TypedThing<Link>(targetLinkThing);                          await baconProvider.GetService<IOfflineService>().StoreHistory(typedLinkThing.Data.Permalink);                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing });                      }                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (SubredditRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/r/");                      var subredditName = str.Substring(nameIndex + 3);                        TypedThing<Subreddit> subreddit = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          subreddit = await baconProvider.GetService<IRedditService>().GetSubreddit(subredditName);                      }                      else                      {                          var thing = await offlineService.GetSubreddit(subredditName);                          if (thing != null)                              subreddit = new TypedThing<Subreddit>(thing);                      }                        if (subreddit != null)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit });                      else                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode");                  }                  else if (UserMultiredditRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/u/");                      string subredditName = "";                      if (nameIndex < 0)                      {                          nameIndex = str.LastIndexOf("/user/");                          subredditName = str.Substring(nameIndex);                      }                      else                      {                          subredditName = str.Substring(nameIndex);                      }                        subredditName = subredditName.Replace("/u/"' "/user/");                        TypedThing<Subreddit> subreddit = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          subreddit = await baconProvider.GetService<IRedditService>().GetSubreddit(subredditName);                      }                      else                      {                          var thing = await offlineService.GetSubreddit(subredditName);                          if (thing != null)                              subreddit = new TypedThing<Subreddit>(thing);                      }                        if (subreddit != null)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit });                      else                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode");                  }                  else if (UserRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/u/");                      string userName = "";                      if (nameIndex < 0)                      {                          nameIndex = str.LastIndexOf("/user/");                          userName = str.Substring(nameIndex + 6);                      }                      else                      {                          userName = str.Substring(nameIndex + 3);                      }                        TypedThing<Account> account = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          account = await baconProvider.GetService<IRedditService>().GetAccountInfo(userName);                            if (account != null)                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().AboutUserView' new SelectUserAccountMessage { Account = account });                          else                              ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This account does not exist.");                      }                      else                      {                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("Cannot access user info in offline mode.");                      }                  }                  else                  {                      var smartOfflineService = baconProvider.GetService<ISmartOfflineService>();                      smartOfflineService.NavigatedToOfflineableThing(sourceLink' false);                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = false' TargetUrl = str });                      await baconProvider.GetService<IOfflineService>().StoreHistory(str);                      var imageResults = await baconProvider.GetService<IImagesService>().GetImagesFromUrl(sourceLink == null ? "" : sourceLink.Data.Title' str);                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                        if (imageResults != null && imageResults.Count() > 0 && !_longNavWatcher.GetTerminatedClearInFlight(str))                      {                          var imageTuple = new Tuple<string' IEnumerable<Tuple<string' string>>' string>(sourceLink != null ? sourceLink.Data.Title : ""' imageResults' sourceLink != null ? sourceLink.Data.Id : "");                          Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = str });                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedPictureView' imageTuple);                      }                      else                      {                          var uri = new Uri(str);                          var targetHost = uri.DnsSafeHost.ToLower();                            Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = str });                          var videoResults = await baconProvider.GetService<IVideoService>().GetPlayableStreams(str);                          if (videoResults != null)                          {                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedVideoView' videoResults);                          }                          else if (settingsService.ApplyReadabliltyToLinks && LinkGlyphUtility.GetLinkGlyph(str) == LinkGlyphUtility.WebGlyph)                          {                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedReadabilityView' Tuple.Create<string' string>(str' sourceLink != null ? sourceLink.Data.Id : ""));                          }                          else                          {                              //its not an image/video url we can understand so whatever it is just show it in the browser                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                          }                      }                  }              }              catch (Exception ex)              {                  ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification(string.Format("failed to navigate to {0}' due to {1}"' str' ex.ToString()));              }
Magic Number,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The following statement contains a magic number: try              {                  var settingsService = ServiceLocator.Current.GetInstance<ISettingsService>();                  _longNavWatcher.ClearInFlight();                  var baconProvider = ServiceLocator.Current.GetInstance<IBaconProvider>();                  var navigationService = baconProvider.GetService<INavigationService>();                    if (CommentRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) :                          new Thing { Kind = "t3"' Data = new Link { Permalink = str' Url = str' Title = str' Name = ""' Author = ""' Selftext = "" } };                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null && targetLinkThing.Data is Link)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = new TypedThing<Link>(targetLinkThing) });                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (CommentsPageRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) : sourceLink;                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null)                      {                          var typedLinkThing = new TypedThing<Link>(targetLinkThing);                          await baconProvider.GetService<IOfflineService>().StoreHistory(typedLinkThing.Data.Permalink);                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing });                      }                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (ShortCommentsPageRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var thingId = "t3_" + str.Split(new char[] { '/' }' StringSplitOptions.RemoveEmptyEntries).Last();                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetThingById(thingId) : sourceLink;                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null)                      {                          var typedLinkThing = new TypedThing<Link>(targetLinkThing);                          await baconProvider.GetService<IOfflineService>().StoreHistory(typedLinkThing.Data.Permalink);                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing });                      }                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (SubredditRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/r/");                      var subredditName = str.Substring(nameIndex + 3);                        TypedThing<Subreddit> subreddit = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          subreddit = await baconProvider.GetService<IRedditService>().GetSubreddit(subredditName);                      }                      else                      {                          var thing = await offlineService.GetSubreddit(subredditName);                          if (thing != null)                              subreddit = new TypedThing<Subreddit>(thing);                      }                        if (subreddit != null)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit });                      else                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode");                  }                  else if (UserMultiredditRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/u/");                      string subredditName = "";                      if (nameIndex < 0)                      {                          nameIndex = str.LastIndexOf("/user/");                          subredditName = str.Substring(nameIndex);                      }                      else                      {                          subredditName = str.Substring(nameIndex);                      }                        subredditName = subredditName.Replace("/u/"' "/user/");                        TypedThing<Subreddit> subreddit = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          subreddit = await baconProvider.GetService<IRedditService>().GetSubreddit(subredditName);                      }                      else                      {                          var thing = await offlineService.GetSubreddit(subredditName);                          if (thing != null)                              subreddit = new TypedThing<Subreddit>(thing);                      }                        if (subreddit != null)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit });                      else                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode");                  }                  else if (UserRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/u/");                      string userName = "";                      if (nameIndex < 0)                      {                          nameIndex = str.LastIndexOf("/user/");                          userName = str.Substring(nameIndex + 6);                      }                      else                      {                          userName = str.Substring(nameIndex + 3);                      }                        TypedThing<Account> account = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          account = await baconProvider.GetService<IRedditService>().GetAccountInfo(userName);                            if (account != null)                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().AboutUserView' new SelectUserAccountMessage { Account = account });                          else                              ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This account does not exist.");                      }                      else                      {                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("Cannot access user info in offline mode.");                      }                  }                  else                  {                      var smartOfflineService = baconProvider.GetService<ISmartOfflineService>();                      smartOfflineService.NavigatedToOfflineableThing(sourceLink' false);                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = false' TargetUrl = str });                      await baconProvider.GetService<IOfflineService>().StoreHistory(str);                      var imageResults = await baconProvider.GetService<IImagesService>().GetImagesFromUrl(sourceLink == null ? "" : sourceLink.Data.Title' str);                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                        if (imageResults != null && imageResults.Count() > 0 && !_longNavWatcher.GetTerminatedClearInFlight(str))                      {                          var imageTuple = new Tuple<string' IEnumerable<Tuple<string' string>>' string>(sourceLink != null ? sourceLink.Data.Title : ""' imageResults' sourceLink != null ? sourceLink.Data.Id : "");                          Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = str });                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedPictureView' imageTuple);                      }                      else                      {                          var uri = new Uri(str);                          var targetHost = uri.DnsSafeHost.ToLower();                            Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = str });                          var videoResults = await baconProvider.GetService<IVideoService>().GetPlayableStreams(str);                          if (videoResults != null)                          {                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedVideoView' videoResults);                          }                          else if (settingsService.ApplyReadabliltyToLinks && LinkGlyphUtility.GetLinkGlyph(str) == LinkGlyphUtility.WebGlyph)                          {                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedReadabilityView' Tuple.Create<string' string>(str' sourceLink != null ? sourceLink.Data.Id : ""));                          }                          else                          {                              //its not an image/video url we can understand so whatever it is just show it in the browser                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                          }                      }                  }              }              catch (Exception ex)              {                  ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification(string.Format("failed to navigate to {0}' due to {1}"' str' ex.ToString()));              }
Magic Number,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The following statement contains a magic number: try              {                  var settingsService = ServiceLocator.Current.GetInstance<ISettingsService>();                  _longNavWatcher.ClearInFlight();                  var baconProvider = ServiceLocator.Current.GetInstance<IBaconProvider>();                  var navigationService = baconProvider.GetService<INavigationService>();                    if (CommentRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) :                          new Thing { Kind = "t3"' Data = new Link { Permalink = str' Url = str' Title = str' Name = ""' Author = ""' Selftext = "" } };                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null && targetLinkThing.Data is Link)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = new TypedThing<Link>(targetLinkThing) });                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (CommentsPageRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetLinkByUrl(str) : sourceLink;                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null)                      {                          var typedLinkThing = new TypedThing<Link>(targetLinkThing);                          await baconProvider.GetService<IOfflineService>().StoreHistory(typedLinkThing.Data.Permalink);                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing });                      }                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (ShortCommentsPageRegex.IsMatch(str))                  {                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      var thingId = "t3_" + str.Split(new char[] { '/' }' StringSplitOptions.RemoveEmptyEntries).Last();                      var targetLinkThing = sourceLink == null ? await baconProvider.GetService<IRedditService>().GetThingById(thingId) : sourceLink;                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                      if (targetLinkThing != null)                      {                          var typedLinkThing = new TypedThing<Link>(targetLinkThing);                          await baconProvider.GetService<IOfflineService>().StoreHistory(typedLinkThing.Data.Permalink);                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().CommentsView' new SelectCommentTreeMessage { LinkThing = typedLinkThing });                      }                      else                      {                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                      }                  }                  else if (SubredditRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/r/");                      var subredditName = str.Substring(nameIndex + 3);                        TypedThing<Subreddit> subreddit = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          subreddit = await baconProvider.GetService<IRedditService>().GetSubreddit(subredditName);                      }                      else                      {                          var thing = await offlineService.GetSubreddit(subredditName);                          if (thing != null)                              subreddit = new TypedThing<Subreddit>(thing);                      }                        if (subreddit != null)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit });                      else                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode");                  }                  else if (UserMultiredditRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/u/");                      string subredditName = "";                      if (nameIndex < 0)                      {                          nameIndex = str.LastIndexOf("/user/");                          subredditName = str.Substring(nameIndex);                      }                      else                      {                          subredditName = str.Substring(nameIndex);                      }                        subredditName = subredditName.Replace("/u/"' "/user/");                        TypedThing<Subreddit> subreddit = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          subreddit = await baconProvider.GetService<IRedditService>().GetSubreddit(subredditName);                      }                      else                      {                          var thing = await offlineService.GetSubreddit(subredditName);                          if (thing != null)                              subreddit = new TypedThing<Subreddit>(thing);                      }                        if (subreddit != null)                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().RedditView' new SelectSubredditMessage { Subreddit = subreddit });                      else                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This subreddit is not available in offline mode");                  }                  else if (UserRegex.IsMatch(str))                  {                      var nameIndex = str.LastIndexOf("/u/");                      string userName = "";                      if (nameIndex < 0)                      {                          nameIndex = str.LastIndexOf("/user/");                          userName = str.Substring(nameIndex + 6);                      }                      else                      {                          userName = str.Substring(nameIndex + 3);                      }                        TypedThing<Account> account = null;                        var offlineService = ServiceLocator.Current.GetInstance<IOfflineService>();                      if (settingsService.IsOnline())                      {                          account = await baconProvider.GetService<IRedditService>().GetAccountInfo(userName);                            if (account != null)                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().AboutUserView' new SelectUserAccountMessage { Account = account });                          else                              ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("This account does not exist.");                      }                      else                      {                          ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification("Cannot access user info in offline mode.");                      }                  }                  else                  {                      var smartOfflineService = baconProvider.GetService<ISmartOfflineService>();                      smartOfflineService.NavigatedToOfflineableThing(sourceLink' false);                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true });                      Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = false' TargetUrl = str });                      await baconProvider.GetService<IOfflineService>().StoreHistory(str);                      var imageResults = await baconProvider.GetService<IImagesService>().GetImagesFromUrl(sourceLink == null ? "" : sourceLink.Data.Title' str);                      Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = false });                        if (imageResults != null && imageResults.Count() > 0 && !_longNavWatcher.GetTerminatedClearInFlight(str))                      {                          var imageTuple = new Tuple<string' IEnumerable<Tuple<string' string>>' string>(sourceLink != null ? sourceLink.Data.Title : ""' imageResults' sourceLink != null ? sourceLink.Data.Id : "");                          Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = str });                          navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedPictureView' imageTuple);                      }                      else                      {                          var uri = new Uri(str);                          var targetHost = uri.DnsSafeHost.ToLower();                            Messenger.Default.Send<LongNavigationMessage>(new LongNavigationMessage { Finished = true' TargetUrl = str });                          var videoResults = await baconProvider.GetService<IVideoService>().GetPlayableStreams(str);                          if (videoResults != null)                          {                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedVideoView' videoResults);                          }                          else if (settingsService.ApplyReadabliltyToLinks && LinkGlyphUtility.GetLinkGlyph(str) == LinkGlyphUtility.WebGlyph)                          {                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedReadabilityView' Tuple.Create<string' string>(str' sourceLink != null ? sourceLink.Data.Id : ""));                          }                          else                          {                              //its not an image/video url we can understand so whatever it is just show it in the browser                              navigationService.Navigate(baconProvider.GetService<IDynamicViewLocator>().LinkedWebView' new NavigateToUrlMessage { TargetUrl = str' Title = str });                          }                      }                  }              }              catch (Exception ex)              {                  ServiceLocator.Current.GetInstance<INotificationService>().CreateNotification(string.Format("failed to navigate to {0}' due to {1}"' str' ex.ToString()));              }
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: var result = new byte[LZ4n.LZ4Codec.MaximumOutputLength(bytes.Length) + 4];
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: var length = LZ4n.LZ4Codec.Encode32(bytes' 0' bytes.Length' result' 4' result.Length - 4);
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: var length = LZ4n.LZ4Codec.Encode32(bytes' 0' bytes.Length' result' 4' result.Length - 4);
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: if (length != result.Length)              {                  if (length < 0)                      throw new InvalidOperationException("Compression has been corrupted");                  var buffer = new byte[length + 4];                  Buffer.BlockCopy(result' 4' buffer' 4' length);                  fixed (byte* bytesPtr = buffer)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return buffer;              }              else if ((length + 4) == result.Length)              {                  fixed (byte* bytesPtr = result)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return result;              }              else                  throw new InvalidOperationException("Compression has been corrupted");
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: if (length != result.Length)              {                  if (length < 0)                      throw new InvalidOperationException("Compression has been corrupted");                  var buffer = new byte[length + 4];                  Buffer.BlockCopy(result' 4' buffer' 4' length);                  fixed (byte* bytesPtr = buffer)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return buffer;              }              else if ((length + 4) == result.Length)              {                  fixed (byte* bytesPtr = result)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return result;              }              else                  throw new InvalidOperationException("Compression has been corrupted");
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: if (length != result.Length)              {                  if (length < 0)                      throw new InvalidOperationException("Compression has been corrupted");                  var buffer = new byte[length + 4];                  Buffer.BlockCopy(result' 4' buffer' 4' length);                  fixed (byte* bytesPtr = buffer)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return buffer;              }              else if ((length + 4) == result.Length)              {                  fixed (byte* bytesPtr = result)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return result;              }              else                  throw new InvalidOperationException("Compression has been corrupted");
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Compress,The following statement contains a magic number: if (length != result.Length)              {                  if (length < 0)                      throw new InvalidOperationException("Compression has been corrupted");                  var buffer = new byte[length + 4];                  Buffer.BlockCopy(result' 4' buffer' 4' length);                  fixed (byte* bytesPtr = buffer)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return buffer;              }              else if ((length + 4) == result.Length)              {                  fixed (byte* bytesPtr = result)                  {                      *((int*)bytesPtr) = bytes.Length;                  }                  return result;              }              else                  throw new InvalidOperationException("Compression has been corrupted");
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Decompress,The following statement contains a magic number: if (bytes == null || bytes.Length < 4)                  return new byte[0];
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Decompress,The following statement contains a magic number: return LZ4n.LZ4Codec.Decode32(bytes' 4' bytes.Length - 4' decompressedSize);
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Decompress,The following statement contains a magic number: return LZ4n.LZ4Codec.Decode32(bytes' 4' bytes.Length - 4' decompressedSize);
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Decompress,The following statement contains a magic number: if (bytes == null || bytes.Length < 4)                  return new byte[0];
Magic Number,BaconographyPortable.Model.Compression,CompressionService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\CompressionService.cs,Decompress,The following statement contains a magic number: var skipLen = 4 + startIndex;
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,MaximumOutputLength,The following statement contains a magic number: return inputLength + (inputLength / 255) + 16;
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: while (len >= 8) { *(ulong*)dst = *(ulong*)src; dst += 8; src += 8; len -= 8; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: while (len >= 8) { *(ulong*)dst = *(ulong*)src; dst += 8; src += 8; len -= 8; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: while (len >= 8) { *(ulong*)dst = *(ulong*)src; dst += 8; src += 8; len -= 8; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: while (len >= 8) { *(ulong*)dst = *(ulong*)src; dst += 8; src += 8; len -= 8; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 4) { *(uint*)dst = *(uint*)src; dst += 4; src += 4; len -= 4; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 4) { *(uint*)dst = *(uint*)src; dst += 4; src += 4; len -= 4; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 4) { *(uint*)dst = *(uint*)src; dst += 4; src += 4; len -= 4; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 4) { *(uint*)dst = *(uint*)src; dst += 4; src += 4; len -= 4; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 2) { *(ushort*)dst = *(ushort*)src; dst += 2; src += 2; len -= 2; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 2) { *(ushort*)dst = *(ushort*)src; dst += 2; src += 2; len -= 2; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 2) { *(ushort*)dst = *(ushort*)src; dst += 2; src += 2; len -= 2; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,BlockCopy,The following statement contains a magic number: if (len >= 2) { *(ushort*)dst = *(ushort*)src; dst += 2; src += 2; len -= 2; }
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compressCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				const int src_base = 0;  				byte* src_anchor = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				int len' length;  				uint h' fwd_h;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;    				byte* dst_end_LASTLITERALS_1 = dst_end - LASTLITERALS - 1;  				byte* dst_end_LASTLITERALS_3 = dst_end - LASTLITERALS - 1 - 2;    				if (src_len < MINLENGTH) goto _last_literals;    				hash_table[(*(uint*)src_p * 2654435761u) >> HASH_ADJUST] = src_p - src_base;  				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = src_p - src_base;  					} while (src_ref < src_p - MAX_DISTANCE || *(uint*)src_ref != *(uint*)src_p);    					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;  					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = RUN_MASK << ML_BITS;  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = (*(int*)(src_ref)) ^ (*(int*)(src_p));  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);    					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;    					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH_ADJUST] = src_p - 2 - src_base;    					h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = src_p - src_base;    					if (src_ref > src_p - MAX_DISTANCE - 1 && *(uint*)src_ref == *(uint*)src_p)  					{  						*(token = dst_p++) = 0;  						goto _next_match;  					}    					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p - dst + lastRun + 1 + (lastRun + 255 - RUN_MASK) / 255 > dst_maxlen) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_compress64kCtx_32,The following statement contains a magic number: fixed (int* debruijn32 = &DEBRUIJN_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_anchor = src_p;  				byte* src_base = src_p;  				byte* src_end = src_p + src_len;  				byte* src_mflimit = src_end - MFLIMIT;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;    				byte* src_end_LASTLITERALS = src_end - LASTLITERALS;  				byte* src_end_LASTLITERALS_1 = src_end - LASTLITERALS - 1;  				byte* src_end_LASTLITERALS_STEPSIZE_1 = src_end - LASTLITERALS - STEPSIZE_32 + 1;  				byte* dst_end_LASTLITERALS_1 = dst_end - 1 - LASTLITERALS;  				byte* dst_end_LASTLITERALS_3 = dst_end - 2 - 1 - LASTLITERALS;    				int len' length;  				uint h' fwd_h;    				if (src_len < MINLENGTH) goto _last_literals;    				src_p++; fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;    				while (true)  				{  					int findMatchAttempts = (1 << SKIPSTRENGTH) + 3;  					byte* fwd_p = src_p;  					byte* src_ref;  					byte* token;    					do  					{  						h = fwd_h;  						int step = findMatchAttempts++ >> SKIPSTRENGTH;  						src_p = fwd_p;  						fwd_p = src_p + step;    						if (fwd_p > src_mflimit) goto _last_literals;    						fwd_h = (*(uint*)fwd_p * 2654435761u) >> HASH64K_ADJUST;  						src_ref = src_base + hash_table[h];  						hash_table[h] = (ushort)(src_p - src_base);    					} while (*(uint*)src_ref != *(uint*)src_p);      					while (src_p > src_anchor && src_ref > src && src_p[-1] == src_ref[-1]) { src_p--; src_ref--; }    					length = (int)(src_p - src_anchor);  					token = dst_p++;    					if (dst_p + length + (length >> 8) > dst_end_LASTLITERALS_3) return 0;  					if (length >= RUN_MASK)  					{  						*token = (RUN_MASK << ML_BITS);  						len = length - RUN_MASK;  						for (; len > 254; len -= 255) *dst_p++ = 255;  						*dst_p++ = (byte)len;  					}  					else  					{  						*token = (byte)(length << ML_BITS);  					}    					byte* e = (dst_p) + (length);  					do  					{  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  						*(uint*)dst_p = *(uint*)src_anchor; dst_p += 4; src_anchor += 4;  					} while (dst_p < e);  					dst_p = e;    				_next_match:  					*(ushort*)dst_p = (ushort)(src_p - src_ref); dst_p += 2;    					src_p += MINMATCH; src_ref += MINMATCH;  					src_anchor = src_p;  					while (src_p < src_end_LASTLITERALS_STEPSIZE_1)  					{  						int diff = *(int*)src_ref ^ *(int*)src_p;  						if (diff == 0) { src_p += STEPSIZE_32; src_ref += STEPSIZE_32; continue; }  						src_p += debruijn32[(uint)(diff & -diff) * 0x077CB531u >> 27];  						goto _endCount;  					}  					if (src_p < src_end_LASTLITERALS_1 && *(ushort*)src_ref == *(ushort*)src_p) { src_p += 2; src_ref += 2; }  					if (src_p < src_end_LASTLITERALS && *src_ref == *src_p) src_p++;    				_endCount:  					len = (int)(src_p - src_anchor);  					if (dst_p + (len >> 8) > dst_end_LASTLITERALS_1) return 0;  					if (len >= ML_MASK)  					{  						*token += ML_MASK;  						len -= ML_MASK;  						for (; len > 509; len -= 510) { *dst_p++ = 255; *dst_p++ = 255; }  						if (len > 254) { len -= 255; *dst_p++ = 255; }  						*dst_p++ = (byte)len;  					}  					else  					{  						*token += (byte)len;  					}    					if (src_p > src_mflimit) { src_anchor = src_p; break; }    					hash_table[(*(uint*)(src_p - 2) * 2654435761u) >> HASH64K_ADJUST] = (ushort)(src_p - 2 - src_base);      					h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  					src_ref = src_base + hash_table[h];  					hash_table[h] = (ushort)(src_p - src_base);  					if (*(uint*)src_ref == *(uint*)src_p) { *(token = dst_p++) = 0; goto _next_match; }      					src_anchor = src_p++;  					fwd_h = (*(uint*)src_p * 2654435761u) >> HASH64K_ADJUST;  				}    			_last_literals:  				var lastRun = (int)(src_end - src_anchor);  				if (dst_p + lastRun + 1 + (lastRun - RUN_MASK + 255) / 255 > dst_end) return 0;  				if (lastRun >= RUN_MASK)  				{  					*dst_p++ = (RUN_MASK << ML_BITS);  					lastRun -= RUN_MASK;  					for (; lastRun > 254; lastRun -= 255) *dst_p++ = 255;  					*dst_p++ = (byte)lastRun;  				}  				else  				{  					*dst_p++ = (byte)(lastRun << ML_BITS);  				}  				BlockCopy(src_anchor' dst_p' (int)(src_end - src_anchor));  				dst_p += src_end - src_anchor;    				return (int)(dst_p - dst);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_len;  				byte* dst_cpy;    				byte token;  				int len' length;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;    				while (true)  				{  					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						for (; (len = *src_p++) == 255; length += 255) { }  						length += len;  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy != dst_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						src_p += length;  						break;  					}    					do  					{  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  					} while (dst_p < dst_cpy);  					src_p -= dst_p - dst_cpy;  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						for (; *src_p == 255; length += 255) { src_p++; }  						length += *src_p++;  					}      					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(src_p - src);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,LZ4n,LZ4Codec,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Compression\LZ4Codec.cs,LZ4_uncompress_unknownOutputSize_32,The following statement contains a magic number: fixed (int* dec32table = &DECODER_TABLE_32[0])  			{  				byte* src_p = src;  				byte* src_end = src_p + src_len;  				byte* dst_ref;    				byte* dst_p = dst;  				byte* dst_end = dst_p + dst_maxlen;  				byte* dst_cpy;    				byte* dst_end_COPYLENGTH = dst_end - COPYLENGTH;  				byte* src_end_COPYLENGTH = src_end - COPYLENGTH;    				while (src_p < src_end)  				{  					byte token;  					int len' length;    					token = *src_p++;  					if ((length = (token >> ML_BITS)) == RUN_MASK)  					{  						len = 255;  						while (src_p < src_end && len == 255) { len = *src_p++; length += len; }  					}    					dst_cpy = dst_p + length;  					if (dst_cpy > dst_end_COPYLENGTH || src_p + length > src_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						if (src_p + length != src_end) goto _output_error;  						BlockCopy(src_p' dst_p' length);  						dst_p += length;  						break;  					}  					{  						do  						{  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  							*(uint*)dst_p = *(uint*)src_p; dst_p += 4; src_p += 4;  						} while (dst_p < dst_cpy);  					}  					src_p -= (dst_p - dst_cpy);  					dst_p = dst_cpy;      					dst_ref = dst_cpy - *(ushort*)src_p; src_p += 2;  					if (dst_ref < dst) goto _output_error;    					if ((length = (token & ML_MASK)) == ML_MASK)  					{  						while (src_p < src_end) { len = *src_p++; length += len; if (len != 255) break; }  					}    					if (dst_p - dst_ref < STEPSIZE_32)  					{  						const int dec64 = 0;  						dst_p[0] = dst_ref[0];  						dst_p[1] = dst_ref[1];  						dst_p[2] = dst_ref[2];  						dst_p[3] = dst_ref[3];  						dst_p += 4; dst_ref += 4;  						dst_ref -= dec32table[dst_p - dst_ref];  						*(uint*)dst_p = *(uint*)dst_ref;  						dst_p += STEPSIZE_32 - 4; dst_ref -= dec64;  					}  					else  					{  						*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  					}  					dst_cpy = dst_p + length - (STEPSIZE_32 - 4);  					if (dst_cpy > dst_end_COPYLENGTH)  					{  						if (dst_cpy > dst_end) goto _output_error;  						do  						{  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  							*(uint*)dst_p = *(uint*)dst_ref; dst_p += 4; dst_ref += 4;  						} while (dst_p < dst_end_COPYLENGTH);  						while (dst_p < dst_cpy) *dst_p++ = *dst_ref++;  						dst_p = dst_cpy;  						if (dst_p == dst_end) goto _output_error;  						continue;  					}  					do  					{  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  						*(uint*)(dst_p) = *(uint*)(dst_ref); dst_p += 4; dst_ref += 4;  					} while (dst_p < dst_cpy);  					dst_p = dst_cpy;  				}      				return (int)(dst_p - dst);      			_output_error:  				return (int)-(src_p - src);  			}
Magic Number,BaconographyPortable.Model.KitaroDB.ListingHelpers,PostComments,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\PostComments.cs,GetInitialListing,The following statement contains a magic number: return _offlineService.GetTopLevelComments(_permaLink' 500);
Magic Number,BaconographyPortable.Model.KitaroDB.ListingHelpers,SubredditInfo,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\SubredditInfo.cs,GetInitialListing,The following statement contains a magic number: var orderedThings = await _offlineService.RetrieveOrderedThings("sublist:" + (await _userService.GetUser()).Username' TimeSpan.FromDays(1024));
Magic Number,BaconographyPortable.Model.KitaroDB.ListingHelpers,SubredditInfo,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\SubredditInfo.cs,GetInitialListing,The following statement contains a magic number: var things = await _offlineService.RetrieveOrderedThings("reddits:"' TimeSpan.FromDays(1024));
Magic Number,BaconographyPortable.Model.KitaroDB.ListingHelpers,SubredditSubscriptions,C:\repos\Synergex_Baconography\BaconographyPortable\Model\KitaroDB\ListingHelpers\SubredditSubscriptions.cs,GetInitialListing,The following statement contains a magic number: var orderedThings = await _offlineService.RetrieveOrderedThings("sublist:" + (await _userService.GetUser()).Username' TimeSpan.FromDays(1024));
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,Search,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,Search,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddits,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubreddits,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetPostsByUser,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetPostsByUser,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetPostsBySubreddit,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetPostsBySubreddit,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetCommentsOnPost,The following statement contains a magic number: if (_lastCommentsOnPostRequest != null &&                  (DateTime.Now - _lastCommentsOnPostRequest.Item1).TotalMinutes < 5 &&                  _lastCommentsOnPostRequest.Item2 == subreddit &&                  _lastCommentsOnPostRequest.Item3 == permalink)                  return _lastCommentsOnPostRequest.Item4;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetCommentsOnPost,The following statement contains a magic number: try              {                  var maxLimit = (await UserIsGold()) ? 1500 : 500;                  var guardedLimit = Math.Min(maxLimit' limit ?? maxLimit);                    string targetUri = null;                    if (permalink.Contains("reddit.com"))                  {                      permalink = permalink.Substring(permalink.IndexOf("reddit.com") + "reddit.com".Length);                  }                    if (permalink.Contains(".json?"))                  {                      targetUri = "http://www.reddit.com" + permalink;                  }                  else if (permalink.Contains("?"))                  {                      var queryPos = permalink.IndexOf("?");                      targetUri = string.Format("http://www.reddit.com{0}.json{1}"' permalink.Remove(queryPos)' permalink.Substring(queryPos));                  }                  else                  {                      targetUri = limit == -1 ?                                  string.Format("http://www.reddit.com{0}.json"' permalink) :                                  string.Format("http://www.reddit.com{0}.json?limit={1}"' permalink' limit);                  }                    Listing listing = null;                  var comments = await _simpleHttpService.SendGet(await GetCurrentLoginCookie()' targetUri);                  if (comments.StartsWith("["))                  {                      var listings = JsonConvert.DeserializeObject<Listing[]>(comments);                      listing = new Listing { Data = new ListingData { Children = new List<Thing>() } };                      foreach (var combinableListing in listings)                      {                          listing.Data.Children.AddRange(combinableListing.Data.Children);                          listing.Kind = combinableListing.Kind;                          listing.Data.After = combinableListing.Data.After;                          listing.Data.Before = combinableListing.Data.Before;                      }                  }                  else                      listing = JsonConvert.DeserializeObject<Listing>(comments);                    var result = MaybeFilterForNSFW(listing);                    var requestedLinkInfo = listing.Data.Children.FirstOrDefault(thing => thing.Data is Link);                  if (requestedLinkInfo != null)                  {                      if (!_linkToOpMap.ContainsKey(((Link)requestedLinkInfo.Data).Name))                      {                          _linkToOpMap.Add(((Link)requestedLinkInfo.Data).Name' ((Link)requestedLinkInfo.Data).Author);                      }                  }                    _lastCommentsOnPostRequest = Tuple.Create(DateTime.Now' subreddit' permalink' result);                    return result;              }              catch (Exception ex)              {                  _notificationService.CreateErrorNotification(ex);                  return new Listing { Kind = "Listing"' Data = new ListingData { Children = new List<Thing>() } };              }
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetCommentsOnPost,The following statement contains a magic number: try              {                  var maxLimit = (await UserIsGold()) ? 1500 : 500;                  var guardedLimit = Math.Min(maxLimit' limit ?? maxLimit);                    string targetUri = null;                    if (permalink.Contains("reddit.com"))                  {                      permalink = permalink.Substring(permalink.IndexOf("reddit.com") + "reddit.com".Length);                  }                    if (permalink.Contains(".json?"))                  {                      targetUri = "http://www.reddit.com" + permalink;                  }                  else if (permalink.Contains("?"))                  {                      var queryPos = permalink.IndexOf("?");                      targetUri = string.Format("http://www.reddit.com{0}.json{1}"' permalink.Remove(queryPos)' permalink.Substring(queryPos));                  }                  else                  {                      targetUri = limit == -1 ?                                  string.Format("http://www.reddit.com{0}.json"' permalink) :                                  string.Format("http://www.reddit.com{0}.json?limit={1}"' permalink' limit);                  }                    Listing listing = null;                  var comments = await _simpleHttpService.SendGet(await GetCurrentLoginCookie()' targetUri);                  if (comments.StartsWith("["))                  {                      var listings = JsonConvert.DeserializeObject<Listing[]>(comments);                      listing = new Listing { Data = new ListingData { Children = new List<Thing>() } };                      foreach (var combinableListing in listings)                      {                          listing.Data.Children.AddRange(combinableListing.Data.Children);                          listing.Kind = combinableListing.Kind;                          listing.Data.After = combinableListing.Data.After;                          listing.Data.Before = combinableListing.Data.Before;                      }                  }                  else                      listing = JsonConvert.DeserializeObject<Listing>(comments);                    var result = MaybeFilterForNSFW(listing);                    var requestedLinkInfo = listing.Data.Children.FirstOrDefault(thing => thing.Data is Link);                  if (requestedLinkInfo != null)                  {                      if (!_linkToOpMap.ContainsKey(((Link)requestedLinkInfo.Data).Name))                      {                          _linkToOpMap.Add(((Link)requestedLinkInfo.Data).Name' ((Link)requestedLinkInfo.Data).Author);                      }                  }                    _lastCommentsOnPostRequest = Tuple.Create(DateTime.Now' subreddit' permalink' result);                    return result;              }              catch (Exception ex)              {                  _notificationService.CreateErrorNotification(ex);                  return new Listing { Kind = "Listing"' Data = new ListingData { Children = new List<Thing>() } };              }
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetMessages,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetMessages,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetAdditionalFromListing,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 500;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetAdditionalFromListing,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 500;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,MaybeInjectAdvertisements,The following statement contains a magic number: for (int i = 9; i < count; i += 10)  			{  				var thing = new Thing { Data = new Advertisement()' Kind = "ad" };  				source.Data.Children.Insert(i' thing);  			}
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,MaybeInjectAdvertisements,The following statement contains a magic number: for (int i = 9; i < count; i += 10)  			{  				var thing = new Thing { Data = new Advertisement()' Kind = "ad" };  				source.Data.Children.Insert(i' thing);  			}
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubscribedSubredditListing,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,RedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\RedditService.cs,GetSubscribedSubredditListing,The following statement contains a magic number: var maxLimit = (await UserIsGold()) ? 1500 : 100;
Magic Number,BaconographyPortable.Model.Reddit,ThingUtility,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ThingUtility.cs,GetFrontPageThing,The following statement contains a magic number: frontPage.Data = new Subreddit              {                  DisplayName = "front page"'                  Url = "/"'                  Name = "/"'                  Id = "/"'                  Subscribers = 5678123'                  HeaderImage = "/Assets/reddit.png"'                  PublicDescription = "The front page of this device."              };
Magic Number,BaconographyPortable.Model.Reddit.ListingHelpers,UserMessages,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\UserMessages.cs,GetInitialListing,The following statement contains a magic number: return _redditService.GetMessages(100);
Magic Number,BaconographyPortable.Model.Reddit.ListingHelpers,UserMessages,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\UserMessages.cs,Refresh,The following statement contains a magic number: return _redditService.GetMessages(100);
Magic Number,BaconographyPortable.Model.Reddit.ListingHelpers,SearchResults,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\SearchResults.cs,GetInitialListing,The following statement contains a magic number: if (string.IsNullOrWhiteSpace(_query))                  return new Listing { Data = new ListingData { Children = new List<Thing>() }' Kind = "Listing" };              else                  return await _redditService.Search(_query' 20' _reddits' _restrictedToSubreddit);
Magic Number,BaconographyPortable.Model.Reddit.ListingHelpers,SearchResults,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\SearchResults.cs,Refresh,The following statement contains a magic number: if (string.IsNullOrWhiteSpace(_query))                  return new Listing { Data = new ListingData { Children = new List<Thing>() }' Kind = "Listing" };              else                  return await _redditService.Search(_query' 20' _reddits' _restrictedToSubreddit);
Magic Number,BaconographyPortable.Model.Reddit.ListingHelpers,SubredditLinks,C:\repos\Synergex_Baconography\BaconographyPortable\Model\Reddit\ListingHelpers\SubredditLinks.cs,GetCachedListing,The following statement contains a magic number: var things = await _offlineService.RetrieveOrderedThings("links:" + _subreddit' TimeSpan.FromDays(14));
Magic Number,BaconographyPortable.Services.Impl,OOMService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\OOMService.cs,TryToCleanup,The following statement contains a magic number: if (forceGC)              {                  for (int i = 0; i < 5; i++)                  {                      GC.Collect(GC.MaxGeneration' GCCollectionMode.Forced' true);                      GC.WaitForPendingFinalizers();                  }              }
Magic Number,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The following statement contains a magic number: try              {                  var offlineService = _baconProvider.GetService<IOfflineService>();                    var allowOver18String = await offlineService.GetSetting("AllowOver18");                  if (!string.IsNullOrWhiteSpace(allowOver18String))                      AllowOver18 = bool.Parse(allowOver18String);                  else                      AllowOver18 = false;                    var maxTopLevelOfflineCommentsString = await offlineService.GetSetting("MaxTopLevelOfflineComments");                  if (!string.IsNullOrWhiteSpace(maxTopLevelOfflineCommentsString))                      MaxTopLevelOfflineComments = int.Parse(maxTopLevelOfflineCommentsString);                  else                      MaxTopLevelOfflineComments = 50;                    var offlineOnlyGetsFirstSetString = await offlineService.GetSetting("OfflineOnlyGetsFirstSet");                  if (!string.IsNullOrWhiteSpace(offlineOnlyGetsFirstSetString))                      OfflineOnlyGetsFirstSet = bool.Parse(offlineOnlyGetsFirstSetString);                  else                      OfflineOnlyGetsFirstSet = true;                    var openLinksInBrowserString = await offlineService.GetSetting("OpenLinksInBrowser");                  if (!string.IsNullOrWhiteSpace(openLinksInBrowserString))                      OpenLinksInBrowser = bool.Parse(openLinksInBrowserString);                  else                      OpenLinksInBrowser = false;                    var highlightAlreadyClickedLinksString = await offlineService.GetSetting("HighlightAlreadyClickedLinks");                  if (!string.IsNullOrWhiteSpace(highlightAlreadyClickedLinksString))                      HighlightAlreadyClickedLinks = bool.Parse(highlightAlreadyClickedLinksString);                  else                      HighlightAlreadyClickedLinks = true;                    var applyReadabliltyToLinksString = await offlineService.GetSetting("ApplyReadabliltyToLinks");                  if (!string.IsNullOrWhiteSpace(applyReadabliltyToLinksString))                      ApplyReadabliltyToLinks = bool.Parse(applyReadabliltyToLinksString);                  else                      ApplyReadabliltyToLinks = false;                    var preferImageLinksForTiles = await offlineService.GetSetting("PreferImageLinksForTiles");                  if (!string.IsNullOrWhiteSpace(preferImageLinksForTiles))                      PreferImageLinksForTiles = bool.Parse(preferImageLinksForTiles);                  else                      PreferImageLinksForTiles = true;                    var defaultOfflineLinkCount = await offlineService.GetSetting("DefaultOfflineLinkCount");                  if (!string.IsNullOrWhiteSpace(defaultOfflineLinkCount))                      DefaultOfflineLinkCount = int.Parse(defaultOfflineLinkCount);                  else                      DefaultOfflineLinkCount = 25;                    var leftHandedMode = await offlineService.GetSetting("LeftHandedMode");                  if (!string.IsNullOrWhiteSpace(leftHandedMode))                      LeftHandedMode = bool.Parse(leftHandedMode);                  else                      LeftHandedMode = false;                    var orientationLock = await offlineService.GetSetting("OrientationLock");                  if (!string.IsNullOrWhiteSpace(orientationLock))                      OrientationLock = bool.Parse(orientationLock);                  else                      OrientationLock = false;                    var orientation = await offlineService.GetSetting("Orientation");                  if (!string.IsNullOrWhiteSpace(orientation))                      Orientation = orientation;                  else                      Orientation = "";                    var predicitveOfflining = await offlineService.GetSetting("AllowPredictiveOfflining");                  if (!string.IsNullOrWhiteSpace(predicitveOfflining))                      AllowPredictiveOfflining = bool.Parse(predicitveOfflining);                  else                      AllowPredictiveOfflining = false;                    PromptForCaptcha = true;                  var over18Items = await offlineService.GetSetting("AllowOver18Items");                  if (!string.IsNullOrWhiteSpace(over18Items))                      AllowOver18Items = bool.Parse(over18Items);                  else                      AllowOver18Items = false;                    var predictiveOffliningOnMeteredConnection = await offlineService.GetSetting("AllowPredictiveOffliningOnMeteredConnection");                  if (!string.IsNullOrWhiteSpace(predictiveOffliningOnMeteredConnection))                      AllowPredictiveOffliningOnMeteredConnection = bool.Parse(predictiveOffliningOnMeteredConnection);                  else                      AllowPredictiveOffliningOnMeteredConnection = false;                    var overlayOpacity = await offlineService.GetSetting("OverlayOpacity");                  if (!string.IsNullOrWhiteSpace(overlayOpacity))                      OverlayOpacity = int.Parse(overlayOpacity);                  else                      OverlayOpacity = 40;                    var highresLockScreenOnly = await offlineService.GetSetting("HighresLockScreenOnly");                  if (!string.IsNullOrWhiteSpace(highresLockScreenOnly))                      HighresLockScreenOnly = bool.Parse(highresLockScreenOnly);                  else                      HighresLockScreenOnly = false;                    var messagesInLockScreenOverlay = await offlineService.GetSetting("MessagesInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(messagesInLockScreenOverlay))                      MessagesInLockScreenOverlay = bool.Parse(messagesInLockScreenOverlay);                  else                      MessagesInLockScreenOverlay = true;                    var enableUpdates = await offlineService.GetSetting("EnableUpdates");                  if (!string.IsNullOrWhiteSpace(enableUpdates))                      EnableUpdates = bool.Parse(enableUpdates);                  else                      EnableUpdates = true;                    var postsInLockScreenOverlay = await offlineService.GetSetting("PostsInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(postsInLockScreenOverlay))                      PostsInLockScreenOverlay = bool.Parse(postsInLockScreenOverlay);                  else                      PostsInLockScreenOverlay = true;                    var imagesSubreddit = await offlineService.GetSetting("ImagesSubreddit");                  if (!string.IsNullOrWhiteSpace(imagesSubreddit))                      ImagesSubreddit = imagesSubreddit;                  else                      ImagesSubreddit = "/r/earthporn+InfrastructurePorn+MachinePorn";                    var lockScreenReddit = await offlineService.GetSetting("LockScreenReddit");                  if (!string.IsNullOrWhiteSpace(lockScreenReddit))                      LockScreenReddit = lockScreenReddit;                  else                      LockScreenReddit = "/";                    var liveTileReddit = await offlineService.GetSetting("LiveTileReddit");                  if (!string.IsNullOrWhiteSpace(liveTileReddit))                      LiveTileReddit = liveTileReddit;                  else                      LiveTileReddit = "/";                    var overlayItemCount = await offlineService.GetSetting("OverlayItemCount");                  if (!string.IsNullOrWhiteSpace(overlayItemCount))                      OverlayItemCount = int.Parse(overlayItemCount);                  else                      OverlayItemCount = 5;                    var offlineCacheDays = await offlineService.GetSetting("OfflineCacheDays");                  if (!string.IsNullOrWhiteSpace(offlineCacheDays))                      OfflineCacheDays = int.Parse(offlineCacheDays);                  else                      OfflineCacheDays = 2;                    var enableOvernightUpdates = await offlineService.GetSetting("EnableOvernightUpdates");                  if (!string.IsNullOrWhiteSpace(enableOvernightUpdates))                      EnableOvernightUpdates = bool.Parse(enableOvernightUpdates);                  else                      EnableOvernightUpdates = true;                    var updateOverlayOnlyOnWifi = await offlineService.GetSetting("UpdateOverlayOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateOverlayOnlyOnWifi))                      UpdateOverlayOnlyOnWifi = bool.Parse(updateOverlayOnlyOnWifi);                  else                      UpdateOverlayOnlyOnWifi = false;                    var updateImagesOnlyOnWifi = await offlineService.GetSetting("UpdateImagesOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateImagesOnlyOnWifi))                      UpdateImagesOnlyOnWifi = bool.Parse(updateImagesOnlyOnWifi);                  else                      UpdateImagesOnlyOnWifi = true;                    var allowAdvertising = await offlineService.GetSetting("AllowAdvertising");                  if (!string.IsNullOrWhiteSpace(allowAdvertising))                      AllowAdvertising = bool.Parse(allowAdvertising);                  else                      AllowAdvertising = true;                    var lastUpdatedImages = await offlineService.GetSetting("LastUpdatedImages");                  if (!string.IsNullOrWhiteSpace(lastUpdatedImages))                      LastUpdatedImages = DateTime.Parse(lastUpdatedImages);                  else                      LastUpdatedImages = new DateTime();                    var lastCleanedCache = await offlineService.GetSetting("LastCleanedCache");                  if (!string.IsNullOrWhiteSpace(lastCleanedCache))                      LastCleanedCache = DateTime.Parse(lastCleanedCache);                  else                      LastCleanedCache = new DateTime();                    var tapForComments = await offlineService.GetSetting("TapForComments");                  if (!string.IsNullOrWhiteSpace(tapForComments))                      TapForComments = bool.Parse(tapForComments);                  else                      TapForComments = false;                    var useImagePickerForLockScreen = await offlineService.GetSetting("UseImagePickerForLockScreen");                  if (!string.IsNullOrWhiteSpace(useImagePickerForLockScreen))                      UseImagePickerForLockScreen = bool.Parse(useImagePickerForLockScreen);                  else                      UseImagePickerForLockScreen = false;                    var roundedLockScreen = await offlineService.GetSetting("RoundedLockScreen");                  if (!string.IsNullOrWhiteSpace(roundedLockScreen))                      RoundedLockScreen = bool.Parse(roundedLockScreen);                  else                      RoundedLockScreen = false;                    var multiColoredCommentMargins = await offlineService.GetSetting("MultiColorCommentMargins");                  if (!string.IsNullOrWhiteSpace(multiColoredCommentMargins))                      MultiColorCommentMargins = bool.Parse(multiColoredCommentMargins);                  else                      MultiColorCommentMargins = false;                    var invertSystemTheme = await offlineService.GetSetting("InvertSystemTheme");                  if (!string.IsNullOrWhiteSpace(invertSystemTheme))                      InvertSystemTheme = bool.Parse(invertSystemTheme);                  else                      InvertSystemTheme = false;                                    var onlyFlipViewUnread = await offlineService.GetSetting("OnlyFlipViewUnread");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewUnread))                      OnlyFlipViewUnread = bool.Parse(onlyFlipViewUnread);                  else                      OnlyFlipViewUnread = false;                    var onlyFlipViewImages = await offlineService.GetSetting("OnlyFlipViewImages2");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewImages))                      OnlyFlipViewImages = bool.Parse(onlyFlipViewImages);                  else                      OnlyFlipViewImages = true;                    Messenger.Default.Send<SettingsChangedMessage>(new SettingsChangedMessage { InitialLoad = true });              }              catch              {                  //not interested in failure here              }
Magic Number,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The following statement contains a magic number: try              {                  var offlineService = _baconProvider.GetService<IOfflineService>();                    var allowOver18String = await offlineService.GetSetting("AllowOver18");                  if (!string.IsNullOrWhiteSpace(allowOver18String))                      AllowOver18 = bool.Parse(allowOver18String);                  else                      AllowOver18 = false;                    var maxTopLevelOfflineCommentsString = await offlineService.GetSetting("MaxTopLevelOfflineComments");                  if (!string.IsNullOrWhiteSpace(maxTopLevelOfflineCommentsString))                      MaxTopLevelOfflineComments = int.Parse(maxTopLevelOfflineCommentsString);                  else                      MaxTopLevelOfflineComments = 50;                    var offlineOnlyGetsFirstSetString = await offlineService.GetSetting("OfflineOnlyGetsFirstSet");                  if (!string.IsNullOrWhiteSpace(offlineOnlyGetsFirstSetString))                      OfflineOnlyGetsFirstSet = bool.Parse(offlineOnlyGetsFirstSetString);                  else                      OfflineOnlyGetsFirstSet = true;                    var openLinksInBrowserString = await offlineService.GetSetting("OpenLinksInBrowser");                  if (!string.IsNullOrWhiteSpace(openLinksInBrowserString))                      OpenLinksInBrowser = bool.Parse(openLinksInBrowserString);                  else                      OpenLinksInBrowser = false;                    var highlightAlreadyClickedLinksString = await offlineService.GetSetting("HighlightAlreadyClickedLinks");                  if (!string.IsNullOrWhiteSpace(highlightAlreadyClickedLinksString))                      HighlightAlreadyClickedLinks = bool.Parse(highlightAlreadyClickedLinksString);                  else                      HighlightAlreadyClickedLinks = true;                    var applyReadabliltyToLinksString = await offlineService.GetSetting("ApplyReadabliltyToLinks");                  if (!string.IsNullOrWhiteSpace(applyReadabliltyToLinksString))                      ApplyReadabliltyToLinks = bool.Parse(applyReadabliltyToLinksString);                  else                      ApplyReadabliltyToLinks = false;                    var preferImageLinksForTiles = await offlineService.GetSetting("PreferImageLinksForTiles");                  if (!string.IsNullOrWhiteSpace(preferImageLinksForTiles))                      PreferImageLinksForTiles = bool.Parse(preferImageLinksForTiles);                  else                      PreferImageLinksForTiles = true;                    var defaultOfflineLinkCount = await offlineService.GetSetting("DefaultOfflineLinkCount");                  if (!string.IsNullOrWhiteSpace(defaultOfflineLinkCount))                      DefaultOfflineLinkCount = int.Parse(defaultOfflineLinkCount);                  else                      DefaultOfflineLinkCount = 25;                    var leftHandedMode = await offlineService.GetSetting("LeftHandedMode");                  if (!string.IsNullOrWhiteSpace(leftHandedMode))                      LeftHandedMode = bool.Parse(leftHandedMode);                  else                      LeftHandedMode = false;                    var orientationLock = await offlineService.GetSetting("OrientationLock");                  if (!string.IsNullOrWhiteSpace(orientationLock))                      OrientationLock = bool.Parse(orientationLock);                  else                      OrientationLock = false;                    var orientation = await offlineService.GetSetting("Orientation");                  if (!string.IsNullOrWhiteSpace(orientation))                      Orientation = orientation;                  else                      Orientation = "";                    var predicitveOfflining = await offlineService.GetSetting("AllowPredictiveOfflining");                  if (!string.IsNullOrWhiteSpace(predicitveOfflining))                      AllowPredictiveOfflining = bool.Parse(predicitveOfflining);                  else                      AllowPredictiveOfflining = false;                    PromptForCaptcha = true;                  var over18Items = await offlineService.GetSetting("AllowOver18Items");                  if (!string.IsNullOrWhiteSpace(over18Items))                      AllowOver18Items = bool.Parse(over18Items);                  else                      AllowOver18Items = false;                    var predictiveOffliningOnMeteredConnection = await offlineService.GetSetting("AllowPredictiveOffliningOnMeteredConnection");                  if (!string.IsNullOrWhiteSpace(predictiveOffliningOnMeteredConnection))                      AllowPredictiveOffliningOnMeteredConnection = bool.Parse(predictiveOffliningOnMeteredConnection);                  else                      AllowPredictiveOffliningOnMeteredConnection = false;                    var overlayOpacity = await offlineService.GetSetting("OverlayOpacity");                  if (!string.IsNullOrWhiteSpace(overlayOpacity))                      OverlayOpacity = int.Parse(overlayOpacity);                  else                      OverlayOpacity = 40;                    var highresLockScreenOnly = await offlineService.GetSetting("HighresLockScreenOnly");                  if (!string.IsNullOrWhiteSpace(highresLockScreenOnly))                      HighresLockScreenOnly = bool.Parse(highresLockScreenOnly);                  else                      HighresLockScreenOnly = false;                    var messagesInLockScreenOverlay = await offlineService.GetSetting("MessagesInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(messagesInLockScreenOverlay))                      MessagesInLockScreenOverlay = bool.Parse(messagesInLockScreenOverlay);                  else                      MessagesInLockScreenOverlay = true;                    var enableUpdates = await offlineService.GetSetting("EnableUpdates");                  if (!string.IsNullOrWhiteSpace(enableUpdates))                      EnableUpdates = bool.Parse(enableUpdates);                  else                      EnableUpdates = true;                    var postsInLockScreenOverlay = await offlineService.GetSetting("PostsInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(postsInLockScreenOverlay))                      PostsInLockScreenOverlay = bool.Parse(postsInLockScreenOverlay);                  else                      PostsInLockScreenOverlay = true;                    var imagesSubreddit = await offlineService.GetSetting("ImagesSubreddit");                  if (!string.IsNullOrWhiteSpace(imagesSubreddit))                      ImagesSubreddit = imagesSubreddit;                  else                      ImagesSubreddit = "/r/earthporn+InfrastructurePorn+MachinePorn";                    var lockScreenReddit = await offlineService.GetSetting("LockScreenReddit");                  if (!string.IsNullOrWhiteSpace(lockScreenReddit))                      LockScreenReddit = lockScreenReddit;                  else                      LockScreenReddit = "/";                    var liveTileReddit = await offlineService.GetSetting("LiveTileReddit");                  if (!string.IsNullOrWhiteSpace(liveTileReddit))                      LiveTileReddit = liveTileReddit;                  else                      LiveTileReddit = "/";                    var overlayItemCount = await offlineService.GetSetting("OverlayItemCount");                  if (!string.IsNullOrWhiteSpace(overlayItemCount))                      OverlayItemCount = int.Parse(overlayItemCount);                  else                      OverlayItemCount = 5;                    var offlineCacheDays = await offlineService.GetSetting("OfflineCacheDays");                  if (!string.IsNullOrWhiteSpace(offlineCacheDays))                      OfflineCacheDays = int.Parse(offlineCacheDays);                  else                      OfflineCacheDays = 2;                    var enableOvernightUpdates = await offlineService.GetSetting("EnableOvernightUpdates");                  if (!string.IsNullOrWhiteSpace(enableOvernightUpdates))                      EnableOvernightUpdates = bool.Parse(enableOvernightUpdates);                  else                      EnableOvernightUpdates = true;                    var updateOverlayOnlyOnWifi = await offlineService.GetSetting("UpdateOverlayOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateOverlayOnlyOnWifi))                      UpdateOverlayOnlyOnWifi = bool.Parse(updateOverlayOnlyOnWifi);                  else                      UpdateOverlayOnlyOnWifi = false;                    var updateImagesOnlyOnWifi = await offlineService.GetSetting("UpdateImagesOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateImagesOnlyOnWifi))                      UpdateImagesOnlyOnWifi = bool.Parse(updateImagesOnlyOnWifi);                  else                      UpdateImagesOnlyOnWifi = true;                    var allowAdvertising = await offlineService.GetSetting("AllowAdvertising");                  if (!string.IsNullOrWhiteSpace(allowAdvertising))                      AllowAdvertising = bool.Parse(allowAdvertising);                  else                      AllowAdvertising = true;                    var lastUpdatedImages = await offlineService.GetSetting("LastUpdatedImages");                  if (!string.IsNullOrWhiteSpace(lastUpdatedImages))                      LastUpdatedImages = DateTime.Parse(lastUpdatedImages);                  else                      LastUpdatedImages = new DateTime();                    var lastCleanedCache = await offlineService.GetSetting("LastCleanedCache");                  if (!string.IsNullOrWhiteSpace(lastCleanedCache))                      LastCleanedCache = DateTime.Parse(lastCleanedCache);                  else                      LastCleanedCache = new DateTime();                    var tapForComments = await offlineService.GetSetting("TapForComments");                  if (!string.IsNullOrWhiteSpace(tapForComments))                      TapForComments = bool.Parse(tapForComments);                  else                      TapForComments = false;                    var useImagePickerForLockScreen = await offlineService.GetSetting("UseImagePickerForLockScreen");                  if (!string.IsNullOrWhiteSpace(useImagePickerForLockScreen))                      UseImagePickerForLockScreen = bool.Parse(useImagePickerForLockScreen);                  else                      UseImagePickerForLockScreen = false;                    var roundedLockScreen = await offlineService.GetSetting("RoundedLockScreen");                  if (!string.IsNullOrWhiteSpace(roundedLockScreen))                      RoundedLockScreen = bool.Parse(roundedLockScreen);                  else                      RoundedLockScreen = false;                    var multiColoredCommentMargins = await offlineService.GetSetting("MultiColorCommentMargins");                  if (!string.IsNullOrWhiteSpace(multiColoredCommentMargins))                      MultiColorCommentMargins = bool.Parse(multiColoredCommentMargins);                  else                      MultiColorCommentMargins = false;                    var invertSystemTheme = await offlineService.GetSetting("InvertSystemTheme");                  if (!string.IsNullOrWhiteSpace(invertSystemTheme))                      InvertSystemTheme = bool.Parse(invertSystemTheme);                  else                      InvertSystemTheme = false;                                    var onlyFlipViewUnread = await offlineService.GetSetting("OnlyFlipViewUnread");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewUnread))                      OnlyFlipViewUnread = bool.Parse(onlyFlipViewUnread);                  else                      OnlyFlipViewUnread = false;                    var onlyFlipViewImages = await offlineService.GetSetting("OnlyFlipViewImages2");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewImages))                      OnlyFlipViewImages = bool.Parse(onlyFlipViewImages);                  else                      OnlyFlipViewImages = true;                    Messenger.Default.Send<SettingsChangedMessage>(new SettingsChangedMessage { InitialLoad = true });              }              catch              {                  //not interested in failure here              }
Magic Number,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The following statement contains a magic number: try              {                  var offlineService = _baconProvider.GetService<IOfflineService>();                    var allowOver18String = await offlineService.GetSetting("AllowOver18");                  if (!string.IsNullOrWhiteSpace(allowOver18String))                      AllowOver18 = bool.Parse(allowOver18String);                  else                      AllowOver18 = false;                    var maxTopLevelOfflineCommentsString = await offlineService.GetSetting("MaxTopLevelOfflineComments");                  if (!string.IsNullOrWhiteSpace(maxTopLevelOfflineCommentsString))                      MaxTopLevelOfflineComments = int.Parse(maxTopLevelOfflineCommentsString);                  else                      MaxTopLevelOfflineComments = 50;                    var offlineOnlyGetsFirstSetString = await offlineService.GetSetting("OfflineOnlyGetsFirstSet");                  if (!string.IsNullOrWhiteSpace(offlineOnlyGetsFirstSetString))                      OfflineOnlyGetsFirstSet = bool.Parse(offlineOnlyGetsFirstSetString);                  else                      OfflineOnlyGetsFirstSet = true;                    var openLinksInBrowserString = await offlineService.GetSetting("OpenLinksInBrowser");                  if (!string.IsNullOrWhiteSpace(openLinksInBrowserString))                      OpenLinksInBrowser = bool.Parse(openLinksInBrowserString);                  else                      OpenLinksInBrowser = false;                    var highlightAlreadyClickedLinksString = await offlineService.GetSetting("HighlightAlreadyClickedLinks");                  if (!string.IsNullOrWhiteSpace(highlightAlreadyClickedLinksString))                      HighlightAlreadyClickedLinks = bool.Parse(highlightAlreadyClickedLinksString);                  else                      HighlightAlreadyClickedLinks = true;                    var applyReadabliltyToLinksString = await offlineService.GetSetting("ApplyReadabliltyToLinks");                  if (!string.IsNullOrWhiteSpace(applyReadabliltyToLinksString))                      ApplyReadabliltyToLinks = bool.Parse(applyReadabliltyToLinksString);                  else                      ApplyReadabliltyToLinks = false;                    var preferImageLinksForTiles = await offlineService.GetSetting("PreferImageLinksForTiles");                  if (!string.IsNullOrWhiteSpace(preferImageLinksForTiles))                      PreferImageLinksForTiles = bool.Parse(preferImageLinksForTiles);                  else                      PreferImageLinksForTiles = true;                    var defaultOfflineLinkCount = await offlineService.GetSetting("DefaultOfflineLinkCount");                  if (!string.IsNullOrWhiteSpace(defaultOfflineLinkCount))                      DefaultOfflineLinkCount = int.Parse(defaultOfflineLinkCount);                  else                      DefaultOfflineLinkCount = 25;                    var leftHandedMode = await offlineService.GetSetting("LeftHandedMode");                  if (!string.IsNullOrWhiteSpace(leftHandedMode))                      LeftHandedMode = bool.Parse(leftHandedMode);                  else                      LeftHandedMode = false;                    var orientationLock = await offlineService.GetSetting("OrientationLock");                  if (!string.IsNullOrWhiteSpace(orientationLock))                      OrientationLock = bool.Parse(orientationLock);                  else                      OrientationLock = false;                    var orientation = await offlineService.GetSetting("Orientation");                  if (!string.IsNullOrWhiteSpace(orientation))                      Orientation = orientation;                  else                      Orientation = "";                    var predicitveOfflining = await offlineService.GetSetting("AllowPredictiveOfflining");                  if (!string.IsNullOrWhiteSpace(predicitveOfflining))                      AllowPredictiveOfflining = bool.Parse(predicitveOfflining);                  else                      AllowPredictiveOfflining = false;                    PromptForCaptcha = true;                  var over18Items = await offlineService.GetSetting("AllowOver18Items");                  if (!string.IsNullOrWhiteSpace(over18Items))                      AllowOver18Items = bool.Parse(over18Items);                  else                      AllowOver18Items = false;                    var predictiveOffliningOnMeteredConnection = await offlineService.GetSetting("AllowPredictiveOffliningOnMeteredConnection");                  if (!string.IsNullOrWhiteSpace(predictiveOffliningOnMeteredConnection))                      AllowPredictiveOffliningOnMeteredConnection = bool.Parse(predictiveOffliningOnMeteredConnection);                  else                      AllowPredictiveOffliningOnMeteredConnection = false;                    var overlayOpacity = await offlineService.GetSetting("OverlayOpacity");                  if (!string.IsNullOrWhiteSpace(overlayOpacity))                      OverlayOpacity = int.Parse(overlayOpacity);                  else                      OverlayOpacity = 40;                    var highresLockScreenOnly = await offlineService.GetSetting("HighresLockScreenOnly");                  if (!string.IsNullOrWhiteSpace(highresLockScreenOnly))                      HighresLockScreenOnly = bool.Parse(highresLockScreenOnly);                  else                      HighresLockScreenOnly = false;                    var messagesInLockScreenOverlay = await offlineService.GetSetting("MessagesInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(messagesInLockScreenOverlay))                      MessagesInLockScreenOverlay = bool.Parse(messagesInLockScreenOverlay);                  else                      MessagesInLockScreenOverlay = true;                    var enableUpdates = await offlineService.GetSetting("EnableUpdates");                  if (!string.IsNullOrWhiteSpace(enableUpdates))                      EnableUpdates = bool.Parse(enableUpdates);                  else                      EnableUpdates = true;                    var postsInLockScreenOverlay = await offlineService.GetSetting("PostsInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(postsInLockScreenOverlay))                      PostsInLockScreenOverlay = bool.Parse(postsInLockScreenOverlay);                  else                      PostsInLockScreenOverlay = true;                    var imagesSubreddit = await offlineService.GetSetting("ImagesSubreddit");                  if (!string.IsNullOrWhiteSpace(imagesSubreddit))                      ImagesSubreddit = imagesSubreddit;                  else                      ImagesSubreddit = "/r/earthporn+InfrastructurePorn+MachinePorn";                    var lockScreenReddit = await offlineService.GetSetting("LockScreenReddit");                  if (!string.IsNullOrWhiteSpace(lockScreenReddit))                      LockScreenReddit = lockScreenReddit;                  else                      LockScreenReddit = "/";                    var liveTileReddit = await offlineService.GetSetting("LiveTileReddit");                  if (!string.IsNullOrWhiteSpace(liveTileReddit))                      LiveTileReddit = liveTileReddit;                  else                      LiveTileReddit = "/";                    var overlayItemCount = await offlineService.GetSetting("OverlayItemCount");                  if (!string.IsNullOrWhiteSpace(overlayItemCount))                      OverlayItemCount = int.Parse(overlayItemCount);                  else                      OverlayItemCount = 5;                    var offlineCacheDays = await offlineService.GetSetting("OfflineCacheDays");                  if (!string.IsNullOrWhiteSpace(offlineCacheDays))                      OfflineCacheDays = int.Parse(offlineCacheDays);                  else                      OfflineCacheDays = 2;                    var enableOvernightUpdates = await offlineService.GetSetting("EnableOvernightUpdates");                  if (!string.IsNullOrWhiteSpace(enableOvernightUpdates))                      EnableOvernightUpdates = bool.Parse(enableOvernightUpdates);                  else                      EnableOvernightUpdates = true;                    var updateOverlayOnlyOnWifi = await offlineService.GetSetting("UpdateOverlayOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateOverlayOnlyOnWifi))                      UpdateOverlayOnlyOnWifi = bool.Parse(updateOverlayOnlyOnWifi);                  else                      UpdateOverlayOnlyOnWifi = false;                    var updateImagesOnlyOnWifi = await offlineService.GetSetting("UpdateImagesOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateImagesOnlyOnWifi))                      UpdateImagesOnlyOnWifi = bool.Parse(updateImagesOnlyOnWifi);                  else                      UpdateImagesOnlyOnWifi = true;                    var allowAdvertising = await offlineService.GetSetting("AllowAdvertising");                  if (!string.IsNullOrWhiteSpace(allowAdvertising))                      AllowAdvertising = bool.Parse(allowAdvertising);                  else                      AllowAdvertising = true;                    var lastUpdatedImages = await offlineService.GetSetting("LastUpdatedImages");                  if (!string.IsNullOrWhiteSpace(lastUpdatedImages))                      LastUpdatedImages = DateTime.Parse(lastUpdatedImages);                  else                      LastUpdatedImages = new DateTime();                    var lastCleanedCache = await offlineService.GetSetting("LastCleanedCache");                  if (!string.IsNullOrWhiteSpace(lastCleanedCache))                      LastCleanedCache = DateTime.Parse(lastCleanedCache);                  else                      LastCleanedCache = new DateTime();                    var tapForComments = await offlineService.GetSetting("TapForComments");                  if (!string.IsNullOrWhiteSpace(tapForComments))                      TapForComments = bool.Parse(tapForComments);                  else                      TapForComments = false;                    var useImagePickerForLockScreen = await offlineService.GetSetting("UseImagePickerForLockScreen");                  if (!string.IsNullOrWhiteSpace(useImagePickerForLockScreen))                      UseImagePickerForLockScreen = bool.Parse(useImagePickerForLockScreen);                  else                      UseImagePickerForLockScreen = false;                    var roundedLockScreen = await offlineService.GetSetting("RoundedLockScreen");                  if (!string.IsNullOrWhiteSpace(roundedLockScreen))                      RoundedLockScreen = bool.Parse(roundedLockScreen);                  else                      RoundedLockScreen = false;                    var multiColoredCommentMargins = await offlineService.GetSetting("MultiColorCommentMargins");                  if (!string.IsNullOrWhiteSpace(multiColoredCommentMargins))                      MultiColorCommentMargins = bool.Parse(multiColoredCommentMargins);                  else                      MultiColorCommentMargins = false;                    var invertSystemTheme = await offlineService.GetSetting("InvertSystemTheme");                  if (!string.IsNullOrWhiteSpace(invertSystemTheme))                      InvertSystemTheme = bool.Parse(invertSystemTheme);                  else                      InvertSystemTheme = false;                                    var onlyFlipViewUnread = await offlineService.GetSetting("OnlyFlipViewUnread");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewUnread))                      OnlyFlipViewUnread = bool.Parse(onlyFlipViewUnread);                  else                      OnlyFlipViewUnread = false;                    var onlyFlipViewImages = await offlineService.GetSetting("OnlyFlipViewImages2");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewImages))                      OnlyFlipViewImages = bool.Parse(onlyFlipViewImages);                  else                      OnlyFlipViewImages = true;                    Messenger.Default.Send<SettingsChangedMessage>(new SettingsChangedMessage { InitialLoad = true });              }              catch              {                  //not interested in failure here              }
Magic Number,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The following statement contains a magic number: try              {                  var offlineService = _baconProvider.GetService<IOfflineService>();                    var allowOver18String = await offlineService.GetSetting("AllowOver18");                  if (!string.IsNullOrWhiteSpace(allowOver18String))                      AllowOver18 = bool.Parse(allowOver18String);                  else                      AllowOver18 = false;                    var maxTopLevelOfflineCommentsString = await offlineService.GetSetting("MaxTopLevelOfflineComments");                  if (!string.IsNullOrWhiteSpace(maxTopLevelOfflineCommentsString))                      MaxTopLevelOfflineComments = int.Parse(maxTopLevelOfflineCommentsString);                  else                      MaxTopLevelOfflineComments = 50;                    var offlineOnlyGetsFirstSetString = await offlineService.GetSetting("OfflineOnlyGetsFirstSet");                  if (!string.IsNullOrWhiteSpace(offlineOnlyGetsFirstSetString))                      OfflineOnlyGetsFirstSet = bool.Parse(offlineOnlyGetsFirstSetString);                  else                      OfflineOnlyGetsFirstSet = true;                    var openLinksInBrowserString = await offlineService.GetSetting("OpenLinksInBrowser");                  if (!string.IsNullOrWhiteSpace(openLinksInBrowserString))                      OpenLinksInBrowser = bool.Parse(openLinksInBrowserString);                  else                      OpenLinksInBrowser = false;                    var highlightAlreadyClickedLinksString = await offlineService.GetSetting("HighlightAlreadyClickedLinks");                  if (!string.IsNullOrWhiteSpace(highlightAlreadyClickedLinksString))                      HighlightAlreadyClickedLinks = bool.Parse(highlightAlreadyClickedLinksString);                  else                      HighlightAlreadyClickedLinks = true;                    var applyReadabliltyToLinksString = await offlineService.GetSetting("ApplyReadabliltyToLinks");                  if (!string.IsNullOrWhiteSpace(applyReadabliltyToLinksString))                      ApplyReadabliltyToLinks = bool.Parse(applyReadabliltyToLinksString);                  else                      ApplyReadabliltyToLinks = false;                    var preferImageLinksForTiles = await offlineService.GetSetting("PreferImageLinksForTiles");                  if (!string.IsNullOrWhiteSpace(preferImageLinksForTiles))                      PreferImageLinksForTiles = bool.Parse(preferImageLinksForTiles);                  else                      PreferImageLinksForTiles = true;                    var defaultOfflineLinkCount = await offlineService.GetSetting("DefaultOfflineLinkCount");                  if (!string.IsNullOrWhiteSpace(defaultOfflineLinkCount))                      DefaultOfflineLinkCount = int.Parse(defaultOfflineLinkCount);                  else                      DefaultOfflineLinkCount = 25;                    var leftHandedMode = await offlineService.GetSetting("LeftHandedMode");                  if (!string.IsNullOrWhiteSpace(leftHandedMode))                      LeftHandedMode = bool.Parse(leftHandedMode);                  else                      LeftHandedMode = false;                    var orientationLock = await offlineService.GetSetting("OrientationLock");                  if (!string.IsNullOrWhiteSpace(orientationLock))                      OrientationLock = bool.Parse(orientationLock);                  else                      OrientationLock = false;                    var orientation = await offlineService.GetSetting("Orientation");                  if (!string.IsNullOrWhiteSpace(orientation))                      Orientation = orientation;                  else                      Orientation = "";                    var predicitveOfflining = await offlineService.GetSetting("AllowPredictiveOfflining");                  if (!string.IsNullOrWhiteSpace(predicitveOfflining))                      AllowPredictiveOfflining = bool.Parse(predicitveOfflining);                  else                      AllowPredictiveOfflining = false;                    PromptForCaptcha = true;                  var over18Items = await offlineService.GetSetting("AllowOver18Items");                  if (!string.IsNullOrWhiteSpace(over18Items))                      AllowOver18Items = bool.Parse(over18Items);                  else                      AllowOver18Items = false;                    var predictiveOffliningOnMeteredConnection = await offlineService.GetSetting("AllowPredictiveOffliningOnMeteredConnection");                  if (!string.IsNullOrWhiteSpace(predictiveOffliningOnMeteredConnection))                      AllowPredictiveOffliningOnMeteredConnection = bool.Parse(predictiveOffliningOnMeteredConnection);                  else                      AllowPredictiveOffliningOnMeteredConnection = false;                    var overlayOpacity = await offlineService.GetSetting("OverlayOpacity");                  if (!string.IsNullOrWhiteSpace(overlayOpacity))                      OverlayOpacity = int.Parse(overlayOpacity);                  else                      OverlayOpacity = 40;                    var highresLockScreenOnly = await offlineService.GetSetting("HighresLockScreenOnly");                  if (!string.IsNullOrWhiteSpace(highresLockScreenOnly))                      HighresLockScreenOnly = bool.Parse(highresLockScreenOnly);                  else                      HighresLockScreenOnly = false;                    var messagesInLockScreenOverlay = await offlineService.GetSetting("MessagesInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(messagesInLockScreenOverlay))                      MessagesInLockScreenOverlay = bool.Parse(messagesInLockScreenOverlay);                  else                      MessagesInLockScreenOverlay = true;                    var enableUpdates = await offlineService.GetSetting("EnableUpdates");                  if (!string.IsNullOrWhiteSpace(enableUpdates))                      EnableUpdates = bool.Parse(enableUpdates);                  else                      EnableUpdates = true;                    var postsInLockScreenOverlay = await offlineService.GetSetting("PostsInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(postsInLockScreenOverlay))                      PostsInLockScreenOverlay = bool.Parse(postsInLockScreenOverlay);                  else                      PostsInLockScreenOverlay = true;                    var imagesSubreddit = await offlineService.GetSetting("ImagesSubreddit");                  if (!string.IsNullOrWhiteSpace(imagesSubreddit))                      ImagesSubreddit = imagesSubreddit;                  else                      ImagesSubreddit = "/r/earthporn+InfrastructurePorn+MachinePorn";                    var lockScreenReddit = await offlineService.GetSetting("LockScreenReddit");                  if (!string.IsNullOrWhiteSpace(lockScreenReddit))                      LockScreenReddit = lockScreenReddit;                  else                      LockScreenReddit = "/";                    var liveTileReddit = await offlineService.GetSetting("LiveTileReddit");                  if (!string.IsNullOrWhiteSpace(liveTileReddit))                      LiveTileReddit = liveTileReddit;                  else                      LiveTileReddit = "/";                    var overlayItemCount = await offlineService.GetSetting("OverlayItemCount");                  if (!string.IsNullOrWhiteSpace(overlayItemCount))                      OverlayItemCount = int.Parse(overlayItemCount);                  else                      OverlayItemCount = 5;                    var offlineCacheDays = await offlineService.GetSetting("OfflineCacheDays");                  if (!string.IsNullOrWhiteSpace(offlineCacheDays))                      OfflineCacheDays = int.Parse(offlineCacheDays);                  else                      OfflineCacheDays = 2;                    var enableOvernightUpdates = await offlineService.GetSetting("EnableOvernightUpdates");                  if (!string.IsNullOrWhiteSpace(enableOvernightUpdates))                      EnableOvernightUpdates = bool.Parse(enableOvernightUpdates);                  else                      EnableOvernightUpdates = true;                    var updateOverlayOnlyOnWifi = await offlineService.GetSetting("UpdateOverlayOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateOverlayOnlyOnWifi))                      UpdateOverlayOnlyOnWifi = bool.Parse(updateOverlayOnlyOnWifi);                  else                      UpdateOverlayOnlyOnWifi = false;                    var updateImagesOnlyOnWifi = await offlineService.GetSetting("UpdateImagesOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateImagesOnlyOnWifi))                      UpdateImagesOnlyOnWifi = bool.Parse(updateImagesOnlyOnWifi);                  else                      UpdateImagesOnlyOnWifi = true;                    var allowAdvertising = await offlineService.GetSetting("AllowAdvertising");                  if (!string.IsNullOrWhiteSpace(allowAdvertising))                      AllowAdvertising = bool.Parse(allowAdvertising);                  else                      AllowAdvertising = true;                    var lastUpdatedImages = await offlineService.GetSetting("LastUpdatedImages");                  if (!string.IsNullOrWhiteSpace(lastUpdatedImages))                      LastUpdatedImages = DateTime.Parse(lastUpdatedImages);                  else                      LastUpdatedImages = new DateTime();                    var lastCleanedCache = await offlineService.GetSetting("LastCleanedCache");                  if (!string.IsNullOrWhiteSpace(lastCleanedCache))                      LastCleanedCache = DateTime.Parse(lastCleanedCache);                  else                      LastCleanedCache = new DateTime();                    var tapForComments = await offlineService.GetSetting("TapForComments");                  if (!string.IsNullOrWhiteSpace(tapForComments))                      TapForComments = bool.Parse(tapForComments);                  else                      TapForComments = false;                    var useImagePickerForLockScreen = await offlineService.GetSetting("UseImagePickerForLockScreen");                  if (!string.IsNullOrWhiteSpace(useImagePickerForLockScreen))                      UseImagePickerForLockScreen = bool.Parse(useImagePickerForLockScreen);                  else                      UseImagePickerForLockScreen = false;                    var roundedLockScreen = await offlineService.GetSetting("RoundedLockScreen");                  if (!string.IsNullOrWhiteSpace(roundedLockScreen))                      RoundedLockScreen = bool.Parse(roundedLockScreen);                  else                      RoundedLockScreen = false;                    var multiColoredCommentMargins = await offlineService.GetSetting("MultiColorCommentMargins");                  if (!string.IsNullOrWhiteSpace(multiColoredCommentMargins))                      MultiColorCommentMargins = bool.Parse(multiColoredCommentMargins);                  else                      MultiColorCommentMargins = false;                    var invertSystemTheme = await offlineService.GetSetting("InvertSystemTheme");                  if (!string.IsNullOrWhiteSpace(invertSystemTheme))                      InvertSystemTheme = bool.Parse(invertSystemTheme);                  else                      InvertSystemTheme = false;                                    var onlyFlipViewUnread = await offlineService.GetSetting("OnlyFlipViewUnread");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewUnread))                      OnlyFlipViewUnread = bool.Parse(onlyFlipViewUnread);                  else                      OnlyFlipViewUnread = false;                    var onlyFlipViewImages = await offlineService.GetSetting("OnlyFlipViewImages2");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewImages))                      OnlyFlipViewImages = bool.Parse(onlyFlipViewImages);                  else                      OnlyFlipViewImages = true;                    Messenger.Default.Send<SettingsChangedMessage>(new SettingsChangedMessage { InitialLoad = true });              }              catch              {                  //not interested in failure here              }
Magic Number,BaconographyPortable.Services.Impl,SettingsServiceImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SettingsServiceImpl.cs,Initialize,The following statement contains a magic number: try              {                  var offlineService = _baconProvider.GetService<IOfflineService>();                    var allowOver18String = await offlineService.GetSetting("AllowOver18");                  if (!string.IsNullOrWhiteSpace(allowOver18String))                      AllowOver18 = bool.Parse(allowOver18String);                  else                      AllowOver18 = false;                    var maxTopLevelOfflineCommentsString = await offlineService.GetSetting("MaxTopLevelOfflineComments");                  if (!string.IsNullOrWhiteSpace(maxTopLevelOfflineCommentsString))                      MaxTopLevelOfflineComments = int.Parse(maxTopLevelOfflineCommentsString);                  else                      MaxTopLevelOfflineComments = 50;                    var offlineOnlyGetsFirstSetString = await offlineService.GetSetting("OfflineOnlyGetsFirstSet");                  if (!string.IsNullOrWhiteSpace(offlineOnlyGetsFirstSetString))                      OfflineOnlyGetsFirstSet = bool.Parse(offlineOnlyGetsFirstSetString);                  else                      OfflineOnlyGetsFirstSet = true;                    var openLinksInBrowserString = await offlineService.GetSetting("OpenLinksInBrowser");                  if (!string.IsNullOrWhiteSpace(openLinksInBrowserString))                      OpenLinksInBrowser = bool.Parse(openLinksInBrowserString);                  else                      OpenLinksInBrowser = false;                    var highlightAlreadyClickedLinksString = await offlineService.GetSetting("HighlightAlreadyClickedLinks");                  if (!string.IsNullOrWhiteSpace(highlightAlreadyClickedLinksString))                      HighlightAlreadyClickedLinks = bool.Parse(highlightAlreadyClickedLinksString);                  else                      HighlightAlreadyClickedLinks = true;                    var applyReadabliltyToLinksString = await offlineService.GetSetting("ApplyReadabliltyToLinks");                  if (!string.IsNullOrWhiteSpace(applyReadabliltyToLinksString))                      ApplyReadabliltyToLinks = bool.Parse(applyReadabliltyToLinksString);                  else                      ApplyReadabliltyToLinks = false;                    var preferImageLinksForTiles = await offlineService.GetSetting("PreferImageLinksForTiles");                  if (!string.IsNullOrWhiteSpace(preferImageLinksForTiles))                      PreferImageLinksForTiles = bool.Parse(preferImageLinksForTiles);                  else                      PreferImageLinksForTiles = true;                    var defaultOfflineLinkCount = await offlineService.GetSetting("DefaultOfflineLinkCount");                  if (!string.IsNullOrWhiteSpace(defaultOfflineLinkCount))                      DefaultOfflineLinkCount = int.Parse(defaultOfflineLinkCount);                  else                      DefaultOfflineLinkCount = 25;                    var leftHandedMode = await offlineService.GetSetting("LeftHandedMode");                  if (!string.IsNullOrWhiteSpace(leftHandedMode))                      LeftHandedMode = bool.Parse(leftHandedMode);                  else                      LeftHandedMode = false;                    var orientationLock = await offlineService.GetSetting("OrientationLock");                  if (!string.IsNullOrWhiteSpace(orientationLock))                      OrientationLock = bool.Parse(orientationLock);                  else                      OrientationLock = false;                    var orientation = await offlineService.GetSetting("Orientation");                  if (!string.IsNullOrWhiteSpace(orientation))                      Orientation = orientation;                  else                      Orientation = "";                    var predicitveOfflining = await offlineService.GetSetting("AllowPredictiveOfflining");                  if (!string.IsNullOrWhiteSpace(predicitveOfflining))                      AllowPredictiveOfflining = bool.Parse(predicitveOfflining);                  else                      AllowPredictiveOfflining = false;                    PromptForCaptcha = true;                  var over18Items = await offlineService.GetSetting("AllowOver18Items");                  if (!string.IsNullOrWhiteSpace(over18Items))                      AllowOver18Items = bool.Parse(over18Items);                  else                      AllowOver18Items = false;                    var predictiveOffliningOnMeteredConnection = await offlineService.GetSetting("AllowPredictiveOffliningOnMeteredConnection");                  if (!string.IsNullOrWhiteSpace(predictiveOffliningOnMeteredConnection))                      AllowPredictiveOffliningOnMeteredConnection = bool.Parse(predictiveOffliningOnMeteredConnection);                  else                      AllowPredictiveOffliningOnMeteredConnection = false;                    var overlayOpacity = await offlineService.GetSetting("OverlayOpacity");                  if (!string.IsNullOrWhiteSpace(overlayOpacity))                      OverlayOpacity = int.Parse(overlayOpacity);                  else                      OverlayOpacity = 40;                    var highresLockScreenOnly = await offlineService.GetSetting("HighresLockScreenOnly");                  if (!string.IsNullOrWhiteSpace(highresLockScreenOnly))                      HighresLockScreenOnly = bool.Parse(highresLockScreenOnly);                  else                      HighresLockScreenOnly = false;                    var messagesInLockScreenOverlay = await offlineService.GetSetting("MessagesInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(messagesInLockScreenOverlay))                      MessagesInLockScreenOverlay = bool.Parse(messagesInLockScreenOverlay);                  else                      MessagesInLockScreenOverlay = true;                    var enableUpdates = await offlineService.GetSetting("EnableUpdates");                  if (!string.IsNullOrWhiteSpace(enableUpdates))                      EnableUpdates = bool.Parse(enableUpdates);                  else                      EnableUpdates = true;                    var postsInLockScreenOverlay = await offlineService.GetSetting("PostsInLockScreenOverlay");                  if (!string.IsNullOrWhiteSpace(postsInLockScreenOverlay))                      PostsInLockScreenOverlay = bool.Parse(postsInLockScreenOverlay);                  else                      PostsInLockScreenOverlay = true;                    var imagesSubreddit = await offlineService.GetSetting("ImagesSubreddit");                  if (!string.IsNullOrWhiteSpace(imagesSubreddit))                      ImagesSubreddit = imagesSubreddit;                  else                      ImagesSubreddit = "/r/earthporn+InfrastructurePorn+MachinePorn";                    var lockScreenReddit = await offlineService.GetSetting("LockScreenReddit");                  if (!string.IsNullOrWhiteSpace(lockScreenReddit))                      LockScreenReddit = lockScreenReddit;                  else                      LockScreenReddit = "/";                    var liveTileReddit = await offlineService.GetSetting("LiveTileReddit");                  if (!string.IsNullOrWhiteSpace(liveTileReddit))                      LiveTileReddit = liveTileReddit;                  else                      LiveTileReddit = "/";                    var overlayItemCount = await offlineService.GetSetting("OverlayItemCount");                  if (!string.IsNullOrWhiteSpace(overlayItemCount))                      OverlayItemCount = int.Parse(overlayItemCount);                  else                      OverlayItemCount = 5;                    var offlineCacheDays = await offlineService.GetSetting("OfflineCacheDays");                  if (!string.IsNullOrWhiteSpace(offlineCacheDays))                      OfflineCacheDays = int.Parse(offlineCacheDays);                  else                      OfflineCacheDays = 2;                    var enableOvernightUpdates = await offlineService.GetSetting("EnableOvernightUpdates");                  if (!string.IsNullOrWhiteSpace(enableOvernightUpdates))                      EnableOvernightUpdates = bool.Parse(enableOvernightUpdates);                  else                      EnableOvernightUpdates = true;                    var updateOverlayOnlyOnWifi = await offlineService.GetSetting("UpdateOverlayOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateOverlayOnlyOnWifi))                      UpdateOverlayOnlyOnWifi = bool.Parse(updateOverlayOnlyOnWifi);                  else                      UpdateOverlayOnlyOnWifi = false;                    var updateImagesOnlyOnWifi = await offlineService.GetSetting("UpdateImagesOnlyOnWifi");                  if (!string.IsNullOrWhiteSpace(updateImagesOnlyOnWifi))                      UpdateImagesOnlyOnWifi = bool.Parse(updateImagesOnlyOnWifi);                  else                      UpdateImagesOnlyOnWifi = true;                    var allowAdvertising = await offlineService.GetSetting("AllowAdvertising");                  if (!string.IsNullOrWhiteSpace(allowAdvertising))                      AllowAdvertising = bool.Parse(allowAdvertising);                  else                      AllowAdvertising = true;                    var lastUpdatedImages = await offlineService.GetSetting("LastUpdatedImages");                  if (!string.IsNullOrWhiteSpace(lastUpdatedImages))                      LastUpdatedImages = DateTime.Parse(lastUpdatedImages);                  else                      LastUpdatedImages = new DateTime();                    var lastCleanedCache = await offlineService.GetSetting("LastCleanedCache");                  if (!string.IsNullOrWhiteSpace(lastCleanedCache))                      LastCleanedCache = DateTime.Parse(lastCleanedCache);                  else                      LastCleanedCache = new DateTime();                    var tapForComments = await offlineService.GetSetting("TapForComments");                  if (!string.IsNullOrWhiteSpace(tapForComments))                      TapForComments = bool.Parse(tapForComments);                  else                      TapForComments = false;                    var useImagePickerForLockScreen = await offlineService.GetSetting("UseImagePickerForLockScreen");                  if (!string.IsNullOrWhiteSpace(useImagePickerForLockScreen))                      UseImagePickerForLockScreen = bool.Parse(useImagePickerForLockScreen);                  else                      UseImagePickerForLockScreen = false;                    var roundedLockScreen = await offlineService.GetSetting("RoundedLockScreen");                  if (!string.IsNullOrWhiteSpace(roundedLockScreen))                      RoundedLockScreen = bool.Parse(roundedLockScreen);                  else                      RoundedLockScreen = false;                    var multiColoredCommentMargins = await offlineService.GetSetting("MultiColorCommentMargins");                  if (!string.IsNullOrWhiteSpace(multiColoredCommentMargins))                      MultiColorCommentMargins = bool.Parse(multiColoredCommentMargins);                  else                      MultiColorCommentMargins = false;                    var invertSystemTheme = await offlineService.GetSetting("InvertSystemTheme");                  if (!string.IsNullOrWhiteSpace(invertSystemTheme))                      InvertSystemTheme = bool.Parse(invertSystemTheme);                  else                      InvertSystemTheme = false;                                    var onlyFlipViewUnread = await offlineService.GetSetting("OnlyFlipViewUnread");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewUnread))                      OnlyFlipViewUnread = bool.Parse(onlyFlipViewUnread);                  else                      OnlyFlipViewUnread = false;                    var onlyFlipViewImages = await offlineService.GetSetting("OnlyFlipViewImages2");                  if (!string.IsNullOrWhiteSpace(onlyFlipViewImages))                      OnlyFlipViewImages = bool.Parse(onlyFlipViewImages);                  else                      OnlyFlipViewImages = true;                    Messenger.Default.Send<SettingsChangedMessage>(new SettingsChangedMessage { InitialLoad = true });              }              catch              {                  //not interested in failure here              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: if (!_settingsService.AllowPredictiveOfflining || (DateTime.Now - _nextOffliningTime).TotalMinutes < 10)                  return;
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: try              {                  //good chance to try and process our delayed actions                  //we dont want to do to much if we've got actions to run and we're just in an idle state                  if (_smartOfflineService.IsActivityIdle)                  {                      if (await RunPeriodic() || token.IsCancellationRequested)                          return;                  }                    var user = await _userService.GetUser();                  if (user != null && (DateTime.Now - _lastMeCheck) >= TimeSpan.FromMinutes(10))                  {                      _lastMeCheck = DateTime.Now;                      user.Me = await GetMe(user);                  }                    if ((user != null && user.Me != null && user.Me.HasMail)                      || !(await _offlineService.UserHasOfflineMessages(user)))                  {                      await GetMessages(null);                  }                    if (_linkThingsAwaitingOfflining.Count > 0)                  {                      while (!token.IsCancellationRequested && _linkThingsAwaitingOfflining.Count > 0)                      {                          var linkThingToOffline = _linkThingsAwaitingOfflining.Pop();                          if (_recentlyLoadedComments.Contains(linkThingToOffline.Permalink))                          {                              _recentlyLoadedComments.Add(linkThingToOffline.Permalink);                              OfflineComments(linkThingToOffline.SubredditId' linkThingToOffline.Permalink);                          }                      }                  }                  else                  {                      HashSet<string> targetDomains = new HashSet<string>();                      var newLinks = _smartOfflineService.OfflineableLinkThingsFromContext.Select(thing => thing.TypedData).ToList();                        var domainAggs = await _offlineService.GetDomainAggregates(TopSubsetMaximum' 25);                      var subredditAggs = await _offlineService.GetSubredditAggregates(TopSubsetMaximum' 25);                        var linkTotal = subredditAggs.Sum(p => p.LinkClicks);                      var commentTotal = subredditAggs.Sum(p => p.CommentClicks);                      var hashes = domainAggs.Select(p => p.DomainHash);                      var subs = subredditAggs.Select(p => p.SubredditId);                        foreach (var domain in newLinks.Select(p => p.Domain).Distinct())                      {                          var hash = (uint)domain.GetHashCode();                          if (hashes.Contains(hash))                              targetDomains.Add(domain);                      }                        var filteredLinks = newLinks.Where(p => targetDomains.Contains(p.Domain) || subs.Contains(p.SubredditId)).ToList();                      if (filteredLinks.Count < 5)                      {                          filteredLinks = newLinks;                      }                        if (filteredLinks.All(link => _recentlyLoadedComments.Contains(link.Permalink)))                      {                          _nextOffliningTime = DateTime.Now.AddMinutes(10);                      }                        _linkThingsAwaitingOfflining = new Stack<Link>(filteredLinks);                  }              }              catch (Exception ex)              {              }              finally              {                  _isOfflining = false;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: try              {                  //good chance to try and process our delayed actions                  //we dont want to do to much if we've got actions to run and we're just in an idle state                  if (_smartOfflineService.IsActivityIdle)                  {                      if (await RunPeriodic() || token.IsCancellationRequested)                          return;                  }                    var user = await _userService.GetUser();                  if (user != null && (DateTime.Now - _lastMeCheck) >= TimeSpan.FromMinutes(10))                  {                      _lastMeCheck = DateTime.Now;                      user.Me = await GetMe(user);                  }                    if ((user != null && user.Me != null && user.Me.HasMail)                      || !(await _offlineService.UserHasOfflineMessages(user)))                  {                      await GetMessages(null);                  }                    if (_linkThingsAwaitingOfflining.Count > 0)                  {                      while (!token.IsCancellationRequested && _linkThingsAwaitingOfflining.Count > 0)                      {                          var linkThingToOffline = _linkThingsAwaitingOfflining.Pop();                          if (_recentlyLoadedComments.Contains(linkThingToOffline.Permalink))                          {                              _recentlyLoadedComments.Add(linkThingToOffline.Permalink);                              OfflineComments(linkThingToOffline.SubredditId' linkThingToOffline.Permalink);                          }                      }                  }                  else                  {                      HashSet<string> targetDomains = new HashSet<string>();                      var newLinks = _smartOfflineService.OfflineableLinkThingsFromContext.Select(thing => thing.TypedData).ToList();                        var domainAggs = await _offlineService.GetDomainAggregates(TopSubsetMaximum' 25);                      var subredditAggs = await _offlineService.GetSubredditAggregates(TopSubsetMaximum' 25);                        var linkTotal = subredditAggs.Sum(p => p.LinkClicks);                      var commentTotal = subredditAggs.Sum(p => p.CommentClicks);                      var hashes = domainAggs.Select(p => p.DomainHash);                      var subs = subredditAggs.Select(p => p.SubredditId);                        foreach (var domain in newLinks.Select(p => p.Domain).Distinct())                      {                          var hash = (uint)domain.GetHashCode();                          if (hashes.Contains(hash))                              targetDomains.Add(domain);                      }                        var filteredLinks = newLinks.Where(p => targetDomains.Contains(p.Domain) || subs.Contains(p.SubredditId)).ToList();                      if (filteredLinks.Count < 5)                      {                          filteredLinks = newLinks;                      }                        if (filteredLinks.All(link => _recentlyLoadedComments.Contains(link.Permalink)))                      {                          _nextOffliningTime = DateTime.Now.AddMinutes(10);                      }                        _linkThingsAwaitingOfflining = new Stack<Link>(filteredLinks);                  }              }              catch (Exception ex)              {              }              finally              {                  _isOfflining = false;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: try              {                  //good chance to try and process our delayed actions                  //we dont want to do to much if we've got actions to run and we're just in an idle state                  if (_smartOfflineService.IsActivityIdle)                  {                      if (await RunPeriodic() || token.IsCancellationRequested)                          return;                  }                    var user = await _userService.GetUser();                  if (user != null && (DateTime.Now - _lastMeCheck) >= TimeSpan.FromMinutes(10))                  {                      _lastMeCheck = DateTime.Now;                      user.Me = await GetMe(user);                  }                    if ((user != null && user.Me != null && user.Me.HasMail)                      || !(await _offlineService.UserHasOfflineMessages(user)))                  {                      await GetMessages(null);                  }                    if (_linkThingsAwaitingOfflining.Count > 0)                  {                      while (!token.IsCancellationRequested && _linkThingsAwaitingOfflining.Count > 0)                      {                          var linkThingToOffline = _linkThingsAwaitingOfflining.Pop();                          if (_recentlyLoadedComments.Contains(linkThingToOffline.Permalink))                          {                              _recentlyLoadedComments.Add(linkThingToOffline.Permalink);                              OfflineComments(linkThingToOffline.SubredditId' linkThingToOffline.Permalink);                          }                      }                  }                  else                  {                      HashSet<string> targetDomains = new HashSet<string>();                      var newLinks = _smartOfflineService.OfflineableLinkThingsFromContext.Select(thing => thing.TypedData).ToList();                        var domainAggs = await _offlineService.GetDomainAggregates(TopSubsetMaximum' 25);                      var subredditAggs = await _offlineService.GetSubredditAggregates(TopSubsetMaximum' 25);                        var linkTotal = subredditAggs.Sum(p => p.LinkClicks);                      var commentTotal = subredditAggs.Sum(p => p.CommentClicks);                      var hashes = domainAggs.Select(p => p.DomainHash);                      var subs = subredditAggs.Select(p => p.SubredditId);                        foreach (var domain in newLinks.Select(p => p.Domain).Distinct())                      {                          var hash = (uint)domain.GetHashCode();                          if (hashes.Contains(hash))                              targetDomains.Add(domain);                      }                        var filteredLinks = newLinks.Where(p => targetDomains.Contains(p.Domain) || subs.Contains(p.SubredditId)).ToList();                      if (filteredLinks.Count < 5)                      {                          filteredLinks = newLinks;                      }                        if (filteredLinks.All(link => _recentlyLoadedComments.Contains(link.Permalink)))                      {                          _nextOffliningTime = DateTime.Now.AddMinutes(10);                      }                        _linkThingsAwaitingOfflining = new Stack<Link>(filteredLinks);                  }              }              catch (Exception ex)              {              }              finally              {                  _isOfflining = false;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: try              {                  //good chance to try and process our delayed actions                  //we dont want to do to much if we've got actions to run and we're just in an idle state                  if (_smartOfflineService.IsActivityIdle)                  {                      if (await RunPeriodic() || token.IsCancellationRequested)                          return;                  }                    var user = await _userService.GetUser();                  if (user != null && (DateTime.Now - _lastMeCheck) >= TimeSpan.FromMinutes(10))                  {                      _lastMeCheck = DateTime.Now;                      user.Me = await GetMe(user);                  }                    if ((user != null && user.Me != null && user.Me.HasMail)                      || !(await _offlineService.UserHasOfflineMessages(user)))                  {                      await GetMessages(null);                  }                    if (_linkThingsAwaitingOfflining.Count > 0)                  {                      while (!token.IsCancellationRequested && _linkThingsAwaitingOfflining.Count > 0)                      {                          var linkThingToOffline = _linkThingsAwaitingOfflining.Pop();                          if (_recentlyLoadedComments.Contains(linkThingToOffline.Permalink))                          {                              _recentlyLoadedComments.Add(linkThingToOffline.Permalink);                              OfflineComments(linkThingToOffline.SubredditId' linkThingToOffline.Permalink);                          }                      }                  }                  else                  {                      HashSet<string> targetDomains = new HashSet<string>();                      var newLinks = _smartOfflineService.OfflineableLinkThingsFromContext.Select(thing => thing.TypedData).ToList();                        var domainAggs = await _offlineService.GetDomainAggregates(TopSubsetMaximum' 25);                      var subredditAggs = await _offlineService.GetSubredditAggregates(TopSubsetMaximum' 25);                        var linkTotal = subredditAggs.Sum(p => p.LinkClicks);                      var commentTotal = subredditAggs.Sum(p => p.CommentClicks);                      var hashes = domainAggs.Select(p => p.DomainHash);                      var subs = subredditAggs.Select(p => p.SubredditId);                        foreach (var domain in newLinks.Select(p => p.Domain).Distinct())                      {                          var hash = (uint)domain.GetHashCode();                          if (hashes.Contains(hash))                              targetDomains.Add(domain);                      }                        var filteredLinks = newLinks.Where(p => targetDomains.Contains(p.Domain) || subs.Contains(p.SubredditId)).ToList();                      if (filteredLinks.Count < 5)                      {                          filteredLinks = newLinks;                      }                        if (filteredLinks.All(link => _recentlyLoadedComments.Contains(link.Permalink)))                      {                          _nextOffliningTime = DateTime.Now.AddMinutes(10);                      }                        _linkThingsAwaitingOfflining = new Stack<Link>(filteredLinks);                  }              }              catch (Exception ex)              {              }              finally              {                  _isOfflining = false;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: try              {                  //good chance to try and process our delayed actions                  //we dont want to do to much if we've got actions to run and we're just in an idle state                  if (_smartOfflineService.IsActivityIdle)                  {                      if (await RunPeriodic() || token.IsCancellationRequested)                          return;                  }                    var user = await _userService.GetUser();                  if (user != null && (DateTime.Now - _lastMeCheck) >= TimeSpan.FromMinutes(10))                  {                      _lastMeCheck = DateTime.Now;                      user.Me = await GetMe(user);                  }                    if ((user != null && user.Me != null && user.Me.HasMail)                      || !(await _offlineService.UserHasOfflineMessages(user)))                  {                      await GetMessages(null);                  }                    if (_linkThingsAwaitingOfflining.Count > 0)                  {                      while (!token.IsCancellationRequested && _linkThingsAwaitingOfflining.Count > 0)                      {                          var linkThingToOffline = _linkThingsAwaitingOfflining.Pop();                          if (_recentlyLoadedComments.Contains(linkThingToOffline.Permalink))                          {                              _recentlyLoadedComments.Add(linkThingToOffline.Permalink);                              OfflineComments(linkThingToOffline.SubredditId' linkThingToOffline.Permalink);                          }                      }                  }                  else                  {                      HashSet<string> targetDomains = new HashSet<string>();                      var newLinks = _smartOfflineService.OfflineableLinkThingsFromContext.Select(thing => thing.TypedData).ToList();                        var domainAggs = await _offlineService.GetDomainAggregates(TopSubsetMaximum' 25);                      var subredditAggs = await _offlineService.GetSubredditAggregates(TopSubsetMaximum' 25);                        var linkTotal = subredditAggs.Sum(p => p.LinkClicks);                      var commentTotal = subredditAggs.Sum(p => p.CommentClicks);                      var hashes = domainAggs.Select(p => p.DomainHash);                      var subs = subredditAggs.Select(p => p.SubredditId);                        foreach (var domain in newLinks.Select(p => p.Domain).Distinct())                      {                          var hash = (uint)domain.GetHashCode();                          if (hashes.Contains(hash))                              targetDomains.Add(domain);                      }                        var filteredLinks = newLinks.Where(p => targetDomains.Contains(p.Domain) || subs.Contains(p.SubredditId)).ToList();                      if (filteredLinks.Count < 5)                      {                          filteredLinks = newLinks;                      }                        if (filteredLinks.All(link => _recentlyLoadedComments.Contains(link.Permalink)))                      {                          _nextOffliningTime = DateTime.Now.AddMinutes(10);                      }                        _linkThingsAwaitingOfflining = new Stack<Link>(filteredLinks);                  }              }              catch (Exception ex)              {              }              finally              {                  _isOfflining = false;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetMe,The following statement contains a magic number: if (_settingsService.IsOnline())              {                  return await _redditService.GetMe();              }              else              {                  var thing = await _offlineService.RetrieveThing(string.Format("account-user:{0}"' user.Username)' TimeSpan.FromDays(1024));                  return thing != null ? thing.Data as Account : null;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetThingById,The following statement contains a magic number: if (id.Length > 2)              {                  var idCode = id.Substring(0' 2);                  Thing gottenThing = null;                  switch (idCode)                  {                      //case "t1":                          //gottenThing = await _offlineService.RetrieveComment(id);                          //break;                      case "t3":                          gottenThing = await _offlineService.RetrieveLink(id);                          break;                      case "t5":                          gottenThing = await _offlineService.RetrieveSubredditById(id);                          break;                  }                    if (gottenThing == null)                      return MaybeStoreThing(await _redditService.GetThingById(id));                  else                      return gottenThing;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetThingById,The following statement contains a magic number: if (id.Length > 2)              {                  var idCode = id.Substring(0' 2);                  Thing gottenThing = null;                  switch (idCode)                  {                      //case "t1":                          //gottenThing = await _offlineService.RetrieveComment(id);                          //break;                      case "t3":                          gottenThing = await _offlineService.RetrieveLink(id);                          break;                      case "t5":                          gottenThing = await _offlineService.RetrieveSubredditById(id);                          break;                  }                    if (gottenThing == null)                      return MaybeStoreThing(await _redditService.GetThingById(id));                  else                      return gottenThing;              }
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetCommentsOnPost,The following statement contains a magic number: if (cachedLink != null && commentMetadata.Item1 != 0)              {                  if (commentMetadata.Item1 != cachedLink.TypedData.CommentCount || _invalidatedIds.Contains(cachedLink.Data.Name))                      return MaybeStoreCommentsOnPost(await _redditService.GetCommentsOnPost(subreddit' permalink' limit)' permalink);                    var comments = await _offlineService.GetTopLevelComments(cachedPermalink' limit ?? 500);                  if (comments != null && comments.Data.Children.Count > 0)                      return comments;                  else                      return MaybeStoreCommentsOnPost(await _redditService.GetCommentsOnPost(subreddit' permalink' limit)' permalink);              }              else                  return MaybeStoreCommentsOnPost(await _redditService.GetCommentsOnPost(subreddit' permalink' limit)' permalink);
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetLinkByUrl,The following statement contains a magic number: var cachedLink = await _offlineService.RetrieveLinkByUrl(permaLink' TimeSpan.FromMinutes(10));
Magic Number,BaconographyPortable.Services.Impl,SmartOfflineService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineService.cs,NavigatedToView,The following statement contains a magic number: if ((DateTime.Now - lastOppertunity).TotalSeconds < 10)                  return;              else                  lastOppertunity = DateTime.Now;
Magic Number,BaconographyPortable.Services.Impl,SuspendableWorkQueueImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SuspendableWorkQueueImpl.cs,RunWorkQueue,The following statement contains a magic number: try              {                  Tuple<TaskCompletionSource<bool>' Func<CancellationToken' Task>> workUnit = null;                  do                  {                      lock (_lowImportanceRestartableWork)                      {                          if (_lowImportanceRestartableWork.Count > 0)                          {                              workUnit = _lowImportanceRestartableWork.Dequeue();                          }                          else                              workUnit = null;                      }                        if (workUnit != null)                      {                          try                          {                              while (HVOCount > 0)                              {                                  await Task.Delay(100);                              }                                await workUnit.Item2(_cancelationTokenSource.Token);                              if (_cancelationTokenSource.IsCancellationRequested)                                  workUnit.Item1.SetCanceled();                              else                                  workUnit.Item1.SetResult(true);                          }                          catch (Exception ex)                          {                              workUnit.Item1.SetException(ex);                          }                        }                  } while (workUnit != null && !_cancelationTokenSource.IsCancellationRequested);              }              finally              {                  _taskQueueRunning = false;              }
Magic Number,BaconographyPortable.Services.Impl,SuspendableWorkQueueImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SuspendableWorkQueueImpl.cs,RunUIWorkQueue,The following statement contains a magic number: try              {                  Func<CancellationToken' Task> workUnit = null;                  do                  {                      lock (_uiInteruptableQueue)                      {                          if (_uiInteruptableQueue.Count > 0)                          {                              workUnit = _uiInteruptableQueue.Dequeue();                          }                          else                              workUnit = null;                      }                        if (workUnit != null)                      {                          try                          {                              while (HVOCount > 0)                              {                                  await Task.Delay(100);                              }                                await workUnit(_cancelationTokenSource.Token);                          }                          catch { }                        }                  } while (workUnit != null && !_cancelationTokenSource.IsCancellationRequested);              }              finally              {                  _uiTaskQueueRunning = false;              }
Magic Number,BaconographyPortable.ViewModel,CommentViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentViewModel.cs,GotoContextImpl,The following statement contains a magic number: try              {                  if (_comment.Data.ParentId == null)                      return;                    MessengerInstance.Send<LoadingMessage>(new LoadingMessage { Loading = true });                  var linkThing = new TypedThing<Link>(await _redditService.GetThingById(_comment.Data.LinkId));                  var parentThing = await _redditService.GetLinkByUrl("http://www.reddit.com/" + linkThing.Data.Permalink + _comment.Data.ParentId.Substring(3));                  var commentTree = new SelectCommentTreeMessage { LinkThing = new TypedThing<Link>(parentThing) };                  MessengerInstance.Send<LoadingMessage>(new LoadingMessage { Loading = false });                  _navigationService.Navigate(_dynamicViewLocator.CommentsView' commentTree);              }              catch (Exception ex)              {                  _baconProvider.GetService<INotificationService>().CreateErrorNotification(ex);              }
Magic Number,BaconographyPortable.ViewModel,CommentViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\CommentViewModel.cs,GotoFullLinkImpl,The following statement contains a magic number: var commentTree = new SelectCommentTreeMessage { Context = 3' LinkThing = new TypedThing<Link>(linkThing) };
Magic Number,BaconographyPortable.ViewModel,MessagesViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\MessagesViewModel.cs,_smartOfflineService_OffliningOpportunity,The following statement contains a magic number: if ((DateTime.Now - _lastCheckedMessages).TotalMinutes > 15)              {                  _lastCheckedMessages = DateTime.Now;                  GetMessages();              }
Magic Number,BaconographyPortable.ViewModel,MessagesViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\MessagesViewModel.cs,GetMessages,The following statement contains a magic number: if (_userLoggedIn)              {                  if (Messages == null)                  {                      Messages = new MessageViewModelCollection(_baconProvider);                      Messages.CollectionChanged += Messages_CollectionChanged;                      await Messages.LoadMoreItemsAsync(30);                  }                  else                  {                      Messages.Refresh();                  }                    lock (this)                  {                      _alreadyToastedMessages = new HashSet<string>(_liveTileService.GetMessagesMarkedRead());                  }              }
Magic Number,BaconographyPortable.ViewModel,LoadIndicatorViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\LoadIndicatorViewModel.cs,OnLoadingMessage,The following statement contains a magic number: if (message.Loading)              {                  ProgressBarVisibility = true;                  _running++;                  _dispatcherTimerHandle = _systemServices.StartTimer(OnTick' TimeSpan.FromSeconds(2)' true);              }              else              {                  _running--;              }
Magic Number,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadOneImpl,The following statement contains a magic number: Messenger.Default.Send<LoadingMessage>(new LoadingMessage { Loading = true' Percentage = 50' Message = "processing page from " + domain });
Magic Number,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadOneImpl,The following statement contains a magic number: foreach (var tpl in pageBlocks)              {                  if (!string.IsNullOrEmpty(tpl.Item2))                  {                      target.Add(new ReadableArticleImage { Url = tpl.Item2 });                  }                    StringBuilder articleContentsBuilder = new StringBuilder();                  foreach (var pp in tpl.Item1.Split(new char[] { '\r'' '\n' }' StringSplitOptions.RemoveEmptyEntries))                  {                      if (target.Count > 200)                          break;                        articleContentsBuilder.AppendLine(pp);                      if (articleContentsBuilder.Length > 1000)                      {                          target.Add(new ReadableArticleParagraph { Text = articleContentsBuilder.ToString() });                          articleContentsBuilder.Clear();                      }                                        }                  if (articleContentsBuilder.Length > 0)                  {                      target.Add(new ReadableArticleParagraph { Text = articleContentsBuilder.ToString() + "\n\n"});                  }              }
Magic Number,BaconographyPortable.ViewModel,ReadableArticleViewModel,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\ReadableArticleViewModel.cs,LoadOneImpl,The following statement contains a magic number: foreach (var tpl in pageBlocks)              {                  if (!string.IsNullOrEmpty(tpl.Item2))                  {                      target.Add(new ReadableArticleImage { Url = tpl.Item2 });                  }                    StringBuilder articleContentsBuilder = new StringBuilder();                  foreach (var pp in tpl.Item1.Split(new char[] { '\r'' '\n' }' StringSplitOptions.RemoveEmptyEntries))                  {                      if (target.Count > 200)                          break;                        articleContentsBuilder.AppendLine(pp);                      if (articleContentsBuilder.Length > 1000)                      {                          target.Add(new ReadableArticleParagraph { Text = articleContentsBuilder.ToString() });                          articleContentsBuilder.Clear();                      }                                        }                  if (articleContentsBuilder.Length > 0)                  {                      target.Add(new ReadableArticleParagraph { Text = articleContentsBuilder.ToString() + "\n\n"});                  }              }
Magic Number,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,RunBackgroundLoad,The following statement contains a magic number: foreach (var vm in remainingVMs)              {                  if (_cancellationTokenSource.IsCancellationRequested)                      return;                  topLevelVMCount++;                  vmCount += VisitAddChildren(vm' insertionIndex);                  if (vmCount > 15)                      break;              }
Magic Number,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,RunBackgroundLoad,The following statement contains a magic number: if (vmCount >= 15)              {                  remainingVMs = remainingVMs.Skip(topLevelVMCount);                  _systemServices.RestartTimer(timerHandle);              }
Magic Number,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,RunUILoad,The following statement contains a magic number: foreach (var vm in remainingVMs)              {                  if (_cancellationTokenSource.IsCancellationRequested)                      return;                    topLevelVMCount++;                  vmCount += VisitAddChildren(vm' insertionIndex);                  if (vmCount > 15)                      break;              }
Magic Number,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,RunUILoad,The following statement contains a magic number: if (vmCount >= 15)              {                  remainingVMs = remainingVMs.Skip(topLevelVMCount);                  EventHandler<object> tickHandler = (obj' obj2) => RunBackgroundLoad(ref remainingVMs' -1' obj);                  _timerHandles.Add(new WeakReference(_systemServices.StartTimer(tickHandler' new TimeSpan(500)' true)));              }
Magic Number,BaconographyPortable.ViewModel.Collections,CommentViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\CommentViewModelCollection.cs,RunUILoad,The following statement contains a magic number: if (vmCount >= 15)              {                  remainingVMs = remainingVMs.Skip(topLevelVMCount);                  EventHandler<object> tickHandler = (obj' obj2) => RunBackgroundLoad(ref remainingVMs' -1' obj);                  _timerHandles.Add(new WeakReference(_systemServices.StartTimer(tickHandler' new TimeSpan(500)' true)));              }
Magic Number,BaconographyPortable.ViewModel.Collections,BindingShellViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\BindingShellViewModelCollection.cs,UpdateRealItems,The following statement contains a magic number: await collection.LoadMoreItemsAsync(30);
Magic Number,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,LoadAdditional,The following statement contains a magic number: if (state.ContainsKey("After"))              {                  var after = state["After"] as string;                  state.Remove("After");                    return MapListing(await GetAdditionalListing(after' state)' state);              }              else if (state.ContainsKey("More"))              {                  var more = state["More"] as IEnumerable<string>;                  var targetMore = more.Take(500)                      .ToList();                    //asking for 500 of anything is probably unreasonable but reddit will sort it out on the other side in the most efficiant way possible                  //but there isnt any sense in asking for more then 500 when thats the max number of items they're going to return us                  if (targetMore.Count == 500)                      state["More"] = more.Skip(500).ToList();                  else                      state.Remove("More");                    return MapListing(await GetMore(targetMore' state)' state);              }              else                  throw new NotImplementedException();
Magic Number,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,LoadAdditional,The following statement contains a magic number: if (state.ContainsKey("After"))              {                  var after = state["After"] as string;                  state.Remove("After");                    return MapListing(await GetAdditionalListing(after' state)' state);              }              else if (state.ContainsKey("More"))              {                  var more = state["More"] as IEnumerable<string>;                  var targetMore = more.Take(500)                      .ToList();                    //asking for 500 of anything is probably unreasonable but reddit will sort it out on the other side in the most efficiant way possible                  //but there isnt any sense in asking for more then 500 when thats the max number of items they're going to return us                  if (targetMore.Count == 500)                      state["More"] = more.Skip(500).ToList();                  else                      state.Remove("More");                    return MapListing(await GetMore(targetMore' state)' state);              }              else                  throw new NotImplementedException();
Magic Number,BaconographyPortable.ViewModel.Collections,ThingViewModelCollection,C:\repos\Synergex_Baconography\BaconographyPortable\ViewModel\Collections\ThingViewModelCollection.cs,LoadAdditional,The following statement contains a magic number: if (state.ContainsKey("After"))              {                  var after = state["After"] as string;                  state.Remove("After");                    return MapListing(await GetAdditionalListing(after' state)' state);              }              else if (state.ContainsKey("More"))              {                  var more = state["More"] as IEnumerable<string>;                  var targetMore = more.Take(500)                      .ToList();                    //asking for 500 of anything is probably unreasonable but reddit will sort it out on the other side in the most efficiant way possible                  //but there isnt any sense in asking for more then 500 when thats the max number of items they're going to return us                  if (targetMore.Count == 500)                      state["More"] = more.Skip(500).ToList();                  else                      state.Remove("More");                    return MapListing(await GetMore(targetMore' state)' state);              }              else                  throw new NotImplementedException();
Duplicate Code,BaconographyPortable.Common,UtilityCommandImpl,C:\repos\Synergex_Baconography\BaconographyPortable\Common\UtilityCommandImpl.cs,GotoLinkImpl,The method contains a code clone-set at the following line numbers (starting from the method definition): ((63' 82)' (98' 117))
Missing Default,BaconographyPortable.Services.Impl,SmartOfflineRedditService,C:\repos\Synergex_Baconography\BaconographyPortable\Services\Impl\SmartOfflineRedditService.cs,GetThingById,The following switch statement is missing a default case: switch (idCode)                  {                      //case "t1":                          //gottenThing = await _offlineService.RetrieveComment(id);                          //break;                      case "t3":                          gottenThing = await _offlineService.RetrieveLink(id);                          break;                      case "t5":                          gottenThing = await _offlineService.RetrieveSubredditById(id);                          break;                  }
