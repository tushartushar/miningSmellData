Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Bomberman.Commands,GloveAction,C:\repos\mierzynskim_bomberman\Bomberman\Commands\GloveAction.cs,Execute,Cyclomatic complexity of the method is 13
Complex Method,Bomberman.GameStateManagement.Screens,LevelsUnlocked,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\LevelsUnlocked.cs,LevelsUnlocked,Cyclomatic complexity of the method is 11
Complex Method,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,Cyclomatic complexity of the method is 10
Complex Method,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,Cyclomatic complexity of the method is 34
Complex Method,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,PlaceTreasure,Cyclomatic complexity of the method is 17
Complex Method,Bomberman.Players,ComputerPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\ComputerPlayer.cs,Move,Cyclomatic complexity of the method is 14
Complex Method,Bomberman.Players,HumanPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\HumanPlayer.cs,Move,Cyclomatic complexity of the method is 14
Complex Method,GameStateManagement,ScreenManager,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\ScreenManager.cs,Update,Cyclomatic complexity of the method is 8
Long Parameter List,Bomberman.GameStateManagement.Screens,MainMenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MainMenuScreen.cs,MainMenuScreen,The method has 8 parameters.
Long Statement,Bomberman.Algorithms,AStarAlgorithm,C:\repos\mierzynskim_bomberman\Bomberman\Algorithms\AStarAlgorithm.cs,FindPath,The length of the statement  "	HeapPriorityQueue<Unit> openList = new HeapPriorityQueue<Unit> (GameSession.GameBoard.Height * GameSession.GameBoard.Width); " is 124.
Long Statement,Bomberman.Commands,RemoteBombFire,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RemoteBombFire.cs,Execute,The length of the statement  "		GameSession.GameBoard.ResetNeighbors (GameSession.GameBoard.Units [remotePosition.Item1' remotePosition.Item2]' actor.TreasureState.IsFlame ? 2 : 1); " is 149.
Long Statement,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,LevelUp,The length of the statement  "	string message = String.Format ("LEVEL UP!\nEnemies killed: {0}\nBombs left: {1}\nLevel points: {2}\nPlayer points: {3}"' LevelConsts.LevelProperties [level].EnemiesCount - gameController.ComputerPlayers.Count' gameController.HumanPlayer.TreasureState.BombsCount' gameController.HumanPlayer.LevelPoints' gameController.HumanPlayer.OverallPoints); " is 346.
Long Statement,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,LevelUp,The length of the statement  "	levelupScreen.Accepted += (sender' e) => LoadingScreen.Load (ScreenManager' true' e.PlayerIndex' new GameplayScreen ()); " is 120.
Long Statement,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,Draw,The length of the statement  "	ScreenManager.SpriteBatch.Draw (grayRectangle' new Rectangle (0' Game1.WindowWidth' Game1.WindowWidth' 66)' Color.LightGray); " is 125.
Long Statement,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetFreeNeighbors,The length of the statement  "	if (unit.X + 1 < Width && (Units [unit.X + 1' unit.Y].UnitState == State.Empty || Units [unit.X + 1' unit.Y].UnitState == State.Player)) " is 136.
Long Statement,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetFreeNeighbors,The length of the statement  "	if (unit.X - 1 > 0 && (Units [unit.X - 1' unit.Y].UnitState == State.Empty || Units [unit.X - 1' unit.Y].UnitState == State.Player)) " is 132.
Long Statement,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetFreeNeighbors,The length of the statement  "	if (unit.Y + 1 < Height && (Units [unit.X' unit.Y + 1].UnitState == State.Empty || Units [unit.X' unit.Y + 1].UnitState == State.Player)) " is 137.
Long Statement,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetFreeNeighbors,The length of the statement  "	if (unit.Y - 1 > 0 && (Units [unit.X' unit.Y - 1].UnitState == State.Empty || Units [unit.X' unit.Y - 1].UnitState == State.Player)) " is 132.
Long Statement,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The length of the statement  "		actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints; " is 127.
Long Statement,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The length of the statement  "		actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints; " is 127.
Long Statement,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The length of the statement  "		actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints; " is 127.
Long Statement,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The length of the statement  "				if (MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage) " is 132.
Long Statement,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The length of the statement  "				if (MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage) " is 134.
Long Statement,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The length of the statement  "				if (MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage) " is 132.
Long Statement,Bomberman,GameSession,C:\repos\mierzynskim_bomberman\Bomberman\GameSession.cs,HandleInput,The length of the statement  "	if (currentKeyboardState.GetPressedKeys ().Contains (Keys.Up) && currentKeyboardState.GetPressedKeys ().Contains (Keys.D3)) " is 123.
Long Statement,Bomberman,GameSession,C:\repos\mierzynskim_bomberman\Bomberman\GameSession.cs,IsMoveValid,The length of the statement  "	return x > 0 && y > 0 && x < GameBoard.Width && y < GameBoard.Height && GameBoard.Units [x' y].UnitState != State.Wall && GameBoard.Units [x' y].UnitState != State.Concrete && GameBoard.Units [x' y].UnitState != State.Enemy && GameBoard.Units [x' y].UnitState != State.Player; " is 276.
Long Statement,Bomberman,GameSession,C:\repos\mierzynskim_bomberman\Bomberman\GameSession.cs,CheckForKilled,The length of the statement  "			HumanPlayer.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].EnemyKilledPoints; " is 131.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsNewKeyPress,The length of the statement  "		return (IsNewKeyPress (key' PlayerIndex.One' out playerIndex) || IsNewKeyPress (key' PlayerIndex.Two' out playerIndex) || IsNewKeyPress (key' PlayerIndex.Three' out playerIndex) || IsNewKeyPress (key' PlayerIndex.Four' out playerIndex)); " is 237.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsNewButtonPress,The length of the statement  "		return (IsNewButtonPress (button' PlayerIndex.One' out playerIndex) || IsNewButtonPress (button' PlayerIndex.Two' out playerIndex) || IsNewButtonPress (button' PlayerIndex.Three' out playerIndex) || IsNewButtonPress (button' PlayerIndex.Four' out playerIndex)); " is 261.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsMenuSelect,The length of the statement  "	return IsNewKeyPress (Keys.Space' controllingPlayer' out playerIndex) || IsNewKeyPress (Keys.Enter' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.A' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.Start' controllingPlayer' out playerIndex); " is 276.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsMenuCancel,The length of the statement  "	return IsNewKeyPress (Keys.Escape' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.B' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.Back' controllingPlayer' out playerIndex); " is 210.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsMenuUp,The length of the statement  "	return IsNewKeyPress (Keys.Up' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.DPadUp' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.LeftThumbstickUp' controllingPlayer' out playerIndex); " is 223.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsMenuDown,The length of the statement  "	return IsNewKeyPress (Keys.Down' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.DPadDown' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.LeftThumbstickDown' controllingPlayer' out playerIndex); " is 229.
Long Statement,GameStateManagement,InputState,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\InputState.cs,IsPauseGame,The length of the statement  "	return IsNewKeyPress (Keys.Escape' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.Back' controllingPlayer' out playerIndex) || IsNewButtonPress (Buttons.Start' controllingPlayer' out playerIndex); " is 214.
Long Statement,GameStateManagement,MessageBoxScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MessageBoxScreen.cs,Draw,The length of the statement  "	Rectangle backgroundRectangle = new Rectangle ((int)textPosition.X - hPad' (int)textPosition.Y - vPad' (int)textSize.X + hPad * 2' (int)textSize.Y + vPad * 2); " is 159.
Long Statement,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,HasHigherPriority,The length of the statement  "	return (higher.Priority < lower.Priority || (Math.Abs (higher.Priority - lower.Priority) < 0.5 && higher.InsertionIndex < lower.InsertionIndex)); " is 145.
Long Statement,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,IsValidQueue,The length of the statement  "			if (childLeftIndex < _nodes.Length && _nodes [childLeftIndex] != null && HasHigherPriority (_nodes [childLeftIndex]' _nodes [i])) " is 129.
Long Statement,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,IsValidQueue,The length of the statement  "			if (childRightIndex < _nodes.Length && _nodes [childRightIndex] != null && HasHigherPriority (_nodes [childRightIndex]' _nodes [i])) " is 132.
Complex Conditional,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The conditional expression  "i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)"  is complex.
Complex Conditional,GameStateManagement,GameScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\ScreenManager\GameScreen.cs,UpdateTransition,The conditional expression  "((direction < 0) && (transitionPosition <= 0)) || ((direction > 0) && (transitionPosition >= 1))"  is complex.
Magic Number,Bomberman.Algorithms,RandomMove,C:\repos\mierzynskim_bomberman\Bomberman\Algorithms\RandomMove.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  	directions.Add ((Direction)random.Next (0' 4));  }  
Magic Number,Bomberman.Algorithms,RandomMove,C:\repos\mierzynskim_bomberman\Bomberman\Algorithms\RandomMove.cs,FindPath,The following statement contains a magic number: for (int i = 0; i < 30; i++) {  	directions.Add ((Direction)random.Next (0' 4));  }  
Magic Number,Bomberman.Algorithms,RandomMove,C:\repos\mierzynskim_bomberman\Bomberman\Algorithms\RandomMove.cs,FindPath,The following statement contains a magic number: directions.Add ((Direction)random.Next (0' 4));  
Magic Number,Bomberman.Commands,FireCommand,C:\repos\mierzynskim_bomberman\Bomberman\Commands\FireCommand.cs,Execute,The following statement contains a magic number: Thread.Sleep (DelayTime * 1000);  
Magic Number,Bomberman.Commands,GloveAction,C:\repos\mierzynskim_bomberman\Bomberman\Commands\GloveAction.cs,Execute,The following statement contains a magic number: if (actor.TreasureState.GlovesCount > 0 && delay == 4) {  	switch (direction) {  	case Direction.Up:  		while (true) {  			y = (y - 1) % GameSession.GameBoard.Height;  			if (y < 0)  				y = GameSession.GameBoard.Height - 1;  			var newUnit = GameSession.GameBoard.Units [x' y];  			if (newUnit.UnitState == State.Empty) {  				var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  				command.Execute (actor);  				break;  			}  		}  		break;  	case Direction.Down:  		while (true) {  			y = (y + 1) % GameSession.GameBoard.Height > 0 ? (y + 1) % GameSession.GameBoard.Height : 0;  			var newUnit = GameSession.GameBoard.Units [x' y];  			if (newUnit.UnitState == State.Empty) {  				var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  				command.Execute (actor);  				break;  			}  		}  		break;  	case Direction.Left:  		while (true) {  			x = (x - 1) % GameSession.GameBoard.Width;  			if (x < 0)  				x = GameSession.GameBoard.Width - 1;  			var newUnit = GameSession.GameBoard.Units [x' y];  			if (newUnit.UnitState == State.Empty) {  				var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  				command.Execute (actor);  				break;  			}  		}  		break;  	case Direction.Right:  		while (true) {  			x = (x + 1) % GameSession.GameBoard.Width > 0 ? (x + 1) % GameSession.GameBoard.Width : 0;  			var newUnit = GameSession.GameBoard.Units [x' y];  			if (newUnit.UnitState == State.Empty) {  				var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  				command.Execute (actor);  				break;  			}  		}  		break;  	}  	actor.TreasureState.GlovesCount--;  }  
Magic Number,Bomberman.Commands,GloveAction,C:\repos\mierzynskim_bomberman\Bomberman\Commands\GloveAction.cs,Execute,The following statement contains a magic number: delay = (delay + 1) % 5;  
Magic Number,Bomberman.Commands,NormalBombFire,C:\repos\mierzynskim_bomberman\Bomberman\Commands\NormalBombFire.cs,Execute,The following statement contains a magic number: GameSession.GameBoard.ResetNeighbors (GameSession.GameBoard.Units [x' y]' actor.TreasureState.IsFlame ? 2 : 1);  
Magic Number,Bomberman.Commands,PutNormalBomb,C:\repos\mierzynskim_bomberman\Bomberman\Commands\PutNormalBomb.cs,Execute,The following statement contains a magic number: if (actor.TreasureState.BombsCount > 0 && (delay == 4 || inst)) {  	GameSession.GameBoard.Units [x' y].Initialize (manager' State.NormalBomb' !inst);  	isTimerOn = true;  	var thread = new Thread (() =>  {  		Thread.Sleep (DelayTime * 1000);  		isTimerOn = false;  		var fireCommand = new NormalBombFire (manager' x' y);  		fireCommand.Execute (actor);  		Thread.CurrentThread.Abort ();  	});  	thread.Start ();  }  
Magic Number,Bomberman.Commands,PutNormalBomb,C:\repos\mierzynskim_bomberman\Bomberman\Commands\PutNormalBomb.cs,Execute,The following statement contains a magic number: if (actor.TreasureState.BombsCount > 0 && (delay == 4 || inst)) {  	GameSession.GameBoard.Units [x' y].Initialize (manager' State.NormalBomb' !inst);  	isTimerOn = true;  	var thread = new Thread (() =>  {  		Thread.Sleep (DelayTime * 1000);  		isTimerOn = false;  		var fireCommand = new NormalBombFire (manager' x' y);  		fireCommand.Execute (actor);  		Thread.CurrentThread.Abort ();  	});  	thread.Start ();  }  
Magic Number,Bomberman.Commands,PutNormalBomb,C:\repos\mierzynskim_bomberman\Bomberman\Commands\PutNormalBomb.cs,Execute,The following statement contains a magic number: Thread.Sleep (DelayTime * 1000);  
Magic Number,Bomberman.Commands,PutNormalBomb,C:\repos\mierzynskim_bomberman\Bomberman\Commands\PutNormalBomb.cs,Execute,The following statement contains a magic number: delay = (delay + 1) % 5;  
Magic Number,Bomberman.Commands,PutRemoteBomb,C:\repos\mierzynskim_bomberman\Bomberman\Commands\PutRemoteBomb.cs,Execute,The following statement contains a magic number: if (actor.TreasureState.RemoteBombsCount > 0 && delay == 4) {  	x = actor.CurrentUnit.X;  	y = actor.CurrentUnit.Y;  	actor.CurrentUnit.Initialize (manager' State.NormalBomb' true);  	RemoteBombUnits.Add (new Tuple<int' int> (x' y));  	actor.TreasureState.RemoteBombsCount--;  }  
Magic Number,Bomberman.Commands,PutRemoteBomb,C:\repos\mierzynskim_bomberman\Bomberman\Commands\PutRemoteBomb.cs,Execute,The following statement contains a magic number: delay = (delay + 1) % 5;  
Magic Number,Bomberman.Commands,RemoteBombFire,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RemoteBombFire.cs,Execute,The following statement contains a magic number: if (PutRemoteBomb.RemoteBombUnits.Count > 0) {  	var remotePosition = PutRemoteBomb.RemoteBombUnits.Last ();  	GameSession.GameBoard.Units [remotePosition.Item1' remotePosition.Item2].Initialize (manager' State.NormalBomb);  	GameSession.GameBoard.ResetNeighbors (GameSession.GameBoard.Units [remotePosition.Item1' remotePosition.Item2]' actor.TreasureState.IsFlame ? 2 : 1);  	PutRemoteBomb.RemoteBombUnits.RemoveAt (PutRemoteBomb.RemoteBombUnits.Count - 1);  }  
Magic Number,Bomberman.Commands,RemoteBombFire,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RemoteBombFire.cs,Execute,The following statement contains a magic number: GameSession.GameBoard.ResetNeighbors (GameSession.GameBoard.Units [remotePosition.Item1' remotePosition.Item2]' actor.TreasureState.IsFlame ? 2 : 1);  
Magic Number,Bomberman.Commands,RollerSkatesCommand,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RollerSkatesCommand.cs,Execute,The following statement contains a magic number: if (actor.TreasureState.IsRollerSkates) {  	var thread = new Thread (() =>  {  		previousVelocity = actor.Velocity;  		actor.Velocity = 3;  		Thread.Sleep (DelayTime * 1000);  		actor.TreasureState.IsRollerSkates = false;  		actor.Velocity = previousVelocity;  		Thread.CurrentThread.Abort ();  	});  	thread.Start ();  }  
Magic Number,Bomberman.Commands,RollerSkatesCommand,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RollerSkatesCommand.cs,Execute,The following statement contains a magic number: if (actor.TreasureState.IsRollerSkates) {  	var thread = new Thread (() =>  {  		previousVelocity = actor.Velocity;  		actor.Velocity = 3;  		Thread.Sleep (DelayTime * 1000);  		actor.TreasureState.IsRollerSkates = false;  		actor.Velocity = previousVelocity;  		Thread.CurrentThread.Abort ();  	});  	thread.Start ();  }  
Magic Number,Bomberman.Commands,RollerSkatesCommand,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RollerSkatesCommand.cs,Execute,The following statement contains a magic number: actor.Velocity = 3;  
Magic Number,Bomberman.Commands,RollerSkatesCommand,C:\repos\mierzynskim_bomberman\Bomberman\Commands\RollerSkatesCommand.cs,Execute,The following statement contains a magic number: Thread.Sleep (DelayTime * 1000);  
Magic Number,Bomberman.GameStateManagement.Screens,InputNewPlayer,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\InputNewPlayer.cs,HandleInput,The following statement contains a magic number: delay = (delay + 1) % 6;  
Magic Number,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,GameplayScreen,The following statement contains a magic number: TransitionOnTime = TimeSpan.FromSeconds (1.5);  
Magic Number,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,GameplayScreen,The following statement contains a magic number: TransitionOffTime = TimeSpan.FromSeconds (0.5);  
Magic Number,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,Update,The following statement contains a magic number: pauseAlpha = coveredByOtherScreen ? Math.Min (pauseAlpha + 1f / 32' 1) : Math.Max (pauseAlpha - 1f / 32' 0);  
Magic Number,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,Update,The following statement contains a magic number: pauseAlpha = coveredByOtherScreen ? Math.Min (pauseAlpha + 1f / 32' 1) : Math.Max (pauseAlpha - 1f / 32' 0);  
Magic Number,Bomberman.GameStateManagement.Screens,GameplayScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\GameplayScreen.cs,Draw,The following statement contains a magic number: ScreenManager.SpriteBatch.Draw (grayRectangle' new Rectangle (0' Game1.WindowWidth' Game1.WindowWidth' 66)' Color.LightGray);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var i = 0; i < Height; i++)  	for (var j = 0; j < Width; j++) {  		Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  			X = i'  			Y = j  		};  		if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  			Units [i' j].Initialize (manager' State.Concrete);  		}  		else {  			var result = rnd.Next (0' 8);  			if (result != 1)  				Units [i' j].UnitState = State.Empty;  			else {  				Units [i' j].Initialize (manager' State.Wall);  			}  		}  	}  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var i = 0; i < Height; i++)  	for (var j = 0; j < Width; j++) {  		Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  			X = i'  			Y = j  		};  		if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  			Units [i' j].Initialize (manager' State.Concrete);  		}  		else {  			var result = rnd.Next (0' 8);  			if (result != 1)  				Units [i' j].UnitState = State.Empty;  			else {  				Units [i' j].Initialize (manager' State.Wall);  			}  		}  	}  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var i = 0; i < Height; i++)  	for (var j = 0; j < Width; j++) {  		Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  			X = i'  			Y = j  		};  		if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  			Units [i' j].Initialize (manager' State.Concrete);  		}  		else {  			var result = rnd.Next (0' 8);  			if (result != 1)  				Units [i' j].UnitState = State.Empty;  			else {  				Units [i' j].Initialize (manager' State.Wall);  			}  		}  	}  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var i = 0; i < Height; i++)  	for (var j = 0; j < Width; j++) {  		Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  			X = i'  			Y = j  		};  		if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  			Units [i' j].Initialize (manager' State.Concrete);  		}  		else {  			var result = rnd.Next (0' 8);  			if (result != 1)  				Units [i' j].UnitState = State.Empty;  			else {  				Units [i' j].Initialize (manager' State.Wall);  			}  		}  	}  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var i = 0; i < Height; i++)  	for (var j = 0; j < Width; j++) {  		Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  			X = i'  			Y = j  		};  		if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  			Units [i' j].Initialize (manager' State.Concrete);  		}  		else {  			var result = rnd.Next (0' 8);  			if (result != 1)  				Units [i' j].UnitState = State.Empty;  			else {  				Units [i' j].Initialize (manager' State.Wall);  			}  		}  	}  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var j = 0; j < Width; j++) {  	Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  		X = i'  		Y = j  	};  	if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  		Units [i' j].Initialize (manager' State.Concrete);  	}  	else {  		var result = rnd.Next (0' 8);  		if (result != 1)  			Units [i' j].UnitState = State.Empty;  		else {  			Units [i' j].Initialize (manager' State.Wall);  		}  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var j = 0; j < Width; j++) {  	Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  		X = i'  		Y = j  	};  	if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  		Units [i' j].Initialize (manager' State.Concrete);  	}  	else {  		var result = rnd.Next (0' 8);  		if (result != 1)  			Units [i' j].UnitState = State.Empty;  		else {  			Units [i' j].Initialize (manager' State.Wall);  		}  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var j = 0; j < Width; j++) {  	Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  		X = i'  		Y = j  	};  	if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  		Units [i' j].Initialize (manager' State.Concrete);  	}  	else {  		var result = rnd.Next (0' 8);  		if (result != 1)  			Units [i' j].UnitState = State.Empty;  		else {  			Units [i' j].Initialize (manager' State.Wall);  		}  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var j = 0; j < Width; j++) {  	Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  		X = i'  		Y = j  	};  	if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  		Units [i' j].Initialize (manager' State.Concrete);  	}  	else {  		var result = rnd.Next (0' 8);  		if (result != 1)  			Units [i' j].UnitState = State.Empty;  		else {  			Units [i' j].Initialize (manager' State.Wall);  		}  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: for (var j = 0; j < Width; j++) {  	Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  		X = i'  		Y = j  	};  	if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  		Units [i' j].Initialize (manager' State.Concrete);  	}  	else {  		var result = rnd.Next (0' 8);  		if (result != 1)  			Units [i' j].UnitState = State.Empty;  		else {  			Units [i' j].Initialize (manager' State.Wall);  		}  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  	X = i'  	Y = j  };  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: Units [i' j] = new Unit (new Vector2 (33 * i' 33 * j)) {  	X = i'  	Y = j  };  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  	Units [i' j].Initialize (manager' State.Concrete);  }  else {  	var result = rnd.Next (0' 8);  	if (result != 1)  		Units [i' j].UnitState = State.Empty;  	else {  		Units [i' j].Initialize (manager' State.Wall);  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  	Units [i' j].Initialize (manager' State.Concrete);  }  else {  	var result = rnd.Next (0' 8);  	if (result != 1)  		Units [i' j].UnitState = State.Empty;  	else {  		Units [i' j].Initialize (manager' State.Wall);  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,Board,The following statement contains a magic number: if (i == 0 || j == 0 || (j % 2 == 0 && i % 2 == 0)) {  	Units [i' j].Initialize (manager' State.Concrete);  }  else {  	var result = rnd.Next (0' 8);  	if (result != 1)  		Units [i' j].UnitState = State.Empty;  	else {  		Units [i' j].Initialize (manager' State.Wall);  	}  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (range == 2) {  	if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X + 2' unit.Y]);  	if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X - 2' unit.Y]);  	if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y + 2]);  	if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  		neighbors.Add (Units [unit.X' unit.Y - 2]);  }  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X + 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X + 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.X + 2 < Width && Units [unit.X + 2' unit.Y].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X + 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: neighbors.Add (Units [unit.X + 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X - 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X - 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.X - 2 > 0 && Units [unit.X - 2' unit.Y].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X - 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: neighbors.Add (Units [unit.X - 2' unit.Y]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X' unit.Y + 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X' unit.Y + 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.Y + 2 < Height && Units [unit.X' unit.Y + 2].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X' unit.Y + 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: neighbors.Add (Units [unit.X' unit.Y + 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X' unit.Y - 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X' unit.Y - 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: if (unit.Y - 2 > 0 && Units [unit.X' unit.Y - 2].UnitState != State.Concrete)  	neighbors.Add (Units [unit.X' unit.Y - 2]);  
Magic Number,Bomberman.Utlis,Board,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Board.cs,GetBombRange,The following statement contains a magic number: neighbors.Add (Units [unit.X' unit.Y - 2]);  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,MoveTo,The following statement contains a magic number: if (GameSession.IsMoveValid (x' y) && actor.CurrentUnit.UnitState != State.Empty) {  	IsTreasure (x' y' actor);  	GameSession.GameBoard.Units [X' Y] = Clone ();  	Position = new Vector2 (33 * x' 33 * y);  	X = x;  	Y = y;  	var previousUnit = GameSession.GameBoard.Units [X' Y];  	if (previousUnit.UnitState == State.NormalBomb || previousUnit.UnitState == State.RemoteBomb) {  		OverlappedState = previousUnit.UnitState;  		overlappedTexture = previousUnit.texture;  	}  	else {  		OverlappedState = State.Empty;  		overlappedTexture = null;  	}  	GameSession.GameBoard.Units [X' Y] = this;  }  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,MoveTo,The following statement contains a magic number: if (GameSession.IsMoveValid (x' y) && actor.CurrentUnit.UnitState != State.Empty) {  	IsTreasure (x' y' actor);  	GameSession.GameBoard.Units [X' Y] = Clone ();  	Position = new Vector2 (33 * x' 33 * y);  	X = x;  	Y = y;  	var previousUnit = GameSession.GameBoard.Units [X' Y];  	if (previousUnit.UnitState == State.NormalBomb || previousUnit.UnitState == State.RemoteBomb) {  		OverlappedState = previousUnit.UnitState;  		overlappedTexture = previousUnit.texture;  	}  	else {  		OverlappedState = State.Empty;  		overlappedTexture = null;  	}  	GameSession.GameBoard.Units [X' Y] = this;  }  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,MoveTo,The following statement contains a magic number: Position = new Vector2 (33 * x' 33 * y);  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,MoveTo,The following statement contains a magic number: Position = new Vector2 (33 * x' 33 * y);  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The following statement contains a magic number: switch (GameSession.GameBoard.Units [x' y].UnitState) {  case State.Fire:  	var fireCommand = new FireCommand ();  	fireCommand.Execute (actor);  	actor.TreasureState.IsFlame = true;  	actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints;  	break;  case State.Glove:  	actor.TreasureState.GlovesCount++;  	actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints;  	break;  case State.RollerSkates:  	actor.TreasureState.IsRollerSkates = true;  	var command = new RollerSkatesCommand ();  	command.Execute (actor);  	break;  case State.NewRemoteBomb:  	actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints;  	actor.TreasureState.RemoteBombsCount++;  	break;  case State.Exit:  	if (actor is HumanPlayer) {  		switch (MonoGameFileSystem.Instance.CurrentPlayerSettings.Level) {  		case Level.Easy:  			if (MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  				MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked++;  			break;  		case Level.Medium:  			if (MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  				MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked++;  			break;  		case Level.Hard:  			if (MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  				MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked++;  			break;  		}  		MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage++;  		actor.LevelPoints += 100;  	}  	break;  //case State.EndlessBombs:  //    actor.TreasureState.EndlessBombs = true;  //    break;  }  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The following statement contains a magic number: if (actor is HumanPlayer) {  	switch (MonoGameFileSystem.Instance.CurrentPlayerSettings.Level) {  	case Level.Easy:  		if (MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  			MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked++;  		break;  	case Level.Medium:  		if (MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  			MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked++;  		break;  	case Level.Hard:  		if (MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  			MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked++;  		break;  	}  	MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage++;  	actor.LevelPoints += 100;  }  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The following statement contains a magic number: actor.LevelPoints += 100;  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,PlaceTreasure,The following statement contains a magic number: switch (Rnd.Next (probability)) {  case 1:  	unitState = State.Fire;  	break;  case 0:  	if (!exitVisible) {  		unitState = State.Exit;  		exitVisible = true;  	}  	break;  case 2:  	unitState = State.Glove;  	break;  case 3:  	unitState = State.RollerSkates;  	break;  case 4:  	unitState = State.NewRemoteBomb;  	break;  //case 4:  //    unitState = State.EndlessBombs;  //    break;  }  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,PlaceTreasure,The following statement contains a magic number: switch (Rnd.Next (probability)) {  case 1:  	unitState = State.Fire;  	break;  case 0:  	if (!exitVisible) {  		unitState = State.Exit;  		exitVisible = true;  	}  	break;  case 2:  	unitState = State.Glove;  	break;  case 3:  	unitState = State.RollerSkates;  	break;  case 4:  	unitState = State.NewRemoteBomb;  	break;  //case 4:  //    unitState = State.EndlessBombs;  //    break;  }  
Magic Number,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,PlaceTreasure,The following statement contains a magic number: switch (Rnd.Next (probability)) {  case 1:  	unitState = State.Fire;  	break;  case 0:  	if (!exitVisible) {  		unitState = State.Exit;  		exitVisible = true;  	}  	break;  case 2:  	unitState = State.Glove;  	break;  case 3:  	unitState = State.RollerSkates;  	break;  case 4:  	unitState = State.NewRemoteBomb;  	break;  //case 4:  //    unitState = State.EndlessBombs;  //    break;  }  
Magic Number,Bomberman.Players,GameActor,C:\repos\mierzynskim_bomberman\Bomberman\Players\GameActor.cs,GameActor,The following statement contains a magic number: Velocity = 5;  
Magic Number,Bomberman.Players,ComputerPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\ComputerPlayer.cs,ComputerPlayer,The following statement contains a magic number: Velocity = 10;  
Magic Number,Bomberman.Players,ComputerPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\ComputerPlayer.cs,Move,The following statement contains a magic number: if (Delay == Velocity / 2) {  	switch (direction) {  	case Direction.Down:  		CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y + 1' this);  		break;  	case Direction.Up:  		CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y - 1' this);  		break;  	case Direction.Left:  		CurrentUnit.MoveTo (CurrentUnit.X - 1' CurrentUnit.Y' this);  		break;  	case Direction.Right:  		CurrentUnit.MoveTo (CurrentUnit.X + 1' CurrentUnit.Y' this);  		break;  	}  	if (Directions.Count > 0)  		Directions.RemoveAt (Directions.Count - 1);  }  
Magic Number,Bomberman.Players,HumanPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\HumanPlayer.cs,HumanPlayer,The following statement contains a magic number: Velocity = 5;  
Magic Number,Bomberman.Players,HumanPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\HumanPlayer.cs,Move,The following statement contains a magic number: if (Delay == Velocity / 2) {  	if (CurrentUnit.UnitState == State.Empty)  		GameOver (this' new PlayerIndexEventArgs (PlayerIndex.One));  	Changed (this' new EventArgs ());  	switch (direction) {  	case Direction.Down:  		CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y + 1' this);  		break;  	case Direction.Up:  		CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y - 1' this);  		break;  	case Direction.Left:  		CurrentUnit.MoveTo (CurrentUnit.X - 1' CurrentUnit.Y' this);  		break;  	case Direction.Right:  		CurrentUnit.MoveTo (CurrentUnit.X + 1' CurrentUnit.Y' this);  		break;  	}  }  
Magic Number,Bomberman,Game1,C:\repos\mierzynskim_bomberman\Bomberman\Game1.cs,Game1,The following statement contains a magic number: WindowHeight = 33 * 22;  
Magic Number,Bomberman,Game1,C:\repos\mierzynskim_bomberman\Bomberman\Game1.cs,Game1,The following statement contains a magic number: WindowHeight = 33 * 22;  
Magic Number,Bomberman,Game1,C:\repos\mierzynskim_bomberman\Bomberman\Game1.cs,Game1,The following statement contains a magic number: WindowWidth = 33 * 20;  
Magic Number,Bomberman,Game1,C:\repos\mierzynskim_bomberman\Bomberman\Game1.cs,Game1,The following statement contains a magic number: WindowWidth = 33 * 20;  
Magic Number,Bomberman,GameSession,C:\repos\mierzynskim_bomberman\Bomberman\GameSession.cs,GameSession,The following statement contains a magic number: GameBoard = new Board (20' 20' contentManager);  
Magic Number,Bomberman,GameSession,C:\repos\mierzynskim_bomberman\Bomberman\GameSession.cs,GameSession,The following statement contains a magic number: GameBoard = new Board (20' 20' contentManager);  
Magic Number,GameStateManagement,BackgroundScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\BackgroundScreen.cs,BackgroundScreen,The following statement contains a magic number: TransitionOnTime = TimeSpan.FromSeconds (0.5);  
Magic Number,GameStateManagement,BackgroundScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\BackgroundScreen.cs,BackgroundScreen,The following statement contains a magic number: TransitionOffTime = TimeSpan.FromSeconds (0.5);  
Magic Number,GameStateManagement,LoadingScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\LoadingScreen.cs,LoadingScreen,The following statement contains a magic number: TransitionOnTime = TimeSpan.FromSeconds (0.5);  
Magic Number,GameStateManagement,LoadingScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\LoadingScreen.cs,Draw,The following statement contains a magic number: if (loadingIsSlow) {  	SpriteBatch spriteBatch = ScreenManager.SpriteBatch;  	SpriteFont font = ScreenManager.Font;  	const string message = "Loading...";  	// Center the text in the viewport.  	Viewport viewport = ScreenManager.GraphicsDevice.Viewport;  	Vector2 viewportSize = new Vector2 (viewport.Width' viewport.Height);  	Vector2 textSize = font.MeasureString (message);  	Vector2 textPosition = (viewportSize - textSize) / 2;  	Color color = Color.White * TransitionAlpha;  	// Draw the text.  	spriteBatch.Begin ();  	spriteBatch.DrawString (font' message' textPosition' color);  	spriteBatch.End ();  }  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,MenuScreen,The following statement contains a magic number: TransitionOnTime = TimeSpan.FromSeconds (0.5);  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,MenuScreen,The following statement contains a magic number: TransitionOffTime = TimeSpan.FromSeconds (0.5);  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: for (int i = 0; i < menuEntries.Count; i++) {  	MenuEntry menuEntry = menuEntries [i];  	// each entry is to be centered horizontally  	position.X = ScreenManager.GraphicsDevice.Viewport.Width / 2 - menuEntry.GetWidth (this) / 2;  	if (ScreenState == ScreenState.TransitionOn)  		position.X -= transitionOffset * 256;  	else  		position.X += transitionOffset * 512;  	// set the entry's position  	menuEntry.Position = position;  	// move down for the next entry the size of this entry  	position.Y += menuEntry.GetHeight (this);  }  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: for (int i = 0; i < menuEntries.Count; i++) {  	MenuEntry menuEntry = menuEntries [i];  	// each entry is to be centered horizontally  	position.X = ScreenManager.GraphicsDevice.Viewport.Width / 2 - menuEntry.GetWidth (this) / 2;  	if (ScreenState == ScreenState.TransitionOn)  		position.X -= transitionOffset * 256;  	else  		position.X += transitionOffset * 512;  	// set the entry's position  	menuEntry.Position = position;  	// move down for the next entry the size of this entry  	position.Y += menuEntry.GetHeight (this);  }  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: for (int i = 0; i < menuEntries.Count; i++) {  	MenuEntry menuEntry = menuEntries [i];  	// each entry is to be centered horizontally  	position.X = ScreenManager.GraphicsDevice.Viewport.Width / 2 - menuEntry.GetWidth (this) / 2;  	if (ScreenState == ScreenState.TransitionOn)  		position.X -= transitionOffset * 256;  	else  		position.X += transitionOffset * 512;  	// set the entry's position  	menuEntry.Position = position;  	// move down for the next entry the size of this entry  	position.Y += menuEntry.GetHeight (this);  }  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: for (int i = 0; i < menuEntries.Count; i++) {  	MenuEntry menuEntry = menuEntries [i];  	// each entry is to be centered horizontally  	position.X = ScreenManager.GraphicsDevice.Viewport.Width / 2 - menuEntry.GetWidth (this) / 2;  	if (ScreenState == ScreenState.TransitionOn)  		position.X -= transitionOffset * 256;  	else  		position.X += transitionOffset * 512;  	// set the entry's position  	menuEntry.Position = position;  	// move down for the next entry the size of this entry  	position.Y += menuEntry.GetHeight (this);  }  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: position.X = ScreenManager.GraphicsDevice.Viewport.Width / 2 - menuEntry.GetWidth (this) / 2;  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: position.X = ScreenManager.GraphicsDevice.Viewport.Width / 2 - menuEntry.GetWidth (this) / 2;  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: if (ScreenState == ScreenState.TransitionOn)  	position.X -= transitionOffset * 256;  else  	position.X += transitionOffset * 512;  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: if (ScreenState == ScreenState.TransitionOn)  	position.X -= transitionOffset * 256;  else  	position.X += transitionOffset * 512;  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: position.X -= transitionOffset * 256;  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,UpdateMenuEntryLocations,The following statement contains a magic number: position.X += transitionOffset * 512;  
Magic Number,GameStateManagement,MenuScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MenuScreen.cs,Draw,The following statement contains a magic number: titlePosition.Y -= transitionOffset * 100;  
Magic Number,GameStateManagement,MessageBoxScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MessageBoxScreen.cs,MessageBoxScreen,The following statement contains a magic number: TransitionOnTime = TimeSpan.FromSeconds (0.2);  
Magic Number,GameStateManagement,MessageBoxScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MessageBoxScreen.cs,MessageBoxScreen,The following statement contains a magic number: TransitionOffTime = TimeSpan.FromSeconds (0.2);  
Magic Number,GameStateManagement,MessageBoxScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MessageBoxScreen.cs,Draw,The following statement contains a magic number: ScreenManager.FadeBackBufferToBlack (TransitionAlpha * 2 / 3);  
Magic Number,GameStateManagement,MessageBoxScreen,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\MessageBoxScreen.cs,Draw,The following statement contains a magic number: ScreenManager.FadeBackBufferToBlack (TransitionAlpha * 2 / 3);  
Magic Number,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,CascadeUp,The following statement contains a magic number: while (parent >= 1) {  	T parentNode = _nodes [parent];  	if (HasHigherPriority (parentNode' node))  		break;  	//Node has lower priority value' so move it up the heap  	Swap (node' parentNode);  	//For some reason' this is faster with Swap() rather than (less..?) individual operations' like in CascadeDown()  	parent = node.QueueIndex / 2;  }  
Magic Number,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,CascadeUp,The following statement contains a magic number: parent = node.QueueIndex / 2;  
Magic Number,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,CascadeDown,The following statement contains a magic number: while (true) {  	newParent = node;  	int childLeftIndex = 2 * finalQueueIndex;  	//Check if the left-child is higher-priority than the current node  	if (childLeftIndex > _numNodes) {  		//This could be placed outside the loop' but then we'd have to check newParent != node twice  		node.QueueIndex = finalQueueIndex;  		_nodes [finalQueueIndex] = node;  		break;  	}  	T childLeft = _nodes [childLeftIndex];  	if (HasHigherPriority (childLeft' newParent)) {  		newParent = childLeft;  	}  	//Check if the right-child is higher-priority than either the current node or the left child  	int childRightIndex = childLeftIndex + 1;  	if (childRightIndex <= _numNodes) {  		T childRight = _nodes [childRightIndex];  		if (HasHigherPriority (childRight' newParent)) {  			newParent = childRight;  		}  	}  	//If either of the children has higher (smaller) priority' swap and continue cascading  	if (newParent != node) {  		//Move new parent to its new index.  node will be moved once' at the end  		//Doing it this way is one less assignment operation than calling Swap()  		_nodes [finalQueueIndex] = newParent;  		int temp = newParent.QueueIndex;  		newParent.QueueIndex = finalQueueIndex;  		finalQueueIndex = temp;  	}  	else {  		//See note above  		node.QueueIndex = finalQueueIndex;  		_nodes [finalQueueIndex] = node;  		break;  	}  }  
Magic Number,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,HasHigherPriority,The following statement contains a magic number: return (higher.Priority < lower.Priority || (Math.Abs (higher.Priority - lower.Priority) < 0.5 && higher.InsertionIndex < lower.InsertionIndex));  
Magic Number,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,IsValidQueue,The following statement contains a magic number: for (int i = 1; i < _nodes.Length; i++) {  	if (_nodes [i] != null) {  		int childLeftIndex = 2 * i;  		if (childLeftIndex < _nodes.Length && _nodes [childLeftIndex] != null && HasHigherPriority (_nodes [childLeftIndex]' _nodes [i]))  			return false;  		int childRightIndex = childLeftIndex + 1;  		if (childRightIndex < _nodes.Length && _nodes [childRightIndex] != null && HasHigherPriority (_nodes [childRightIndex]' _nodes [i]))  			return false;  	}  }  
Magic Number,Priority_Queue,HeapPriorityQueue,C:\repos\mierzynskim_bomberman\Bomberman\PriorityQueue\HeapPriorityQueue.cs,IsValidQueue,The following statement contains a magic number: if (_nodes [i] != null) {  	int childLeftIndex = 2 * i;  	if (childLeftIndex < _nodes.Length && _nodes [childLeftIndex] != null && HasHigherPriority (_nodes [childLeftIndex]' _nodes [i]))  		return false;  	int childRightIndex = childLeftIndex + 1;  	if (childRightIndex < _nodes.Length && _nodes [childRightIndex] != null && HasHigherPriority (_nodes [childRightIndex]' _nodes [i]))  		return false;  }  
Missing Default,Bomberman.Commands,GloveAction,C:\repos\mierzynskim_bomberman\Bomberman\Commands\GloveAction.cs,Execute,The following switch statement is missing a default case: switch (direction) {  case Direction.Up:  	while (true) {  		y = (y - 1) % GameSession.GameBoard.Height;  		if (y < 0)  			y = GameSession.GameBoard.Height - 1;  		var newUnit = GameSession.GameBoard.Units [x' y];  		if (newUnit.UnitState == State.Empty) {  			var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  			command.Execute (actor);  			break;  		}  	}  	break;  case Direction.Down:  	while (true) {  		y = (y + 1) % GameSession.GameBoard.Height > 0 ? (y + 1) % GameSession.GameBoard.Height : 0;  		var newUnit = GameSession.GameBoard.Units [x' y];  		if (newUnit.UnitState == State.Empty) {  			var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  			command.Execute (actor);  			break;  		}  	}  	break;  case Direction.Left:  	while (true) {  		x = (x - 1) % GameSession.GameBoard.Width;  		if (x < 0)  			x = GameSession.GameBoard.Width - 1;  		var newUnit = GameSession.GameBoard.Units [x' y];  		if (newUnit.UnitState == State.Empty) {  			var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  			command.Execute (actor);  			break;  		}  	}  	break;  case Direction.Right:  	while (true) {  		x = (x + 1) % GameSession.GameBoard.Width > 0 ? (x + 1) % GameSession.GameBoard.Width : 0;  		var newUnit = GameSession.GameBoard.Units [x' y];  		if (newUnit.UnitState == State.Empty) {  			var command = new PutNormalBomb (manager' newUnit.X' newUnit.Y' true);  			command.Execute (actor);  			break;  		}  	}  	break;  }  
Missing Default,Bomberman.GameStateManagement.Screens,LevelsUnlocked,C:\repos\mierzynskim_bomberman\Bomberman\GameStateManagement\Screens\LevelsUnlocked.cs,LevelsUnlocked,The following switch statement is missing a default case: switch (MonoGameFileSystem.Instance.CurrentPlayerSettings.Level) {  case Level.Easy:  	stagesCount = MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked;  	break;  case Level.Medium:  	stagesCount = MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked;  	break;  case Level.Hard:  	stagesCount = MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked;  	break;  }  
Missing Default,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The following switch statement is missing a default case: switch (GameSession.GameBoard.Units [x' y].UnitState) {  case State.Fire:  	var fireCommand = new FireCommand ();  	fireCommand.Execute (actor);  	actor.TreasureState.IsFlame = true;  	actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints;  	break;  case State.Glove:  	actor.TreasureState.GlovesCount++;  	actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints;  	break;  case State.RollerSkates:  	actor.TreasureState.IsRollerSkates = true;  	var command = new RollerSkatesCommand ();  	command.Execute (actor);  	break;  case State.NewRemoteBomb:  	actor.LevelPoints += LevelConsts.LevelProperties [MonoGameFileSystem.Instance.CurrentPlayerSettings.Level].TreasureFoundPoints;  	actor.TreasureState.RemoteBombsCount++;  	break;  case State.Exit:  	if (actor is HumanPlayer) {  		switch (MonoGameFileSystem.Instance.CurrentPlayerSettings.Level) {  		case Level.Easy:  			if (MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  				MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked++;  			break;  		case Level.Medium:  			if (MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  				MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked++;  			break;  		case Level.Hard:  			if (MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  				MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked++;  			break;  		}  		MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage++;  		actor.LevelPoints += 100;  	}  	break;  //case State.EndlessBombs:  //    actor.TreasureState.EndlessBombs = true;  //    break;  }  
Missing Default,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,IsTreasure,The following switch statement is missing a default case: switch (MonoGameFileSystem.Instance.CurrentPlayerSettings.Level) {  case Level.Easy:  	if (MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  		MonoGameFileSystem.Instance.CurrentPlayerSettings.EasyLevelsUnlocked++;  	break;  case Level.Medium:  	if (MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  		MonoGameFileSystem.Instance.CurrentPlayerSettings.MediumLevelsUnlocked++;  	break;  case Level.Hard:  	if (MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked <= MonoGameFileSystem.Instance.CurrentPlayerSettings.Stage)  		MonoGameFileSystem.Instance.CurrentPlayerSettings.HardLevelsUnlocked++;  	break;  }  
Missing Default,Bomberman.Utlis,Unit,C:\repos\mierzynskim_bomberman\Bomberman\Utlis\Unit.cs,PlaceTreasure,The following switch statement is missing a default case: switch (Rnd.Next (probability)) {  case 1:  	unitState = State.Fire;  	break;  case 0:  	if (!exitVisible) {  		unitState = State.Exit;  		exitVisible = true;  	}  	break;  case 2:  	unitState = State.Glove;  	break;  case 3:  	unitState = State.RollerSkates;  	break;  case 4:  	unitState = State.NewRemoteBomb;  	break;  //case 4:  //    unitState = State.EndlessBombs;  //    break;  }  
Missing Default,Bomberman.Players,ComputerPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\ComputerPlayer.cs,Move,The following switch statement is missing a default case: switch (direction) {  case Direction.Down:  	CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y + 1' this);  	break;  case Direction.Up:  	CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y - 1' this);  	break;  case Direction.Left:  	CurrentUnit.MoveTo (CurrentUnit.X - 1' CurrentUnit.Y' this);  	break;  case Direction.Right:  	CurrentUnit.MoveTo (CurrentUnit.X + 1' CurrentUnit.Y' this);  	break;  }  
Missing Default,Bomberman.Players,HumanPlayer,C:\repos\mierzynskim_bomberman\Bomberman\Players\HumanPlayer.cs,Move,The following switch statement is missing a default case: switch (direction) {  case Direction.Down:  	CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y + 1' this);  	break;  case Direction.Up:  	CurrentUnit.MoveTo (CurrentUnit.X' CurrentUnit.Y - 1' this);  	break;  case Direction.Left:  	CurrentUnit.MoveTo (CurrentUnit.X - 1' CurrentUnit.Y' this);  	break;  case Direction.Right:  	CurrentUnit.MoveTo (CurrentUnit.X + 1' CurrentUnit.Y' this);  	break;  }  
