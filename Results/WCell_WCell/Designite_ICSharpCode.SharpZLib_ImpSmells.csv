Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The method has 105 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The method has 189 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,Finish,The method has 113 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The method has 178 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,RunUpdates,The method has 126 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The method has 147 lines of code.
Long Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The method has 148 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The method has 147 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The method has 311 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,QSort3,The method has 123 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The method has 187 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method has 123 lines of code.
Long Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The method has 153 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The method has 116 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The method has 121 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The method has 103 lines of code.
Long Method,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The method has 108 lines of code.
Complex Method,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Adler32.cs,Update,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,Cyclomatic complexity of the method is 30
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,Finish,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestArchive,Cyclomatic complexity of the method is 18
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLocalEntryHeader,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,Cyclomatic complexity of the method is 16
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,RunUpdates,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,ExtractEntry,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLocalHeader,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,Cyclomatic complexity of the method is 28
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,HbCreateDecodeTables,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,Cyclomatic complexity of the method is 58
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SimpleSort,Cyclomatic complexity of the method is 15
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,QSort3,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,Cyclomatic complexity of the method is 22
Complex Method,ICSharpCode.SharpZipLib.Tar,TarOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarOutputStream.cs,Write,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarInputStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,InternalWriteEntry,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.SharpZipLib.Core,FileSystemScanner,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Core\FileSystemScanner.cs,ScanDir,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Core\StreamUtils.cs,Copy,Cyclomatic complexity of the method is 11
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,CopyBytes,The method has 5 parameters. Parameters: update' destination' source' bytesToCopy' updateCrc
Long Parameter List,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,CopyEntryDataDirect,The method has 5 parameters. Parameters: update' stream' updateCrc' destinationPosition' sourcePosition
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters. Parameters: zipFileName' sourceDirectory' recurse' fileFilter' directoryFilter
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,CreateZip,The method has 5 parameters. Parameters: outputStream' sourceDirectory' recurse' fileFilter' directoryFilter
Long Parameter List,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,ExtractZip,The method has 7 parameters. Parameters: zipFileName' targetDirectory' overwrite' confirmDelegate' fileFilter' directoryFilter' restoreDateTime
Long Parameter List,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,HbCreateDecodeTables,The method has 7 parameters. Parameters: limit' baseArray' perm' length' minLen' maxLen' alphaSize
Long Parameter List,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbAssignCodes,The method has 5 parameters. Parameters: code' length' minLen' maxLen' alphaSize
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters. Parameters: name' nameOffset' buffer' bufferOffset' length
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarHeader.cs,GetNameBytes,The method has 5 parameters. Parameters: name' nameOffset' buffer' bufferOffset' length
Long Parameter List,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarHeader.cs,GetAsciiBytes,The method has 5 parameters. Parameters: toAdd' nameOffset' buffer' bufferOffset' length
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,DeflaterOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\DeflaterOutputStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,ICSharpCode.SharpZipLib.Core,ExtendedPathFilter,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Core\PathFilter.cs,ExtendedPathFilter,The method has 5 parameters. Parameters: filter' minSize' maxSize' minDate' maxDate
Long Parameter List,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Core\StreamUtils.cs,Copy,The method has 7 parameters. Parameters: source' destination' buffer' progressHandler' updateInterval' sender' name
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicEncryptCryptoTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,ICSharpCode.SharpZipLib.Encryption,PkzipClassicDecryptCryptoTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,TransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipConstants.cs,,The length of the parameter Zip64CentralFileHeaderSignature is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipConstants.cs,,The length of the parameter Zip64CentralDirLocatorSignature is 31.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipConstants,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipConstants.cs,,The length of the parameter EndOfCentralDirectorySignature is 30.
Long Identifier,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The length of the parameter CentralHeaderCommentSizeOffset is 30.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The length of the statement  "			if (method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))) { " is 143.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) { " is 162.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) { " is 139.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 128.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The length of the statement  "							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion)); " is 128.
Long Statement,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The length of the statement  "				long offset = LocateBlockWithSignature(ZipConstants.Zip64CentralDirLocatorSignature' locatedEndOfCentralDir' 0' 0x1000); " is 120.
Long Statement,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The length of the statement  "				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals " is 124.
Long Statement,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The length of the statement  "						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) { " is 121.
Long Statement,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The length of the statement  "						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff))); " is 125.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "				string errorText = string.Format("TarBuffer.WriteBlock - block to write has length '{0}' which is not the block size of '{1}'"' " is 127.
Long Statement,ICSharpCode.SharpZipLib.Tar,TarBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarBuffer.cs,WriteBlock,The length of the statement  "				string errorText = string.Format("TarBuffer.WriteBlock - record has length '{0}' with offset '{1}' which is less than the record size of '{2}'"' " is 144.
Long Statement,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The length of the statement  "						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) { " is 123.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "header == ZipConstants.CentralHeaderSignature ||  				header == ZipConstants.EndOfCentralDirectorySignature ||  				header == ZipConstants.CentralHeaderDigitalSignature ||  				header == ZipConstants.ArchiveExtraDataSignature ||  				header == ZipConstants.Zip64CentralFileHeaderSignature"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The conditional expression  "method == (int)CompressionMethod.Stored && (!isCrypted && csize != size || (isCrypted && csize - ZipConstants.CryptoHeaderSize != size))"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The conditional expression  "(extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The conditional expression  "(thisDiskNumber == 0xffff) ||  				(startCentralDirDisk == 0xffff) ||  				(entriesForThisDisk == 0xffff) ||  				(entriesForWholeCentralDir == 0xffff) ||  				(centralDirSize == 0xffffffff) ||  				(offsetOfCentralDir == 0xffffffff)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,Initialize,The conditional expression  "magic1 != 'B' || magic2 != 'Z' || magic3 != 'h' || magic4 < '1' || magic4 > '9'"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic1 == 0x17 && magic2 == 0x72 && magic3 == 0x45 && magic4 == 0x38 && magic5 == 0x50 && magic6 == 0x90"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,InitBlock,The conditional expression  "magic1 != 0x31 || magic2 != 0x41 || magic3 != 0x59 || magic4 != 0x26 || magic5 != 0x53 || magic6 != 0x59"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The conditional expression  "!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The conditional expression  "ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The conditional expression  "block == null || quadrant == null || zptr == null  || ftab == null"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,IsBinary,The conditional expression  "(b < 8) || ((b > 13) && (b < 32)) || (b == 255)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[curMatch + best_len] != scan_end      ||   					window[curMatch + best_len - 1] != scan_end1 ||   					window[curMatch] != window[scan]             ||   					window[curMatch + 1] != window[scan + 1]"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The conditional expression  "window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&  					(scan < strend)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateStored,The conditional expression  "(storedLength >= DeflaterConstants.MAX_BLOCK_SIZE) || // Block is full  				(blockStart < WSIZE && storedLength >= MAX_DIST) ||   // Block may move out of window  				flush"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The conditional expression  "lookahead >= MIN_MATCH &&   					(hashHead = InsertString()) != 0 &&   					strategy != DeflateStrategy.HuffmanOnly &&  					strstart - hashHead <= MAX_DIST &&   					FindLongestMatch(hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= MAX_DIST &&  						FindLongestMatch(hashHead)"  is complex.
Complex Conditional,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The conditional expression  "matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))"  is complex.
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) + s1;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: uint s2 = checksum >> 16;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: while (count > 0) {  				// We can defer the modulo operation:  				// s1 maximally grows from 65521 to 65521 + 255 * 3800  				// s2 maximally grows by 3800 * median(s1) = 2090079800 < 2^31  				int n = 3800;  				if (n > count) {  					n = count;  				}  				count -= n;  				while (--n >= 0) {  					s1 = s1 + (uint)(buffer[offset++] & 0xff);  					s2 = s2 + s1;  				}  				s1 %= BASE;  				s2 %= BASE;  			}
Magic Number,ICSharpCode.SharpZipLib.Checksums,Adler32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Adler32.cs,Update,The following statement contains a magic number: checksum = (s2 << 16) | s1;
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Crc32.cs,ComputeCrc32,The following statement contains a magic number: return (uint)(Crc32.CrcTable[(oldCrc ^ value) & 0xFF] ^ (oldCrc >> 8));
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Crc32.cs,Update,The following statement contains a magic number: crc  = CrcTable[(crc ^ value) & 0xFF] ^ (crc >> 8);
Magic Number,ICSharpCode.SharpZipLib.Checksums,Crc32,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\Crc32.cs,Update,The following statement contains a magic number: while (--count >= 0) {  				crc = CrcTable[(crc ^ buffer[offset++]) & 0xFF] ^ (crc >> 8);  			}
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\StrangeCrc.cs,Update,The following statement contains a magic number: int temp = (globalCrc >> 24) ^ value;
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\StrangeCrc.cs,Update,The following statement contains a magic number: if (temp < 0) {  				temp = 256 + temp;  			}
Magic Number,ICSharpCode.SharpZipLib.Checksums,StrangeCRC,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Checksums\StrangeCrc.cs,Update,The following statement contains a magic number: globalCrc = unchecked((int)((globalCrc << 8) ^ crc32Table[temp]));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ZipEntry,The following statement contains a magic number: if ( (versionRequiredToExtract != 0) && (versionRequiredToExtract < 10) ) {  				throw new ArgumentOutOfRangeException("versionRequiredToExtract");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(0x0001) ) {  				if ( (versionToExtract & 0xff) < ZipConstants.VersionZip64 ) {  					throw new ZipException("Zip64 Extended information found but version is not valid");  				}    				// The recorded size will change but remember that this is zip64.  				forceZip64_ = true;    				if ( extraData.ValueLength < 4 ) {  					throw new ZipException("Extra data extended Zip64 information length is invalid");  				}    				if ( localHeader || (size == uint.MaxValue) ) {  					size = (ulong)extraData.ReadLong();  				}    				if ( localHeader || (compressedSize == uint.MaxValue) ) {  					compressedSize = (ulong)extraData.ReadLong();  				}    				if ( !localHeader && (offset == uint.MaxValue) ) {  					offset = extraData.ReadLong();  				}  			}  			else {  				if (   					((versionToExtract & 0xff) >= ZipConstants.VersionZip64) &&  					((size == uint.MaxValue) || (compressedSize == uint.MaxValue))  				) {  					throw new ZipException("Zip64 Extended information required but is missing.");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(10) ) {  				// No room for any tags.  				if ( extraData.ValueLength < 8 ) {  					throw new ZipException("NTFS Extra data invalid");  				}    				extraData.ReadInt(); // Reserved    				while ( extraData.UnreadCount >= 4 ) {  					int ntfsTag = extraData.ReadShort();  					int ntfsLength = extraData.ReadShort();  					if ( ntfsTag == 1 ) {  						if ( ntfsLength >= 24 ) {  							long lastModification = extraData.ReadLong();  							long lastAccess = extraData.ReadLong();  							long createTime = extraData.ReadLong();    							DateTime = System.DateTime.FromFileTime(lastModification);  						}  						break;  					}  					else {  						// An unknown NTFS tag so simply skip it.  						extraData.Skip(ntfsLength);  					}  				}  			}  			else if ( extraData.Find(0x5455) ) {  				int length = extraData.ValueLength;	  				int flags = extraData.ReadByte();  					  				// Can include other times but these are ignored.  Length of data should  				// actually be 1 + 4 * no of bits in flags.  				if ( ((flags & 1) != 0) && (length >= 5) ) {  					int iTime = extraData.ReadInt();    					DateTime = (new System.DateTime ( 1970' 1' 1' 0' 0' 0 ).ToUniversalTime() +  						new TimeSpan ( 0' 0' 0' iTime' 0 )).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(10) ) {  				// No room for any tags.  				if ( extraData.ValueLength < 8 ) {  					throw new ZipException("NTFS Extra data invalid");  				}    				extraData.ReadInt(); // Reserved    				while ( extraData.UnreadCount >= 4 ) {  					int ntfsTag = extraData.ReadShort();  					int ntfsLength = extraData.ReadShort();  					if ( ntfsTag == 1 ) {  						if ( ntfsLength >= 24 ) {  							long lastModification = extraData.ReadLong();  							long lastAccess = extraData.ReadLong();  							long createTime = extraData.ReadLong();    							DateTime = System.DateTime.FromFileTime(lastModification);  						}  						break;  					}  					else {  						// An unknown NTFS tag so simply skip it.  						extraData.Skip(ntfsLength);  					}  				}  			}  			else if ( extraData.Find(0x5455) ) {  				int length = extraData.ValueLength;	  				int flags = extraData.ReadByte();  					  				// Can include other times but these are ignored.  Length of data should  				// actually be 1 + 4 * no of bits in flags.  				if ( ((flags & 1) != 0) && (length >= 5) ) {  					int iTime = extraData.ReadInt();    					DateTime = (new System.DateTime ( 1970' 1' 1' 0' 0' 0 ).ToUniversalTime() +  						new TimeSpan ( 0' 0' 0' iTime' 0 )).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(10) ) {  				// No room for any tags.  				if ( extraData.ValueLength < 8 ) {  					throw new ZipException("NTFS Extra data invalid");  				}    				extraData.ReadInt(); // Reserved    				while ( extraData.UnreadCount >= 4 ) {  					int ntfsTag = extraData.ReadShort();  					int ntfsLength = extraData.ReadShort();  					if ( ntfsTag == 1 ) {  						if ( ntfsLength >= 24 ) {  							long lastModification = extraData.ReadLong();  							long lastAccess = extraData.ReadLong();  							long createTime = extraData.ReadLong();    							DateTime = System.DateTime.FromFileTime(lastModification);  						}  						break;  					}  					else {  						// An unknown NTFS tag so simply skip it.  						extraData.Skip(ntfsLength);  					}  				}  			}  			else if ( extraData.Find(0x5455) ) {  				int length = extraData.ValueLength;	  				int flags = extraData.ReadByte();  					  				// Can include other times but these are ignored.  Length of data should  				// actually be 1 + 4 * no of bits in flags.  				if ( ((flags & 1) != 0) && (length >= 5) ) {  					int iTime = extraData.ReadInt();    					DateTime = (new System.DateTime ( 1970' 1' 1' 0' 0' 0 ).ToUniversalTime() +  						new TimeSpan ( 0' 0' 0' iTime' 0 )).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(10) ) {  				// No room for any tags.  				if ( extraData.ValueLength < 8 ) {  					throw new ZipException("NTFS Extra data invalid");  				}    				extraData.ReadInt(); // Reserved    				while ( extraData.UnreadCount >= 4 ) {  					int ntfsTag = extraData.ReadShort();  					int ntfsLength = extraData.ReadShort();  					if ( ntfsTag == 1 ) {  						if ( ntfsLength >= 24 ) {  							long lastModification = extraData.ReadLong();  							long lastAccess = extraData.ReadLong();  							long createTime = extraData.ReadLong();    							DateTime = System.DateTime.FromFileTime(lastModification);  						}  						break;  					}  					else {  						// An unknown NTFS tag so simply skip it.  						extraData.Skip(ntfsLength);  					}  				}  			}  			else if ( extraData.Find(0x5455) ) {  				int length = extraData.ValueLength;	  				int flags = extraData.ReadByte();  					  				// Can include other times but these are ignored.  Length of data should  				// actually be 1 + 4 * no of bits in flags.  				if ( ((flags & 1) != 0) && (length >= 5) ) {  					int iTime = extraData.ReadInt();    					DateTime = (new System.DateTime ( 1970' 1' 1' 0' 0' 0 ).ToUniversalTime() +  						new TimeSpan ( 0' 0' 0' iTime' 0 )).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(10) ) {  				// No room for any tags.  				if ( extraData.ValueLength < 8 ) {  					throw new ZipException("NTFS Extra data invalid");  				}    				extraData.ReadInt(); // Reserved    				while ( extraData.UnreadCount >= 4 ) {  					int ntfsTag = extraData.ReadShort();  					int ntfsLength = extraData.ReadShort();  					if ( ntfsTag == 1 ) {  						if ( ntfsLength >= 24 ) {  							long lastModification = extraData.ReadLong();  							long lastAccess = extraData.ReadLong();  							long createTime = extraData.ReadLong();    							DateTime = System.DateTime.FromFileTime(lastModification);  						}  						break;  					}  					else {  						// An unknown NTFS tag so simply skip it.  						extraData.Skip(ntfsLength);  					}  				}  			}  			else if ( extraData.Find(0x5455) ) {  				int length = extraData.ValueLength;	  				int flags = extraData.ReadByte();  					  				// Can include other times but these are ignored.  Length of data should  				// actually be 1 + 4 * no of bits in flags.  				if ( ((flags & 1) != 0) && (length >= 5) ) {  					int iTime = extraData.ReadInt();    					DateTime = (new System.DateTime ( 1970' 1' 1' 0' 0' 0 ).ToUniversalTime() +  						new TimeSpan ( 0' 0' 0' iTime' 0 )).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntry.cs,ProcessExtraData,The following statement contains a magic number: if ( extraData.Find(10) ) {  				// No room for any tags.  				if ( extraData.ValueLength < 8 ) {  					throw new ZipException("NTFS Extra data invalid");  				}    				extraData.ReadInt(); // Reserved    				while ( extraData.UnreadCount >= 4 ) {  					int ntfsTag = extraData.ReadShort();  					int ntfsLength = extraData.ReadShort();  					if ( ntfsTag == 1 ) {  						if ( ntfsLength >= 24 ) {  							long lastModification = extraData.ReadLong();  							long lastAccess = extraData.ReadLong();  							long createTime = extraData.ReadLong();    							DateTime = System.DateTime.FromFileTime(lastModification);  						}  						break;  					}  					else {  						// An unknown NTFS tag so simply skip it.  						extraData.Skip(ntfsLength);  					}  				}  			}  			else if ( extraData.Find(0x5455) ) {  				int length = extraData.ValueLength;	  				int flags = extraData.ReadByte();  					  				// Can include other times but these are ignored.  Length of data should  				// actually be 1 + 4 * no of bits in flags.  				if ( ((flags & 1) != 0) && (length >= 5) ) {  					int iTime = extraData.ReadInt();    					DateTime = (new System.DateTime ( 1970' 1' 1' 0' 0' 0 ).ToUniversalTime() +  						new TimeSpan ( 0' 0' 0' iTime' 0 )).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  				entry.Crc  = crc2 & 0xFFFFFFFFL;  				entry.Size = size & 0xFFFFFFFFL;  				entry.CompressedSize = csize & 0xFFFFFFFFL;    				entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);    			} else {  				  				// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  				// says these values are zero under these circumstances.  				if (crc2 != 0) {  					entry.Crc = crc2 & 0xFFFFFFFFL;  				}  				  				if (size != 0) {  					entry.Size = size & 0xFFFFFFFFL;  				}    				if (csize != 0) {  					entry.CompressedSize = csize & 0xFFFFFFFFL;  				}    				entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  				entry.Crc  = crc2 & 0xFFFFFFFFL;  				entry.Size = size & 0xFFFFFFFFL;  				entry.CompressedSize = csize & 0xFFFFFFFFL;    				entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);    			} else {  				  				// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  				// says these values are zero under these circumstances.  				if (crc2 != 0) {  					entry.Crc = crc2 & 0xFFFFFFFFL;  				}  				  				if (size != 0) {  					entry.Size = size & 0xFFFFFFFFL;  				}    				if (csize != 0) {  					entry.CompressedSize = csize & 0xFFFFFFFFL;  				}    				entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,GetNextEntry,The following statement contains a magic number: if ((flags & 8) == 0) {  				entry.Crc  = crc2 & 0xFFFFFFFFL;  				entry.Size = size & 0xFFFFFFFFL;  				entry.CompressedSize = csize & 0xFFFFFFFFL;    				entry.CryptoCheckValue = (byte)((crc2 >> 24) & 0xff);    			} else {  				  				// This allows for GNU' WinZip and possibly other archives' the PKZIP spec  				// says these values are zero under these circumstances.  				if (crc2 != 0) {  					entry.Crc = crc2 & 0xFFFFFFFFL;  				}  				  				if (size != 0) {  					entry.Size = size & 0xFFFFFFFFL;  				}    				if (csize != 0) {  					entry.CompressedSize = csize & 0xFFFFFFFFL;  				}    				entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,CompleteCloseEntry,The following statement contains a magic number: if ((flags & 8) != 0) {  				ReadDataDescriptor();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  				if ((flags & 8) != 0) {  					// We don't know how much we must skip' read until end.  					byte[] tmp = new byte[2048];    					// Read will close this entry  					while (Read(tmp' 0' tmp.Length) > 0) {  					}  					return;  				}    				csize -= inf.TotalIn;  				inputBuffer.Available += inf.RemainingInput;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,CloseEntry,The following statement contains a magic number: if (method == (int)CompressionMethod.Deflated) {  				if ((flags & 8) != 0) {  					// We don't know how much we must skip' read until end.  					byte[] tmp = new byte[2048];    					// Read will close this entry  					while (Read(tmp' 0' tmp.Length) > 0) {  					}  					return;  				}    				csize -= inf.TotalIn;  				inputBuffer.Available += inf.RemainingInput;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following statement contains a magic number: switch (method) {  				case (int)CompressionMethod.Deflated:  					count = base.Read(buffer' offset' count);  					if (count <= 0) {  						if (!inf.IsFinished) {  							throw new ZipException("Inflater not finished!");  						}  						inputBuffer.Available = inf.RemainingInput;  						  						if ((flags & 8) == 0 && (inf.TotalIn != csize || inf.TotalOut != size)) {  							throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  						}  						inf.Reset();  						finished = true;  					}  					break;  					  				case (int)CompressionMethod.Stored:  					if ( (count > csize) && (csize >= 0) ) {  						count = (int)csize;  					}  					  					if ( count > 0 ) {  						count = inputBuffer.ReadClearTextBuffer(buffer' offset' count);  						if (count > 0) {  							csize -= count;  							size -= count;  						}  					}  					  					if (csize == 0) {  						finished = true;  					} else {  						if (count < 0) {  							throw new ZipException("EOF in stored block");  						}  					}  					break;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,WriteLeShort,The following statement contains a magic number: unchecked {  				baseOutputStream_.WriteByte((byte)(value & 0xff));  				baseOutputStream_.WriteByte((byte)((value >> 8) & 0xff));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,WriteLeInt,The following statement contains a magic number: unchecked {  				WriteLeShort(value);  				WriteLeShort(value >> 16);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,WriteLeLong,The following statement contains a magic number: unchecked {  				WriteLeInt((int)value);  				WriteLeInt((int)(value >> 32));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (method == CompressionMethod.Stored) {  				// Cant store values in a data descriptor as you cant extract stored files  				// if the length isnt known.  				entry.Flags &= ~8;  				if (entry.CompressedSize >= 0) {  					if (entry.Size < 0) {  						entry.Size = entry.CompressedSize;  					} else if (entry.Size != entry.CompressedSize) {  						throw new ZipException("Method STORED' but compressed size != size");  					}  				} else {  					if (entry.Size >= 0) {  						entry.CompressedSize = entry.Size;  					}  				}  					  				if (entry.Size < 0 || entry.Crc < 0) {  					if (CanPatchEntries == true) {  						headerInfoAvailable = false;  					}  					else {  						// Can't patch entries so storing is not possible.  						method = CompressionMethod.Deflated;  						compressionLevel = 0;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (headerInfoAvailable == false) {  				if (CanPatchEntries == false) {  					// Only way to record size and compressed size is to append a data descriptor  					// after compressed data.  					entry.Flags |= 8;  				} else {  					patchEntryHeader = true;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (Password != null) {  				entry.IsCrypted = true;  				if (entry.Crc < 0) {  					// Need to append a data descriptor as the crc isnt available for use  					// with encryption' the date is used instead.  Setting the flag  					// indicates this to the decompressor.  					entry.Flags |= 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,PutNextEntry,The following statement contains a magic number: if (entry.IsCrypted == true) {  				if (entry.Crc < 0) {			// so testing Zip will says its ok  					WriteEncryptionHeader(entry.DosTime << 16);  				} else {  					WriteEncryptionHeader(entry.Crc);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,CloseEntry,The following statement contains a magic number: if ((curEntry.Flags & 8) != 0) {  				WriteLeInt(ZipConstants.DataDescriptorSignature);  				WriteLeInt(unchecked((int)curEntry.Crc));  				  				if ( curEntry.LocalHeaderRequiresZip64 ) {  					WriteLeLong(curEntry.CompressedSize);  					WriteLeLong(curEntry.Size);  					offset += ZipConstants.Zip64DataDescriptorSize;  				}  				else {  					WriteLeInt((int)curEntry.CompressedSize);  					WriteLeInt((int)curEntry.Size);  					offset += ZipConstants.DataDescriptorSize;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,CopyAndEncrypt,The following statement contains a magic number: const int CopyBufferSize = 4096;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,Finish,The following statement contains a magic number: foreach (ZipEntry entry in entries) {  				WriteLeInt(ZipConstants.CentralHeaderSignature);   				WriteLeShort(ZipConstants.VersionMadeBy);  				WriteLeShort(entry.Version);  				WriteLeShort(entry.Flags);  				WriteLeShort((short)entry.CompressionMethod);  				WriteLeInt((int)entry.DosTime);  				WriteLeInt((int)entry.Crc);    				if ( entry.IsZip64Forced() ||   					(entry.CompressedSize >= uint.MaxValue) )  				{  					WriteLeInt(-1);  				}  				else {  					WriteLeInt((int)entry.CompressedSize);  				}    				if ( entry.IsZip64Forced() ||  					(entry.Size >= uint.MaxValue) )  				{  					WriteLeInt(-1);  				}  				else {  					WriteLeInt((int)entry.Size);  				}    				byte[] name = ZipConstants.ConvertToArray(entry.Flags' entry.Name);  				  				if (name.Length > 0xffff) {  					throw new ZipException("Name too long.");  				}  				  				ZipExtraData ed = new ZipExtraData(entry.ExtraData);    				if ( entry.CentralHeaderRequiresZip64 ) {  					ed.StartNewEntry();  					if ( entry.IsZip64Forced() ||  						(entry.Size >= 0xffffffff) )  					{  						ed.AddLeLong(entry.Size);  					}    					if ( entry.IsZip64Forced() ||  						(entry.CompressedSize >= 0xffffffff) )  					{  						ed.AddLeLong(entry.CompressedSize);  					}    					if ( entry.Offset >= 0xffffffff )  					{  						ed.AddLeLong(entry.Offset);  					}    					ed.AddNewEntry(1);  				}  				else {  					ed.Delete(1);  				}    				byte[] extra = ed.GetEntryData();  				  				byte[] entryComment =   					(entry.Comment != null) ?   					ZipConstants.ConvertToArray(entry.Flags' entry.Comment) :  					new byte[0];    				if (entryComment.Length > 0xffff) {  					throw new ZipException("Comment too long.");  				}  				  				WriteLeShort(name.Length);  				WriteLeShort(extra.Length);  				WriteLeShort(entryComment.Length);  				WriteLeShort(0);	// disk number  				WriteLeShort(0);	// internal file attributes  									// external file attributes    				if (entry.ExternalFileAttributes != -1) {  					WriteLeInt(entry.ExternalFileAttributes);  				} else {  					if (entry.IsDirectory) {                         // mark entry as directory (from nikolam.AT.perfectinfo.com)  						WriteLeInt(16);  					} else {  						WriteLeInt(0);  					}  				}    				if ( entry.Offset >= uint.MaxValue ) {  					WriteLeInt(-1);  				}  				else {  					WriteLeInt((int)entry.Offset);  				}  				  				if ( name.Length > 0 ) {  					baseOutputStream_.Write(name'    0' name.Length);  				}    				if ( extra.Length > 0 ) {  					baseOutputStream_.Write(extra'   0' extra.Length);  				}    				if ( entryComment.Length > 0 ) {  					baseOutputStream_.Write(entryComment' 0' entryComment.Length);  				}    				sizeEntries += ZipConstants.CentralHeaderBaseSize + name.Length + extra.Length + entryComment.Length;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestArchive,The following statement contains a magic number: try {  				int entryIndex = 0;    				while ( testing && (entryIndex < Count) ) {  					if ( resultHandler != null ) {  						status.SetEntry(this[entryIndex]);  						status.SetOperation(TestOperation.EntryHeader);  						resultHandler(status' null);  					}    					try	{  						TestLocalHeader(this[entryIndex]' test);  					}  					catch(ZipException ex) {  						status.AddError();    						if ( resultHandler != null ) {  							resultHandler(status'  								string.Format("Exception during test - '{0}'"' ex.Message));  						}    						if ( strategy == TestStrategy.FindFirstError ) {  							testing = false;   						}  					}    					if ( testing && testData && this[entryIndex].IsFile ) {  						if ( resultHandler != null ) {  							status.SetOperation(TestOperation.EntryData);  							resultHandler(status' null);  						}    						Stream entryStream = this.GetInputStream(this[entryIndex]);  						  						Crc32 crc = new Crc32();  						byte[] buffer = new byte[4096];  						long totalBytes = 0;  						int bytesRead;  						while ((bytesRead = entryStream.Read(buffer' 0' buffer.Length)) > 0) {  							crc.Update(buffer' 0' bytesRead);    							if ( resultHandler != null ) {  								totalBytes += bytesRead;  								status.SetBytesTested(totalBytes);  								resultHandler(status' null);  							}  						}  	  						if (this[entryIndex].Crc != crc.Value) {  							status.AddError();  							  							if ( resultHandler != null ) {  								resultHandler(status' "CRC mismatch");  							}    							if ( strategy == TestStrategy.FindFirstError ) {  								testing = false;  							}  						}    						if (( this[entryIndex].Flags & (int)GeneralBitFlags.Descriptor) != 0 ) {  							ZipHelperStream helper = new ZipHelperStream(baseStream_);  							DescriptorData data = new DescriptorData();  							helper.ReadDataDescriptor(this[entryIndex].LocalHeaderRequiresZip64' data);  							if (this[entryIndex].Crc != data.Crc) {  								status.AddError();  							}    							if (this[entryIndex].CompressedSize != data.CompressedSize) {  								status.AddError();  							}    							if (this[entryIndex].Size != data.Size) {  								status.AddError();  							}  						}  					}    					if ( resultHandler != null ) {  						status.SetOperation(TestOperation.EntryComplete);  						resultHandler(status' null);  					}    					entryIndex += 1;  				}    				if ( resultHandler != null ) {  					status.SetOperation(TestOperation.MiscellaneousTests);  					resultHandler(status' null);  				}    				// TODO: the 'Corrina Johns' test where local headers are missing from  				// the central directory.  They are therefore invisible to many archivers.  			}  			catch (Exception ex) {  				status.AddError();    				if ( resultHandler != null ) {  					resultHandler(status' string.Format("Exception during test - '{0}'"' ex.Message));  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,TestLocalHeader,The following statement contains a magic number: lock(baseStream_)   			{  				bool testHeader = (tests & HeaderTest.Header) != 0;  				bool testData = (tests & HeaderTest.Extract) != 0;    				baseStream_.Seek(offsetOfFirstEntry + entry.Offset' SeekOrigin.Begin);  				if ((int)ReadLEUint() != ZipConstants.LocalHeaderSignature) {  					throw new ZipException(string.Format("Wrong local header signature @{0:X}"' offsetOfFirstEntry + entry.Offset));  				}    				short extractVersion = ( short )ReadLEUshort();  				short localFlags = ( short )ReadLEUshort();  				short compressionMethod = ( short )ReadLEUshort();  				short fileTime = ( short )ReadLEUshort();  				short fileDate = ( short )ReadLEUshort();  				uint crcValue = ReadLEUint();  				long compressedSize = ReadLEUint();  				long size = ReadLEUint();  				int storedNameLength = ReadLEUshort();  				int extraDataLength = ReadLEUshort();    				byte[] nameData = new byte[storedNameLength];  				StreamUtils.ReadFully(baseStream_' nameData);    				byte[] extraData = new byte[extraDataLength];  				StreamUtils.ReadFully(baseStream_' extraData);    				ZipExtraData ed = new ZipExtraData(extraData);    				// Extra data / zip64 checks  				if (ed.Find(1))  				{  					// TODO Check for tag values being distinct..  Multiple zip64 tags means what?    					// Zip64 extra data but 'extract version' is too low  					if (extractVersion < ZipConstants.VersionZip64)  					{  						throw new ZipException(  							string.Format("Extra data contains Zip64 information but version {0}.{1} is not high enough"'  							extractVersion / 10' extractVersion % 10));  					}    					// Zip64 extra data but size fields dont indicate its required.  					if (((uint)size != uint.MaxValue) && ((uint)compressedSize != uint.MaxValue))  					{  						throw new ZipException("Entry sizes not correct for Zip64");  					}    					size = ed.ReadLong();  					compressedSize = ed.ReadLong();  				}  				else  				{  					// No zip64 extra data but entry requires it.  					if ((extractVersion >= ZipConstants.VersionZip64) &&  						(((uint)size == uint.MaxValue) || ((uint)compressedSize == uint.MaxValue)))  					{  						throw new ZipException("Required Zip64 extended information missing");  					}  				}    				if ( testData ) {  					if ( entry.IsFile ) {  						if ( !entry.IsCompressionMethodSupported() ) {  							throw new ZipException("Compression method not supported");  						}    						if ( (extractVersion > ZipConstants.VersionMadeBy)  							|| ((extractVersion > 20) && (extractVersion < ZipConstants.VersionZip64)) ) {  							throw new ZipException(string.Format("Version required to extract this entry not supported ({0})"' extractVersion));  						}    						if ( (localFlags & ( int )(GeneralBitFlags.Patched | GeneralBitFlags.StrongEncryption | GeneralBitFlags.EnhancedCompress | GeneralBitFlags.HeaderMasked)) != 0 ) {  							throw new ZipException("The library does not support the zip version required to extract this entry");  						}  					}  				}    				if ( testHeader ) {  					if ((extractVersion <= 63) &&	// Ignore later versions as we dont know about them..  						(extractVersion != 10) &&  						(extractVersion != 11) &&  						(extractVersion != 20) &&  						(extractVersion != 21) &&  						(extractVersion != 25) &&  						(extractVersion != 27) &&  						(extractVersion != 45) &&  						(extractVersion != 46) &&  						(extractVersion != 50) &&  						(extractVersion != 51) &&  						(extractVersion != 52) &&  						(extractVersion != 61) &&  						(extractVersion != 62) &&  						(extractVersion != 63)  						) {  						throw new ZipException(string.Format("Version required to extract this entry is invalid ({0})"' extractVersion));  					}    					// Local entry flags dont have reserved bit set on.  					if ( (localFlags & ( int )(GeneralBitFlags.ReservedPKware4 | GeneralBitFlags.ReservedPkware14 | GeneralBitFlags.ReservedPkware15)) != 0 ) {  						throw new ZipException("Reserved bit flags cannot be set.");  					}    					// Encryption requires extract version >= 20  					if ( ((localFlags & ( int )GeneralBitFlags.Encrypted) != 0) && (extractVersion < 20) ) {  						throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  					}    					// Strong encryption requires encryption flag to be set and extract version >= 50.  					if ( (localFlags & (int)GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( (localFlags & (int)GeneralBitFlags.Encrypted) == 0 ) {  							throw new ZipException("Strong encryption flag set but encryption flag is not set");  						}    						if ( extractVersion < 50 ) {  							throw new ZipException(string.Format("Version required to extract this entry is too low for encryption ({0})"' extractVersion));  						}  					}    					// Patched entries require extract version >= 27  					if ( ((localFlags & ( int )GeneralBitFlags.Patched) != 0) && (extractVersion < 27) ) {  						throw new ZipException(string.Format("Patched data requires higher version than ({0})"' extractVersion));  					}    					// Central header flags match local entry flags.  					if ( localFlags != entry.Flags ) {  						throw new ZipException("Central header/local header flags mismatch");  					}    					// Central header compression method matches local entry  					if ( entry.CompressionMethod != ( CompressionMethod )compressionMethod ) {  						throw new ZipException("Central header/local header compression method mismatch");  					}    					// Strong encryption and extract version match  					if ( (localFlags & ( int )GeneralBitFlags.StrongEncryption) != 0 ) {  						if ( extractVersion < 62 ) {  							throw new ZipException("Strong encryption flag set but version not high enough");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.HeaderMasked) != 0 ) {  						if ( (fileTime != 0) || (fileDate != 0) ) {  							throw new ZipException("Header masked set but date/time values non-zero");  						}  					}    					if ( (localFlags & ( int )GeneralBitFlags.Descriptor) == 0 ) {  						if ( crcValue != (uint)entry.Crc ) {  							throw new ZipException("Central header/local header crc mismatch");  						}  					}    					// Crc valid for empty entry.  					// This will also apply to streamed entries where size isnt known and the header cant be patched  					if ( (size == 0) && (compressedSize == 0) ) {  						if ( crcValue != 0 ) {  							throw new ZipException("Invalid CRC for empty entry");  						}  					}    					// TODO: make test more correct...  can't compare lengths as was done originally as this can fail for MBCS strings  					// Assuming a code page at this point is not valid?  Best is to store the name length in the ZipEntry probably  					if ( entry.Name.Length > storedNameLength ) {  						throw new ZipException("File name length mismatch");  					}    					// Name data has already been read convert it and compare.  					string localName = ZipConstants.ConvertToStringExt(localFlags' nameData);    					// Central directory and local entry name match  					if ( localName != entry.Name ) {  						throw new ZipException("Central header and local header file name mismatch");  					}    					// Directories have zero size.  					if ( entry.IsDirectory ) {  						if ( (compressedSize != 0) || (size != 0) ) {  							throw new ZipException("Directory cannot have size");  						}  					}    					if ( !ZipNameTransform.IsValidName(localName' true) ) {  						throw new ZipException("Name is invalid");  					}    				}    				// Tests that apply to both data and header.    				// Size can be verified only if it is known in the local header.  				// it will always be known in the central header.  				if ((localFlags & (int)GeneralBitFlags.Descriptor) == 0 ||  					(size != 0 || compressedSize != 0)) {    					if (size != entry.Size) {  						throw new ZipException(  							string.Format("Size mismatch between central header({0}) and local header({1})"'  								entry.Size' size));  					}    					if (compressedSize != entry.CompressedSize) {  						throw new ZipException(  							string.Format("Compressed size mismatch between central header({0}) and local header({1})"'  							entry.CompressedSize' compressedSize));  					}  				}    				int extraLength = storedNameLength + extraDataLength;  				return offsetOfFirstEntry + entry.Offset + ZipConstants.LocalHeaderBaseSize + extraLength;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLEShort,The following statement contains a magic number: baseStream_.WriteByte(( byte )((value >> 8) & 0xff));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLEUshort,The following statement contains a magic number: baseStream_.WriteByte(( byte )(value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort(value >> 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort((ushort)(value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLeLong,The following statement contains a magic number: WriteLEInt(( int )(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint(( uint )(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteCentralDirectoryHeader,The following statement contains a magic number: if ( entry.ExternalFileAttributes != -1 ) {  				WriteLEInt(entry.ExternalFileAttributes);  			}  			else {  				if ( entry.IsDirectory ) {  					WriteLEUint(16);  				}  				else {  					WriteLEUint(0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ( (update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				result = ZipConstants.DataDescriptorSize - 4;  				if ( update.Entry.LocalHeaderRequiresZip64 ) {  					result = ZipConstants.Zip64DataDescriptorSize - 4;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,GetDescriptorSize,The following statement contains a magic number: if ( (update.Entry.Flags & (int)GeneralBitFlags.Descriptor) != 0) {  				result = ZipConstants.DataDescriptorSize - 4;  				if ( update.Entry.LocalHeaderRequiresZip64 ) {  					result = ZipConstants.Zip64DataDescriptorSize - 4;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,GetOutputStream,The following statement contains a magic number: switch ( entry.CompressionMethod ) {  				case CompressionMethod.Stored:  					result = new UncompressedStream(result);  					break;    				case CompressionMethod.Deflated:  					DeflaterOutputStream dos = new DeflaterOutputStream(result' new Deflater(9' true));  					dos.IsStreamOwner = false;  					result = dos;  					break;    				default:  					throw new ZipException("Unknown compression method " + entry.CompressionMethod);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,CopyEntryDirect,The following statement contains a magic number: const int NameLengthOffset = 26;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,CopyEntry,The following statement contains a magic number: if ( update.Entry.CompressedSize > 0 ) {  				const int NameLengthOffset = 26;    				long entryDataOffset = update.Entry.Offset + NameLengthOffset;    				// TODO: This wont work for SFX files!  				baseStream_.Seek(entryDataOffset' SeekOrigin.Begin);    				uint nameLength = ReadLEUshort();  				uint extraLength = ReadLEUshort();    				baseStream_.Seek(nameLength + extraLength' SeekOrigin.Current);    				CopyBytes(update' workFile.baseStream_' baseStream_' update.Entry.CompressedSize' false);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,UpdateCommentOnly,The following statement contains a magic number: using ( updateFile ) {  				long locatedCentralDirOffset =   					updateFile.LocateBlockWithSignature(ZipConstants.EndOfCentralDirectorySignature'   														baseLength' ZipConstants.EndOfCentralRecordBaseSize' 0xffff);  				if ( locatedCentralDirOffset < 0 ) {  					throw new ZipException("Cannot find central directory");  				}    				const int CentralHeaderCommentSizeOffset = 16;  				updateFile.Position += CentralHeaderCommentSizeOffset;    				byte[] rawComment = newComment_.RawComment;    				updateFile.WriteLEShort(rawComment.Length);  				updateFile.Write(rawComment' 0' rawComment.Length);  				updateFile.SetLength(updateFile.Position);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadLEUshort,The following statement contains a magic number: return unchecked((ushort)((ushort)data1 | (ushort)(data2 << 8)));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadLEUint,The following statement contains a magic number: return (uint)(ReadLEUshort() | (ReadLEUshort() << 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadLEUlong,The following statement contains a magic number: return ReadLEUint() | ((ulong)ReadLEUint() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ( !isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize)) ) {  				offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  				if (offsetOfFirstEntry <= 0) {  					throw new ZipException("Invalid embedded zip archive");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: if ( !isZip64 && (offsetOfCentralDir < locatedEndOfCentralDir - (4 + (long)centralDirSize)) ) {  				offsetOfFirstEntry = locatedEndOfCentralDir - (4 + (long)centralDirSize + offsetOfCentralDir);  				if (offsetOfFirstEntry <= 0) {  					throw new ZipException("Invalid embedded zip archive");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  				if (ReadLEUint() != ZipConstants.CentralHeaderSignature) {  					throw new ZipException("Wrong Central Directory signature");  				}  				  				int versionMadeBy      = ReadLEUshort();  				int versionToExtract   = ReadLEUshort();  				int bitFlags           = ReadLEUshort();  				int method             = ReadLEUshort();  				uint dostime           = ReadLEUint();  				uint crc               = ReadLEUint();  				long csize             = (long)ReadLEUint();  				long size              = (long)ReadLEUint();  				int nameLen            = ReadLEUshort();  				int extraLen           = ReadLEUshort();  				int commentLen         = ReadLEUshort();  				  				int diskStartNo        = ReadLEUshort();  // Not currently used  				int internalAttributes = ReadLEUshort();  // Not currently used    				uint externalAttributes = ReadLEUint();  				long offset             = ReadLEUint();  				  				byte[] buffer = new byte[Math.Max(nameLen' commentLen)];  				  				StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);  				string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);  				  				ZipEntry entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod)method);  				entry.Crc = crc & 0xffffffffL;  				entry.Size = size & 0xffffffffL;  				entry.CompressedSize = csize & 0xffffffffL;  				entry.Flags = bitFlags;  				entry.DosTime = (uint)dostime;  				entry.ZipFileIndex = (long)i;  				entry.Offset = offset;  				entry.ExternalFileAttributes = (int)externalAttributes;    				if ((bitFlags & 8) == 0) {  					entry.CryptoCheckValue = (byte)(crc >> 24);  				}  				else {  					entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  				}    				if (extraLen > 0) {  					byte[] extra = new byte[extraLen];  					StreamUtils.ReadFully(baseStream_' extra);  					entry.ExtraData = extra;  				}    				entry.ProcessExtraData(false);  				  				if (commentLen > 0) {  					StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);  					entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);  				}  				  				entries_[i] = entry;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  				if (ReadLEUint() != ZipConstants.CentralHeaderSignature) {  					throw new ZipException("Wrong Central Directory signature");  				}  				  				int versionMadeBy      = ReadLEUshort();  				int versionToExtract   = ReadLEUshort();  				int bitFlags           = ReadLEUshort();  				int method             = ReadLEUshort();  				uint dostime           = ReadLEUint();  				uint crc               = ReadLEUint();  				long csize             = (long)ReadLEUint();  				long size              = (long)ReadLEUint();  				int nameLen            = ReadLEUshort();  				int extraLen           = ReadLEUshort();  				int commentLen         = ReadLEUshort();  				  				int diskStartNo        = ReadLEUshort();  // Not currently used  				int internalAttributes = ReadLEUshort();  // Not currently used    				uint externalAttributes = ReadLEUint();  				long offset             = ReadLEUint();  				  				byte[] buffer = new byte[Math.Max(nameLen' commentLen)];  				  				StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);  				string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);  				  				ZipEntry entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod)method);  				entry.Crc = crc & 0xffffffffL;  				entry.Size = size & 0xffffffffL;  				entry.CompressedSize = csize & 0xffffffffL;  				entry.Flags = bitFlags;  				entry.DosTime = (uint)dostime;  				entry.ZipFileIndex = (long)i;  				entry.Offset = offset;  				entry.ExternalFileAttributes = (int)externalAttributes;    				if ((bitFlags & 8) == 0) {  					entry.CryptoCheckValue = (byte)(crc >> 24);  				}  				else {  					entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  				}    				if (extraLen > 0) {  					byte[] extra = new byte[extraLen];  					StreamUtils.ReadFully(baseStream_' extra);  					entry.ExtraData = extra;  				}    				entry.ProcessExtraData(false);  				  				if (commentLen > 0) {  					StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);  					entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);  				}  				  				entries_[i] = entry;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,ReadEntries,The following statement contains a magic number: for (ulong i = 0; i < entriesForThisDisk; i++) {  				if (ReadLEUint() != ZipConstants.CentralHeaderSignature) {  					throw new ZipException("Wrong Central Directory signature");  				}  				  				int versionMadeBy      = ReadLEUshort();  				int versionToExtract   = ReadLEUshort();  				int bitFlags           = ReadLEUshort();  				int method             = ReadLEUshort();  				uint dostime           = ReadLEUint();  				uint crc               = ReadLEUint();  				long csize             = (long)ReadLEUint();  				long size              = (long)ReadLEUint();  				int nameLen            = ReadLEUshort();  				int extraLen           = ReadLEUshort();  				int commentLen         = ReadLEUshort();  				  				int diskStartNo        = ReadLEUshort();  // Not currently used  				int internalAttributes = ReadLEUshort();  // Not currently used    				uint externalAttributes = ReadLEUint();  				long offset             = ReadLEUint();  				  				byte[] buffer = new byte[Math.Max(nameLen' commentLen)];  				  				StreamUtils.ReadFully(baseStream_' buffer' 0' nameLen);  				string name = ZipConstants.ConvertToStringExt(bitFlags' buffer' nameLen);  				  				ZipEntry entry = new ZipEntry(name' versionToExtract' versionMadeBy' (CompressionMethod)method);  				entry.Crc = crc & 0xffffffffL;  				entry.Size = size & 0xffffffffL;  				entry.CompressedSize = csize & 0xffffffffL;  				entry.Flags = bitFlags;  				entry.DosTime = (uint)dostime;  				entry.ZipFileIndex = (long)i;  				entry.Offset = offset;  				entry.ExternalFileAttributes = (int)externalAttributes;    				if ((bitFlags & 8) == 0) {  					entry.CryptoCheckValue = (byte)(crc >> 24);  				}  				else {  					entry.CryptoCheckValue = (byte)((dostime >> 8) & 0xff);  				}    				if (extraLen > 0) {  					byte[] extra = new byte[extraLen];  					StreamUtils.ReadFully(baseStream_' extra);  					entry.ExtraData = extra;  				}    				entry.ProcessExtraData(false);  				  				if (commentLen > 0) {  					StreamUtils.ReadFully(baseStream_' buffer' 0' commentLen);  					entry.Comment = ZipConstants.ConvertToStringExt(bitFlags' buffer' commentLen);  				}  				  				entries_[i] = entry;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ( (entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				PkzipClassicManaged classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  				// which doesnt do this.  				result = new CryptoStream(new UncompressedStream(baseStream)'  					classicManaged.CreateEncryptor(key' null)' CryptoStreamMode.Write);    				if ( (entry.Crc < 0) || (entry.Flags & 8) != 0) {  					WriteEncryptionHeader(result' entry.DosTime << 16);  				}  				else {  					WriteEncryptionHeader(result' entry.Crc);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,CreateAndInitEncryptionStream,The following statement contains a magic number: if ( (entry.Version < ZipConstants.VersionStrongEncryption)  				|| (entry.Flags & (int)GeneralBitFlags.StrongEncryption) == 0) {  				PkzipClassicManaged classicManaged = new PkzipClassicManaged();    				OnKeysRequired(entry.Name);  				if (HaveKeys == false) {  					throw new ZipException("No password available for encrypted stream");  				}    				// Closing a CryptoStream will close the base stream as well so wrap it in an UncompressedStream  				// which doesnt do this.  				result = new CryptoStream(new UncompressedStream(baseStream)'  					classicManaged.CreateEncryptor(key' null)' CryptoStreamMode.Write);    				if ( (entry.Crc < 0) || (entry.Flags & 8) != 0) {  					WriteEncryptionHeader(result' entry.DosTime << 16);  				}  				else {  					WriteEncryptionHeader(result' entry.Crc);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteEncryptionHeader,The following statement contains a magic number: cryptBuffer[11] = (byte)(crcValue >> 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,MakeTemporaryCopy,The following statement contains a magic number: StreamUtils.Copy(stream' temporaryStream_' new byte[4096]);
Magic Number,ICSharpCode.SharpZipLib.Zip,MemoryArchiveStorage,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,OpenForDirectUpdate,The following statement contains a magic number: if ((stream == null) || !stream.CanWrite) {    				result = new MemoryStream();    				if (stream != null) {  					stream.Position = 0;  					StreamUtils.Copy(stream' result' new byte[4096]);    					stream.Close();  				}  			}  			else {  				result = stream;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,AddFileContents,The following statement contains a magic number: if ( buffer_ == null ) {  				buffer_ = new byte[4096];  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,FastZip,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\FastZip.cs,ExtractFileEntry,The following statement contains a magic number: if ( proceed ) {  				if ( events_ != null ) {  					continueRunning_ = events_.OnProcessFile(entry.Name);  				}  			  				if ( continueRunning_ ) {  					try {  						using ( FileStream outputStream = File.Create(targetName) ) {  							if ( buffer_ == null ) {  								buffer_ = new byte[4096];  							}  							if ((events_ != null) && (events_.Progress != null))  							{  								StreamUtils.Copy(zipFile_.GetInputStream(entry)' outputStream' buffer_'  									events_.Progress' events_.ProgressInterval' this' entry.Name);  							}  							else  							{  								StreamUtils.Copy(zipFile_.GetInputStream(entry)' outputStream' buffer_);  							}  							  							if (events_ != null) {  								continueRunning_ = events_.OnCompletedFile(entry.Name);  							}  						}    #if !NETCF_1_0 && !NETCF_2_0  						if ( restoreDateTimeOnExtract_ ) {  							File.SetLastWriteTime(targetName' entry.DateTime);  						}  						  						if ( RestoreAttributesOnExtract && entry.IsDOSEntry && (entry.ExternalFileAttributes != -1)) {  							FileAttributes fileAttributes = (FileAttributes) entry.ExternalFileAttributes;  							// TODO: FastZip - Setting of other file attributes on extraction is a little trickier.  							fileAttributes &= (FileAttributes.Archive | FileAttributes.Normal | FileAttributes.ReadOnly | FileAttributes.Hidden);  							File.SetAttributes(targetName' fileAttributes);  						}  #endif						  					}  					catch(Exception ex) {  						if ( events_ != null ) {  							continueRunning_ = events_.OnFileFailure(targetName' ex);  						}  						else {  							continueRunning_ = false;  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: int howMany = invalidPathChars.Length + 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryCharsRelaxed[howMany - 2] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: howMany = invalidPathChars.Length + 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 2] = '\\';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 3] = '*';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipNameTransform,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipNameTransform.cs,ZipNameTransform,The following statement contains a magic number: InvalidEntryChars[howMany - 4] = '?';
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteZip64EndOfCentralDirectory,The following statement contains a magic number: WriteLELong(44);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,ReadLEShort,The following statement contains a magic number: return byteValue1 | (byteValue2 << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,ReadLEInt,The following statement contains a magic number: return ReadLEShort() | (ReadLEShort() << 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,ReadLELong,The following statement contains a magic number: return (uint)ReadLEInt() | ((long)ReadLEInt() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLEShort,The following statement contains a magic number: stream_.WriteByte(( byte )((value >> 8) & 0xff));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUshort,The following statement contains a magic number: stream_.WriteByte(( byte )(value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLEInt,The following statement contains a magic number: WriteLEShort(value >> 16);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUint,The following statement contains a magic number: WriteLEUshort(( ushort )(value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLELong,The following statement contains a magic number: WriteLEInt(( int )(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteLEUlong,The following statement contains a magic number: WriteLEUint(( uint )(value >> 32));
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)  			{  				// The signature is not PKZIP originally but is now described as optional  				// in the PKZIP Appnote documenting trhe format.  				WriteLEInt(ZipConstants.DataDescriptorSignature);  				WriteLEInt(unchecked((int)(entry.Crc)));    				result+=8;    				if (entry.LocalHeaderRequiresZip64)  				{  					WriteLELong(entry.CompressedSize);  					WriteLELong(entry.Size);  					result+=16;  				}  				else  				{  					WriteLEInt((int)entry.CompressedSize);  					WriteLEInt((int)entry.Size);  					result+=8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)  			{  				// The signature is not PKZIP originally but is now described as optional  				// in the PKZIP Appnote documenting trhe format.  				WriteLEInt(ZipConstants.DataDescriptorSignature);  				WriteLEInt(unchecked((int)(entry.Crc)));    				result+=8;    				if (entry.LocalHeaderRequiresZip64)  				{  					WriteLELong(entry.CompressedSize);  					WriteLELong(entry.Size);  					result+=16;  				}  				else  				{  					WriteLEInt((int)entry.CompressedSize);  					WriteLEInt((int)entry.Size);  					result+=8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipHelperStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipHelperStream.cs,WriteDataDescriptor,The following statement contains a magic number: if ((entry.Flags & (int)GeneralBitFlags.Descriptor) != 0)  			{  				// The signature is not PKZIP originally but is now described as optional  				// in the PKZIP Appnote documenting trhe format.  				WriteLEInt(ZipConstants.DataDescriptorSignature);  				WriteLEInt(unchecked((int)(entry.Crc)));    				result+=8;    				if (entry.LocalHeaderRequiresZip64)  				{  					WriteLELong(entry.CompressedSize);  					WriteLELong(entry.Size);  					result+=16;  				}  				else  				{  					WriteLEInt((int)entry.CompressedSize);  					WriteLEInt((int)entry.Size);  					result+=8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present  				  				flags_ = (Flags)helperStream.ReadByte();  				if (((flags_ & Flags.ModificationTime) != 0) && (count >= 5))  				{  					int iTime = helperStream.ReadLEInt();    					modificationTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}    				if ((flags_ & Flags.AccessTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					lastAccessTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  				  				if ((flags_ & Flags.CreateTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					createTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present  				  				flags_ = (Flags)helperStream.ReadByte();  				if (((flags_ & Flags.ModificationTime) != 0) && (count >= 5))  				{  					int iTime = helperStream.ReadLEInt();    					modificationTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}    				if ((flags_ & Flags.AccessTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					lastAccessTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  				  				if ((flags_ & Flags.CreateTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					createTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present  				  				flags_ = (Flags)helperStream.ReadByte();  				if (((flags_ & Flags.ModificationTime) != 0) && (count >= 5))  				{  					int iTime = helperStream.ReadLEInt();    					modificationTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}    				if ((flags_ & Flags.AccessTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					lastAccessTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  				  				if ((flags_ & Flags.CreateTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					createTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				// bit 0           if set' modification time is present  				// bit 1           if set' access time is present  				// bit 2           if set' creation time is present  				  				flags_ = (Flags)helperStream.ReadByte();  				if (((flags_ & Flags.ModificationTime) != 0) && (count >= 5))  				{  					int iTime = helperStream.ReadLEInt();    					modificationTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}    				if ((flags_ & Flags.AccessTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					lastAccessTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  				  				if ((flags_ & Flags.CreateTime) != 0)  				{  					int iTime = helperStream.ReadLEInt();    					createTime_ = (new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime() +  						new TimeSpan(0' 0' 0' iTime' 0)).ToLocalTime();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				helperStream.IsStreamOwner = false;  				helperStream.WriteByte((byte)flags_);     // Flags  				if ( (flags_ & Flags.ModificationTime) != 0) {  					TimeSpan span = modificationTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ( (flags_ & Flags.AccessTime) != 0) {  					TimeSpan span = lastAccessTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ( (flags_ & Flags.CreateTime) != 0) {  					TimeSpan span = createTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				helperStream.IsStreamOwner = false;  				helperStream.WriteByte((byte)flags_);     // Flags  				if ( (flags_ & Flags.ModificationTime) != 0) {  					TimeSpan span = modificationTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ( (flags_ & Flags.AccessTime) != 0) {  					TimeSpan span = lastAccessTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ( (flags_ & Flags.CreateTime) != 0) {  					TimeSpan span = createTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				helperStream.IsStreamOwner = false;  				helperStream.WriteByte((byte)flags_);     // Flags  				if ( (flags_ & Flags.ModificationTime) != 0) {  					TimeSpan span = modificationTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ( (flags_ & Flags.AccessTime) != 0) {  					TimeSpan span = lastAccessTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				if ( (flags_ & Flags.CreateTime) != 0) {  					TimeSpan span = createTime_.ToUniversalTime() - new System.DateTime(1970' 1' 1' 0' 0' 0).ToUniversalTime();  					int seconds = (int)span.TotalSeconds;  					helperStream.WriteLEInt(seconds);  				}  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,ExtendedUnixData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,IsValidValue,The following statement contains a magic number: return (( value >= new DateTime(1901' 12' 13' 20' 45' 52)) ||   					( value <= new DateTime(2038' 1' 19' 03' 14' 07) ));
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream(data' index' count' false))   			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				helperStream.ReadLEInt(); // Reserved  				while (helperStream.Position < helperStream.Length)  				{  					int ntfsTag = helperStream.ReadLEShort();  					int ntfsLength = helperStream.ReadLEShort();  					if (ntfsTag == 1)  					{  						if (ntfsLength >= 24)  						{  							long lastModificationTicks = helperStream.ReadLELong();  							lastModificationTime_ = DateTime.FromFileTime(lastModificationTicks);    							long lastAccessTicks = helperStream.ReadLELong();  							lastAccessTime_ = DateTime.FromFileTime(lastAccessTicks);    							long createTimeTicks = helperStream.ReadLELong();  							createTime_ = DateTime.FromFileTime(createTimeTicks);  						}  						break;  					}  					else  					{  						// An unknown NTFS tag so simply skip it.  						helperStream.Seek(ntfsLength' SeekOrigin.Current);  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,NTTaggedData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,GetData,The following statement contains a magic number: using (MemoryStream ms = new MemoryStream())  			using (ZipHelperStream helperStream = new ZipHelperStream(ms))  			{  				helperStream.IsStreamOwner = false;  				helperStream.WriteLEInt(0);       // Reserved  				helperStream.WriteLEShort(1);     // Tag  				helperStream.WriteLEShort(24);    // Length = 3 x 8.  				helperStream.WriteLELong(lastModificationTime_.ToFileTime());  				helperStream.WriteLELong(lastAccessTime_.ToFileTime());  				helperStream.WriteLELong(createTime_.ToFileTime());  				return ms.ToArray();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,Find,The following statement contains a magic number: while ( (localTag != headerID) && (index_ < data_.Length - 3) ) {  				localTag = ReadShortInternal();  				localLength = ReadShortInternal();  				if ( localTag != headerID ) {  					index_ += localLength;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: int newLength = data_.Length + addLength + 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,AddEntry,The following statement contains a magic number: if ( Find(headerID) )  			{  				newLength -= (ValueLength + 4);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,AddLeShort,The following statement contains a magic number: unchecked {  				newEntry_.WriteByte(( byte )toAdd);  				newEntry_.WriteByte(( byte )(toAdd >> 8));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,AddLeInt,The following statement contains a magic number: unchecked {  				AddLeShort(( short )toAdd);  				AddLeShort(( short )(toAdd >> 16));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,AddLeLong,The following statement contains a magic number: unchecked {  				AddLeInt(( int )(toAdd & 0xffffffff));  				AddLeInt(( int )(toAdd >> 32));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if ( Find(headerID) ) {  				result = true;  				int trueStart = readValueStart_ - 4;    				byte[] newData = new byte[data_.Length - (ValueLength + 4)];  				Array.Copy(data_' 0' newData' 0' trueStart);    				int trueEnd = trueStart + ValueLength + 4;  				Array.Copy(data_' trueEnd' newData' trueStart' data_.Length - trueEnd);  				data_ = newData;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if ( Find(headerID) ) {  				result = true;  				int trueStart = readValueStart_ - 4;    				byte[] newData = new byte[data_.Length - (ValueLength + 4)];  				Array.Copy(data_' 0' newData' 0' trueStart);    				int trueEnd = trueStart + ValueLength + 4;  				Array.Copy(data_' trueEnd' newData' trueStart' data_.Length - trueEnd);  				data_ = newData;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,Delete,The following statement contains a magic number: if ( Find(headerID) ) {  				result = true;  				int trueStart = readValueStart_ - 4;    				byte[] newData = new byte[data_.Length - (ValueLength + 4)];  				Array.Copy(data_' 0' newData' 0' trueStart);    				int trueEnd = trueStart + ValueLength + 4;  				Array.Copy(data_' trueEnd' newData' trueStart' data_.Length - trueEnd);  				data_ = newData;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: ReadCheck(8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadLong,The following statement contains a magic number: return (ReadInt() & 0xffffffff) | ((( long )ReadInt()) << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: ReadCheck(4);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8) +   				(data_[index_ + 2] << 16) + (data_[index_ + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8) +   				(data_[index_ + 2] << 16) + (data_[index_ + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8) +   				(data_[index_ + 2] << 16) + (data_[index_ + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8) +   				(data_[index_ + 2] << 16) + (data_[index_ + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8) +   				(data_[index_ + 2] << 16) + (data_[index_ + 3] << 24);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadInt,The following statement contains a magic number: index_ += 4;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: ReadCheck(2);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadShort,The following statement contains a magic number: index_ += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadCheck,The following statement contains a magic number: if ((readValueStart_ > data_.Length) ||  				(readValueStart_ < 4) ) {  				throw new ZipException("Find must be called before calling a Read method");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: if ( index_ > data_.Length - 2) {  				throw new ZipException("End of extra data");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: int result = data_[index_] + (data_[index_ + 1] << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,ReadShortInternal,The following statement contains a magic number: index_ += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: data_[index + 1] = (byte)(source >> 8);
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipExtraData,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipExtraData.cs,SetShort,The following statement contains a magic number: index += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip,ZipEntryFactory,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipEntryFactory.cs,MakeDirectoryEntry,The following statement contains a magic number: externalAttributes |= (setAttributes_ | 16);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: byte[] gzipFooter = {  				(byte) crcval' (byte) (crcval >> 8)'  				(byte) (crcval >> 16)' (byte) (crcval >> 24)'  				  				(byte) totalin' (byte) (totalin >> 8)'  				(byte) (totalin >> 16)' (byte) (totalin >> 24)  			};
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: byte[] gzipFooter = {  				(byte) crcval' (byte) (crcval >> 8)'  				(byte) (crcval >> 16)' (byte) (crcval >> 24)'  				  				(byte) totalin' (byte) (totalin >> 8)'  				(byte) (totalin >> 16)' (byte) (totalin >> 24)  			};
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: byte[] gzipFooter = {  				(byte) crcval' (byte) (crcval >> 8)'  				(byte) (crcval >> 16)' (byte) (crcval >> 24)'  				  				(byte) totalin' (byte) (totalin >> 8)'  				(byte) (totalin >> 16)' (byte) (totalin >> 24)  			};
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: byte[] gzipFooter = {  				(byte) crcval' (byte) (crcval >> 8)'  				(byte) (crcval >> 16)' (byte) (crcval >> 24)'  				  				(byte) totalin' (byte) (totalin >> 8)'  				(byte) (totalin >> 16)' (byte) (totalin >> 24)  			};
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: byte[] gzipFooter = {  				(byte) crcval' (byte) (crcval >> 8)'  				(byte) (crcval >> 16)' (byte) (crcval >> 24)'  				  				(byte) totalin' (byte) (totalin >> 8)'  				(byte) (totalin >> 16)' (byte) (totalin >> 24)  			};
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,Finish,The following statement contains a magic number: byte[] gzipFooter = {  				(byte) crcval' (byte) (crcval >> 8)'  				(byte) (crcval >> 16)' (byte) (crcval >> 24)'  				  				(byte) totalin' (byte) (totalin >> 8)'  				(byte) (totalin >> 16)' (byte) (totalin >> 24)  			};
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if ( !headerWritten_ )   			{  				headerWritten_ = true;  				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if ( !headerWritten_ )   			{  				headerWritten_ = true;  				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if ( !headerWritten_ )   			{  				headerWritten_ = true;  				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if ( !headerWritten_ )   			{  				headerWritten_ = true;  				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if ( !headerWritten_ )   			{  				headerWritten_ = true;  				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipOutputStream.cs,WriteHeader,The following statement contains a magic number: if ( !headerWritten_ )   			{  				headerWritten_ = true;  				int mod_time = (int)((DateTime.Now.Ticks - new DateTime(1970' 1' 1).Ticks) / 10000000L);  // Ticks give back 100ns intervals  				byte[] gzipHeader = {  					// The two magic bytes  					(byte) (GZipConstants.GZIP_MAGIC >> 8)' (byte) (GZipConstants.GZIP_MAGIC & 0xff)'    					// The compression type  					(byte) Deflater.DEFLATED'    					// The flags (not set)  					0'    					// The modification time  					(byte) mod_time' (byte) (mod_time >> 8)'  					(byte) (mod_time >> 16)' (byte) (mod_time >> 24)'    					// The extra flags  					0'    					// The OS type (unknown)  					(byte) 255  				};  				baseOutputStream_.Write(gzipHeader' 0' gzipHeader.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if (magic != (GZipConstants.GZIP_MAGIC >> 8)) {  				throw new GZipException("Error GZIP header' first magic byte doesn't match");  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ( compressionType != 8 ) {  				throw new GZipException("Error GZIP header' data not in deflate format");  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: for (int i=0; i< 6; i++) {  				int readByte = baseInputStream.ReadByte();  				if (readByte < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				headCRC.Update(readByte);  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FEXTRA) != 0) {  				// Skip subfield id  				for (int i=0; i< 2; i++) {  					int readByte = baseInputStream.ReadByte();  					if (readByte < 0) {  						throw new EndOfStreamException("EOS reading GZIP header");  					}  					headCRC.Update(readByte);  				}    				if (baseInputStream.ReadByte() < 0 || baseInputStream.ReadByte() < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				  				int len1' len2;  				len1 = baseInputStream.ReadByte();  				len2 = baseInputStream.ReadByte();  				if ((len1 < 0) || (len2 < 0)) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				headCRC.Update(len1);  				headCRC.Update(len2);  				  				int extraLen = (len1 << 8) | len2;  				for (int i = 0; i < extraLen;i++) {  					int readByte = baseInputStream.ReadByte();  					if (readByte < 0)   					{  						throw new EndOfStreamException("EOS reading GZIP header");  					}  					headCRC.Update(readByte);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FEXTRA) != 0) {  				// Skip subfield id  				for (int i=0; i< 2; i++) {  					int readByte = baseInputStream.ReadByte();  					if (readByte < 0) {  						throw new EndOfStreamException("EOS reading GZIP header");  					}  					headCRC.Update(readByte);  				}    				if (baseInputStream.ReadByte() < 0 || baseInputStream.ReadByte() < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				  				int len1' len2;  				len1 = baseInputStream.ReadByte();  				len2 = baseInputStream.ReadByte();  				if ((len1 < 0) || (len2 < 0)) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				headCRC.Update(len1);  				headCRC.Update(len2);  				  				int extraLen = (len1 << 8) | len2;  				for (int i = 0; i < extraLen;i++) {  					int readByte = baseInputStream.ReadByte();  					if (readByte < 0)   					{  						throw new EndOfStreamException("EOS reading GZIP header");  					}  					headCRC.Update(readByte);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadHeader,The following statement contains a magic number: if ((flags & GZipConstants.FHCRC) != 0) {  				int tempByte;  				int crcval = baseInputStream.ReadByte();  				if (crcval < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				  				tempByte = baseInputStream.ReadByte();  				if (tempByte < 0) {  					throw new EndOfStreamException("EOS reading GZIP header");  				}  				  				crcval = (crcval << 8) | tempByte;  				if (crcval != ((int) headCRC.Value & 0xffff)) {  					throw new GZipException("Header CRC value mismatch");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: byte[] footer = new byte[8];
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: if (avail > 8) {  				avail = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: if (avail > 8) {  				avail = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int needed = 8 - avail;
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: while (needed > 0) {  				int count = baseInputStream.Read(footer' 8 - needed' needed);  				if (count <= 0) {  					throw new EndOfStreamException("EOS reading GZIP footer");  				}  				needed -= count; // Jewel Jan 16  			}
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: int crcval = (footer[0] & 0xff) | ((footer[1] & 0xff) << 8) | ((footer[2] & 0xff) << 16) | (footer[3] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.GZip,GZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\GZip\GzipInputStream.cs,ReadFooter,The following statement contains a magic number: uint total =   				(uint)((uint)footer[4] & 0xff) |  				(uint)(((uint)footer[5] & 0xff) << 8) |  				(uint)(((uint)footer[6] & 0xff) << 16) |  				(uint)((uint)footer[7] << 24);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; ++i) {  				if (inUse[i]) {  					seqToUnseq[nInUse] = (byte)i;  					unseqToSeq[i] = (byte)nInUse;  					nInUse++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,EndBlock,The following statement contains a magic number: computedCombinedCRC = ((computedCombinedCRC << 1) & 0xFFFFFFFF) | (computedCombinedCRC >> 31);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,FillBuffer,The following statement contains a magic number: bsBuff = (bsBuff << 8) | (thech & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,FillBuffer,The following statement contains a magic number: bsLive += 8;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetUChar,The following statement contains a magic number: return (char)BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: int u =        BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,BsGetint,The following statement contains a magic number: u = (u << 8) | BsR(8);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				inUse16[i] = (BsR(1) == 1);  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int i = 0; i < 16; i++) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = (BsR(1) == 1);  					}  				} else {  					for (int j = 0; j < 16; j++) {  						inUse[i * 16 + j] = false;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int alphaSize = nInUse + 2;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int nGroups    = BsR(3);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: int nSelectors = BsR(15);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				int curr = BsR(5);  				for (int i = 0; i < alphaSize; i++) {  					while (BsR(1) == 1) {  						if (BsR(1) == 0) {  							curr++;  						} else {  							curr--;  						}  					}  					len[t][i] = (char)curr;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,RecvDecodingTables,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				int minLen = 32;  				int maxLen = 0;  				for (int i = 0; i < alphaSize; i++) {  					maxLen = Math.Max(maxLen' len[t][i]);  					minLen = Math.Min(minLen' len[t][i]);  				}  				HbCreateDecodeTables(limit[t]' baseArray[t]' perm[t]' len[t]' minLen' maxLen' alphaSize);  				minLens[t] = minLen;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: byte[] yy = new byte[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: origPtr = BsGetIntVS(24);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++) {  				unzftab[i] = 0;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: for (int i = 0; i <= 255; i++) {  				yy[i] = (byte)i;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,GetAndMoveToFrontDecode,The following statement contains a magic number: while (zvec > limit[zt][zn]) {  				if (zn > 20) { // the longest code  					throw new BZip2Exception("Bzip data error");  				}  				zn++;  				while (bsLive < 1) {  					FillBuffer();  				}  				zj = (bsBuff >> (bsLive-1)) & 1;  				bsLive--;  				zvec = (zvec << 1) | zj;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: int[] cftab = new int[257];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: Array.Copy(unzftab' 0' cftab' 1' 256);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: for (int i = 1; i <= 256; i++) {  				cftab[i] += cftab[i - 1];  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupBlock,The following statement contains a magic number: ch2   = 256;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupRandPartA,The following statement contains a magic number: if (i2 <= last) {  				chPrev = ch2;  				ch2  = ll8[tPos];  				tPos = tt[tPos];  				if (rNToGo == 0) {  					rNToGo = BZip2Constants.rNums[rTPos];  					rTPos++;  					if (rTPos == 512) {  						rTPos = 0;  					}  				}  				rNToGo--;  				ch2 ^= (int)((rNToGo == 1) ? 1 : 0);  				i2++;  				  				currentChar  = ch2;  				currentState = RAND_PART_B_STATE;  				mCrc.Update(ch2);  			} else {  				EndBlock();  				InitBlock();  				SetupBlock();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  				currentState = RAND_PART_A_STATE;  				count = 1;  				SetupRandPartA();  			} else {  				count++;  				if (count >= 4) {  					z = ll8[tPos];  					tPos = tt[tPos];  					if (rNToGo == 0) {  						rNToGo = BZip2Constants.rNums[rTPos];  						rTPos++;  						if (rTPos == 512) {  							rTPos = 0;  						}  					}  					rNToGo--;  					z ^= (byte)((rNToGo == 1) ? 1 : 0);  					j2 = 0;  					currentState = RAND_PART_C_STATE;  					SetupRandPartC();  				} else {  					currentState = RAND_PART_A_STATE;  					SetupRandPartA();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  				currentState = RAND_PART_A_STATE;  				count = 1;  				SetupRandPartA();  			} else {  				count++;  				if (count >= 4) {  					z = ll8[tPos];  					tPos = tt[tPos];  					if (rNToGo == 0) {  						rNToGo = BZip2Constants.rNums[rTPos];  						rTPos++;  						if (rTPos == 512) {  							rTPos = 0;  						}  					}  					rNToGo--;  					z ^= (byte)((rNToGo == 1) ? 1 : 0);  					j2 = 0;  					currentState = RAND_PART_C_STATE;  					SetupRandPartC();  				} else {  					currentState = RAND_PART_A_STATE;  					SetupRandPartA();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetupNoRandPartB,The following statement contains a magic number: if (ch2 != chPrev) {  				currentState = NO_RAND_PART_A_STATE;  				count = 1;  				SetupNoRandPartA();  			} else {  				count++;  				if (count >= 4) {  					z = ll8[tPos];  					tPos = tt[tPos];  					currentState = NO_RAND_PART_C_STATE;  					j2 = 0;  					SetupNoRandPartC();  				} else {  					currentState = NO_RAND_PART_A_STATE;  					SetupNoRandPartA();  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {  				throw new BZip2Exception("Invalid block size");  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2InputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2InputStream.cs,SetDecompressStructureSizes,The following statement contains a magic number: if (!(0 <= newSize100k && newSize100k <= 9 && 0 <= blockSize100k && blockSize100k <= 9)) {  				throw new BZip2Exception("Invalid block size");  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: workFactor = 50;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9) {  				blockSize = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BZip2OutputStream,The following statement contains a magic number: if (blockSize > 9) {  				blockSize = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: int b = (256 + value) % 256;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteByte,The following statement contains a magic number: if (currentChar != -1) {  				if (currentChar == b) {  					runLength++;  					if (runLength > 254) {  						WriteRun();  						currentChar = -1;  						runLength = 0;  					}  				} else {  					WriteRun();  					runLength = 1;  					currentChar = b;  				}  			} else {  				currentChar = b;  				runLength++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MakeMaps,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				if (inUse[i]) {  					seqToUnseq[nInUse] = (char)i;  					unseqToSeq[i] = (char)nInUse;  					nInUse++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}  				  				switch (runLength) {  					case 1:  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 2:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 3:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					default:  						inUse[runLength - 4] = true;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)(runLength - 4);  						break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}  				  				switch (runLength) {  					case 1:  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 2:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 3:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					default:  						inUse[runLength - 4] = true;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)(runLength - 4);  						break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}  				  				switch (runLength) {  					case 1:  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 2:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 3:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					default:  						inUse[runLength - 4] = true;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)(runLength - 4);  						break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,WriteRun,The following statement contains a magic number: if (last < allowableBlockSize) {  				inUse[currentChar] = true;  				for (int i = 0; i < runLength; i++) {  					mCrc.Update(currentChar);  				}  				  				switch (runLength) {  					case 1:  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 2:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					case 3:  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						break;  					default:  						inUse[runLength - 4] = true;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)currentChar;  						last++;  						block[last + 1] = (byte)(runLength - 4);  						break;  				}  			} else {  				EndBlock();  				InitBlock();  				WriteRun();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,InitBlock,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  				inUse[i] = false;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,InitBlock,The following statement contains a magic number: allowableBlockSize = BZip2Constants.baseBlockSize * blockSize100k - 20;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,EndBlock,The following statement contains a magic number: combinedCRC = (combinedCRC << 1) | (combinedCRC >> 31);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0)   			{  				int ch = (bsBuff >> 24);  				baseStream.WriteByte((byte)ch); // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				bytesOut++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0)   			{  				int ch = (bsBuff >> 24);  				baseStream.WriteByte((byte)ch); // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				bytesOut++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsFinishedWithStream,The following statement contains a magic number: while (bsLive > 0)   			{  				int ch = (bsBuff >> 24);  				baseStream.WriteByte((byte)ch); // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				bytesOut++;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked{baseStream.WriteByte((byte)ch);} // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked{baseStream.WriteByte((byte)ch);} // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked{baseStream.WriteByte((byte)ch);} // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: while (bsLive >= 8) {  				int ch = (bsBuff >> 24);  				unchecked{baseStream.WriteByte((byte)ch);} // write 8-bit  				bsBuff <<= 8;  				bsLive -= 8;  				++bytesOut;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsW,The following statement contains a magic number: bsBuff |= (v << (32 - bsLive - n));
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutUChar,The following statement contains a magic number: BsW(8' c);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 24) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >> 16) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >>  8) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8' (u >>  8) & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,BsPutint,The following statement contains a magic number: BsW(8'  u        & 0xFF);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: alphaSize = nInUse + 2;
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (nMTF < 200) {  				nGroups = 2;  			} else if (nMTF < 600) {  				nGroups = 3;  			} else if (nMTF < 1200) {  				nGroups = 4;  			} else if (nMTF < 2400) {  				nGroups = 5;  			} else {  				nGroups = 6;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: while (nPart > 0) {  				int tFreq = remF / nPart;  				int aFreq = 0;  				ge = gs - 1;  				while (aFreq < tFreq && ge < alphaSize - 1) {  					ge++;  					aFreq += mtfFreq[ge];  				}  				  				if (ge > gs && nPart != nGroups && nPart != 1 && ((nGroups - nPart) % 2 == 1)) {  					aFreq -= mtfFreq[ge];  					ge--;  				}  				  				for (int v = 0; v < alphaSize; v++) {  					if (v >= gs && v <= ge) {  						len[nPart - 1][v] = (char)LESSER_ICOST;  					} else {  						len[nPart - 1][v] = (char)GREATER_ICOST;  					}  				}  				  				nPart--;  				gs = ge + 1;  				remF -= aFreq;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (iter = 0; iter < BZip2Constants.N_ITERS; ++iter) {  				for (int t = 0; t < nGroups; ++t) {  					fave[t] = 0;  				}  				  				for (int t = 0; t < nGroups; ++t) {  					for (int v = 0; v < alphaSize; ++v) {  						rfreq[t][v] = 0;  					}  				}  				  				nSelectors = 0;  				totc = 0;  				gs   = 0;  				while (true) {  					/*--- Set group start & end marks. --*/  					if (gs >= nMTF) {  						break;  					}  					ge = gs + BZip2Constants.G_SIZE - 1;  					if (ge >= nMTF) {  						ge = nMTF - 1;  					}  					  					/*--  					Calculate the cost of this group as coded  					by each of the coding tables.  					--*/  					for (int t = 0; t < nGroups; t++) {  						cost[t] = 0;  					}  					  					if (nGroups == 6) {  						short cost0' cost1' cost2' cost3' cost4' cost5;  						cost0 = cost1 = cost2 = cost3 = cost4 = cost5 = 0;  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							cost0 += (short)len[0][icv];  							cost1 += (short)len[1][icv];  							cost2 += (short)len[2][icv];  							cost3 += (short)len[3][icv];  							cost4 += (short)len[4][icv];  							cost5 += (short)len[5][icv];  						}  						cost[0] = cost0;  						cost[1] = cost1;  						cost[2] = cost2;  						cost[3] = cost3;  						cost[4] = cost4;  						cost[5] = cost5;  					} else {  						for (int i = gs; i <= ge; ++i) {  							short icv = szptr[i];  							for (int t = 0; t < nGroups; t++) {  								cost[t] += (short)len[t][icv];  							}  						}  					}  					  					/*--  					Find the coding table which is best for this group'  					and record its identity in the selector table.  					--*/  					bc = 999999999;  					bt = -1;  					for (int t = 0; t < nGroups; ++t) {  						if (cost[t] < bc) {  							bc = cost[t];  							bt = t;  						}  					}  					totc += bc;  					fave[bt]++;  					selector[nSelectors] = (char)bt;  					nSelectors++;  					  					/*--  					Increment the symbol frequencies for the selected table.  					--*/  					for (int i = gs; i <= ge; ++i) {  						++rfreq[bt][szptr[i]];  					}  					  					gs = ge+1;  				}  				  				/*--  				Recompute the tables based on the accumulated frequencies.  				--*/  				for (int t = 0; t < nGroups; ++t) {  					HbMakeCodeLengths(len[t]' rfreq[t]' alphaSize' 20);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nGroups < 8)) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.G_SIZE)))) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.G_SIZE)))) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: if (!(nSelectors < 32768 && nSelectors <= (2 + (900000 / BZip2Constants.G_SIZE)))) {  				Panic();  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				minLen = 32;  				maxLen = 0;  				for (int i = 0; i < alphaSize; i++) {  					if (len[t][i] > maxLen) {  						maxLen = len[t][i];  					}  					if (len[t][i] < minLen) {  						minLen = len[t][i];  					}  				}  				if (maxLen > 20) {  					Panic();  				}  				if (minLen < 1) {  					Panic();  				}  				HbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; t++) {  				minLen = 32;  				maxLen = 0;  				for (int i = 0; i < alphaSize; i++) {  					if (len[t][i] > maxLen) {  						maxLen = len[t][i];  					}  					if (len[t][i] < minLen) {  						minLen = len[t][i];  					}  				}  				if (maxLen > 20) {  					Panic();  				}  				if (minLen < 1) {  					Panic();  				}  				HbAssignCodes(code[t]' len[t]' minLen' maxLen' alphaSize);  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: bool[] inUse16 = new bool[16];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				inUse16[i] = false;  				for (int j = 0; j < 16; ++j) {  					if (inUse[i * 16 + j]) {  						inUse16[i] = true;   					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				inUse16[i] = false;  				for (int j = 0; j < 16; ++j) {  					if (inUse[i * 16 + j]) {  						inUse16[i] = true;   					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				inUse16[i] = false;  				for (int j = 0; j < 16; ++j) {  					if (inUse[i * 16 + j]) {  						inUse16[i] = true;   					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					BsW(1'1);  				} else {  					BsW(1'0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; ++j) {  						if (inUse[i * 16 + j]) {  							BsW(1'1);  						} else {  							BsW(1'0);  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; ++j) {  						if (inUse[i * 16 + j]) {  							BsW(1'1);  						} else {  							BsW(1'0);  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int i = 0; i < 16; ++i) {  				if (inUse16[i]) {  					for (int j = 0; j < 16; ++j) {  						if (inUse[i * 16 + j]) {  							BsW(1'1);  						} else {  							BsW(1'0);  						}  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(3' nGroups);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: BsW(15' nSelectors);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW (1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW (1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW (1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW (1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SendMTFValues,The following statement contains a magic number: for (int t = 0; t < nGroups; ++t) {  				int curr = len[t][0];  				BsW(5' curr);  				for (int i = 0; i < alphaSize; ++i) {  					while (curr < len[t][i]) {  						BsW(2' 2);  						curr++; /* 10 */  					}  					while (curr > len[t][i]) {  						BsW(2' 3);  						curr--; /* 11 */  					}  					BsW (1' 0);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MoveToFrontCodeAndSend,The following statement contains a magic number: BsPutIntVS(24' origPtr);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,SimpleSort,The following statement contains a magic number: if (bigN < 2) {  				return;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: int[] runningOrder = new int[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: int[] copy = new int[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: bool[] bigDone = new bool[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: for (i = 0; i < BZip2Constants.NUM_OVERSHOOT_BYTES; i++) {  				block[last + i + 2] = block[(i % (last + 1)) + 1];  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,MainSort,The following statement contains a magic number: if (last < 4000) {  				/*--  				Use simpleSort()' since the full sorting mechanism  				has quite a large constant overhead.  				--*/  				for (i = 0; i <= last; i++) {  					zptr[i] = i;  				}  				firstAttempt = false;  				workDone = workLimit = 0;  				SimpleSort(0' last' 0);  			} else {  				numQSorted = 0;  				for (i = 0; i <= 255; i++) {  					bigDone[i] = false;  				}  				for (i = 0; i <= 65536; i++) {  					ftab[i] = 0;  				}  				  				c1 = block[0];  				for (i = 0; i <= last; i++) {  					c2 = block[i + 1];  					ftab[(c1 << 8) + c2]++;  					c1 = c2;  				}  				  				for (i = 1; i <= 65536; i++) {  					ftab[i] += ftab[i - 1];  				}  				  				c1 = block[1];  				for (i = 0; i < last; i++) {  					c2 = block[i + 2];  					j = (c1 << 8) + c2;  					c1 = c2;  					ftab[j]--;  					zptr[ftab[j]] = i;  				}  				  				j = ((block[last + 1]) << 8) + (block[1]);  				ftab[j]--;  				zptr[ftab[j]] = last;  				  				/*--  				Now ftab contains the first loc of every small bucket.  				Calculate the running order' from smallest to largest  				big bucket.  				--*/  				  				for (i = 0; i <= 255; i++) {  					runningOrder[i] = i;  				}  				  				int vv;  				int h = 1;  				do {  					h = 3 * h + 1;  				} while (h <= 256);  				do {  					h = h / 3;  					for (i = h; i <= 255; i++) {  						vv = runningOrder[i];  						j = i;  						while ((ftab[((runningOrder[j-h])+1) << 8] - ftab[(runningOrder[j-h]) << 8]) > (ftab[((vv)+1) << 8] - ftab[(vv) << 8])) {  							runningOrder[j] = runningOrder[j-h];  							j = j - h;  							if (j <= (h - 1)) {  								break;  							}  						}  						runningOrder[j] = vv;  					}  				} while (h != 1);  				  				/*--  				The main sorting loop.  				--*/  				for (i = 0; i <= 255; i++) {  					  					/*--  					Process big buckets' starting with the least full.  					--*/  					ss = runningOrder[i];  					  					/*--  					Complete the big bucket [ss] by quicksorting  					any unsorted small buckets [ss' j].  Hopefully  					previous pointer-scanning phases have already  					completed many of the small buckets [ss' j]' so  					we don't have to sort them at all.  					--*/  					for (j = 0; j <= 255; j++) {  						sb = (ss << 8) + j;  						if(!((ftab[sb] & SETMASK) == SETMASK)) {  							int lo = ftab[sb] & CLEARMASK;  							int hi = (ftab[sb+1] & CLEARMASK) - 1;  							if (hi > lo) {  								QSort3(lo' hi' 2);  								numQSorted += (hi - lo + 1);  								if (workDone > workLimit && firstAttempt) {  									return;  								}  							}  							ftab[sb] |= SETMASK;  						}  					}  					  					/*--  					The ss big bucket is now done.  Record this fact'  					and update the quadrant descriptors.  Remember to  					update quadrants in the overshoot area too' if  					necessary.  The "if (i < 255)" test merely skips  					this updating for the last bucket processed' since  					updating for the last bucket is pointless.  					--*/  					bigDone[ss] = true;  					  					if (i < 255) {  						int bbStart  = ftab[ss << 8] & CLEARMASK;  						int bbSize   = (ftab[(ss+1) << 8] & CLEARMASK) - bbStart;  						int shifts   = 0;  						  						while ((bbSize >> shifts) > 65534) {  							shifts++;  						}  						  						for (j = 0; j < bbSize; j++) {  							int a2update = zptr[bbStart + j];  							int qVal = (j >> shifts);  							quadrant[a2update] = qVal;  							if (a2update < BZip2Constants.NUM_OVERSHOOT_BYTES) {  								quadrant[a2update + last + 1] = qVal;  							}  						}  						  						if (!(((bbSize-1) >> shifts) <= 65535)) {  							Panic();  						}  					}  					  					/*--  					Now scan this big bucket so as to synthesise the  					sorted order for small buckets [t' ss] for all t != ss.  					--*/  					for (j = 0; j <= 255; j++) {  						copy[j] = ftab[(j << 8) + ss] & CLEARMASK;  					}  					  					for (j = ftab[ss << 8] & CLEARMASK; j < (ftab[(ss+1) << 8] & CLEARMASK); j++) {  						c1 = block[zptr[j]];  						if (!bigDone[c1]) {  							zptr[copy[c1]] = zptr[j] == 0 ? last : zptr[j] - 1;  							copy[c1] ++;  						}  					}  					  					for (j = 0; j <= 255; j++) {  						ftab[(j << 8) + ss] |= SETMASK;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i < 256; i++) {  				inUse[i] = false;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,RandomiseBlock,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				if (rNToGo == 0) {  					rNToGo = (int)BZip2Constants.rNums[rTPos];  					rTPos++;  					if (rTPos == 512) {  						rTPos = 0;  					}  				}  				rNToGo--;  				block[i + 1] ^= (byte)((rNToGo == 1) ? 1 : 0);  				// handle 16 bit signed numbers  				block[i + 1] &= 0xFF;  				  				inUse[block[i + 1]] = true;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The following statement contains a magic number: do {  				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;  				  				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;  				  				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;  				  				c1 = block[i1 + 1];  				c2 = block[i2 + 1];  				if (c1 != c2) {  					return c1 > c2;  				}  				s1 = quadrant[i1];  				s2 = quadrant[i2];  				if (s1 != s2) {  					return s1 > s2;  				}  				i1++;  				i2++;  				  				if (i1 > last) {  					i1 -= last;  					i1--;  				}  				if (i2 > last) {  					i2 -= last;  					i2--;  				}  				  				k -= 4;  				++workDone;  			} while (k >= 0);
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: ftab = new int[65537];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,AllocateCompressStructures,The following statement contains a magic number: szptr = new short[2 * n];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: char[] yy = new char[256];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;  				  				ll_i = unseqToSeq[block[zptr[i]]];  				  				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;  				  				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  								case 0:  									szptr[wr] = (short)BZip2Constants.RUNA;  									wr++;  									mtfFreq[BZip2Constants.RUNA]++;  									break;  								case 1:  									szptr[wr] = (short)BZip2Constants.RUNB;  									wr++;  									mtfFreq[BZip2Constants.RUNB]++;  									break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;  				  				ll_i = unseqToSeq[block[zptr[i]]];  				  				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;  				  				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  								case 0:  									szptr[wr] = (short)BZip2Constants.RUNA;  									wr++;  									mtfFreq[BZip2Constants.RUNA]++;  									break;  								case 1:  									szptr[wr] = (short)BZip2Constants.RUNB;  									wr++;  									mtfFreq[BZip2Constants.RUNB]++;  									break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;  				  				ll_i = unseqToSeq[block[zptr[i]]];  				  				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;  				  				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  								case 0:  									szptr[wr] = (short)BZip2Constants.RUNA;  									wr++;  									mtfFreq[BZip2Constants.RUNA]++;  									break;  								case 1:  									szptr[wr] = (short)BZip2Constants.RUNB;  									wr++;  									mtfFreq[BZip2Constants.RUNB]++;  									break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: for (i = 0; i <= last; i++) {  				char ll_i;  				  				ll_i = unseqToSeq[block[zptr[i]]];  				  				j = 0;  				tmp = yy[j];  				while (ll_i != tmp) {  					j++;  					tmp2 = tmp;  					tmp = yy[j];  					yy[j] = tmp2;  				}  				yy[0] = tmp;  				  				if (j == 0) {  					zPend++;  				} else {  					if (zPend > 0) {  						zPend--;  						while (true) {  							switch (zPend % 2) {  								case 0:  									szptr[wr] = (short)BZip2Constants.RUNA;  									wr++;  									mtfFreq[BZip2Constants.RUNA]++;  									break;  								case 1:  									szptr[wr] = (short)BZip2Constants.RUNB;  									wr++;  									mtfFreq[BZip2Constants.RUNB]++;  									break;  							}  							if (zPend < 2) {  								break;  							}  							zPend = (zPend - 2) / 2;  						}  						zPend = 0;  					}  					szptr[wr] = (short)(j + 1);  					wr++;  					mtfFreq[j + 1]++;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  						case 0:  							szptr[wr] = (short)BZip2Constants.RUNA;  							wr++;  							mtfFreq[BZip2Constants.RUNA]++;  							break;  						case 1:  							szptr[wr] = (short)BZip2Constants.RUNB;  							wr++;  							mtfFreq[BZip2Constants.RUNB]++;  							break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  						case 0:  							szptr[wr] = (short)BZip2Constants.RUNA;  							wr++;  							mtfFreq[BZip2Constants.RUNA]++;  							break;  						case 1:  							szptr[wr] = (short)BZip2Constants.RUNB;  							wr++;  							mtfFreq[BZip2Constants.RUNB]++;  							break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  						case 0:  							szptr[wr] = (short)BZip2Constants.RUNA;  							wr++;  							mtfFreq[BZip2Constants.RUNA]++;  							break;  						case 1:  							szptr[wr] = (short)BZip2Constants.RUNB;  							wr++;  							mtfFreq[BZip2Constants.RUNB]++;  							break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following statement contains a magic number: if (zPend > 0) {  				zPend--;  				while (true) {  					switch (zPend % 2) {  						case 0:  							szptr[wr] = (short)BZip2Constants.RUNA;  							wr++;  							mtfFreq[BZip2Constants.RUNA]++;  							break;  						case 1:  							szptr[wr] = (short)BZip2Constants.RUNB;  							wr++;  							mtfFreq[BZip2Constants.RUNB]++;  							break;  					}  					if (zPend < 2) {  						break;  					}  					zPend = (zPend - 2) / 2;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] heap   = new int[BZip2Constants.MAX_ALPHA_SIZE + 2];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] weight = new int[BZip2Constants.MAX_ALPHA_SIZE * 2];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: int[] parent = new int[BZip2Constants.MAX_ALPHA_SIZE * 2];
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: for (int i = 0; i < alphaSize; ++i)   			{  				weight[i+1] = (freq[i] == 0 ? 1 : freq[i]) << 8;  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)   			{  				nNodes = alphaSize;  				nHeap = 0;  				  				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;  				  				for (int i = 1; i <= alphaSize; ++i)   				{  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MAX_ALPHA_SIZE+2)))   				{  					Panic();  				}  				  				while (nHeap > 1)   				{  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap &&  weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					  					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap && weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;  					  					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |   						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));  					  					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;  					  					zz  = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2)))   				{  					Panic();  				}  				  				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i)   				{  					j = 0;  					k = i;  					while (parent[k] >= 0)   					{  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					if (j > maxLen)   					{  						tooLong = true;  					}  				}  				  				if (!tooLong)   				{  					break;  				}  				  				for (int i = 1; i < alphaSize; ++i)   				{  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)   			{  				nNodes = alphaSize;  				nHeap = 0;  				  				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;  				  				for (int i = 1; i <= alphaSize; ++i)   				{  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MAX_ALPHA_SIZE+2)))   				{  					Panic();  				}  				  				while (nHeap > 1)   				{  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap &&  weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					  					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap && weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;  					  					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |   						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));  					  					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;  					  					zz  = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2)))   				{  					Panic();  				}  				  				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i)   				{  					j = 0;  					k = i;  					while (parent[k] >= 0)   					{  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					if (j > maxLen)   					{  						tooLong = true;  					}  				}  				  				if (!tooLong)   				{  					break;  				}  				  				for (int i = 1; i < alphaSize; ++i)   				{  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)   			{  				nNodes = alphaSize;  				nHeap = 0;  				  				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;  				  				for (int i = 1; i <= alphaSize; ++i)   				{  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MAX_ALPHA_SIZE+2)))   				{  					Panic();  				}  				  				while (nHeap > 1)   				{  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap &&  weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					  					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap && weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;  					  					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |   						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));  					  					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;  					  					zz  = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2)))   				{  					Panic();  				}  				  				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i)   				{  					j = 0;  					k = i;  					while (parent[k] >= 0)   					{  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					if (j > maxLen)   					{  						tooLong = true;  					}  				}  				  				if (!tooLong)   				{  					break;  				}  				  				for (int i = 1; i < alphaSize; ++i)   				{  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)   			{  				nNodes = alphaSize;  				nHeap = 0;  				  				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;  				  				for (int i = 1; i <= alphaSize; ++i)   				{  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MAX_ALPHA_SIZE+2)))   				{  					Panic();  				}  				  				while (nHeap > 1)   				{  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap &&  weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					  					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap && weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;  					  					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |   						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));  					  					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;  					  					zz  = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2)))   				{  					Panic();  				}  				  				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i)   				{  					j = 0;  					k = i;  					while (parent[k] >= 0)   					{  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					if (j > maxLen)   					{  						tooLong = true;  					}  				}  				  				if (!tooLong)   				{  					break;  				}  				  				for (int i = 1; i < alphaSize; ++i)   				{  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)   			{  				nNodes = alphaSize;  				nHeap = 0;  				  				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;  				  				for (int i = 1; i <= alphaSize; ++i)   				{  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MAX_ALPHA_SIZE+2)))   				{  					Panic();  				}  				  				while (nHeap > 1)   				{  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap &&  weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					  					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap && weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;  					  					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |   						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));  					  					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;  					  					zz  = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2)))   				{  					Panic();  				}  				  				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i)   				{  					j = 0;  					k = i;  					while (parent[k] >= 0)   					{  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					if (j > maxLen)   					{  						tooLong = true;  					}  				}  				  				if (!tooLong)   				{  					break;  				}  				  				for (int i = 1; i < alphaSize; ++i)   				{  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,HbMakeCodeLengths,The following statement contains a magic number: while (true)   			{  				nNodes = alphaSize;  				nHeap = 0;  				  				heap[0] = 0;  				weight[0] = 0;  				parent[0] = -2;  				  				for (int i = 1; i <= alphaSize; ++i)   				{  					parent[i] = -1;  					nHeap++;  					heap[nHeap] = i;  					int zz = nHeap;  					int tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nHeap < (BZip2Constants.MAX_ALPHA_SIZE+2)))   				{  					Panic();  				}  				  				while (nHeap > 1)   				{  					n1 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					int zz = 1;  					int yy = 0;  					int tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap &&  weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					n2 = heap[1];  					heap[1] = heap[nHeap];  					nHeap--;  					  					zz = 1;  					yy = 0;  					tmp = heap[zz];  					while (true)   					{  						yy = zz << 1;  						if (yy > nHeap)   						{  							break;  						}  						if (yy < nHeap && weight[heap[yy+1]] < weight[heap[yy]])   						{  							yy++;  						}  						if (weight[tmp] < weight[heap[yy]])   						{  							break;  						}  						heap[zz] = heap[yy];  						zz = yy;  					}  					heap[zz] = tmp;  					nNodes++;  					parent[n1] = parent[n2] = nNodes;  					  					weight[nNodes] = (int)((weight[n1] & 0xffffff00) + (weight[n2] & 0xffffff00)) |   						(int)(1 + (((weight[n1] & 0x000000ff) > (weight[n2] & 0x000000ff)) ? (weight[n1] & 0x000000ff) : (weight[n2] & 0x000000ff)));  					  					parent[nNodes] = -1;  					nHeap++;  					heap[nHeap] = nNodes;  					  					zz  = nHeap;  					tmp = heap[zz];  					while (weight[tmp] < weight[heap[zz >> 1]])   					{  						heap[zz] = heap[zz >> 1];  						zz >>= 1;  					}  					heap[zz] = tmp;  				}  				if (!(nNodes < (BZip2Constants.MAX_ALPHA_SIZE * 2)))   				{  					Panic();  				}  				  				tooLong = false;  				for (int i = 1; i <= alphaSize; ++i)   				{  					j = 0;  					k = i;  					while (parent[k] >= 0)   					{  						k = parent[k];  						j++;  					}  					len[i - 1] = (char)j;  					if (j > maxLen)   					{  						tooLong = true;  					}  				}  				  				if (!tooLong)   				{  					break;  				}  				  				for (int i = 1; i < alphaSize; ++i)   				{  					j = weight[i] >> 8;  					j = 1 + (j / 2);  					weight[i] = j << 8;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Directory.Exists(file)) {  				header.Mode     = 1003; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_DIR;  				if ( (header.Name.Length == 0) || header.Name[header.Name.Length - 1] != '/') {  					header.Name = header.Name + "/";  				}  				  				header.Size     = 0;  			} else {  				header.Mode     = 33216; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_NORMAL;  				header.Size     = new FileInfo(file.Replace('/'' Path.DirectorySeparatorChar)).Length;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarEntry.cs,GetFileTarHeader,The following statement contains a magic number: if (Directory.Exists(file)) {  				header.Mode     = 1003; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_DIR;  				if ( (header.Name.Length == 0) || header.Name[header.Name.Length - 1] != '/') {  					header.Name = header.Name + "/";  				}  				  				header.Size     = 0;  			} else {  				header.Mode     = 33216; // Magic number for security access for a UNIX filesystem  				header.TypeFlag = TarHeader.LF_NORMAL;  				header.Size     = new FileInfo(file.Replace('/'' Path.DirectorySeparatorChar)).Length;  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;
Magic Number,ICSharpCode.SharpZipLib.Tar,TarEntry,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarEntry.cs,NameTarHeader,The following statement contains a magic number: header.Mode = isDir ? 1003 : 33216;
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarHeader.cs,ParseOctal,The following statement contains a magic number: for (int i = offset; i < end ; ++i) {  				if (header[i] == 0) {  					break;  				}  				  				if (header[i] == (byte)' ' || header[i] == '0') {  					if (stillPadding) {  						continue;  					}  					  					if (header[i] == (byte)' ') {  						break;  					}  				}  				  				stillPadding = false;  				  				result = (result << 3) + (header[i] - '0');  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  				for ( long v = value; (localIndex >= 0) && (v > 0); --localIndex ) {  					buffer[offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  					v >>= 3;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarHeader.cs,GetOctalBytes,The following statement contains a magic number: if (value > 0) {  				for ( long v = value; (localIndex >= 0) && (v > 0); --localIndex ) {  					buffer[offset + localIndex] = (byte)((byte)'0' + (byte)(v & 7));  					v >>= 3;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarInputStream.cs,Skip,The following statement contains a magic number: byte[] skipBuf = new byte[8 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarInputStream.cs,Skip,The following statement contains a magic number: byte[] skipBuf = new byte[8 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarInputStream.cs,CopyEntryContents,The following statement contains a magic number: byte[] tempBuffer = new byte[32 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarInputStream.cs,CopyEntryContents,The following statement contains a magic number: byte[] tempBuffer = new byte[32 * 1024];
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				EnsureDirectoryExists(destFile);  			} else {  				string parentDirectory = Path.GetDirectoryName(destFile);  				EnsureDirectoryExists(parentDirectory);  				  				bool process = true;  				FileInfo fileInfo = new FileInfo(destFile);  				if (fileInfo.Exists) {  					if (this.keepOldFiles) {  						OnProgressMessageEvent(entry' "Destination file already exists");  						process = false;  					} else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  						OnProgressMessageEvent(entry' "Destination file already exists' and is read-only");  						process = false;  					}  				}  				  				if (process) {  					bool asciiTrans = false;  					  					Stream outputStream = File.Create(destFile);  					if (this.asciiTranslate) {  						asciiTrans = !IsBinary(destFile);  					}  					  					StreamWriter outw = null;  					if (asciiTrans) {  						outw = new StreamWriter(outputStream);  					}  					  					byte[] rdbuf = new byte[32 * 1024];  					  					while (true) {  						int numRead = this.tarIn.Read(rdbuf' 0' rdbuf.Length);  						  						if (numRead <= 0) {  							break;  						}  						  						if (asciiTrans) {  							for (int off = 0' b = 0; b < numRead; ++b) {  								if (rdbuf[b] == 10) {  									string s = Encoding.ASCII.GetString(rdbuf' off' (b - off));  									outw.WriteLine(s);  									off = b + 1;  								}  							}  						} else {  							outputStream.Write(rdbuf' 0' numRead);  						}  					}  					  					if (asciiTrans) {  						outw.Close();  					} else {  						outputStream.Close();  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				EnsureDirectoryExists(destFile);  			} else {  				string parentDirectory = Path.GetDirectoryName(destFile);  				EnsureDirectoryExists(parentDirectory);  				  				bool process = true;  				FileInfo fileInfo = new FileInfo(destFile);  				if (fileInfo.Exists) {  					if (this.keepOldFiles) {  						OnProgressMessageEvent(entry' "Destination file already exists");  						process = false;  					} else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  						OnProgressMessageEvent(entry' "Destination file already exists' and is read-only");  						process = false;  					}  				}  				  				if (process) {  					bool asciiTrans = false;  					  					Stream outputStream = File.Create(destFile);  					if (this.asciiTranslate) {  						asciiTrans = !IsBinary(destFile);  					}  					  					StreamWriter outw = null;  					if (asciiTrans) {  						outw = new StreamWriter(outputStream);  					}  					  					byte[] rdbuf = new byte[32 * 1024];  					  					while (true) {  						int numRead = this.tarIn.Read(rdbuf' 0' rdbuf.Length);  						  						if (numRead <= 0) {  							break;  						}  						  						if (asciiTrans) {  							for (int off = 0' b = 0; b < numRead; ++b) {  								if (rdbuf[b] == 10) {  									string s = Encoding.ASCII.GetString(rdbuf' off' (b - off));  									outw.WriteLine(s);  									off = b + 1;  								}  							}  						} else {  							outputStream.Write(rdbuf' 0' numRead);  						}  					}  					  					if (asciiTrans) {  						outw.Close();  					} else {  						outputStream.Close();  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,ExtractEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				EnsureDirectoryExists(destFile);  			} else {  				string parentDirectory = Path.GetDirectoryName(destFile);  				EnsureDirectoryExists(parentDirectory);  				  				bool process = true;  				FileInfo fileInfo = new FileInfo(destFile);  				if (fileInfo.Exists) {  					if (this.keepOldFiles) {  						OnProgressMessageEvent(entry' "Destination file already exists");  						process = false;  					} else if ((fileInfo.Attributes & FileAttributes.ReadOnly) != 0) {  						OnProgressMessageEvent(entry' "Destination file already exists' and is read-only");  						process = false;  					}  				}  				  				if (process) {  					bool asciiTrans = false;  					  					Stream outputStream = File.Create(destFile);  					if (this.asciiTranslate) {  						asciiTrans = !IsBinary(destFile);  					}  					  					StreamWriter outw = null;  					if (asciiTrans) {  						outw = new StreamWriter(outputStream);  					}  					  					byte[] rdbuf = new byte[32 * 1024];  					  					while (true) {  						int numRead = this.tarIn.Read(rdbuf' 0' rdbuf.Length);  						  						if (numRead <= 0) {  							break;  						}  						  						if (asciiTrans) {  							for (int off = 0' b = 0; b < numRead; ++b) {  								if (rdbuf[b] == 10) {  									string s = Encoding.ASCII.GetString(rdbuf' off' (b - off));  									outw.WriteLine(s);  									off = b + 1;  								}  							}  						} else {  							outputStream.Write(rdbuf' 0' numRead);  						}  					}  					  					if (asciiTrans) {  						outw.Close();  					} else {  						outputStream.Close();  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,InternalWriteEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				if (recurse) {  					TarEntry[] list = entry.GetDirectoryEntries();  					for (int i = 0; i < list.Length; ++i) {  						InternalWriteEntry(list[i]' recurse);  					}  				}  			}  			else {  				using (Stream inputStream = File.OpenRead(entryFilename)) {  					int numWritten = 0;  					byte[] localBuffer = new byte[32 * 1024];  					while (true) {  						int numRead = inputStream.Read(localBuffer' 0' localBuffer.Length);  						  						if (numRead <=0) {  							break;  						}  						  						tarOut.Write(localBuffer' 0' numRead);  						numWritten +=  numRead;  					}  				}  				  				if ( (tempFileName != null) && (tempFileName.Length > 0) ) {  					File.Delete(tempFileName);  				}  				  				tarOut.CloseEntry();  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,InternalWriteEntry,The following statement contains a magic number: if (entry.IsDirectory) {  				if (recurse) {  					TarEntry[] list = entry.GetDirectoryEntries();  					for (int i = 0; i < list.Length; ++i) {  						InternalWriteEntry(list[i]' recurse);  					}  				}  			}  			else {  				using (Stream inputStream = File.OpenRead(entryFilename)) {  					int numWritten = 0;  					byte[] localBuffer = new byte[32 * 1024];  					while (true) {  						int numRead = inputStream.Read(localBuffer' 0' localBuffer.Length);  						  						if (numRead <=0) {  							break;  						}  						  						tarOut.Write(localBuffer' 0' numRead);  						numWritten +=  numRead;  					}  				}  				  				if ( (tempFileName != null) && (tempFileName.Length > 0) ) {  					File.Delete(tempFileName);  				}  				  				tarOut.CloseEntry();  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename))  			{  				int sampleSize = System.Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];  			  				int bytesRead = fs.Read(content' 0' sampleSize);  			  				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ( (b < 8) || ((b > 13) && (b < 32)) || (b == 255) ) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename))  			{  				int sampleSize = System.Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];  			  				int bytesRead = fs.Read(content' 0' sampleSize);  			  				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ( (b < 8) || ((b > 13) && (b < 32)) || (b == 255) ) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename))  			{  				int sampleSize = System.Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];  			  				int bytesRead = fs.Read(content' 0' sampleSize);  			  				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ( (b < 8) || ((b > 13) && (b < 32)) || (b == 255) ) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename))  			{  				int sampleSize = System.Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];  			  				int bytesRead = fs.Read(content' 0' sampleSize);  			  				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ( (b < 8) || ((b > 13) && (b < 32)) || (b == 255) ) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Tar,TarArchive,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Tar\TarArchive.cs,IsBinary,The following statement contains a magic number: using (FileStream fs = File.OpenRead(filename))  			{  				int sampleSize = System.Math.Min(4096' (int)fs.Length);  				byte[] content = new byte[sampleSize];  			  				int bytesRead = fs.Read(content' 0' sampleSize);  			  				for (int i = 0; i < bytesRead; ++i) {  					byte b = content[i];  					if ( (b < 8) || ((b > 13) && (b < 32)) || (b == 255) ) {  						return true;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShort,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 16));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteInt,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (value >> 24));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0)   			{  				buffer_[end++] = unchecked((byte) bits);  				if (bitCount > 8) {  					buffer_[end++] = unchecked((byte) (bits >> 8));  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,AlignToByte,The following statement contains a magic number: if (bitCount > 0)   			{  				buffer_[end++] = unchecked((byte) bits);  				if (bitCount > 8) {  					buffer_[end++] = unchecked((byte) (bits >> 8));  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer_[end++] = unchecked((byte) bits);  				buffer_[end++] = unchecked((byte) (bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer_[end++] = unchecked((byte) bits);  				buffer_[end++] = unchecked((byte) (bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer_[end++] = unchecked((byte) bits);  				buffer_[end++] = unchecked((byte) (bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteBits,The following statement contains a magic number: if (bitCount >= 16) {  				buffer_[end++] = unchecked((byte) bits);  				buffer_[end++] = unchecked((byte) (bits >> 8));  				bits >>= 16;  				bitCount -= 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,WriteShortMSB,The following statement contains a magic number: buffer_[end++] = unchecked((byte) (s >> 8));
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  				buffer_[end++] = unchecked((byte) bits);  				bits >>= 8;  				bitCount -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  				buffer_[end++] = unchecked((byte) bits);  				bits >>= 8;  				bitCount -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,PendingBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\PendingBuffer.cs,Flush,The following statement contains a magic number: if (bitCount >= 8) {  				buffer_[end++] = unchecked((byte) bits);  				bits >>= 8;  				bitCount -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following statement contains a magic number: decode_loop:  				for (;;) {  					switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,InflaterHuffmanTree,The following statement contains a magic number: try {  				byte[] codeLengths = new byte[288];  				int i = 0;  				while (i < 144) {  					codeLengths[i++] = 8;  				}  				while (i < 256) {  					codeLengths[i++] = 9;  				}  				while (i < 280) {  					codeLengths[i++] = 7;  				}  				while (i < 288) {  					codeLengths[i++] = 8;  				}  				defLitLenTree = new InflaterHuffmanTree(codeLengths);  				  				codeLengths = new byte[32];  				i = 0;  				while (i < 32) {  					codeLengths[i++] = 5;  				}  				defDistTree = new InflaterHuffmanTree(codeLengths);  			} catch (Exception) {  				throw new SharpZipBaseException("InflaterHuffmanTree: static tree length illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treeSize = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = 1; bits <= MAX_BITLEN; bits++) {  				nextCode[bits] = code;  				code += blCount[bits] << (16 - bits);  				if (bits >= 10) {  					/* We need an extra table for bit lengths >= 10. */  					int start = nextCode[bits] & 0x1ff80;  					int end   = code & 0x1ff80;  					treeSize += (end - start) >> (16 - bits);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: int treePtr = 512;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int bits = MAX_BITLEN; bits >= 10; bits--) {  				int end   = code & 0x1ff80;  				code -= blCount[bits] << (16 - bits);  				int start = code & 0x1ff80;  				for (int i = start; i < end; i += 1 << 7) {  					tree[DeflaterHuffman.BitReverse(i)] = (short) ((-treePtr << 4) | bits);  					treePtr += 1 << (bits-9);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < codeLengths.Length; i++) {  				int bits = codeLengths[i];  				if (bits == 0) {  					continue;  				}  				code = nextCode[bits];  				int revcode = DeflaterHuffman.BitReverse(code);  				if (bits <= 9) {  					do {  						tree[revcode] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < 512);  				} else {  					int subTree = tree[revcode & 511];  					int treeLen = 1 << (subTree & 15);  					subTree = -(subTree >> 4);  					do {  						tree[subTree | (revcode >> 9)] = (short) ((i << 4) | bits);  						revcode += 1 << bits;  					} while (revcode < treeLen);  				}  				nextCode[bits] = code + (1 << (16 - bits));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,InflaterHuffmanTree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterHuffmanTree.cs,GetSymbol,The following statement contains a magic number: if ((lookahead = input.PeekBits(9)) >= 0) {  				if ((symbol = tree[lookahead]) >= 0) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				}  				int subtree = -(symbol >> 4);  				int bitlen = symbol & 15;  				if ((lookahead = input.PeekBits(bitlen)) >= 0) {  					symbol = tree[subtree | (lookahead >> 9)];  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					int bits = input.AvailableBits;  					lookahead = input.PeekBits(bits);  					symbol = tree[subtree | (lookahead >> 9)];  					if ((symbol & 15) <= bits) {  						input.DropBits(symbol & 15);  						return symbol >> 4;  					} else {  						return -1;  					}  				}  			} else {  				int bits = input.AvailableBits;  				lookahead = input.PeekBits(bits);  				symbol = tree[lookahead];  				if (symbol >= 0 && (symbol & 15) <= bits) {  					input.DropBits(symbol & 15);  					return symbol >> 4;  				} else {  					return -1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  				staticLCodes[i] = BitReverse((0x030 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  				staticLCodes[i] = BitReverse((0x030 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 144) {  				staticLCodes[i] = BitReverse((0x030 + i) << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 256) {  				staticLCodes[i] = BitReverse((0x190 - 144 + i) << 7);  				staticLLength[i++] = 9;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < 280) {  				staticLCodes[i] = BitReverse((0x000 - 256 + i) << 9);  				staticLLength[i++] = 7;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  				staticLCodes[i] = BitReverse((0x0c0 - 280 + i)  << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  				staticLCodes[i] = BitReverse((0x0c0 - 280 + i)  << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: while (i < LITERAL_NUM) {  				staticLCodes[i] = BitReverse((0x0c0 - 280 + i)  << 8);  				staticLLength[i++] = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  				staticDCodes[i] = BitReverse(i << 11);  				staticDLength[i] = 5;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: for (i = 0; i < DIST_NUM; i++) {  				staticDCodes[i] = BitReverse(i << 11);  				staticDLength[i] = 5;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: literalTree = new Tree(this' LITERAL_NUM' 257' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: distTree    = new Tree(this' DIST_NUM' 1' 15);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree      = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,DeflaterHuffman,The following statement contains a magic number: blTree      = new Tree(this' BITLEN_NUM' 4' 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(literalTree.numCodes - 257' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(distTree.numCodes - 1' 5);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: pending.WriteBits(blTreeCodes - 4' 4);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,SendAllTrees,The following statement contains a magic number: for (int rank = 0; rank < blTreeCodes; rank++) {  				pending.WriteBits(blTree.length[BL_ORDER[rank]]' 3);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}  					  					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);  					  					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}  					  					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);  					  					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}  					  					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);  					  					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}  					  					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);  					  					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}  					  					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);  					  					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}  					  					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);  					  					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CompressBlock,The following statement contains a magic number: for (int i = 0; i < last_lit; i++) {  				int litlen = l_buf[i] & 0xff;  				int dist = d_buf[i];  				if (dist-- != 0) {  					//					if (DeflaterConstants.DEBUGGING) {  					//						Console.Write("["+(dist+1)+"'"+(litlen+3)+"]: ");  					//					}  					  					int lc = Lcode(litlen);  					literalTree.WriteSymbol(lc);  					  					int bits = (lc - 261) / 4;  					if (bits > 0 && bits <= 5) {  						pending.WriteBits(litlen & ((1 << bits) - 1)' bits);  					}  					  					int dc = Dcode(dist);  					distTree.WriteSymbol(dc);  					  					bits = dc / 2 - 1;  					if (bits > 0) {  						pending.WriteBits(dist & ((1 << bits) - 1)' bits);  					}  				} else {  					//					if (DeflaterConstants.DEBUGGING) {  					//						if (litlen > 32 && litlen < 127) {  					//							Console.Write("("+(char)litlen+"): ");  					//						} else {  					//							Console.Write("{"+litlen+"}: ");  					//						}  					//					}  					literalTree.WriteSymbol(litlen);  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushStoredBlock,The following statement contains a magic number: pending.WriteBits((DeflaterConstants.STORED_BLOCK << 1) + (lastBlock ? 1 : 0)' 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int blTreeCodes = 4;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: for (int i = 18; i > blTreeCodes; i--) {  				if (blTree.length[BL_ORDER[i]] > 0) {  					blTreeCodes = i+1;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +   				literalTree.GetEncodedLength() + distTree.GetEncodedLength() +   				extra_bits;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: int opt_len = 14 + blTreeCodes * 3 + blTree.GetEncodedLength() +   				literalTree.GetEncodedLength() + distTree.GetEncodedLength() +   				extra_bits;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,FlushBlock,The following statement contains a magic number: if (storedOffset >= 0 && storedLength + 4 < opt_len >> 3) {  				// Store Block    				//				if (DeflaterConstants.DEBUGGING) {  				//					//Console.WriteLine("Storing' since " + storedLength + " < " + opt_len  				//					                  + " <= " + static_len);  				//				}  				FlushStoredBlock(stored' storedOffset' storedLength' lastBlock);  			} else if (opt_len == static_len) {  				// Encode with static tree  				pending.WriteBits((DeflaterConstants.STATIC_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				literalTree.SetStaticCodes(staticLCodes' staticLLength);  				distTree.SetStaticCodes(staticDCodes' staticDLength);  				CompressBlock();  				Reset();  			} else {  				// Encode with dynamic tree  				pending.WriteBits((DeflaterConstants.DYN_TREES << 1) + (lastBlock ? 1 : 0)' 3);  				SendAllTrees(blTreeCodes);  				CompressBlock();  				Reset();  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: l_buf[last_lit++] = (byte)(length - 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: int lc = Lcode(length - 3);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (lc >= 265 && lc < 285) {  				extra_bits += (lc - 261) / 4;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  				extra_bits += dc / 2 - 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,TallyDist,The following statement contains a magic number: if (dc >= 4) {  				extra_bits += dc / 2 - 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BitReverse,The following statement contains a magic number: return (short) (bit4Reverse[toReverse & 0xF] << 12 |   			                bit4Reverse[(toReverse >> 4) & 0xF] << 8 |   			                bit4Reverse[(toReverse >> 8) & 0xF] << 4 |  			                bit4Reverse[toReverse >> 12]);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  				return 285;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: if (length == 255) {  				return 285;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: int code = 257;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  				code += 4;  				length >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Lcode,The following statement contains a magic number: while (length >= 8) {  				code += 4;  				length >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  				code += 2;  				distance >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterHuffman,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,Dcode,The following statement contains a magic number: while (distance >= 4) {  				code += 2;  				distance >>= 1;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildCodes,The following statement contains a magic number: for (int bits = 0; bits < maxLength; bits++) {  					nextCode[bits] = code;  					code += bl_counts[bits] << (15 - bits);    					//					if (DeflaterConstants.DEBUGGING) {  					//						//Console.WriteLine("bits: " + ( bits + 1) + " count: " + bl_counts[bits]  					//						                  +" nextCode: "+code);  					//					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildCodes,The following statement contains a magic number: for (int i=0; i < numCodes; i++) {  					int bits = length[i];  					if (bits > 0) {    						//						if (DeflaterConstants.DEBUGGING) {  						//								//Console.WriteLine("codes["+i+"] = rev(" + nextCode[bits-1]+")'  						//								                  +bits);  						//						}    						codes[i] = BitReverse(nextCode[bits-1]);  						nextCode[bits-1] += 1 << (16 - bits);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int n = 0; n < numSymbols; n++) {  					int freq = freqs[n];  					if (freq != 0) {  						// Insert n into heap  						int pos = heapLen++;  						int ppos;  						while (pos > 0 && freqs[heap[ppos = (pos - 1) / 2]] > freq) {  							heap[pos] = heap[ppos];  							pos = ppos;  						}  						heap[pos] = n;  						  						maxCode = n;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2) {  					int node = maxCode < 2 ? ++maxCode : 0;  					heap[heapLen++] = node;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: while (heapLen < 2) {  					int node = maxCode < 2 ? ++maxCode : 0;  					heap[heapLen++] = node;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: int[] childs = new int[4 * heapLen - 2];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: int[] values = new int[2 * heapLen - 1];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++) {  					int node = heap[i];  					childs[2 * i]   = node;  					childs[2 * i + 1] = -1;  					values[i] = freqs[node] << 8;  					heap[i] = i;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++) {  					int node = heap[i];  					childs[2 * i]   = node;  					childs[2 * i + 1] = -1;  					values[i] = freqs[node] << 8;  					heap[i] = i;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: for (int i = 0; i < heapLen; i++) {  					int node = heap[i];  					childs[2 * i]   = node;  					childs[2 * i + 1] = -1;  					values[i] = freqs[node] << 8;  					heap[i] = i;  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last  = heap[--heapLen];  					  					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}  						  					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  					  					  					int second = heap[0];  					  					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;  					  					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}  						  					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last  = heap[--heapLen];  					  					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}  						  					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  					  					  					int second = heap[0];  					  					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;  					  					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}  						  					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last  = heap[--heapLen];  					  					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}  						  					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  					  					  					int second = heap[0];  					  					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;  					  					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}  						  					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last  = heap[--heapLen];  					  					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}  						  					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  					  					  					int second = heap[0];  					  					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;  					  					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}  						  					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last  = heap[--heapLen];  					  					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}  						  					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  					  					  					int second = heap[0];  					  					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;  					  					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}  						  					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: do {  					int first = heap[0];  					int last  = heap[--heapLen];  					  					// Propagate the hole to the leafs of the heap  					int ppos = 0;  					int path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = path * 2 + 1;  					}  						  					/* Now propagate the last element down along path.  Normally  					* it shouldn't go too deep.  					*/  					int lastVal = values[last];  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  					  					  					int second = heap[0];  					  					// Create a new node father of first and second  					last = numNodes++;  					childs[2 * last] = first;  					childs[2 * last + 1] = second;  					int mindepth = Math.Min(values[first] & 0xff' values[second] & 0xff);  					values[last] = lastVal = values[first] + values[second] - mindepth + 1;  					  					// Again' propagate the hole to the leafs  					ppos = 0;  					path = 1;  					  					while (path < heapLen) {  						if (path + 1 < heapLen && values[heap[path]] > values[heap[path+1]]) {  							path++;  						}  							  						heap[ppos] = heap[path];  						ppos = path;  						path = ppos * 2 + 1;  					}  						  					// Now propagate the new element down along path  					while ((path = ppos) > 0 && values[heap[ppos = (path - 1)/2]] > lastVal) {  						heap[path] = heap[ppos];  					}  					heap[path] = last;  				} while (heapLen > 1);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildTree,The following statement contains a magic number: if (heap[0] != childs.Length / 2 - 1) {  					throw new SharpZipBaseException("Heap invariant violated");  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,CalcBLFreq,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.freqs[nextlen]++;  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						blTree.freqs[curlen] += (short)count;  					} else if (curlen != 0) {  						blTree.freqs[REP_3_6]++;  					} else if (count <= 10) {  						blTree.freqs[REP_3_10]++;  					} else {  						blTree.freqs[REP_11_138]++;  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,WriteTree,The following statement contains a magic number: while (i < numCodes) {  					count = 1;  					int nextlen = length[i];  					if (nextlen == 0) {  						max_count = 138;  						min_count = 3;  					} else {  						max_count = 6;  						min_count = 3;  						if (curlen != nextlen) {  							blTree.WriteSymbol(nextlen);  							count = 0;  						}  					}  					curlen = nextlen;  					i++;  					  					while (i < numCodes && curlen == length[i]) {  						i++;  						if (++count >= max_count) {  							break;  						}  					}  					  					if (count < min_count) {  						while (count-- > 0) {  							blTree.WriteSymbol(curlen);  						}  					} else if (curlen != 0) {  						blTree.WriteSymbol(REP_3_6);  						dh.pending.WriteBits(count - 3' 2);  					} else if (count <= 10) {  						blTree.WriteSymbol(REP_3_10);  						dh.pending.WriteBits(count - 3' 3);  					} else {  						blTree.WriteSymbol(REP_11_138);  						dh.pending.WriteBits(count - 11' 7);  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int numNodes = childs.Length / 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int numLeafs = (numNodes + 1) / 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2*i]] = (byte) lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2*i]] = (byte) lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2*i]] = (byte) lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int i = numNodes - 1; i >= 0; i--) {  					if (childs[2 * i + 1] != -1) {  						int bitLength = lengths[i] + 1;  						if (bitLength > maxLength) {  							bitLength = maxLength;  							overflow++;  						}  						lengths[childs[2 * i]] = lengths[childs[2 * i + 1]] = bitLength;  					} else {  						// A leaf node  						int bitLength = lengths[i];  						bl_counts[bitLength - 1]++;  						this.length[childs[2*i]] = (byte) lengths[i];  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: bl_counts[maxLength-2] -= overflow;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: int nodePtr = 2 * numLeafs;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Tree,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterHuffman.cs,BuildLength,The following statement contains a magic number: for (int bits = maxLength; bits != 0; bits--) {  					int n = bl_counts[bits-1];  					while (n > 0) {  						int childPtr = 2*childs[nodePtr++];  						if (childs[childPtr + 1] == -1) {  							// We found another leaf  							length[childs[childPtr]] = (byte) bits;  							n--;  						}  					}  				}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflaterEngine,The following statement contains a magic number: window = new byte[2 * WSIZE];
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetDictionary,The following statement contains a magic number: strstart += 2;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following statement contains a magic number: if ( (level < 0) || (level > 9) )  			{  				throw new ArgumentOutOfRangeException("level");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,FillWindow,The following statement contains a magic number: while (lookahead < DeflaterConstants.MIN_LOOKAHEAD && inputOff < inputEnd)   			{  				int more = 2 * WSIZE - lookahead - strstart;  				  				if (more > inputEnd - inputOff)   				{  					more = inputEnd - inputOff;  				}  				  				System.Array.Copy(inputBuf' inputOff' window' strstart + lookahead' more);  				adler.Update(inputBuf' inputOff' more);  				  				inputOff += more;  				totalIn  += more;  				lookahead += more;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: if (best_len >= this.goodLength) {  				chainLength >>= 2;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {    #if DebugDeflation    				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) )  				{  					throw new InvalidOperationException("no future");  				}  #endif              				if (window[curMatch + best_len] != scan_end      ||   					window[curMatch + best_len - 1] != scan_end1 ||   					window[curMatch] != window[scan]             ||   					window[curMatch + 1] != window[scan + 1]) {  					continue;  				}  				  				match = curMatch + 2;  				scan += 2;  				  				/* We check for insufficient lookahead only every 8th comparison;  				* the 256th check will be made at strstart + 258.  				*/  				while (  					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&  					(scan < strend))  				{  					// Do nothing  				}  				  				if (scan > best_end) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && (ins_h == 0) )  						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));  #endif  					matchStart = curMatch;  					best_end = scan;  					best_len = scan - strstart;  					  					if (best_len >= niceLength) {  						break;  					}  					  					scan_end1  = window[best_end - 1];  					scan_end   = window[best_end];  				}  				scan = strstart;  			} while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,FindLongestMatch,The following statement contains a magic number: do {    #if DebugDeflation    				if (DeflaterConstants.DEBUGGING && (curMatch >= strstart) )  				{  					throw new InvalidOperationException("no future");  				}  #endif              				if (window[curMatch + best_len] != scan_end      ||   					window[curMatch + best_len - 1] != scan_end1 ||   					window[curMatch] != window[scan]             ||   					window[curMatch + 1] != window[scan + 1]) {  					continue;  				}  				  				match = curMatch + 2;  				scan += 2;  				  				/* We check for insufficient lookahead only every 8th comparison;  				* the 256th check will be made at strstart + 258.  				*/  				while (  					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&   					window[++scan] == window[++match] &&  					(scan < strend))  				{  					// Do nothing  				}  				  				if (scan > best_end) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && (ins_h == 0) )  						Console.Error.WriteLine("Found match: " + curMatch + "-" + (scan - strstart));  #endif  					matchStart = curMatch;  					best_end = scan;  					best_len = scan - strstart;  					  					if (best_len >= niceLength) {  						break;  					}  					  					scan_end1  = window[best_end - 1];  					scan_end   = window[best_end];  				}  				scan = strstart;  			} while ((curMatch = (prev[curMatch & WMASK] & 0xffff)) > limit && --chainLength != 0);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateFast,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					// We are flushing everything  					huffman.FlushBlock(window' blockStart' strstart - blockStart' finish);  					blockStart = strstart;  					return false;  				}  				  				if (strstart > 2 * WSIZE - MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}  				  				int hashHead;  				if (lookahead >= MIN_MATCH &&   					(hashHead = InsertString()) != 0 &&   					strategy != DeflateStrategy.HuffmanOnly &&  					strstart - hashHead <= MAX_DIST &&   					FindLongestMatch(hashHead)) {  					// longestMatch sets matchStart and matchLen  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  						for (int i = 0 ; i < matchLen; i++) {  							if (window[strstart + i] != window[matchStart + i]) {  								throw new SharpZipBaseException("Match failure");  							}  						}  					}  #endif					    					bool full = huffman.TallyDist(strstart - matchStart' matchLen);    					lookahead -= matchLen;  					if (matchLen <= max_lazy && lookahead >= MIN_MATCH) {  						while (--matchLen > 0) {  							++strstart;  							InsertString();  						}  						++strstart;  					} else {  						strstart += matchLen;  						if (lookahead >= MIN_MATCH - 1) {  							UpdateHash();  						}  					}  					matchLen = MIN_MATCH - 1;  					if (!full) {  						continue;  					}  				} else {  					// No match found  					huffman.TallyLit(window[strstart] & 0xff);  					++strstart;  					--lookahead;  				}  				  				if (huffman.IsFull()) {  					bool lastBlock = finish && (lookahead == 0);  					huffman.FlushBlock(window' blockStart' strstart - blockStart' lastBlock);  					blockStart = strstart;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart-1] & 0xff);  					}  					prevAvailable = false;  					  					// We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif                 					huffman.FlushBlock(window' blockStart' strstart - blockStart'  						finish);  					blockStart = strstart;  					return false;  				}  				  				if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}  				  				int prevMatch = matchStart;  				int prevLen = matchLen;  				if (lookahead >= MIN_MATCH) {    					int hashHead = InsertString();    					if (strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= MAX_DIST &&  						FindLongestMatch(hashHead)) {  						  						// longestMatch sets matchStart and matchLen  							  						// Discard match if too small and too far away  						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  							matchLen = MIN_MATCH - 1;  						}  					}  				}  				  				// previous match was better  				if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen) ) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif  					huffman.TallyDist(strstart - 1 - prevMatch' prevLen);  					prevLen -= 2;  					do {  						strstart++;  						lookahead--;  						if (lookahead >= MIN_MATCH) {  							InsertString();  						}  					} while (--prevLen > 0);    					strstart ++;  					lookahead--;  					prevAvailable = false;  					matchLen = MIN_MATCH - 1;  				} else {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart-1] & 0xff);  					}  					prevAvailable = true;  					strstart++;  					lookahead--;  				}  				  				if (huffman.IsFull()) {  					int len = strstart - blockStart;  					if (prevAvailable) {  						len--;  					}  					bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  					huffman.FlushBlock(window' blockStart' len' lastBlock);  					blockStart += len;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart-1] & 0xff);  					}  					prevAvailable = false;  					  					// We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif                 					huffman.FlushBlock(window' blockStart' strstart - blockStart'  						finish);  					blockStart = strstart;  					return false;  				}  				  				if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}  				  				int prevMatch = matchStart;  				int prevLen = matchLen;  				if (lookahead >= MIN_MATCH) {    					int hashHead = InsertString();    					if (strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= MAX_DIST &&  						FindLongestMatch(hashHead)) {  						  						// longestMatch sets matchStart and matchLen  							  						// Discard match if too small and too far away  						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  							matchLen = MIN_MATCH - 1;  						}  					}  				}  				  				// previous match was better  				if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen) ) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif  					huffman.TallyDist(strstart - 1 - prevMatch' prevLen);  					prevLen -= 2;  					do {  						strstart++;  						lookahead--;  						if (lookahead >= MIN_MATCH) {  							InsertString();  						}  					} while (--prevLen > 0);    					strstart ++;  					lookahead--;  					prevAvailable = false;  					matchLen = MIN_MATCH - 1;  				} else {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart-1] & 0xff);  					}  					prevAvailable = true;  					strstart++;  					lookahead--;  				}  				  				if (huffman.IsFull()) {  					int len = strstart - blockStart;  					if (prevAvailable) {  						len--;  					}  					bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  					huffman.FlushBlock(window' blockStart' len' lastBlock);  					blockStart += len;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,DeflateSlow,The following statement contains a magic number: while (lookahead >= MIN_LOOKAHEAD || flush) {  				if (lookahead == 0) {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart-1] & 0xff);  					}  					prevAvailable = false;  					  					// We are flushing everything  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING && !flush)   					{  						throw new SharpZipBaseException("Not flushing' but no lookahead");  					}  #endif                 					huffman.FlushBlock(window' blockStart' strstart - blockStart'  						finish);  					blockStart = strstart;  					return false;  				}  				  				if (strstart >= 2 * WSIZE - MIN_LOOKAHEAD) {  					/* slide window' as FindLongestMatch needs this.  					 * This should only happen when flushing and the window  					 * is almost full.  					 */  					SlideWindow();  				}  				  				int prevMatch = matchStart;  				int prevLen = matchLen;  				if (lookahead >= MIN_MATCH) {    					int hashHead = InsertString();    					if (strategy != DeflateStrategy.HuffmanOnly &&  						hashHead != 0 &&  						strstart - hashHead <= MAX_DIST &&  						FindLongestMatch(hashHead)) {  						  						// longestMatch sets matchStart and matchLen  							  						// Discard match if too small and too far away  						if (matchLen <= 5 && (strategy == DeflateStrategy.Filtered || (matchLen == MIN_MATCH && strstart - matchStart > TooFar))) {  							matchLen = MIN_MATCH - 1;  						}  					}  				}  				  				// previous match was better  				if ((prevLen >= MIN_MATCH) && (matchLen <= prevLen) ) {  #if DebugDeflation  					if (DeflaterConstants.DEBUGGING)   					{  					   for (int i = 0 ; i < matchLen; i++) {  						  if (window[strstart-1+i] != window[prevMatch + i])  							 throw new SharpZipBaseException();  						}  					}  #endif  					huffman.TallyDist(strstart - 1 - prevMatch' prevLen);  					prevLen -= 2;  					do {  						strstart++;  						lookahead--;  						if (lookahead >= MIN_MATCH) {  							InsertString();  						}  					} while (--prevLen > 0);    					strstart ++;  					lookahead--;  					prevAvailable = false;  					matchLen = MIN_MATCH - 1;  				} else {  					if (prevAvailable) {  						huffman.TallyLit(window[strstart-1] & 0xff);  					}  					prevAvailable = true;  					strstart++;  					lookahead--;  				}  				  				if (huffman.IsFull()) {  					int len = strstart - blockStart;  					if (prevAvailable) {  						len--;  					}  					bool lastBlock = (finish && (lookahead == 0) && !prevAvailable);  					huffman.FlushBlock(window' blockStart' len' lastBlock);  					blockStart += len;  					return !lastBlock;  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: int header = input.PeekBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: input.DropBits(16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: header = ((header << 8) | (header >> 8)) & 0xffff;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if (header % 31 != 0) {  				throw new SharpZipBaseException("Header checksum illegal");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0f00) != (Deflater.DEFLATED << 8)) {  				throw new SharpZipBaseException("Compression Method unknown");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHeader,The following statement contains a magic number: if ((header & 0x0020) == 0) { // Dictionary flag?  				mode = DECODE_BLOCKS;  			} else {  				mode = DECODE_DICT;  				neededBits = 32;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeDict,The following statement contains a magic number: while (neededBits > 0) {  				int dictByte = input.PeekBits(8);  				if (dictByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | dictByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeHuffman,The following statement contains a magic number: while (free >= 258)   			{  				int symbol;  				switch (mode)   				{  					case DECODE_HUFFMAN:  						// This is the inner loop so it is optimized a bit  						while (((symbol = litlenTree.GetSymbol(input)) & ~0xff) == 0)   						{  							outputWindow.Write(symbol);  							if (--free < 258)   							{  								return true;  							}  						}  						  						if (symbol < 257)   						{  							if (symbol < 0)   							{  								return false;  							}   							else   							{  								// symbol == 256: end of block  								distTree = null;  								litlenTree = null;  								mode = DECODE_BLOCKS;  								return true;  							}  						}  						  						try   						{  							repLength = CPLENS[symbol - 257];  							neededBits = CPLEXT[symbol - 257];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep length code");  						}  						goto case DECODE_HUFFMAN_LENBITS; // fall through  						  					case DECODE_HUFFMAN_LENBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_LENBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repLength += i;  						}  						mode = DECODE_HUFFMAN_DIST;  						goto case DECODE_HUFFMAN_DIST; // fall through  						  					case DECODE_HUFFMAN_DIST:  						symbol = distTree.GetSymbol(input);  						if (symbol < 0)   						{  							return false;  						}  						  						try   						{  							repDist = CPDIST[symbol];  							neededBits = CPDEXT[symbol];  						}   						catch (Exception)   						{  							throw new SharpZipBaseException("Illegal rep dist code");  						}  						  						goto case DECODE_HUFFMAN_DISTBITS; // fall through  						  					case DECODE_HUFFMAN_DISTBITS:  						if (neededBits > 0)   						{  							mode = DECODE_HUFFMAN_DISTBITS;  							int i = input.PeekBits(neededBits);  							if (i < 0)   							{  								return false;  							}  							input.DropBits(neededBits);  							repDist += i;  						}  						  						outputWindow.Repeat(repLength' repDist);  						free -= repLength;  						mode = DECODE_HUFFMAN;  						break;  					  					default:  						throw new SharpZipBaseException("Inflater unknown mode");  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,DecodeChksum,The following statement contains a magic number: while (neededBits > 0) {  				int chkByte = input.PeekBits(8);  				if (chkByte < 0) {  					return false;  				}  				input.DropBits(8);  				readAdler = (readAdler << 8) | chkByte;  				neededBits -= 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Inflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Inflater.cs,Decode,The following statement contains a magic number: switch (mode) {  				case DECODE_HEADER:  					return DecodeHeader();    				case DECODE_DICT:  					return DecodeDict();    				case DECODE_CHKSUM:  					return DecodeChksum();  				  				case DECODE_BLOCKS:  					if (isLastBlock) {  						if (noHeader) {  							mode = FINISHED;  							return false;  						} else {  							input.SkipToByteBoundary();  							neededBits = 32;  							mode = DECODE_CHKSUM;  							return true;  						}  					}  					  					int type = input.PeekBits(3);  					if (type < 0) {  						return false;  					}  					input.DropBits(3);  					  					if ((type & 1) != 0) {  						isLastBlock = true;  					}  					switch (type >> 1){  						case DeflaterConstants.STORED_BLOCK:  							input.SkipToByteBoundary();  							mode = DECODE_STORED_LEN1;  							break;  						case DeflaterConstants.STATIC_TREES:  							litlenTree = InflaterHuffmanTree.defLitLenTree;  							distTree = InflaterHuffmanTree.defDistTree;  							mode = DECODE_HUFFMAN;  							break;  						case DeflaterConstants.DYN_TREES:  							dynHeader = new InflaterDynHeader();  							mode = DECODE_DYN_HEADER;  							break;  						default:  							throw new SharpZipBaseException("Unknown block type " + type);  					}  					return true;  				  				case DECODE_STORED_LEN1:   				{  					if ((uncomprLen = input.PeekBits(16)) < 0) {  						return false;  					}  					input.DropBits(16);  					mode = DECODE_STORED_LEN2;  				}  					goto case DECODE_STORED_LEN2; // fall through  					  				case DECODE_STORED_LEN2:   				{  					int nlen = input.PeekBits(16);  					if (nlen < 0) {  						return false;  					}  					input.DropBits(16);  					if (nlen != (uncomprLen ^ 0xffff)) {  						throw new SharpZipBaseException("broken uncompressed block");  					}  					mode = DECODE_STORED;  				}  					goto case DECODE_STORED; // fall through  					  				case DECODE_STORED:   				{  					int more = outputWindow.CopyStored(input' uncomprLen);  					uncomprLen -= more;  					if (uncomprLen == 0) {  						mode = DECODE_BLOCKS;  						return true;  					}  					return !input.IsNeedingInput;  				}  				  				case DECODE_DYN_HEADER:  					if (!dynHeader.Decode(input)) {  						return false;  					}  					  					litlenTree = dynHeader.BuildLitLenTree();  					distTree = dynHeader.BuildDistTree();  					mode = DECODE_HUFFMAN;  					goto case DECODE_HUFFMAN; // fall through  					  				case DECODE_HUFFMAN:  				case DECODE_HUFFMAN_LENBITS:  				case DECODE_HUFFMAN_DIST:  				case DECODE_HUFFMAN_DISTBITS:  					return DecodeHuffman();  				  				case FINISHED:  					return false;  				  				default:  					throw new SharpZipBaseException("Inflater.Decode unknown mode");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflater,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  				level = 6;  			} else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  				throw new ArgumentOutOfRangeException("level");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,SetLevel,The following statement contains a magic number: if (level == DEFAULT_COMPRESSION) {  				level = 6;  			} else if (level < NO_COMPRESSION || level > BEST_COMPRESSION) {  				throw new ArgumentOutOfRangeException("level");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: if (state < BUSY_STATE) {  				// output header  				int header = (DEFLATED +  					((DeflaterConstants.MAX_WBITS - 8) << 4)) << 8;  				int level_flags = (level - 1) >> 1;  				if (level_flags < 0 || level_flags > 3) {  					level_flags = 3;  				}  				header |= level_flags << 6;  				if ((state & IS_SETDICT) != 0) {  					// Dictionary was set  					header |= DeflaterConstants.PRESET_DICT;  				}  				header += 31 - (header % 31);  				  				pending.WriteShortMSB(header);  				if ((state & IS_SETDICT) != 0) {  					int chksum = engine.Adler;  					engine.ResetAdler();  					pending.WriteShortMSB(chksum >> 16);  					pending.WriteShortMSB(chksum & 0xffff);  				}  				  				state = BUSY_STATE | (state & (IS_FLUSHING | IS_FINISHING));  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset   += count;  				totalOut += count;  				length   -= count;  				  				if (length == 0 || state == FINISHED_STATE) {  					break;  				}  				  				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					if (state == BUSY_STATE) {  						// We need more input now  						return origLength - length;  					} else if (state == FLUSHING_STATE) {  						if (level != NO_COMPRESSION) {  							/* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */  							int neededbits = 8 + ((-pending.BitCount) & 7);  							while (neededbits > 0) {  								/* write a static tree block consisting solely of  								 * an EOF:  								 */  								pending.WriteBits(2' 10);  								neededbits -= 10;  							}  						}  						state = BUSY_STATE;  					} else if (state == FINISHING_STATE) {  						pending.AlignToByte();    						// Compressed data is complete.  Write footer information if required.  						if (!noZlibHeaderOrFooter) {  							int adler = engine.Adler;  							pending.WriteShortMSB(adler >> 16);  							pending.WriteShortMSB(adler & 0xffff);  						}  						state = FINISHED_STATE;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset   += count;  				totalOut += count;  				length   -= count;  				  				if (length == 0 || state == FINISHED_STATE) {  					break;  				}  				  				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					if (state == BUSY_STATE) {  						// We need more input now  						return origLength - length;  					} else if (state == FLUSHING_STATE) {  						if (level != NO_COMPRESSION) {  							/* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */  							int neededbits = 8 + ((-pending.BitCount) & 7);  							while (neededbits > 0) {  								/* write a static tree block consisting solely of  								 * an EOF:  								 */  								pending.WriteBits(2' 10);  								neededbits -= 10;  							}  						}  						state = BUSY_STATE;  					} else if (state == FINISHING_STATE) {  						pending.AlignToByte();    						// Compressed data is complete.  Write footer information if required.  						if (!noZlibHeaderOrFooter) {  							int adler = engine.Adler;  							pending.WriteShortMSB(adler >> 16);  							pending.WriteShortMSB(adler & 0xffff);  						}  						state = FINISHED_STATE;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset   += count;  				totalOut += count;  				length   -= count;  				  				if (length == 0 || state == FINISHED_STATE) {  					break;  				}  				  				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					if (state == BUSY_STATE) {  						// We need more input now  						return origLength - length;  					} else if (state == FLUSHING_STATE) {  						if (level != NO_COMPRESSION) {  							/* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */  							int neededbits = 8 + ((-pending.BitCount) & 7);  							while (neededbits > 0) {  								/* write a static tree block consisting solely of  								 * an EOF:  								 */  								pending.WriteBits(2' 10);  								neededbits -= 10;  							}  						}  						state = BUSY_STATE;  					} else if (state == FINISHING_STATE) {  						pending.AlignToByte();    						// Compressed data is complete.  Write footer information if required.  						if (!noZlibHeaderOrFooter) {  							int adler = engine.Adler;  							pending.WriteShortMSB(adler >> 16);  							pending.WriteShortMSB(adler & 0xffff);  						}  						state = FINISHED_STATE;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset   += count;  				totalOut += count;  				length   -= count;  				  				if (length == 0 || state == FINISHED_STATE) {  					break;  				}  				  				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					if (state == BUSY_STATE) {  						// We need more input now  						return origLength - length;  					} else if (state == FLUSHING_STATE) {  						if (level != NO_COMPRESSION) {  							/* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */  							int neededbits = 8 + ((-pending.BitCount) & 7);  							while (neededbits > 0) {  								/* write a static tree block consisting solely of  								 * an EOF:  								 */  								pending.WriteBits(2' 10);  								neededbits -= 10;  							}  						}  						state = BUSY_STATE;  					} else if (state == FINISHING_STATE) {  						pending.AlignToByte();    						// Compressed data is complete.  Write footer information if required.  						if (!noZlibHeaderOrFooter) {  							int adler = engine.Adler;  							pending.WriteShortMSB(adler >> 16);  							pending.WriteShortMSB(adler & 0xffff);  						}  						state = FINISHED_STATE;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset   += count;  				totalOut += count;  				length   -= count;  				  				if (length == 0 || state == FINISHED_STATE) {  					break;  				}  				  				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					if (state == BUSY_STATE) {  						// We need more input now  						return origLength - length;  					} else if (state == FLUSHING_STATE) {  						if (level != NO_COMPRESSION) {  							/* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */  							int neededbits = 8 + ((-pending.BitCount) & 7);  							while (neededbits > 0) {  								/* write a static tree block consisting solely of  								 * an EOF:  								 */  								pending.WriteBits(2' 10);  								neededbits -= 10;  							}  						}  						state = BUSY_STATE;  					} else if (state == FINISHING_STATE) {  						pending.AlignToByte();    						// Compressed data is complete.  Write footer information if required.  						if (!noZlibHeaderOrFooter) {  							int adler = engine.Adler;  							pending.WriteShortMSB(adler >> 16);  							pending.WriteShortMSB(adler & 0xffff);  						}  						state = FINISHED_STATE;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression,Deflater,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Deflater.cs,Deflate,The following statement contains a magic number: for (;;) {  				int count = pending.Flush(output' offset' length);  				offset   += count;  				totalOut += count;  				length   -= count;  				  				if (length == 0 || state == FINISHED_STATE) {  					break;  				}  				  				if (!engine.Deflate((state & IS_FLUSHING) != 0' (state & IS_FINISHING) != 0)) {  					if (state == BUSY_STATE) {  						// We need more input now  						return origLength - length;  					} else if (state == FLUSHING_STATE) {  						if (level != NO_COMPRESSION) {  							/* We have to supply some lookahead.  8 bit lookahead  							 * is needed by the zlib inflater' and we must fill  							 * the next byte' so that all bits are flushed.  							 */  							int neededbits = 8 + ((-pending.BitCount) & 7);  							while (neededbits > 0) {  								/* write a static tree block consisting solely of  								 * an EOF:  								 */  								pending.WriteBits(2' 10);  								neededbits -= 10;  							}  						}  						state = BUSY_STATE;  					} else if (state == FINISHING_STATE) {  						pending.AlignToByte();    						// Compressed data is complete.  Write footer information if required.  						if (!noZlibHeaderOrFooter) {  							int adler = engine.Adler;  							pending.WriteShortMSB(adler >> 16);  							pending.WriteShortMSB(adler & 0xffff);  						}  						state = FINISHED_STATE;  					}  				}  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if ( bufferSize < 1024 ) {  				bufferSize = 1024;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,InflaterInputBuffer,The following statement contains a magic number: if ( bufferSize < 1024 ) {  				bufferSize = 1024;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeShort,The following statement contains a magic number: return ReadLeByte() | (ReadLeByte() << 8);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeInt,The following statement contains a magic number: return ReadLeShort() | (ReadLeShort() << 16);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputBuffer,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,ReadLeLong,The following statement contains a magic number: return (uint)ReadLeInt() | ((long)ReadLeInt() << 32);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,InflaterInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\InflaterInputStream.cs,Skip,The following statement contains a magic number: if (baseInputStream.CanSeek)   			{  				baseInputStream.Seek(count' SeekOrigin.Current);  				return count;  			}   			else   			{  				int len = 2048;  				if (count < len)   				{  					len = (int) count;  				}  				byte[] tmp = new byte[len];  				return (long)baseInputStream.Read(tmp' 0' tmp.Length);  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  				                 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,PeekBits,The following statement contains a magic number: if (bitsInBuffer_ < bitCount) {  				if (windowStart_ == windowEnd_) {  					return -1; // ok  				}  				buffer_ |= (uint)((window_[windowStart_++] & 0xff |  				                 (window_[windowStart_++] & 0xff) << 8) << bitsInBuffer_);  				bitsInBuffer_ += 16;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: buffer_ >>= (bitsInBuffer_ & 7);
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SkipToByteBoundary,The following statement contains a magic number: bitsInBuffer_ &= ~7;
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if ((bitsInBuffer_ & 7) != 0) {  				// bits_in_buffer may only be 0 or a multiple of 8  				throw new InvalidOperationException("Bit buffer is not byte aligned!");  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte) buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: while ((bitsInBuffer_ > 0) && (length > 0)) {  				output[offset++] = (byte) buffer_;  				buffer_ >>= 8;  				bitsInBuffer_ -= 8;  				length--;  				count++;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,CopyBytes,The following statement contains a magic number: if (((windowStart_ - windowEnd_) & 1) != 0) {  				// We always want an even number of bytes in input' see peekBits  				buffer_ = (uint)(window_[windowStart_++] & 0xff);  				bitsInBuffer_ = 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Zip.Compression.Streams,StreamManipulator,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\Streams\StreamManipulator.cs,SetInput,The following statement contains a magic number: if ((count & 1) != 0) {  				// We always want an even number of bytes in input' see PeekBits  				buffer_ |= (uint)((buffer[offset++] & 0xff) << bitsInBuffer_);  				bitsInBuffer_ += 8;  			}
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if (buffer.Length < 128) {  				throw new ArgumentException("Buffer is too small"' "buffer");  			}
Magic Number,ICSharpCode.SharpZipLib.Core,StreamUtils,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Core\StreamUtils.cs,Copy,The following statement contains a magic number: if ( buffer.Length < 128 ) {  				throw new ArgumentException("Buffer is too small"' "buffer");  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)   			{  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)   			{  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)   			{  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: for (int i = 0; i < seed.Length; ++i)   			{  				newKeys[0] = Crc32.ComputeCrc32(newKeys[0]' seed[i]);  				newKeys[1] = newKeys[1] + (byte)newKeys[0];  				newKeys[1] = newKeys[1] * 134775813 + 1;  				newKeys[2] = Crc32.ComputeCrc32(newKeys[2]' (byte)(newKeys[1] >> 24));  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: byte[] result = new byte[12];
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[1] = (byte)((newKeys[0] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[2] = (byte)((newKeys[0] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[2] = (byte)((newKeys[0] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[3] = (byte)((newKeys[0] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[3] = (byte)((newKeys[0] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[4] = (byte)(newKeys[1] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[5] = (byte)((newKeys[1] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[5] = (byte)((newKeys[1] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[6] = (byte)((newKeys[1] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[6] = (byte)((newKeys[1] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[7] = (byte)((newKeys[1] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[7] = (byte)((newKeys[1] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[8] = (byte)(newKeys[2] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[8] = (byte)(newKeys[2] & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte)((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte)((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[9] = (byte)((newKeys[2] >> 8) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte)((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte)((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[10] = (byte)((newKeys[2] >> 16) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte)((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte)((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassic,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKeys,The following statement contains a magic number: result[11] = (byte)((newKeys[2] >> 24) & 0xff);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: uint temp = ((keys[2] & 0xFFFF) | 2);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: uint temp = ((keys[2] & 0xFFFF) | 2);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,TransformByte,The following statement contains a magic number: return (byte)((temp * (temp ^ 1)) >> 8);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: if ( keyData.Length != 12 ) {  				throw new InvalidOperationException("Key length is not valid");  			}
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys = new uint[3];
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[0] = (uint)((keyData[3] << 24) | (keyData[2] << 16) | (keyData[1] << 8) | keyData[0]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[1] = (uint)((keyData[7] << 24) | (keyData[6] << 16) | (keyData[5] << 8) | keyData[4]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,SetKeys,The following statement contains a magic number: keys[2] = (uint)((keyData[11] << 24) | (keyData[10] << 16) | (keyData[9] << 8) | keyData[8]);
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[1] = keys[1] * 134775813 + 1;
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte)(keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte)(keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,UpdateKeys,The following statement contains a magic number: keys[2] = Crc32.ComputeCrc32(keys[2]' (byte)(keys[1] >> 24));
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicCryptoBase,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,Reset,The following statement contains a magic number: keys[2] = 0;
Magic Number,ICSharpCode.SharpZipLib.Encryption,PkzipClassicManaged,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Encryption\PkzipClassic.cs,GenerateKey,The following statement contains a magic number: key_ = new byte[12];
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (13' 32)' (21' 40)' (29' 48))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 39)' (13' 47))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((5' 24)' (21' 40)' (29' 48))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 88)' (70' 101))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,FullGtU,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 76)' (83' 102))
Duplicate Code,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The method contains a code clone-set at the following line numbers (starting from the method definition): ((42' 61)' (70' 89))
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipInputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipInputStream.cs,BodyRead,The following switch statement is missing a default case: switch (method) {  				case (int)CompressionMethod.Deflated:  					count = base.Read(buffer' offset' count);  					if (count <= 0) {  						if (!inf.IsFinished) {  							throw new ZipException("Inflater not finished!");  						}  						inputBuffer.Available = inf.RemainingInput;  						  						if ((flags & 8) == 0 && (inf.TotalIn != csize || inf.TotalOut != size)) {  							throw new ZipException("Size mismatch: " + csize + ";" + size + " <-> " + inf.TotalIn + ";" + inf.TotalOut);  						}  						inf.Reset();  						finished = true;  					}  					break;  					  				case (int)CompressionMethod.Stored:  					if ( (count > csize) && (csize >= 0) ) {  						count = (int)csize;  					}  					  					if ( count > 0 ) {  						count = inputBuffer.ReadClearTextBuffer(buffer' offset' count);  						if (count > 0) {  							csize -= count;  							size -= count;  						}  					}  					  					if (csize == 0) {  						finished = true;  					} else {  						if (count < 0) {  							throw new ZipException("EOF in stored block");  						}  					}  					break;  			}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipOutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipOutputStream.cs,Write,The following switch statement is missing a default case: switch (curMethod) {  				case CompressionMethod.Deflated:  					base.Write(buffer' offset' count);  					break;  				  				case CompressionMethod.Stored:  					if (Password != null) {  						CopyAndEncrypt(buffer' offset' count);  					} else {  						baseOutputStream_.Write(buffer' offset' count);  					}  					break;  			}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,WriteLocalEntryHeader,The following switch statement is missing a default case: switch (useZip64_) {  					case UseZip64.Dynamic:  						if (entry.Size < 0) {  							entry.ForceZip64();  						}  						break;    					case UseZip64.On:  						entry.ForceZip64();  						break;    					case UseZip64.Off:  						// Do nothing.  The entry itself may be using Zip64 independantly.  						break;  				}
Missing Default,ICSharpCode.SharpZipLib.Zip,ZipFile,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\ZipFile.cs,RunUpdates,The following switch statement is missing a default case: switch (update.Command) {  							case UpdateCommand.Copy:  								if (directUpdate) {  									CopyEntryDirect(workFile' update' ref destinationPosition);  								}  								else {  									CopyEntry(workFile' update);  								}  								break;    							case UpdateCommand.Modify:  								// TODO: Direct modifying of an entry will take some legwork.  								ModifyEntry(workFile' update);  								break;    							case UpdateCommand.Add:  								if (!IsNewArchive && directUpdate) {  									workFile.baseStream_.Position = destinationPosition;  								}    								AddEntry(workFile' update);    								if (directUpdate) {  									destinationPosition = workFile.baseStream_.Position;  								}  								break;  						}
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2) {  								case 0:  									szptr[wr] = (short)BZip2Constants.RUNA;  									wr++;  									mtfFreq[BZip2Constants.RUNA]++;  									break;  								case 1:  									szptr[wr] = (short)BZip2Constants.RUNB;  									wr++;  									mtfFreq[BZip2Constants.RUNB]++;  									break;  							}
Missing Default,ICSharpCode.SharpZipLib.BZip2,BZip2OutputStream,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\BZip2\BZip2OutputStream.cs,GenerateMTFValues,The following switch statement is missing a default case: switch (zPend % 2) {  						case 0:  							szptr[wr] = (short)BZip2Constants.RUNA;  							wr++;  							mtfFreq[BZip2Constants.RUNA]++;  							break;  						case 1:  							szptr[wr] = (short)BZip2Constants.RUNB;  							wr++;  							mtfFreq[BZip2Constants.RUNB]++;  							break;  					}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,InflaterDynHeader,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\InflaterDynHeader.cs,Decode,The following switch statement is missing a default case: switch (mode) {  						case LNUM:  							lnum = input.PeekBits(5);  							if (lnum < 0) {  								return false;  							}  							lnum += 257;  							input.DropBits(5);  							//  	    System.err.println("LNUM: "+lnum);  							mode = DNUM;  							goto case DNUM; // fall through  						case DNUM:  							dnum = input.PeekBits(5);  							if (dnum < 0) {  								return false;  							}  							dnum++;  							input.DropBits(5);  							//  	    System.err.println("DNUM: "+dnum);  							num = lnum+dnum;  							litdistLens = new byte[num];  							mode = BLNUM;  							goto case BLNUM; // fall through  						case BLNUM:  							blnum = input.PeekBits(4);  							if (blnum < 0) {  								return false;  							}  							blnum += 4;  							input.DropBits(4);  							blLens = new byte[19];  							ptr = 0;  							//  	    System.err.println("BLNUM: "+blnum);  							mode = BLLENS;  							goto case BLLENS; // fall through  						case BLLENS:  							while (ptr < blnum) {  								int len = input.PeekBits(3);  								if (len < 0) {  									return false;  								}  								input.DropBits(3);  								//  		System.err.println("blLens["+BL_ORDER[ptr]+"]: "+len);  								blLens[BL_ORDER[ptr]] = (byte) len;  								ptr++;  							}  							blTree = new InflaterHuffmanTree(blLens);  							blLens = null;  							ptr = 0;  							mode = LENS;  							goto case LENS; // fall through  						case LENS:   						{  							int symbol;  							while (((symbol = blTree.GetSymbol(input)) & ~15) == 0) {  								/* Normal case: symbol in [0..15] */  							  								//  		  System.err.println("litdistLens["+ptr+"]: "+symbol);  								litdistLens[ptr++] = lastLen = (byte)symbol;  							  								if (ptr == num) {  									/* Finished */  									return true;  								}  							}  						  							/* need more input ? */  							if (symbol < 0) {  								return false;  							}  						  							/* otherwise repeat code */  							if (symbol >= 17) {  								/* repeat zero */  								//  		  System.err.println("repeating zero");  								lastLen = 0;  							} else {  								if (ptr == 0) {  									throw new SharpZipBaseException();  								}  							}  							repSymbol = symbol-16;  						}  							mode = REPS;  							goto case REPS; // fall through  						case REPS:  						{  							int bits = repBits[repSymbol];  							int count = input.PeekBits(bits);  							if (count < 0) {  								return false;  							}  							input.DropBits(bits);  							count += repMin[repSymbol];  							//  	      System.err.println("litdistLens repeated: "+count);  							  							if (ptr + count > num) {  								throw new SharpZipBaseException();  							}  							while (count-- > 0) {  								litdistLens[ptr++] = lastLen;  							}  							  							if (ptr == num) {  								/* Finished */  								return true;  							}  						}  							mode = LENS;  							goto decode_loop;  					}
Missing Default,ICSharpCode.SharpZipLib.Zip.Compression,DeflaterEngine,C:\repos\WCell_WCell\Libraries\Source\ICSharpCode\SharpZipLib\Zip\Compression\DeflaterEngine.cs,SetLevel,The following switch statement is missing a default case: switch (compressionFunction) {  					case DEFLATE_STORED:  						if (strstart > blockStart) {  							huffman.FlushStoredBlock(window' blockStart'  								strstart - blockStart' false);  							blockStart = strstart;  						}  						UpdateHash();  						break;    					case DEFLATE_FAST:  						if (strstart > blockStart) {  							huffman.FlushBlock(window' blockStart' strstart - blockStart'  								false);  							blockStart = strstart;  						}  						break;    					case DEFLATE_SLOW:  						if (prevAvailable) {  							huffman.TallyLit(window[strstart-1] & 0xff);  						}  						if (strstart > blockStart) {  							huffman.FlushBlock(window' blockStart' strstart - blockStart' false);  							blockStart = strstart;  						}  						prevAvailable = false;  						matchLen = MIN_MATCH - 1;  						break;  				}
