Implementation smell,Namespace,Class,File,Method,Description
Long Method,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The method has 157 lines of code.
Long Method,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The method has 156 lines of code.
Complex Method,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,Decimate,Cyclomatic complexity of the method is 8
Complex Method,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,ApplyMeshPenalties,Cyclomatic complexity of the method is 8
Complex Method,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,Decimate,Cyclomatic complexity of the method is 8
Complex Method,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalInvert,Cyclomatic complexity of the method is 18
Complex Method,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,Cyclomatic complexity of the method is 23
Complex Method,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,Cyclomatic complexity of the method is 23
Complex Method,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,Cyclomatic complexity of the method is 18
Complex Method,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,CompactVertices,Cyclomatic complexity of the method is 8
Long Parameter List,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,MxQuadric3,The method has 5 parameters. Parameters: a' b' c' d' area
Long Parameter List,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The method has 5 parameters. Parameters: a' b' c' d' area
Long Parameter List,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitEdge,The method has 5 parameters. Parameters: vertA' vertB' midX' midY' midZ
Long Parameter List,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,Contract,The method has 5 parameters. Parameters: vertId1' vertId2' vertId3' newVert' changed
Long Parameter List,QSlim,QSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\QSlim.cs,QSlim,The method has 9 parameters. Parameters: vertices' indices' contractByFaces' joinOnly' placePolicy' weightPolicy' boundaryWeight' compactRatio' meshPenalty
Magic Number,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,ComputeFaceInfo,The following statement contains a magic number: var k = model.Face(faceId)[2];
Magic Number,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,ComputeFaceInfo,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal &&                  Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  info.HeapKey = (float)-Q.Evaluate(info.vNew);              }              else              {                  var v1 = new MxVector3(model.Vertex(i));                  var v2 = new MxVector3(model.Vertex(j));                  var v3 = new MxVector3(model.Vertex(k));                  var e1 = Q.Evaluate(v1);                  var e2 = Q.Evaluate(v2);                  var e3 = Q.Evaluate(v3);                    MxVector3 best;                  double eMin;                  if (e1 <= e2 && e1 <= e3)                  {                      eMin = e1;                      best = v1;                  }                   else if (e2 <= e1 && e2 <= e3)                  {                      eMin = e2;                      best = v2;                  }                  else                  {                      eMin = e3;                      best = v3;                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];                  info.HeapKey = (float)(-eMin);              }
Magic Number,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,ComputeFaceInfo,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal &&                  Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  info.HeapKey = (float)-Q.Evaluate(info.vNew);              }              else              {                  var v1 = new MxVector3(model.Vertex(i));                  var v2 = new MxVector3(model.Vertex(j));                  var v3 = new MxVector3(model.Vertex(k));                  var e1 = Q.Evaluate(v1);                  var e2 = Q.Evaluate(v2);                  var e3 = Q.Evaluate(v3);                    MxVector3 best;                  double eMin;                  if (e1 <= e2 && e1 <= e3)                  {                      eMin = e1;                      best = v1;                  }                   else if (e2 <= e1 && e2 <= e3)                  {                      eMin = e2;                      best = v2;                  }                  else                  {                      eMin = e3;                      best = v3;                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];                  info.HeapKey = (float)(-eMin);              }
Magic Number,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,ComputeFaceInfo,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal &&                  Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  info.HeapKey = (float)-Q.Evaluate(info.vNew);              }              else              {                  var v1 = new MxVector3(model.Vertex(i));                  var v2 = new MxVector3(model.Vertex(j));                  var v3 = new MxVector3(model.Vertex(k));                  var e1 = Q.Evaluate(v1);                  var e2 = Q.Evaluate(v2);                  var e3 = Q.Evaluate(v3);                    MxVector3 best;                  double eMin;                  if (e1 <= e2 && e1 <= e3)                  {                      eMin = e1;                      best = v1;                  }                   else if (e2 <= e1 && e2 <= e3)                  {                      eMin = e2;                      best = v2;                  }                  else                  {                      eMin = e3;                      best = v3;                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];                  info.HeapKey = (float)(-eMin);              }
Magic Number,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,Decimate,The following statement contains a magic number: while(ValidFaces > target)              {                  var info = heap.Extract() as TriInfo;                  if (info == null) return false;                    var faceId = info.FaceId;                  var v1 = model.Face(faceId)[0];                  var v2 = model.Face(faceId)[1];                  var v3 = model.Face(faceId)[2];                    if (!model.FaceIsValid(faceId)) continue;                                    model.Contract(v1' v2' v3' info.vNew' changed);                    quadrics[v1] += quadrics[v2];                  quadrics[v1] += quadrics[v3];                    ValidVerts -= 2;                  foreach (var changedFace in changed)                  {                      if (!model.FaceIsValid(changedFace))                           ValidFaces--;                  }                    foreach (var face in changed)                  {                      if (model.FaceIsValid(face)) ComputeFaceInfo(face);                      else heap.RemoveItem(faceInfo[face]);                  }              }
Magic Number,QSlim.MxKit,MxFaceQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceQSlim.cs,Decimate,The following statement contains a magic number: while(ValidFaces > target)              {                  var info = heap.Extract() as TriInfo;                  if (info == null) return false;                    var faceId = info.FaceId;                  var v1 = model.Face(faceId)[0];                  var v2 = model.Face(faceId)[1];                  var v3 = model.Face(faceId)[2];                    if (!model.FaceIsValid(faceId)) continue;                                    model.Contract(v1' v2' v3' info.vNew' changed);                    quadrics[v1] += quadrics[v2];                  quadrics[v1] += quadrics[v3];                    ValidVerts -= 2;                  foreach (var changedFace in changed)                  {                      if (!model.FaceIsValid(changedFace))                           ValidFaces--;                  }                    foreach (var face in changed)                  {                      if (model.FaceIsValid(face)) ComputeFaceInfo(face);                      else heap.RemoveItem(faceInfo[face]);                  }              }
Magic Number,QSlim.MxKit,MxGeom3d,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxGeom3d.cs,TriangleArea,The following statement contains a magic number: return 0.5*(MxVector3.Norm(vec));
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,AddVertex,The following statement contains a magic number: return AddVertex(vert[0]' vert[1]' vert[2]);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,AddFace,The following statement contains a magic number: return AddFace(face[0]' face[1]' face[2]);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceNormal,The following statement contains a magic number: var v2 = Vertex(Face(faceId)[2]);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceNormal,The following statement contains a magic number: var a = new[] {v1[0] - v0[0]' v1[1] - v0[1]' v1[2] - v0[2]};
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceNormal,The following statement contains a magic number: var a = new[] {v1[0] - v0[0]' v1[1] - v0[1]' v1[2] - v0[2]};
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceNormal,The following statement contains a magic number: var b = new[] {v2[0] - v0[0]' v2[1] - v0[1]' v2[2] - v0[2]};
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceNormal,The following statement contains a magic number: var b = new[] {v2[0] - v0[0]' v2[1] - v0[1]' v2[2] - v0[2]};
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFacePlane,The following statement contains a magic number: plane[3] = -MxVectorOps.Dot3(plane' Corner(faceId' 0).Pos);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceArea,The following statement contains a magic number: var normal = new double[3];
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFaceArea,The following statement contains a magic number: return 0.5*MxVectorOps.Length3(normal);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFacePerimeter,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  if (flags != null)                  {                     if (!flags[i]) continue;                  }                    var vi = Vertex(face[i]);                  var vj = Vertex(face[(i + 1)%3]);                  var diff = new double[3];                    MxVectorOps.Sub3(ref diff' vi.Pos' vj.Pos);                  perim += MxVectorOps.Length3(diff);              }
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFacePerimeter,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  if (flags != null)                  {                     if (!flags[i]) continue;                  }                    var vi = Vertex(face[i]);                  var vj = Vertex(face[(i + 1)%3]);                  var diff = new double[3];                    MxVectorOps.Sub3(ref diff' vi.Pos' vj.Pos);                  perim += MxVectorOps.Length3(diff);              }
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeFacePerimeter,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  if (flags != null)                  {                     if (!flags[i]) continue;                  }                    var vi = Vertex(face[i]);                  var vj = Vertex(face[(i + 1)%3]);                  var diff = new double[3];                    MxVectorOps.Sub3(ref diff' vi.Pos' vj.Pos);                  perim += MxVectorOps.Length3(diff);              }
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeCornerAngle,The following statement contains a magic number: var cornerPrev = (corner == 0) ? 2 : (corner - 1);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeCornerAngle,The following statement contains a magic number: var cornerNext = (corner == 2) ? 0 : (corner + 1);
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeCornerAngle,The following statement contains a magic number: var ePrev = new double[3];
Magic Number,QSlim.MxKit,MxBlockModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxBlockModel.cs,ComputeCornerAngle,The following statement contains a magic number: var eNext = new double[3];
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalCompactness,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  MxVector3[] fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var c = MxGeom3d.TriangleCompactness(fAfter[0]' fAfter[1]' fAfter[2]);                  if (c < cMin) cMin = c;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalCompactness,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  MxVector3[] fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var c = MxGeom3d.TriangleCompactness(fAfter[0]' fAfter[1]' fAfter[2]);                  if (c < cMin) cMin = c;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalCompactness,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  MxVector3[] fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var c = MxGeom3d.TriangleCompactness(fAfter[0]' fAfter[1]' fAfter[2]);                  if (c < cMin) cMin = c;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalInversion,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var nml = new double[3];                  model.ComputeFaceNormal(faceId' ref nml);                  var nBefore = new MxVector3(nml);                    var fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var newNml = MxGeom3d.TriangleNormal(fAfter[0]' fAfter[1]' fAfter[2]);                  var delta = nBefore*newNml;                  if (delta < nMin) nMin = delta;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalInversion,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var nml = new double[3];                  model.ComputeFaceNormal(faceId' ref nml);                  var nBefore = new MxVector3(nml);                    var fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var newNml = MxGeom3d.TriangleNormal(fAfter[0]' fAfter[1]' fAfter[2]);                  var delta = nBefore*newNml;                  if (delta < nMin) nMin = delta;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalInversion,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var nml = new double[3];                  model.ComputeFaceNormal(faceId' ref nml);                  var nBefore = new MxVector3(nml);                    var fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var newNml = MxGeom3d.TriangleNormal(fAfter[0]' fAfter[1]' fAfter[2]);                  var delta = nBefore*newNml;                  if (delta < nMin) nMin = delta;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalInversion,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var nml = new double[3];                  model.ComputeFaceNormal(faceId' ref nml);                  var nBefore = new MxVector3(nml);                    var fAfter = new MxVector3[3];                  for (var i = 0; i < 3; i++)                  {                      fAfter[i] = (face[i] == vertId)                                      ? new MxVector3(vNew)                                      : new MxVector3(model.Vertex(face[i]));                  }                    var newNml = MxGeom3d.TriangleNormal(fAfter[0]' fAfter[1]' fAfter[2]);                  var delta = nBefore*newNml;                  if (delta < nMin) nMin = delta;              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,CheckLocalValidity,The following statement contains a magic number: foreach (var faceId in n1)              {                  if (!model.FaceIsValid(faceId)) continue;                    var face = model.Face(faceId);                  var k = face.FindVertex(vertId);                  var x = face[(k + 1)%3];                  var y = face[(k + 2)%3];                  var vPos = model.Vertex(vertId).Pos;                  var xPos = model.Vertex(x).Pos;                  var yPos = model.Vertex(y).Pos;                    var dYX = new double[3];                  MxVectorOps.Sub3(ref dYX' xPos' yPos);                    var dVX = new double[3];                  MxVectorOps.Sub3(ref dVX' vPos' xPos);                    var dVNew = new double[3];                  MxVectorOps.Sub3(ref dVNew' vNew' xPos);                    var fN = new double[3];                  MxVectorOps.Cross3(ref fN' dYX' dVX);                    var nml = new double[3];                  MxVectorOps.Cross3(ref nml' dYX' dVX);                  MxVectorOps.Unitize3(ref nml);                    if(MxVectorOps.Dot3(dVNew' nml) < LocalValidityThreshold*MxVectorOps.Dot3(dVX' nml))                  {                      nFailed++;                  }              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,ApplyMeshPenalties,The following statement contains a magic number: if (maxDeg > VertexDegreeLimit) bias += (maxDeg - VertexDegreeLimit)*MeshingPenalty*0.001;
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,ComputeTargetPlacement,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal                   && Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  eMin = Q.Evaluate(info.vNew);              }              else              {                  var vi = new MxVector3(model.Vertex(i));                  var vj = new MxVector3(model.Vertex(j));                  var best = new MxVector3(0.0' 0.0' 0.0);                    if (PlacementPolicy == MxPlacement.Line && Q.Optimize(vi' vj' ref best))                  {                      eMin = Q.Evaluate(best);                  }                  else                  {                      var ei = Q.Evaluate(vi);                      var ej = Q.Evaluate(vj);                        if (ei < ej)                      {                          eMin = ei;                          best = vi;                      }                      else                      {                          eMin = ej;                          best = vj;                      }                        if (PlacementPolicy == MxPlacement.EndOrMid)                      {                          var mid = (vi + vj)*0.5;                          var eMid = Q.Evaluate(mid);                          if (eMid < eMin)                          {                              eMin = eMid;                              best = mid;                          }                      }                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,ComputeTargetPlacement,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal                   && Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  eMin = Q.Evaluate(info.vNew);              }              else              {                  var vi = new MxVector3(model.Vertex(i));                  var vj = new MxVector3(model.Vertex(j));                  var best = new MxVector3(0.0' 0.0' 0.0);                    if (PlacementPolicy == MxPlacement.Line && Q.Optimize(vi' vj' ref best))                  {                      eMin = Q.Evaluate(best);                  }                  else                  {                      var ei = Q.Evaluate(vi);                      var ej = Q.Evaluate(vj);                        if (ei < ej)                      {                          eMin = ei;                          best = vi;                      }                      else                      {                          eMin = ej;                          best = vj;                      }                        if (PlacementPolicy == MxPlacement.EndOrMid)                      {                          var mid = (vi + vj)*0.5;                          var eMid = Q.Evaluate(mid);                          if (eMid < eMin)                          {                              eMin = eMid;                              best = mid;                          }                      }                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,ComputeTargetPlacement,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal                   && Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  eMin = Q.Evaluate(info.vNew);              }              else              {                  var vi = new MxVector3(model.Vertex(i));                  var vj = new MxVector3(model.Vertex(j));                  var best = new MxVector3(0.0' 0.0' 0.0);                    if (PlacementPolicy == MxPlacement.Line && Q.Optimize(vi' vj' ref best))                  {                      eMin = Q.Evaluate(best);                  }                  else                  {                      var ei = Q.Evaluate(vi);                      var ej = Q.Evaluate(vj);                        if (ei < ej)                      {                          eMin = ei;                          best = vi;                      }                      else                      {                          eMin = ej;                          best = vj;                      }                        if (PlacementPolicy == MxPlacement.EndOrMid)                      {                          var mid = (vi + vj)*0.5;                          var eMid = Q.Evaluate(mid);                          if (eMid < eMin)                          {                              eMin = eMid;                              best = mid;                          }                      }                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];              }
Magic Number,QSlim.MxKit,MxEdgeQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,ComputeTargetPlacement,The following statement contains a magic number: if (PlacementPolicy == MxPlacement.Optimal                   && Q.Optimize(ref info.vNew[0]' ref info.vNew[1]' ref info.vNew[2]))              {                  eMin = Q.Evaluate(info.vNew);              }              else              {                  var vi = new MxVector3(model.Vertex(i));                  var vj = new MxVector3(model.Vertex(j));                  var best = new MxVector3(0.0' 0.0' 0.0);                    if (PlacementPolicy == MxPlacement.Line && Q.Optimize(vi' vj' ref best))                  {                      eMin = Q.Evaluate(best);                  }                  else                  {                      var ei = Q.Evaluate(vi);                      var ej = Q.Evaluate(vj);                        if (ei < ej)                      {                          eMin = ei;                          best = vi;                      }                      else                      {                          eMin = ej;                          best = vj;                      }                        if (PlacementPolicy == MxPlacement.EndOrMid)                      {                          var mid = (vi + vj)*0.5;                          var eMid = Q.Evaluate(mid);                          if (eMid < eMin)                          {                              eMin = eMid;                              best = mid;                          }                      }                  }                    info.vNew[0] = best[0];                  info.vNew[1] = best[1];                  info.vNew[2] = best[2];              }
Magic Number,QSlim.MxKit,MxQSlimEdge,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxEdgeQSlim.cs,MxQSlimEdge,The following statement contains a magic number: vNew = new double[3];
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,MxFace,The following statement contains a magic number: VertexIds = new[] {face.VertexIds[0]' face.VertexIds[1]' face.VertexIds[2]};
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,RemapVertex,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  if (VertexIds[i] != fromId) continue;                  VertexIds[i] = toId;                  nMapped++;              }
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,FindVertex,The following statement contains a magic number: Debug.Assert(VertexIds[2] == vertIndex);
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,FindVertex,The following statement contains a magic number: return 2;
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,OppositeVertex,The following statement contains a magic number: Debug.Assert(VertexIds[2] != vId0 && VertexIds[2] != vId1);
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,OppositeVertex,The following statement contains a magic number: Debug.Assert(VertexIds[2] != vId0 && VertexIds[2] != vId1);
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,OppositeVertex,The following statement contains a magic number: return VertexIds[2];
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,IsInOrder,The following statement contains a magic number: if (VertexIds[1] == vId0) return (VertexIds[2] == vId1);
Magic Number,QSlim.MxKit,MxFace,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFace.cs,IsInOrder,The following statement contains a magic number: Debug.Assert(VertexIds[2] == vId0);
Magic Number,QSlim.MxKit,MxFaceContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceContraction.cs,MxFaceContraction,The following statement contains a magic number: DeltaV1 = new double[3];
Magic Number,QSlim.MxKit,MxFaceContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceContraction.cs,MxFaceContraction,The following statement contains a magic number: DeltaV2 = new double[3];
Magic Number,QSlim.MxKit,MxFaceContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceContraction.cs,MxFaceContraction,The following statement contains a magic number: DeltaV3 = new double[3];
Magic Number,QSlim.MxKit,MxFaceContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceContraction.cs,MxFaceContraction,The following statement contains a magic number: DeltaFaces = new List<int>(6);
Magic Number,QSlim.MxKit,MxFaceContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxFaceContraction.cs,MxFaceContraction,The following statement contains a magic number: DeadFaces = new List<int>(6);
Magic Number,QSlim.MxKit,MxHeap,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxHeap.cs,Parent,The following statement contains a magic number: return val/2;
Magic Number,QSlim.MxKit,MxHeap,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxHeap.cs,Left,The following statement contains a magic number: return (2*i + 1);
Magic Number,QSlim.MxKit,MxHeap,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxHeap.cs,Right,The following statement contains a magic number: return (2*i + 2);
Magic Number,QSlim.MxKit,MxHeap,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxHeap.cs,Right,The following statement contains a magic number: return (2*i + 2);
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: var a = new[] {new double[3]' new double[3]' new double[3]};
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: var a = new[] {new double[3]' new double[3]' new double[3]};
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: var a = new[] {new double[3]' new double[3]' new double[3]};
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: var v = new[] { new double[3]' new double[3]' new double[3] };
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: var v = new[] { new double[3]' new double[3]' new double[3] };
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: var v = new[] { new double[3]' new double[3]' new double[3] };
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  for (var j = 0; j < 3; j++)                  {                      a[i][j] = input[i' j];                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  for (var j = 0; j < 3; j++)                  {                      a[i][j] = input[i' j];                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  for (var j = 0; j < 3; j++)                  {                      eigenVectors[index++] = v[j][i];                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,Jacobi,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  for (var j = 0; j < 3; j++)                  {                      eigenVectors[index++] = v[j][i];                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (ip = 0; ip < 3; ip++)              {                  for (iq = 0; iq < 3; iq++)                  {                      eigenVectors[ip][iq] = 0.0;                  }                  eigenVectors[ip][ip] = 1.0;              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (ip = 0; ip < 3; ip++)              {                  for (iq = 0; iq < 3; iq++)                  {                      eigenVectors[ip][iq] = 0.0;                  }                  eigenVectors[ip][ip] = 1.0;              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: var b = new double[3];
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: var z = new double[3];
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (ip = 0; ip < 3; ip++)              {                  b[ip] = eigenValues[ip] = input[ip][ip];                  z[ip] = 0.0;              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 2; ip++)                  {                      for (iq = ip + 1; iq < 3; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/9 : 0.0;                    for (ip = 0; ip < 2; ip++)                  {                      for (iq = 0; iq < 3; iq++)                      {                          var g = 100.0*Math.Abs(input[ip][iq]);                          if ((i > 4) &&                               ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                           else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq])/h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip-1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                   h = input[j][iq];                                  input[j][ip] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                   h = input[j][iq];                                  input[ip][j] = g - s*(h + g*tau);                                  input[j][iq] = h + s*(g - h*tau);                              }                              for (j = (iq + 1); j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s*(h + g*tau);                                  input[iq][j] = h + s*(g - h*tau);                              }                              for (j = 0; j < 3; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s*(h + g*tau);                                  eigenVectors[j][iq] = h + s*(g - h*tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var k = j;                  var tmp = eigenValues[k];                  for (i = j; i < 3; i++)                  {                      if (eigenValues[i] < tmp) continue;                        k = i;                      tmp = eigenValues[k];                  }                    if (k == j) continue;                    eigenValues[k] = eigenValues[j];                  eigenValues[j] = tmp;                  for (i = 0; i < 3; i++)                  {                      tmp = eigenVectors[i][j];                      eigenVectors[i][j] = eigenVectors[i][k];                      eigenVectors[i][k] = tmp;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var k = j;                  var tmp = eigenValues[k];                  for (i = j; i < 3; i++)                  {                      if (eigenValues[i] < tmp) continue;                        k = i;                      tmp = eigenValues[k];                  }                    if (k == j) continue;                    eigenValues[k] = eigenValues[j];                  eigenValues[j] = tmp;                  for (i = 0; i < 3; i++)                  {                      tmp = eigenVectors[i][j];                      eigenVectors[i][j] = eigenVectors[i][k];                      eigenVectors[i][k] = tmp;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var k = j;                  var tmp = eigenValues[k];                  for (i = j; i < 3; i++)                  {                      if (eigenValues[i] < tmp) continue;                        k = i;                      tmp = eigenValues[k];                  }                    if (k == j) continue;                    eigenValues[k] = eigenValues[j];                  eigenValues[j] = tmp;                  for (i = 0; i < 3; i++)                  {                      tmp = eigenVectors[i][j];                      eigenVectors[i][j] = eigenVectors[i][k];                      eigenVectors[i][k] = tmp;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                                    for (i = 0; i < 3;i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                                    for (i = 0; i < 3;i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                                    for (i = 0; i < 3;i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                                    for (i = 0; i < 3;i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (ip = 0; ip < 4; ip++)              {                  for (iq = 0; iq < 4; iq++)                  {                      eigenVectors[ip][iq] = 0.0;                  }                  eigenVectors[ip][ip] = 1.0;              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (ip = 0; ip < 4; ip++)              {                  for (iq = 0; iq < 4; iq++)                  {                      eigenVectors[ip][iq] = 0.0;                  }                  eigenVectors[ip][ip] = 1.0;              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: var b = new double[4];
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: var z = new double[4];
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (ip = 0; ip < 4; ip++)              {                  b[ip] = eigenValues[ip] = input[ip][ip];                  z[ip] = 0.0;              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (i = 0; i < MaxRotations; i++)              {                  var sm = 0.0;                  for (ip = 0; ip < 3; ip++)                  {                      for (iq = ip + 1; iq < 4; iq++)                      {                          sm += Math.Abs(input[ip][iq]);                      }                  }                  if (sm.IsCloseEnoughTo(0.0)) break;                    var tresh = (i < 4) ? 0.2*sm/16 : 0.0;                    for (ip = 0; ip < 3; ip++)                  {                      for (iq = 0; iq < 4; iq++)                      {                          var g = 100.0 * Math.Abs(input[ip][iq]);                          if ((i > 4) &&                              ((Math.Abs(eigenValues[ip]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[ip]))) &&                              ((Math.Abs(eigenValues[iq]) + g).IsCloseEnoughTo(Math.Abs(eigenValues[iq]))))                          {                              input[ip][iq] = 0.0;                          }                          else if (Math.Abs(input[ip][iq]) > tresh)                          {                              var h = eigenValues[iq] - eigenValues[ip];                              double t;                              if ((Math.Abs(h) + g).IsCloseEnoughTo(Math.Abs(h)))                              {                                  t = (input[ip][iq]) / h;                              }                              else                              {                                  var theta = 0.5*h/(input[ip][iq]);                                  t = 1.0/(Math.Abs(theta) + Math.Sqrt(1.0 + (theta*theta)));                                  if (theta < 0.0) t = -t;                              }                                var c = 1.0/Math.Sqrt(1 + t*t);                              var s = t*c;                              var tau = s/(1.0 + c);                              h = t*(input[ip][iq]);                              z[ip] -= h;                              z[iq] += h;                              eigenValues[ip] -= h;                              eigenValues[iq] += h;                              input[ip][iq] = 0.0;                                for (j = 0; j < (ip - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'j' ip'j' iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  input[j][ip] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (ip + 1); j < (iq - 1); j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j' j' iq)                                  g = input[ip][j];                                  h = input[j][iq];                                  input[ip][j] = g - s * (h + g * tau);                                  input[j][iq] = h + s * (g - h * tau);                              }                              for (j = (iq + 1); j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(a'ip'j'iq'j)                                  g = input[ip][j];                                  h = input[iq][j];                                  input[ip][j] = g - s * (h + g * tau);                                  input[iq][j] = h + s * (g - h * tau);                              }                              for (j = 0; j < 4; j++)                              {                                  //      i' j' k' l                                  //ROT(v'j'ip'j'iq)                                  g = input[j][ip];                                  h = input[j][iq];                                  eigenVectors[j][ip] = g - s * (h + g * tau);                                  eigenVectors[j][iq] = h + s * (g - h * tau);                              }                          }                      }                  }                    for (ip = 0; ip < 3; ip++)                  {                      b[ip] += z[ip];                      eigenValues[ip] = b[ip];                      z[ip] = 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var k = j;                  var tmp = eigenValues[k];                  for (i = j; i < 3; i++)                  {                      if (eigenValues[i] < tmp) continue;                        k = i;                      tmp = eigenValues[k];                  }                    if (k == j) continue;                    eigenValues[k] = eigenValues[j];                  eigenValues[j] = tmp;                  for (i = 0; i < 3; i++)                  {                      tmp = eigenVectors[i][j];                      eigenVectors[i][j] = eigenVectors[i][k];                      eigenVectors[i][k] = tmp;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var k = j;                  var tmp = eigenValues[k];                  for (i = j; i < 3; i++)                  {                      if (eigenValues[i] < tmp) continue;                        k = i;                      tmp = eigenValues[k];                  }                    if (k == j) continue;                    eigenValues[k] = eigenValues[j];                  eigenValues[j] = tmp;                  for (i = 0; i < 3; i++)                  {                      tmp = eigenVectors[i][j];                      eigenVectors[i][j] = eigenVectors[i][k];                      eigenVectors[i][k] = tmp;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var k = j;                  var tmp = eigenValues[k];                  for (i = j; i < 3; i++)                  {                      if (eigenValues[i] < tmp) continue;                        k = i;                      tmp = eigenValues[k];                  }                    if (k == j) continue;                    eigenValues[k] = eigenValues[j];                  eigenValues[j] = tmp;                  for (i = 0; i < 3; i++)                  {                      tmp = eigenVectors[i][j];                      eigenVectors[i][j] = eigenVectors[i][k];                      eigenVectors[i][k] = tmp;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                    for (i = 0; i < 3; i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                    for (i = 0; i < 3; i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                    for (i = 0; i < 3; i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix.cs,InternalJacobi4,The following statement contains a magic number: for (j = 0; j < 3; j++)              {                  var numPos = 0;                  for (i = 0; i < 3; i++)                  {                      if (eigenVectors[i][j] < 0.0) continue;                      numPos++;                  }                  if (numPos >= 2) continue;                    for (i = 0; i < 3; i++)                  {                      eigenVectors[i][j] *= -1.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = new MxVector3(fillVal' fillVal' fillVal);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = row2;
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[0] = new MxVector3((mat3[0])[0]' (mat3[0])[1]' (mat3[0])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[1] = new MxVector3((mat3[1])[0]' (mat3[1])[1]' (mat3[1])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = new MxVector3((mat3[2])[0]' (mat3[2])[1]' (mat3[2])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = new MxVector3((mat3[2])[0]' (mat3[2])[1]' (mat3[2])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = new MxVector3((mat3[2])[0]' (mat3[2])[1]' (mat3[2])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = new MxVector3((mat3[2])[0]' (mat3[2])[1]' (mat3[2])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,MxMatrix3,The following statement contains a magic number: rows[2] = new MxVector3((mat3[2])[0]' (mat3[2])[1]' (mat3[2])[2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Column,The following statement contains a magic number: return new MxVector3((rows[0])[i]' (rows[1])[i]' (rows[2])[i]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Det,The following statement contains a magic number: return (mat[0]*(mat[1] ^ mat[2]));
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Trace,The following statement contains a magic number: return (mat[0' 0] + mat[1' 1] + mat[2' 2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Trace,The following statement contains a magic number: return (mat[0' 0] + mat[1' 1] + mat[2' 2]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Transpose,The following statement contains a magic number: return new MxMatrix3(mat.Column(0)' mat.Column(1)' mat.Column(2));
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Diag,The following statement contains a magic number: return new MxMatrix3(new MxVector3(vec[0]' 0.0' 0.0)'                                   new MxVector3(0.0' vec[1]' 0.0)'                                   new MxVector3(0.0' 0.0' vec[2]));
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: var z = vec[2];
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[0' 2] = x*z;
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[1' 2] = y*z;
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[2' 0] = mat[0' 2];
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[2' 0] = mat[0' 2];
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[2' 1] = mat[1' 2];
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[2' 1] = mat[1' 2];
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[2' 2] = z*z;
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: mat[2' 2] = z*z;
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  for (var j = 0; j < 3; j++)                  {                      mat[i' j] = vec1[i]*vec2[j];                  }              }
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,OuterProduct,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  for (var j = 0; j < 3; j++)                  {                      mat[i' j] = vec1[i]*vec2[j];                  }              }
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Adjoint,The following statement contains a magic number: return new MxMatrix3(mat[1] ^ mat[2]'                                   mat[2] ^ mat[0]'                                   mat[0] ^ mat[1]);
Magic Number,QSlim.MxKit,MxMatrix3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix3.cs,Adjoint,The following statement contains a magic number: return new MxMatrix3(mat[1] ^ mat[2]'                                   mat[2] ^ mat[0]'                                   mat[0] ^ mat[1]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4(fillVal' fillVal' fillVal' fillVal);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4(fillVal' fillVal' fillVal' fillVal);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = row2;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = row3;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[0] = new MxVector4((mat4[0])[0]' (mat4[0])[1]' (mat4[0])[2]' (mat4[0])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[0] = new MxVector4((mat4[0])[0]' (mat4[0])[1]' (mat4[0])[2]' (mat4[0])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[1] = new MxVector4((mat4[1])[0]' (mat4[1])[1]' (mat4[1])[2]' (mat4[1])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[1] = new MxVector4((mat4[1])[0]' (mat4[1])[1]' (mat4[1])[2]' (mat4[1])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[2] = new MxVector4((mat4[2])[0]' (mat4[2])[1]' (mat4[2])[2]' (mat4[2])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,MxMatrix4,The following statement contains a magic number: rows[3] = new MxVector4((mat4[3])[0]' (mat4[3])[1]' (mat4[3])[2]' (mat4[3])[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Column,The following statement contains a magic number: return new MxVector4((rows[0])[i]' (rows[1])[i]' (rows[2])[i]' (rows[3])[i]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Column,The following statement contains a magic number: return new MxVector4((rows[0])[i]' (rows[1])[i]' (rows[2])[i]' (rows[3])[i]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Det,The following statement contains a magic number: return (mat[0]*MxVector4.Cross(mat[1]' mat[2]' mat[3]));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Det,The following statement contains a magic number: return (mat[0]*MxVector4.Cross(mat[1]' mat[2]' mat[3]));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Trace,The following statement contains a magic number: return (mat[0' 0] + mat[1' 1] + mat[2' 2] + mat[3'3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Trace,The following statement contains a magic number: return (mat[0' 0] + mat[1' 1] + mat[2' 2] + mat[3'3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Trace,The following statement contains a magic number: return (mat[0' 0] + mat[1' 1] + mat[2' 2] + mat[3'3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Trace,The following statement contains a magic number: return (mat[0' 0] + mat[1' 1] + mat[2' 2] + mat[3'3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Transpose,The following statement contains a magic number: return new MxMatrix4(mat.Column(0)' mat.Column(1)' mat.Column(2)' mat.Column(3));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Transpose,The following statement contains a magic number: return new MxMatrix4(mat.Column(0)' mat.Column(1)' mat.Column(2)' mat.Column(3));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Diag,The following statement contains a magic number: return new MxMatrix4(new MxVector4(vec[0]' 0.0' 0.0' 0.0)'                                   new MxVector4(0.0' vec[1]' 0.0' 0.0)'                                   new MxVector4(0.0' 0.0' vec[2]' 0.0)'                                   new MxVector4(0.0' 0.0' 0.0' vec[3]));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Diag,The following statement contains a magic number: return new MxMatrix4(new MxVector4(vec[0]' 0.0' 0.0' 0.0)'                                   new MxVector4(0.0' vec[1]' 0.0' 0.0)'                                   new MxVector4(0.0' 0.0' vec[2]' 0.0)'                                   new MxVector4(0.0' 0.0' 0.0' vec[3]));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,TranslationMatrix,The following statement contains a magic number: return new MxMatrix4(new MxVector4(1.0' 0.0' 0.0' delta[0])'                                   new MxVector4(0.0' 1.0' 0.0' delta[1])'                                   new MxVector4(0.0' 0.0' 1.0' delta[2])'                                   new MxVector4(0.0' 0.0' 0.0' 1.0));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,ScalingMatrix,The following statement contains a magic number: return new MxMatrix4(new MxVector4(scale[0]' 0.0' 0.0' 0.0)'                                   new MxVector4(0.0' scale[1]' 0.0' 0.0)'                                   new MxVector4(0.0' 0.0' scale[2]' 0.0)'                                   new MxVector4(0.0' 0.0' 0.0' 1.0));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,RotationMatrixRad,The following statement contains a magic number: var xz = axis[0]*axis[2];
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,RotationMatrixRad,The following statement contains a magic number: var yz = axis[1]*axis[2];
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,RotationMatrixRad,The following statement contains a magic number: var zz = axis[2]*axis[2];
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,RotationMatrixRad,The following statement contains a magic number: var zz = axis[2]*axis[2];
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,RotationMatrixRad,The following statement contains a magic number: var zs = axis[2]*sin;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,RotationMatrixDeg,The following statement contains a magic number: return RotationMatrixRad(theta*Math.PI/180.0' axis);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: if (zMax.IsCloseEnoughTo(0.0))              {                  a = b = 1.0;              }              else              {                  a = (zMax + zMin)/(zMin - zMax);                  b = (2*zMax*zMin)/(zMin - zMax);              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: var f = 1.0/Math.Tan(fovy*Math.PI/180.0/2.0);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: var f = 1.0/Math.Tan(fovy*Math.PI/180.0/2.0);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[2' 2] = a;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[2' 2] = a;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[2' 3] = b;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[2' 3] = b;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[3' 2] = -1.0;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[3' 2] = -1.0;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[3' 3] = 0.0;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,PerspectiveMatrix,The following statement contains a magic number: ret[3' 3] = 0.0;
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,LookAtMatrix,The following statement contains a magic number: var vUp = new MxVector3(up[0]' up[1]' up[2]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,ViewportMatrix,The following statement contains a magic number: var scale = ScalingMatrix(new MxVector3(w*0.5' -h*0.5' 1.0));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,ViewportMatrix,The following statement contains a magic number: var scale = ScalingMatrix(new MxVector3(w*0.5' -h*0.5' 1.0));
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[0] = MxVector4.Cross( mat[1]' mat[2]' mat[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[0] = MxVector4.Cross( mat[1]' mat[2]' mat[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[1] = MxVector4.Cross(-mat[0]' mat[2]' mat[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[1] = MxVector4.Cross(-mat[0]' mat[2]' mat[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[2] = MxVector4.Cross( mat[0]' mat[1]' mat[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[2] = MxVector4.Cross( mat[0]' mat[1]' mat[3]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Adjoint,The following statement contains a magic number: adj[0] = MxVector4.Cross(-mat[0]' mat[1]' mat[2]);
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  for (j = 0; j < 4; j++)                  {                      invMat[i' j] = (i == j) ? 1.0 : 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  for (j = 0; j < 4; j++)                  {                      invMat[i' j] = (i == j) ? 1.0 : 0.0;                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 0; i < 4; i++)              {                  var max = -1.0;                  for (k = i; k < 4; k++)                  {                      if (Math.Abs(mat1[k' i]) <= max) continue;                      max = Math.Abs(mat1[k' i]);                      j = k;                  }                    if (max <= 0.0) return 0.0;                  if (j != i)                  {                      /* swap rows i and j */                      for (k = i; k < 4; k++)                      {                          var t = mat1[i' k];                          mat1[i' k] = mat1[j' k];                          mat1[j' k] = t;                                                }                      for (k = 0; k < 4; k++)                      {                          var t = invMat[i' k];                          invMat[i' k] = invMat[j' k];                          invMat[j' k] = t;                      }                      det = -det;                  }                    var pivot = mat1[i' i];                  det *= pivot;                  for (k = i + 1; k < 4; k++)                  {                      mat1[i' k] /= pivot;                  }                  for (k = 0; k < 4; k++)                  {                      invMat[i' k] /= pivot;                  }                                    for (j = i + 1; j < 4; j++)                  {                      var t = mat1[j' i];                      for (k = i + 1; k < 4; k++)                      {                          mat1[j' k] -= mat1[i' k]*t;                      }                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 3; i > 0; i--)              {                  for (j = 0; j < i; j++)                  {                      var t = mat1[j' i];                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxMatrix4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxMatrix4.cs,Invert,The following statement contains a magic number: for (i = 3; i > 0; i--)              {                  for (j = 0; j < i; j++)                  {                      var t = mat1[j' i];                      for (k = 0; k < 4; k++)                      {                          invMat[j' k] -= invMat[i' k]*t;                      }                  }              }
Magic Number,QSlim.MxKit,MxNormal,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxNormal.cs,MxNormal,The following statement contains a magic number: Dir = new short[3];
Magic Number,QSlim.MxKit,MxNormal,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxNormal.cs,MxNormal,The following statement contains a magic number: Dir = new short[3];
Magic Number,QSlim.MxKit,MxNormal,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxNormal.cs,MxNormal,The following statement contains a magic number: Dir = new short[3];
Magic Number,QSlim.MxKit,MxNormal,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxNormal.cs,IntRound,The following statement contains a magic number: return (int) (dbl + 0.5);
Magic Number,QSlim.MxKit,MxPairContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxPairContraction.cs,MxPairContraction,The following statement contains a magic number: DeltaV1 = new double[3];
Magic Number,QSlim.MxKit,MxPairContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxPairContraction.cs,MxPairContraction,The following statement contains a magic number: DeltaV2 = new double[3];
Magic Number,QSlim.MxKit,MxPairContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxPairContraction.cs,MxPairContraction,The following statement contains a magic number: DeltaFaces = new List<int>(6);
Magic Number,QSlim.MxKit,MxPairContraction,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxPairContraction.cs,MxPairContraction,The following statement contains a magic number: DeadFaces = new List<int>(6);
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: var sum  = x*x*a2 + 2*x*y*ab + 2*x*z*ac + 2*x*ad;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: var sum  = x*x*a2 + 2*x*y*ab + 2*x*z*ac + 2*x*ad;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: var sum  = x*x*a2 + 2*x*y*ab + 2*x*z*ac + 2*x*ad;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: sum +=            y*y*b2 + 2*y*z*bc + 2*y*bd;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: sum +=            y*y*b2 + 2*y*z*bc + 2*y*bd;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: sum +=                       z*z*c2 + 2*z*cd;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: return Evaluate(vec[0]' vec[1]' vec[2]);
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Evaluate,The following statement contains a magic number: return Evaluate(vec[0]' vec[1]' vec[2]);
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,PointConstraint,The following statement contains a magic number: cd = -point[2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,PointConstraint,The following statement contains a magic number: d2 = point[0]*point[0] + point[1]*point[1] + point[2]*point[2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,PointConstraint,The following statement contains a magic number: d2 = point[0]*point[0] + point[1]*point[1] + point[2]*point[2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: z = vec[2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var denom = 2.0*diff*tDiff;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var a = (-2.0*(Vector*diff) - (diff*tV2) - (vec2*tDiff))/(2.0*(diff*tDiff));
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var a = (-2.0*(Vector*diff) - (diff*tV2) - (vec2*tDiff))/(2.0*(diff*tDiff));
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var denom = d13AD13*d23AD23 - 2.0*d13D23;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var a = ((d23AD23*(2.0*(B*d13) + v3D13)) -                       (d13D23*(2.0*(B*d23) + v3D23)))/-denom;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var a = ((d23AD23*(2.0*(B*d13) + v3D13)) -                       (d13D23*(2.0*(B*d23) + v3D23)))/-denom;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var b = ((d13AD13*(2.0*(B*d13) + v3D23)) - (d13D23*(2.0*(B*d13) + v3D13)))/-denom;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Optimize,The following statement contains a magic number: var b = ((d13AD13*(2.0*(B*d13) + v3D23)) - (d13D23*(2.0*(B*d13) + v3D13)))/-denom;
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: ac = mat[0' 2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: ad = mat[0' 3];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: bc = mat[1' 2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: bd = mat[1' 3];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: c2 = mat[2' 2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: c2 = mat[2' 2];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: cd = mat[2' 3];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: cd = mat[2' 3];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: d2 = mat[3' 3];
Magic Number,QSlim.MxKit,MxQuadric3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQMetric3.cs,Init,The following statement contains a magic number: d2 = mat[3' 3];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,MarkCorners,The following statement contains a magic number: foreach (var faceId in faces)              {                  var face = Face(faceId);                  VertMark(face[0]' mark);                  VertMark(face[1]' mark);                  VertMark(face[2]' mark);              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,CollectUnMarkedCorners,The following statement contains a magic number: foreach (var faceId in faces)              {                  var face = Face(faceId);                  for (var i = 0; i < 3; i++ )                  {                      var vertId = face[i];                      if (VertMark(vertId) != 0x0) continue;                        verts.Add(vertId);                      VertMark(vertId' 0x1);                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,CollectNeighborhood,The following statement contains a magic number: while (depth > 0)              {                  // Unmark the neighbors of all vertices in the neighborhood                  foreach(var faceId in neighbors)                  {                      var face = Face(faceId);                      MarkNeighborhood(face[0]' 0x0);                      MarkNeighborhood(face[1]' 0x0);                      MarkNeighborhood(face[2]' 0x0);                  }                    // Mark the faces already accumulated                  foreach(var faceId in faces)                  {                      FaceMark(faceId' 0x1);                  }                    // Collect all unmarked faces                  var limit = faces.Count;                  for (var i = 0; i < limit; i++)                  {                      var faceId = faces[i];                      var face = Face(faceId);                      CollectUnMarkedNeighbors(face[0]' faces);                      CollectUnMarkedNeighbors(face[1]' faces);                      CollectUnMarkedNeighbors(face[2]' faces);                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,CollectNeighborhood,The following statement contains a magic number: while (depth > 0)              {                  // Unmark the neighbors of all vertices in the neighborhood                  foreach(var faceId in neighbors)                  {                      var face = Face(faceId);                      MarkNeighborhood(face[0]' 0x0);                      MarkNeighborhood(face[1]' 0x0);                      MarkNeighborhood(face[2]' 0x0);                  }                    // Mark the faces already accumulated                  foreach(var faceId in faces)                  {                      FaceMark(faceId' 0x1);                  }                    // Collect all unmarked faces                  var limit = faces.Count;                  for (var i = 0; i < limit; i++)                  {                      var faceId = faces[i];                      var face = Face(faceId);                      CollectUnMarkedNeighbors(face[0]' faces);                      CollectUnMarkedNeighbors(face[1]' faces);                      CollectUnMarkedNeighbors(face[2]' faces);                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ComputeVertexNormal,The following statement contains a magic number: for (var i = 0; i < 3; i++)              {                  nml[i] = 0.0;              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ComputeVertexNormal,The following statement contains a magic number: foreach (var faceId in star)              {                  var faceNml = new double[3];                    ComputeFaceNormal(faceId' ref faceNml' false);                  MxVectorOps.AddInto3(ref nml' faceNml);              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SynthesizeNormals,The following statement contains a magic number: var nml = new double[3];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SynthesizeNormals,The following statement contains a magic number: switch(NormalBinding)              {                  case(MxBinding.PerFace):                      {                          for (var faceId = 0; faceId < FaceCount; faceId++)                          {                              ComputeFaceNormal(faceId' ref nml);                              AddNormal(nml[0]' nml[1]' nml[2]);                          }                          break;                      }                  case(MxBinding.PerVertex):                      {                          for (var vertId = 0; vertId < VertCount; vertId++)                          {                              ComputeVertexNormal(vertId' ref nml);                              AddNormal(nml[0]' nml[1]' nml[2]);                          }                          break;                      }                  default:                      {                          break;                      }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SynthesizeNormals,The following statement contains a magic number: switch(NormalBinding)              {                  case(MxBinding.PerFace):                      {                          for (var faceId = 0; faceId < FaceCount; faceId++)                          {                              ComputeFaceNormal(faceId' ref nml);                              AddNormal(nml[0]' nml[1]' nml[2]);                          }                          break;                      }                  case(MxBinding.PerVertex):                      {                          for (var vertId = 0; vertId < VertCount; vertId++)                          {                              ComputeVertexNormal(vertId' ref nml);                              AddNormal(nml[0]' nml[1]' nml[2]);                          }                          break;                      }                  default:                      {                          break;                      }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitEdge,The following statement contains a magic number: var midX = (a[0] - b[0])*0.5;
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitEdge,The following statement contains a magic number: var midY = (a[1] - b[1])*0.5;
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitEdge,The following statement contains a magic number: var midZ = (a[2] - b[2])*0.5;
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitEdge,The following statement contains a magic number: var midZ = (a[2] - b[2])*0.5;
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitEdge,The following statement contains a magic number: var midZ = (a[2] - b[2])*0.5;
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,FlipEdge,The following statement contains a magic number: if (faces.Count != 2) return;
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,SplitFace4,The following statement contains a magic number: var vertId2 = face[2];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,UnLinkFace,The following statement contains a magic number: faceLinks[face[2]].Remove(faceId);
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,UnLinkFace,The following statement contains a magic number: Debug.Assert(!faceLinks[face[2]].Contains(faceId));
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,RemoveDegeneracy,The following statement contains a magic number: foreach (var faceId in faces)              {                  var face = Face(faceId);                  Debug.Assert(FaceIsValid(faceId));                    if (face[0] == face[1] || face[1] == face[2] || face[2] == face[0])                  {                      UnLinkFace(faceId);                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,RemoveDegeneracy,The following statement contains a magic number: foreach (var faceId in faces)              {                  var face = Face(faceId);                  Debug.Assert(FaceIsValid(faceId));                    if (face[0] == face[1] || face[1] == face[2] || face[2] == face[0])                  {                      UnLinkFace(faceId);                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ApplyContraction,The following statement contains a magic number: if (NormalBinding == MxBinding.PerFace)              {                  var nml = new double[3];                  foreach (var faceId in conx.DeltaFaces)                  {                      ComputeFaceNormal(faceId' ref nml);                      Normal(faceId' new MxNormal(nml));                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ApplyExpansion,The following statement contains a magic number: var newPos1 = new double[3];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ApplyExpansion,The following statement contains a magic number: foreach (var faceId in conx.DeadFaces)              {                  FaceMarkValid(faceId);                    var face = Face(faceId);                  faceLinks[face[0]].Add(faceId);                  faceLinks[face[1]].Add(faceId);                  faceLinks[face[2]].Add(faceId);              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ApplyExpansion,The following statement contains a magic number: if (NormalBinding == MxBinding.PerFace)              {                  var nml = new double[3];                  foreach(var faceId in conx.DeltaFaces)                  {                      ComputeFaceNormal(faceId' ref nml);                      Normal(faceId' new MxNormal(nml));                  }                    foreach(var faceId in conx.DeadFaces)                  {                      ComputeFaceNormal(faceId' ref nml);                      Normal(faceId' new MxNormal(nml));                  }              }
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,Contract,The following statement contains a magic number: Vertex(vertId1).Pos[2] = newVert[2];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,Contract,The following statement contains a magic number: Vertex(vertId1).Pos[2] = newVert[2];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,Contract,The following statement contains a magic number: var nml = new double[3];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,Contract,The following statement contains a magic number: Vertex(vertId1).Pos[2] = newVert[2];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,Contract,The following statement contains a magic number: Vertex(vertId1).Pos[2] = newVert[2];
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ComputeContraction,The following statement contains a magic number: MarkNeighborhood(face[2]' 0x0);
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ComputeContraction,The following statement contains a magic number: MarkNeighborhoodDelta(face[2]' 0x1);
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,ComputeContraction,The following statement contains a magic number: PartitionMarkedNeighbors(face[2]' 0x2' conx.DeltaFaces' conx.DeadFaces);
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,AllocVertex,The following statement contains a magic number: faceLinks.Add(new List<int>(6));
Magic Number,QSlim.MxKit,MxStdModel,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdModel.cs,InitFace,The following statement contains a magic number: faceLinks[face[2]].Add(faceId);
Magic Number,QSlim.MxKit,MxStdSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdSlim.cs,MxStdSlim,The following statement contains a magic number: heap = new MxHeap(64);
Magic Number,QSlim.MxKit,MxStdSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdSlim.cs,MxStdSlim,The following statement contains a magic number: BoundaryWeight = 1000.0;
Magic Number,QSlim.MxKit,MxStdSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxStdSlim.cs,MxStdSlim,The following statement contains a magic number: VertexDegreeLimit = 24;
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,MxVector3,The following statement contains a magic number: elt[2] = z;
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,MxVector3,The following statement contains a magic number: elt[2] = vec3[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,MxVector3,The following statement contains a magic number: elt[2] = vec3[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,MxVector3,The following statement contains a magic number: elt[2] = pos[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,MxVector3,The following statement contains a magic number: elt[2] = pos[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Unitize,The following statement contains a magic number: var denom = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Unitize,The following statement contains a magic number: var denom = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Unitize,The following statement contains a magic number: vec[2] *= invDenom;
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Cross,The following statement contains a magic number: ret[0] = u[1] * v[2] - v[1] * u[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Cross,The following statement contains a magic number: ret[0] = u[1] * v[2] - v[1] * u[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Cross,The following statement contains a magic number: ret[1] = v[0] * u[2] - u[0] * v[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Cross,The following statement contains a magic number: ret[1] = v[0] * u[2] - u[0] * v[2];
Magic Number,QSlim.MxKit,MxVector3,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector3.cs,Cross,The following statement contains a magic number: ret[2] = u[0] * v[1] - v[0] * u[1];
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,MxVector4,The following statement contains a magic number: elt[2] = z;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,MxVector4,The following statement contains a magic number: elt[3] = w;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Unitize,The following statement contains a magic number: var denom = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] + vec[3]*vec[3];
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Unitize,The following statement contains a magic number: var denom = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] + vec[3]*vec[3];
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Unitize,The following statement contains a magic number: var denom = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] + vec[3]*vec[3];
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Unitize,The following statement contains a magic number: var denom = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2] + vec[3]*vec[3];
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Unitize,The following statement contains a magic number: vec[2] *= invDenom;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Unitize,The following statement contains a magic number: vec[3] *= invDenom;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d1 = (b[2] * c[3]) - (b[3] * c[2]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d1 = (b[2] * c[3]) - (b[3] * c[2]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d1 = (b[2] * c[3]) - (b[3] * c[2]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d1 = (b[2] * c[3]) - (b[3] * c[2]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d2 = (b[1] * c[3]) - (b[3] * c[1]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d2 = (b[1] * c[3]) - (b[3] * c[1]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d3 = (b[1] * c[2]) - (b[2] * c[1]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d3 = (b[1] * c[2]) - (b[2] * c[1]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d4 = (b[0] * c[3]) - (b[3] * c[0]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d4 = (b[0] * c[3]) - (b[3] * c[0]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d5 = (b[0] * c[2]) - (b[2] * c[0]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: var d5 = (b[0] * c[2]) - (b[2] * c[0]);
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[0] = -a[1]*d1 + a[2]*d2 - a[3]*d3;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[0] = -a[1]*d1 + a[2]*d2 - a[3]*d3;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[1] =  a[0]*d1 - a[2]*d4 + a[3]*d5;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[1] =  a[0]*d1 - a[2]*d4 + a[3]*d5;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[2] = -a[0]*d2 + a[1]*d4 - a[3]*d6;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[2] = -a[0]*d2 + a[1]*d4 - a[3]*d6;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[3] =  a[0]*d3 - a[1]*d5 + a[2]*d6;
Magic Number,QSlim.MxKit,MxVector4,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVector4.cs,Cross,The following statement contains a magic number: ret[3] =  a[0]*d3 - a[1]*d5 + a[2]*d6;
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Cross3,The following statement contains a magic number: ret[0] = u[1]*v[2] - v[1]*u[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Cross3,The following statement contains a magic number: ret[0] = u[1]*v[2] - v[1]*u[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Cross3,The following statement contains a magic number: ret[1] = v[0]*u[2] - u[0]*v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Cross3,The following statement contains a magic number: ret[1] = v[0]*u[2] - u[0]*v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Cross3,The following statement contains a magic number: ret[2] = u[0]*v[1] - v[0]*u[1];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Unitize3,The following statement contains a magic number: var denom = ret[0]*ret[0] + ret[1]*ret[1] + ret[2]*ret[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Unitize3,The following statement contains a magic number: var denom = ret[0]*ret[0] + ret[1]*ret[1] + ret[2]*ret[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Unitize3,The following statement contains a magic number: ret[2] *= invDenom;
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Dot3,The following statement contains a magic number: return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Dot3,The following statement contains a magic number: return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Length3,The following statement contains a magic number: var len2 = u[0]*u[0] + u[1]*u[1] + u[2]*u[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Length3,The following statement contains a magic number: var len2 = u[0]*u[0] + u[1]*u[1] + u[2]*u[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Sub3,The following statement contains a magic number: diff[2] = u[2] - v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Sub3,The following statement contains a magic number: diff[2] = u[2] - v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,Sub3,The following statement contains a magic number: diff[2] = u[2] - v[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,SubFrom3,The following statement contains a magic number: from[2] -= subtractor[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,SubFrom3,The following statement contains a magic number: from[2] -= subtractor[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,AddInto3,The following statement contains a magic number: collector[2] += addend[2];
Magic Number,QSlim.MxKit,MxVectorOps,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVectorOps.cs,AddInto3,The following statement contains a magic number: collector[2] += addend[2];
Magic Number,QSlim.MxKit,MxVertex,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVertex.cs,MxVertex,The following statement contains a magic number: Info = new VertexInfo              {                  Pos = new double[3]'                  Proxy = new ProxyStruct()'              };
Magic Number,QSlim.MxKit,MxVertex,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxVertex.cs,MxVertex,The following statement contains a magic number: Info = new VertexInfo              {                  Pos = new double[3]'                  Proxy = new ProxyStruct()'              };
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim.MxKit,MxQSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\MxKit\MxQSlim.cs,CollectQuadrics,The following statement contains a magic number: for (var i = 0; i < model.FaceCount; i++)              {                  var face = model.Face(i);                  var vert0 = new MxVector3(model.Vertex(face[0]));                  var vert1 = new MxVector3(model.Vertex(face[1]));                  var vert2 = new MxVector3(model.Vertex(face[2]));                    var plane = (WeightingPolicy == MxWeighting.RawNormals)                                  ? MxGeom3d.TriangleRawPlane(vert0' vert1' vert2)                                  : MxGeom3d.TrianglePlane(vert0' vert1' vert2);                    var quad = new MxQuadric3(plane[0]' plane[1]' plane[2]' plane[3]' model.ComputeFaceArea(i));                    switch(WeightingPolicy)                  {                      case MxWeighting.Angle:                          {                              for (int j = 0; j < 3; j++)                              {                                  var quadJ = new MxQuadric3(quad);                                  quadJ *= model.ComputeCornerAngle(i' j);                                  quadrics[face[j]] += quadJ;                              }                              break;                          }                      case MxWeighting.Area:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      case MxWeighting.AreaAverage:                          {                              quad *= quad.Area;                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                      default:                          {                              quadrics[face[0]] += quad;                              quadrics[face[1]] += quad;                              quadrics[face[2]] += quad;                              break;                          }                  }              }
Magic Number,QSlim,QSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\QSlim.cs,GenerateOutput,The following statement contains a magic number: indices = new List<int>(baseModel.FaceCount*3);
Magic Number,QSlim,QSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\QSlim.cs,GenerateOutput,The following statement contains a magic number: for (var faceId = 0; faceId < baseModel.FaceCount; faceId++)              {                  if (!baseModel.FaceIsValid(faceId)) continue;                    var face = baseModel.Face(faceId);                  var vertId0 = face[0];                  var vert0 = baseModel.Vertex(vertId0);                  var vertId1 = face[1];                  var vert1 = baseModel.Vertex(vertId1);                  var vertId2 = face[2];                  var vert2 = baseModel.Vertex(vertId2);                    if (!IsWoundClockwise(vert0' vert1' vert2))                  {                      var t = vertId1;                      vertId1 = vertId2;                      vertId2 = t;                  }                    indices.Add(vertId0);                  indices.Add(vertId1);                  indices.Add(vertId2);              }
Magic Number,QSlim,QSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\QSlim.cs,GenerateOutput,The following statement contains a magic number: for (var vertId = 0; vertId < baseModel.VertCount; vertId++)              {                  var vert = baseModel.Vertex(vertId);                  var wVert = new Vector3((float)vert[0]' (float)vert[1]' (float)vert[2]);                  vertices.Add(wVert);              }
Magic Number,QSlim,QSlim,C:\repos\WCell_WCell\WCell-Terrain\QSlim\QSlim.cs,InitBaseModel,The following statement contains a magic number: baseModel = new MxStdModel(inputVertices.Count' inputIndices.Count/3)              {                  ColorBinding = MxBinding.UnBound'                  NormalBinding = MxBinding.UnBound              };
