Implementation smell,Namespace,Class,File,Method,Description
Long Method,NLog.Conditions,ConditionTokenizer,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionTokenizer.cs,GetNextToken,The method has 163 lines of code.
Complex Method,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,NeedToPreformatMessage,Cyclomatic complexity of the method is 9
Complex Method,NLog,LoggerImpl,C:\repos\WCell_WCell\Libraries\Source\NLog\LoggerImpl.cs,Write,Cyclomatic complexity of the method is 14
Complex Method,NLog,LogFactory,C:\repos\WCell_WCell\Libraries\Source\NLog\LogFactory.cs,GetTargetsByLevelForLogger,Cyclomatic complexity of the method is 10
Complex Method,NLog.Conditions,ConditionParser,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionParser.cs,ParseLiteralExpression,Cyclomatic complexity of the method is 13
Complex Method,NLog.Conditions,ConditionRelationalExpression,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionRelationalExpression.cs,PromoteTypes,Cyclomatic complexity of the method is 10
Complex Method,NLog.Conditions,ConditionTokenizer,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionTokenizer.cs,GetNextToken,Cyclomatic complexity of the method is 26
Complex Method,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureFromXmlElement,Cyclomatic complexity of the method is 10
Complex Method,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureRulesFromElement,Cyclomatic complexity of the method is 11
Complex Method,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureTargetFromXmlElement,Cyclomatic complexity of the method is 11
Complex Method,NLog.LayoutRenderers,CallSiteLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\CallSite.cs,Append,Cyclomatic complexity of the method is 10
Complex Method,NLog.LayoutRenderers,IdentityLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Identity.cs,Append,Cyclomatic complexity of the method is 15
Complex Method,NLog.LayoutRenderers,Log4JXmlEventLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Log4JXmlEvent.cs,Append,Cyclomatic complexity of the method is 9
Complex Method,NLog.Layouts,CsvLayout,C:\repos\WCell_WCell\Libraries\Source\NLog\Layouts\CsvLayout.cs,GetFormattedMessage,Cyclomatic complexity of the method is 8
Complex Method,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,IsSupportedOnCurrentRuntime,Cyclomatic complexity of the method is 9
Complex Method,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,IsSupportedOnCurrentRuntime,Cyclomatic complexity of the method is 9
Complex Method,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,RuntimeMatches,Cyclomatic complexity of the method is 10
Complex Method,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,CompareVersion,Cyclomatic complexity of the method is 9
Complex Method,NLog.Targets,DatabaseTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Database.cs,PopulateLayouts,Cyclomatic complexity of the method is 8
Complex Method,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,ShouldAutoArchive,Cyclomatic complexity of the method is 8
Complex Method,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,WriteToFile,Cyclomatic complexity of the method is 15
Complex Method,NLog.Targets,MailTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Mail.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,NLog.Targets.Wrappers,PostFilteringTargetWrapper,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\PostFilteringWrapper.cs,Write,Cyclomatic complexity of the method is 13
Complex Method,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,Output,Cyclomatic complexity of the method is 10
Long Parameter List,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,LogEventInfo,The method has 5 parameters. Parameters: level' loggerName' formatProvider' message' parameters
Long Parameter List,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,LogEventInfo,The method has 6 parameters. Parameters: level' loggerName' formatProvider' message' parameters' exception
Long Parameter List,NLog,Logger,C:\repos\WCell_WCell\Libraries\Source\NLog\Logger.cs,WriteToTargets,The method has 5 parameters. Parameters: level' formatProvider' message' args' exception
Long Parameter List,NLog,Logger,C:\repos\WCell_WCell\Libraries\Source\NLog\Logger.cs,Log,The method has 5 parameters. Parameters: level' message' arg1' arg2' arg3
Long Parameter List,NLog.Internal.Win32,Win32FileHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\Win32\Win32FileHelper.cs,CreateFile,The method has 7 parameters. Parameters: lpFileName' dwDesiredAccess' dwShareMode' lpSecurityAttributes' dwCreationDisposition' dwFlagsAndAttributes' hTemplateFile
Long Parameter List,NLog.Targets.Wrappers,ImpersonatingTargetWrapper,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\ImpersonatingWrapper.cs,LogonUser,The method has 6 parameters. Parameters: pszUsername' pszDomain' pszPassword' dwLogonType' dwLogonProvider' phToken
Long Parameter List,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorizeEscapeSequences,The method has 5 parameters. Parameters: output' hConsole' message' startingAttribute' defaultAttribute
Long Parameter List,NLog.Win32.Targets,ConsoleWin32Api,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ConsoleWin32Api.cs,FillConsoleOutputAttribute,The method has 5 parameters. Parameters: hConsole' wAttributes' nLength' dwWriteCoord' written
Long Identifier,NLog,LogFactory,C:\repos\WCell_WCell\Libraries\Source\NLog\LogFactory.cs,,The length of the parameter ReconfigAfterFileChangedTimeout is 31.
Long Identifier,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureTargetsFromElement,The length of the parameter typeNameToDefaultTargetParametersElement is 40.
Long Identifier,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,,The length of the parameter _currentFrameworkCompatibleWith is 31.
Long Identifier,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,,The length of the parameter _replaceFileContentsOnEachWrite is 31.
Long Identifier,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,,The length of the parameter _defaultRichTextBoxRowColoringRules is 35.
Long Identifier,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,,The length of the parameter _useDefaultRowHighlightingRules is 31.
Long Identifier,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,,The length of the parameter _defaultConsoleRowHighlightingRules is 35.
Long Statement,NLog,ConditionMethodFactory,C:\repos\WCell_WCell\Libraries\Source\NLog\ConditionMethodFactory.cs,AddConditionMethodsFromAssembly,The length of the statement  "                                ConditionMethodAttribute[] malist = (ConditionMethodAttribute[])mi.GetCustomAttributes(typeof(ConditionMethodAttribute)' false); " is 128.
Long Statement,NLog,LayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderer.cs,IsVolatile,The length of the statement  "            LayoutRendererAttribute attr = (LayoutRendererAttribute)Attribute.GetCustomAttribute(this.GetType()' typeof(LayoutRendererAttribute)); " is 134.
Long Statement,NLog,LayoutRendererFactory,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRendererFactory.cs,AddLayoutRenderersFromAssembly,The length of the statement  "                    LayoutRendererAttribute[]attributes = (LayoutRendererAttribute[])t.GetCustomAttributes(typeof(LayoutRendererAttribute)' false); " is 127.
Long Statement,NLog,LogFactory,C:\repos\WCell_WCell\Libraries\Source\NLog\LogFactory.cs,ConfigFileChanged,The length of the statement  "                    _reloadTimer = new Timer(new TimerCallback(ReloadConfigOnTimer)' Configuration' ReconfigAfterFileChangedTimeout' Timeout.Infinite); " is 131.
Long Statement,NLog.Conditions,ConditionTokenizer,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionTokenizer.cs,Expect,The length of the statement  "                throw new ConditionParseException("Expected token of type: " + type + "' got " + _tokenType + " (" + _tokenValue + ")."); " is 121.
Long Statement,NLog.Config,LoggingRule,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\LoggingRule.cs,ToString,The length of the statement  "            sb.AppendFormat(CultureInfo.InvariantCulture' "logNamePattern: ({0}:{1})"' _loggerNameMatchArgument' _loggerNameMatchMode); " is 123.
Long Statement,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,WrapWithDefaultWrapper,The length of the statement  "            InternalLogger.Debug("Wrapping target '{0}' with '{1}' and renaming to '{2}"' wrapperTargetInstance.Name' wrapperTargetInstance.GetType().Name' t.Name); " is 152.
Long Statement,NLog.LayoutRenderers,Log4JXmlEventLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Log4JXmlEvent.cs,Append,The length of the statement  "            xtw.WriteAttributeString("timestamp"' Convert.ToString((long)(logEvent.TimeStamp.ToUniversalTime() - _log4jDateBase).TotalMilliseconds)); " is 137.
Long Statement,NLog.Internal,FactoryHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\FactoryHelper.cs,CreateInstance,The length of the statement  "            ConstructorInfo constructor = t.GetConstructor(EmptyTypes); //t.GetConstructor(BindingFlags.Public | BindingFlags.Instance' null' Type.EmptyTypes' null); " is 153.
Long Statement,NLog.Internal,LogEventInfoBuffer,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\LogEventInfoBuffer.cs,Append,The length of the statement  "                InternalLogger.Trace("GetPointer: {0} PutPointer: {1} Count: {2} BufferLength: {3}"' _getPointer' _putPointer' _count' _buffer.Length); " is 135.
Long Statement,NLog.Internal,MultiFileWatcher,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\MultiFileWatcher.cs,Watch,The length of the statement  "            watcher.NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.CreationTime | NotifyFilters.Size | NotifyFilters.Security | NotifyFilters.Attributes; " is 149.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,GetEnumValue,The length of the statement  "                    FieldInfo enumField = enumType.GetField(v.Trim()' BindingFlags.IgnoreCase | BindingFlags.Static | BindingFlags.FlattenHierarchy | BindingFlags.Public); " is 151.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,GetEnumValue,The length of the statement  "                FieldInfo enumField = enumType.GetField(value' BindingFlags.IgnoreCase | BindingFlags.Static | BindingFlags.FlattenHierarchy | BindingFlags.Public); " is 148.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,SetPropertyFromString,The length of the statement  "                    throw new NotSupportedException("Parameter " + name + " of " + o.GetType().Name + " is an array and cannot be assigned a scalar value."); " is 137.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,GetPropertyInfo,The length of the statement  "            PropertyInfo propInfo = o.GetType().GetProperty(propertyName' BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); " is 133.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,GetPropertyInfo,The length of the statement  "                PropertyInfo propInfo = targetType.GetProperty(propertyName' BindingFlags.IgnoreCase | BindingFlags.Public | BindingFlags.Instance); " is 132.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,BuildPropertyInfoDictionary,The length of the statement  "                    ArrayParameterAttribute[] attributes = (ArrayParameterAttribute[])propInfo.GetCustomAttributes(typeof(ArrayParameterAttribute)' false); " is 135.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,GetArrayItemType,The length of the statement  "                ArrayParameterAttribute[] attributes = (ArrayParameterAttribute[])propInfo.GetCustomAttributes(typeof(ArrayParameterAttribute)' false); " is 135.
Long Statement,NLog.Internal,PropertyHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PropertyHelper.cs,SetLayoutFromElement,The length of the statement  "            PropertyInfo targetPropertyInfo = o.GetType().GetProperty(name' BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy | BindingFlags.IgnoreCase); " is 167.
Long Statement,NLog.Internal.FileAppenders,MutexMultiProcessFileAppender,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\FileAppenders\MutexMultiProcessFileAppender.cs,GetFileInfo,The length of the statement  "            return FileInfoHelper.Helper.GetFileInfo(FileName' _file.SafeFileHandle.DangerousGetHandle()' out lastWriteTime' out fileLength); " is 129.
Long Statement,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,ReplaceNumber,The length of the statement  "            return pattern.Substring(0' firstPart) + Convert.ToString(value' 10).PadLeft(numDigits' '0') + pattern.Substring(lastPart); " is 123.
Long Statement,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,Initialize,The length of the statement  "                _autoClosingTimer = new Timer(new TimerCallback(this.AutoClosingTimerCallback)' null' OpenFileCacheTimeout * 1000' OpenFileCacheTimeout * 1000); " is 144.
Long Statement,NLog.Targets,NetworkTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Network.cs,ChunkedSend,The length of the statement  "                        throw new OverflowException("Attempted to send a message larger than MaxMessageSize(" + MaxMessageSize + "). Actual size was: " + buffer.Length + ". Adjust OnOverflow and MaxMessageSize parameters accordingly."); " is 212.
Long Statement,NLog.Targets,WebServiceTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\WebService.cs,InvokeHttpPost,The length of the statement  "                    sw.Write(Parameters[i].Name + "=" + System.Web.HttpUtility.UrlEncodeUnicode(Convert.ToString(parameters[i])) + ((i < (Parameters.Count - 1)) ? "&" : "")); " is 154.
Long Statement,NLog.Targets.Compound,FallbackTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Compound\FallbackTarget.cs,Write,The length of the statement  "                        InternalLogger.Warn("Fallback: target '{0}' failed. Proceeding to the next one. Error was: {1}"' Targets[_currentTarget]' ex); " is 126.
Long Statement,NLog.Targets.Wrappers,WrapperTargetBase,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\WrapperTargetBase.cs,ToString,The length of the statement  "            return ((this.Name != null) ? this.Name : "unnamed") + ":" + this.GetType().Name + "(" + ((WrappedTarget != null) ? WrappedTarget.ToString() : "null") + ")"; " is 157.
Long Statement,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,Output,The length of the statement  "            IntPtr hConsole = ConsoleWin32Api.GetStdHandle(ErrorStream ? ConsoleWin32Api.STD_ERROR_HANDLE : ConsoleWin32Api.STD_OUTPUT_HANDLE); " is 131.
Long Statement,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,Output,The length of the statement  "            ushort newColor = ColorFromForegroundAndBackground(csbi.wAttributes' matchingRule.ForegroundColor' matchingRule.BackgroundColor); " is 129.
Long Statement,NLog.Win32.Targets,PerfCounterTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\PerfCounterTarget.cs,InitializePerfCounter,The length of the statement  "                    if (!PerformanceCounterCategory.Exists(CategoryName) || !PerformanceCounterCategory.CounterExists(CounterName' CategoryName)) " is 125.
Complex Conditional,NLog,LayoutParser,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutParser.cs,ParseParameterName,The conditional expression  "(ch == '=' || ch == '}' || ch == ':') && nestLevel == 0"  is complex.
Complex Conditional,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureTargetFromXmlElement,The conditional expression  "(name == "target" || name == "wrapper" || name == "wrapper-target" || name == "compound-target")"  is complex.
Complex Conditional,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureTargetFromXmlElement,The conditional expression  "(name == "target" || name == "wrapper" || name == "wrapper-target" || name == "compound-target")"  is complex.
Complex Conditional,NLog.LayoutRenderers,IdentityLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Identity.cs,Append,The conditional expression  "!Char.IsLetterOrDigit(c) && c != '_' && c != '-' && c != '.'"  is complex.
Virtual Method Call from Constructor,NLog,FilterCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\FilterCollection.cs,FilterCollection,The constructor "FilterCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,FilterCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\FilterCollection.cs,FilterCollection,The constructor "FilterCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,LayoutCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutCollection.cs,LayoutCollection,The constructor "LayoutCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,LayoutCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutCollection.cs,LayoutCollection,The constructor "LayoutCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,LayoutRendererCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRendererCollection.cs,LayoutRendererCollection,The constructor "LayoutRendererCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,LayoutRendererCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRendererCollection.cs,LayoutRendererCollection,The constructor "LayoutRendererCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,TargetCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\TargetCollection.cs,TargetCollection,The constructor "TargetCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,TargetCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\TargetCollection.cs,TargetCollection,The constructor "TargetCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,RichTextBoxRowColoringRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBoxRowColoringRuleCollection.cs,RichTextBoxRowColoringRuleCollection,The constructor "RichTextBoxRowColoringRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog,RichTextBoxRowColoringRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBoxRowColoringRuleCollection.cs,RichTextBoxRowColoringRuleCollection,The constructor "RichTextBoxRowColoringRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Conditions,ConditionExpressionCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionExpressionCollection.cs,ConditionExpressionCollection,The constructor "ConditionExpressionCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Conditions,ConditionExpressionCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionExpressionCollection.cs,ConditionExpressionCollection,The constructor "ConditionExpressionCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Config,LoggingRule,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\LoggingRule.cs,LoggingRule,The constructor "LoggingRule" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Config,LoggingRule,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\LoggingRule.cs,LoggingRule,The constructor "LoggingRule" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Config,LoggingRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\LoggingRuleCollection.cs,LoggingRuleCollection,The constructor "LoggingRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Config,LoggingRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\LoggingRuleCollection.cs,LoggingRuleCollection,The constructor "LoggingRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Layouts,CsvColumnCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Layouts\CsvColumnCollection.cs,CsvColumnCollection,The constructor "CsvColumnCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Layouts,CsvColumnCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Layouts\CsvColumnCollection.cs,CsvColumnCollection,The constructor "CsvColumnCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,DatabaseParameterInfoCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\DatabaseParameterInfoCollection.cs,DatabaseParameterInfoCollection,The constructor "DatabaseParameterInfoCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,DatabaseParameterInfoCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\DatabaseParameterInfoCollection.cs,DatabaseParameterInfoCollection,The constructor "DatabaseParameterInfoCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,MethodCallParameterCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\MethodCallParameterCollection.cs,MethodCallParameterCollection,The constructor "MethodCallParameterCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,MethodCallParameterCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\MethodCallParameterCollection.cs,MethodCallParameterCollection,The constructor "MethodCallParameterCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,NLogViewerParameterInfoCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\NLogViewerParameterInfoCollection.cs,NLogViewerParameterInfoCollection,The constructor "NLogViewerParameterInfoCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,NLogViewerParameterInfoCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\NLogViewerParameterInfoCollection.cs,NLogViewerParameterInfoCollection,The constructor "NLogViewerParameterInfoCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,RichTextBoxTarget,The constructor "RichTextBoxTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,RichTextBoxTarget,The constructor "RichTextBoxTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,RichTextBoxTarget,The constructor "RichTextBoxTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,RichTextBoxTarget,The constructor "RichTextBoxTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,RichTextBoxTarget,The constructor "RichTextBoxTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBox.cs,RichTextBoxTarget,The constructor "RichTextBoxTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxWordColoringRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBoxWordColoringRuleCollection.cs,RichTextBoxWordColoringRuleCollection,The constructor "RichTextBoxWordColoringRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets,RichTextBoxWordColoringRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\RichTextBoxWordColoringRuleCollection.cs,RichTextBoxWordColoringRuleCollection,The constructor "RichTextBoxWordColoringRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets.Compound,CompoundTargetBase,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Compound\CompoundTargetBase.cs,CompoundTargetBase,The constructor "CompoundTargetBase" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets.Wrappers,FilteringRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\FilteringRuleCollection.cs,FilteringRuleCollection,The constructor "FilteringRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Targets.Wrappers,FilteringRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\FilteringRuleCollection.cs,FilteringRuleCollection,The constructor "FilteringRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColoredConsoleTarget,The constructor "ColoredConsoleTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColoredConsoleTarget,The constructor "ColoredConsoleTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColoredConsoleTarget,The constructor "ColoredConsoleTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColoredConsoleTarget,The constructor "ColoredConsoleTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColoredConsoleTarget,The constructor "ColoredConsoleTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColoredConsoleTarget,The constructor "ColoredConsoleTarget" calls a virtual method "Add".
Virtual Method Call from Constructor,NLog.Win32.Targets,ConsoleRowHighlightingRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ConsoleRowHighlightingRuleCollection.cs,ConsoleRowHighlightingRuleCollection,The constructor "ConsoleRowHighlightingRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Win32.Targets,ConsoleRowHighlightingRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ConsoleRowHighlightingRuleCollection.cs,ConsoleRowHighlightingRuleCollection,The constructor "ConsoleRowHighlightingRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Win32.Targets,ConsoleWordHighlightingRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ConsoleWordHighlightingRuleCollection.cs,ConsoleWordHighlightingRuleCollection,The constructor "ConsoleWordHighlightingRuleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,NLog.Win32.Targets,ConsoleWordHighlightingRuleCollection,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ConsoleWordHighlightingRuleCollection.cs,ConsoleWordHighlightingRuleCollection,The constructor "ConsoleWordHighlightingRuleCollection" calls a virtual method "AddRange".
Empty Catch Block,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,GetSetting,The method has an empty catch block.
Empty Catch Block,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,InternalLogger,The method has an empty catch block.
Empty Catch Block,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,InternalLogger,The method has an empty catch block.
Empty Catch Block,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,InternalLogger,The method has an empty catch block.
Empty Catch Block,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,InternalLogger,The method has an empty catch block.
Empty Catch Block,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,Write,The method has an empty catch block.
Empty Catch Block,NLog.Internal.NetworkSenders,TcpNetworkSender,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\NetworkSenders\TcpNetworkSender.cs,Close,The method has an empty catch block.
Empty Catch Block,NLog.Internal.NetworkSenders,UdpNetworkSender,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\NetworkSenders\UdpNetworkSender.cs,Close,The method has an empty catch block.
Magic Number,NLog,LayoutRendererFactory,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRendererFactory.cs,ApplyLayoutRendererParameters,The following statement contains a magic number: while (pos < parameterString.Length)              {                  int nameStartPos = pos;                  while (pos < parameterString.Length && Char.IsWhiteSpace(parameterString[pos]))                  {                      pos++;                  }                  while (pos < parameterString.Length && parameterString[pos] != '=')                  {                      pos++;                  }                  int nameEndPos = pos;                  if (nameStartPos == nameEndPos)                      break;                    pos++;                    // we've got a name - now get a value                  //                    StringBuilder valueBuf = new StringBuilder();                  while (pos < parameterString.Length)                  {                      if (parameterString[pos] == '\\')                      {                          valueBuf.Append(parameterString[pos + 1]);                          pos += 2;                      }                      else if (parameterString[pos] == ':')                      {                          pos++;                          break;                      }                      else                      {                          valueBuf.Append(parameterString[pos]);                          pos++;                      }                  }                    string name = parameterString.Substring(nameStartPos' nameEndPos - nameStartPos);                  string value = valueBuf.ToString();                    PropertyHelper.SetPropertyFromString(target' name' value' null);              }
Magic Number,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,NeedToPreformatMessage,The following statement contains a magic number: if (parameters.Length > 3)              {                  // too many parameters' too costly to check                  return true;              }
Magic Number,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,NeedToPreformatMessage,The following statement contains a magic number: if (parameters.Length >= 2)              {                  if (!IsSafeToDeferFormatting(parameters[1]))                      return true;              }
Magic Number,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,NeedToPreformatMessage,The following statement contains a magic number: if (parameters.Length >= 3)              {                  if (!IsSafeToDeferFormatting(parameters[2]))                      return true;              }
Magic Number,NLog,LogEventInfo,C:\repos\WCell_WCell\Libraries\Source\NLog\LogEventInfo.cs,NeedToPreformatMessage,The following statement contains a magic number: if (parameters.Length >= 3)              {                  if (!IsSafeToDeferFormatting(parameters[2]))                      return true;              }
Magic Number,NLog,LogLevel,C:\repos\WCell_WCell\Libraries\Source\NLog\LogLevel.cs,LogLevel,The following statement contains a magic number: MaxLevel = _levelByOrdinal[_levelByOrdinal.Length - 2];
Magic Number,NLog,Target,C:\repos\WCell_WCell\Libraries\Source\NLog\Target.cs,NeedsStackTrace,The following statement contains a magic number: if (nst == -1)              {                  lock (this)                  {                      nst = _needsStackTrace;                      if (nst == -1)                      {                          int max = 0;                          LayoutCollection layouts = GetLayouts();                            for (int i = 0; i < layouts.Count; ++i)                          {                              max = Math.Max(max' layouts[i].NeedsStackTrace());                              if (max == 2)                                  break;                          }                          nst = max;                          _needsStackTrace = nst;                      }                  }              }
Magic Number,NLog.Conditions,ConditionTokenizer,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionTokenizer.cs,ConditionTokenizer,The following statement contains a magic number: for (int i = 0; i < 128; ++i)               {                  charIndexToTokenType[i] = ConditionTokenType.Invalid;              }
Magic Number,NLog.Conditions,ConditionTokenizer,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionTokenizer.cs,GetNextToken,The following statement contains a magic number: if (ch >= 32 && ch < 128)               {                  ConditionTokenType tt = charIndexToTokenType[ch];                    if (tt != ConditionTokenType.Invalid)                   {                      TokenType = tt;                      _tokenValue = new String(ch' 1);                      return ;                  }                   else                   {                      throw new Exception("Invalid punctuation: " + ch);                  }              }
Magic Number,NLog.Conditions,ConditionTokenizer,C:\repos\WCell_WCell\Libraries\Source\NLog\Conditions\ConditionTokenizer.cs,GetNextToken,The following statement contains a magic number: if (ch >= 32 && ch < 128)               {                  ConditionTokenType tt = charIndexToTokenType[ch];                    if (tt != ConditionTokenType.Invalid)                   {                      TokenType = tt;                      _tokenValue = new String(ch' 1);                      return ;                  }                   else                   {                      throw new Exception("Invalid punctuation: " + ch);                  }              }
Magic Number,NLog.LayoutRenderers,Rot13LayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Rot13.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 30;
Magic Number,NLog.LayoutRenderers,FileContentsLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\FileContents.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 8;
Magic Number,NLog.LayoutRenderers,ASPNETApplicationValueLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ASPNetApplication.cs,GetEstimatedBufferSize,The following statement contains a magic number: if (_variable == null)                  return 0;              else                  return 64;
Magic Number,NLog.LayoutRenderers,ASPNETRequestValueLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ASPNetRequest.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.LayoutRenderers,ASPNETSessionValueLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ASPNetSession.cs,GetEstimatedBufferSize,The following statement contains a magic number: if (Variable == null)                  return 0;              else                  return 64;
Magic Number,NLog.LayoutRenderers,ASPNETSessionIDLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ASPNetSessionID.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.LayoutRenderers,ASPNETUserAuthTypeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ASPNetUserAuthType.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.LayoutRenderers,ASPNETUserIdentityLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ASPNetUserIdentity.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.LayoutRenderers,BaseDirLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\BaseDir.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,CallSiteLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\CallSite.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 200;
Magic Number,NLog.LayoutRenderers,CallSiteLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\CallSite.cs,NeedsStackTrace,The following statement contains a magic number: return _sourceFile ? 2 : 1;
Magic Number,NLog.LayoutRenderers,GCLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\GC.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ProcessInfoLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessInfo.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,SpecialFolderLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\SpecialFolder.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,TempDirLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\TempDir.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,QpcLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\QPC.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,CounterLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Counter.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,DateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Date.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,EnvironmentLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Environment.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ExceptionLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Exception.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ExceptionLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Exception.cs,Append,The following statement contains a magic number: if (logEvent.Exception != null)              {                  StringBuilder sb2 = new StringBuilder(128);                    for (int i = 0; i < _exceptionDataTargets.Length; ++i)                  {                      if (i != 0)                          sb2.Append(Separator);                      _exceptionDataTargets[i](sb2' logEvent.Exception);                  }                  builder.Append(ApplyPadding(sb2.ToString()));              }
Magic Number,NLog.LayoutRenderers,GuidLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Guid.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,IdentityLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Identity.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,LevelLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Level.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 8;
Magic Number,NLog.LayoutRenderers,Log4JXmlEventLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Log4JXmlEvent.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 512;
Magic Number,NLog.LayoutRenderers,LoggerNameLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LoggerName.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 24;
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append2DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append2DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 1000 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 1000 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 100 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 100 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 10 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 10 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append4DigitsZeroPadded,The following statement contains a magic number: builder.Append((char)((number / 1 % 10) + '0'));
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append,The following statement contains a magic number: if (NeedPadding())              {                  builder.Append(ApplyPadding(logEvent.TimeStamp.ToString("yyyy-MM-dd HH:mm:ss.ffff"' CultureInfo)));              }              else              {                  DateTime dt = logEvent.TimeStamp;                    builder.Append(dt.Year);                  builder.Append('-');                  Append2DigitsZeroPadded(builder' dt.Month);                  builder.Append('-');                  Append2DigitsZeroPadded(builder' dt.Day);                  builder.Append(' ');                  Append2DigitsZeroPadded(builder' dt.Hour);                  builder.Append(':');                  Append2DigitsZeroPadded(builder' dt.Minute);                  builder.Append(':');                  Append2DigitsZeroPadded(builder' dt.Second);                  builder.Append('.');                  Append4DigitsZeroPadded(builder' (int)(dt.Ticks % 10000000) / 1000);              }
Magic Number,NLog.LayoutRenderers,LongDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\LongDate.cs,Append,The following statement contains a magic number: if (NeedPadding())              {                  builder.Append(ApplyPadding(logEvent.TimeStamp.ToString("yyyy-MM-dd HH:mm:ss.ffff"' CultureInfo)));              }              else              {                  DateTime dt = logEvent.TimeStamp;                    builder.Append(dt.Year);                  builder.Append('-');                  Append2DigitsZeroPadded(builder' dt.Month);                  builder.Append('-');                  Append2DigitsZeroPadded(builder' dt.Day);                  builder.Append(' ');                  Append2DigitsZeroPadded(builder' dt.Hour);                  builder.Append(':');                  Append2DigitsZeroPadded(builder' dt.Minute);                  builder.Append(':');                  Append2DigitsZeroPadded(builder' dt.Second);                  builder.Append('.');                  Append4DigitsZeroPadded(builder' (int)(dt.Ticks % 10000000) / 1000);              }
Magic Number,NLog.LayoutRenderers,NewLine,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\NewLine.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 2;
Magic Number,NLog.LayoutRenderers,NLogDirLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\NLogDir.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,PerformanceCounterLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\PerformanceCounter.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ProcessIDLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessID.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ProcessNameLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessName.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,Append,The following statement contains a magic number: if (ts.Hours < 10)                  builder.Append('0');
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,Append,The following statement contains a magic number: if (ts.Minutes < 10)                  builder.Append('0');
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,Append,The following statement contains a magic number: if (ts.Seconds < 10)                  builder.Append('0');
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,Append,The following statement contains a magic number: if (ts.Milliseconds < 1000)                  builder.Append('0');
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,Append,The following statement contains a magic number: if (ts.Milliseconds < 100)                  builder.Append('0');
Magic Number,NLog.LayoutRenderers,ProcessTimeLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ProcessTime.cs,Append,The following statement contains a magic number: if (ts.Milliseconds < 10)                  builder.Append('0');
Magic Number,NLog.LayoutRenderers,ShortDateLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ShortDate.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 10;
Magic Number,NLog.LayoutRenderers,StackTraceLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\StackTrace.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 200;
Magic Number,NLog.LayoutRenderers,StackTraceLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\StackTrace.cs,NeedsStackTrace,The following statement contains a magic number: return 2;
Magic Number,NLog.LayoutRenderers,ThreadIDLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ThreadID.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,ThreadNameLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\ThreadName.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,TicksLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\Ticks.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.LayoutRenderers,EventContextLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\EventContext.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.Internal,Win32FileInfoHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\FileInfoHelper.cs,GetFileInfo,The following statement contains a magic number: if (Win32FileHelper.GetFileInformationByHandle(fileHandle' out fi))              {                  lastWriteTime = DateTime.FromFileTime(fi.ftLastWriteTime);                  fileLength = fi.nFileSizeLow + (((long)fi.nFileSizeHigh) << 32);                  return true;              }              else              {                  lastWriteTime = DateTime.MinValue;                  fileLength = -1;                  return false;              }
Magic Number,NLog.Internal,InternalLogger,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\InternalLogger.cs,Write,The following statement contains a magic number: try              {                  string formattedMessage = message;                  if (args != null)                      formattedMessage = String.Format(formatProvider' message' args);                    StringBuilder builder = new StringBuilder(message.Length + 32);                  builder.Append(CurrentTimeGetter.Now.ToString("yyyy-MM-dd HH:mm:ss.ffff"' CultureInfo.InvariantCulture));                  builder.Append(" ");                  builder.Append(level.ToString());                  builder.Append(" ");                  builder.Append(formattedMessage);                  string msg = builder.ToString();                    if (_logFile != null)                  {                      using(TextWriter textWriter = File.AppendText(_logFile))                      {                          textWriter.WriteLine(msg);                      }                  }                    if (_logToConsole)                  {                      Console.WriteLine(msg);                  }    #if !NETCF_1_0                  if (_logToConsoleError)                  {                      Console.Error.WriteLine(msg);                  }  #endif              }              catch               {                  // we have no place to log the message to so we ignore it              }
Magic Number,NLog.Internal,LogEventInfoBuffer,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\LogEventInfoBuffer.cs,Append,The following statement contains a magic number: lock (this)              {                  // make room for additional item                    if (_count >= _buffer.Length)                  {                      if (_growAsNeeded && _buffer.Length < _growLimit)                      {                          // create a new buffer' copy data from current                            int newLength = _buffer.Length * 2;                          if (newLength >= _growLimit)                              newLength = _growLimit;                            LogEventInfo[] newBuffer = new LogEventInfo[newLength];                          // InternalLogger.Trace("Enlarging LogEventInfoBuffer from {0} to {1}"' _buffer.Length' _buffer.Length * 2);                          Array.Copy(_buffer' 0' newBuffer' 0' _buffer.Length);                          _buffer = newBuffer;                      }                      else                      {                          // lose the oldest item                          _getPointer = _getPointer + 1;                      }                  }                    // put the item                    _putPointer = _putPointer % _buffer.Length;                  _buffer[_putPointer] = e;                  _putPointer = _putPointer + 1;                  _count++;                  if (_count >= _buffer.Length)                      _count = _buffer.Length;                  return _count;    /*                  InternalLogger.Trace("GetPointer: {0} PutPointer: {1} Count: {2} BufferLength: {3}"' _getPointer' _putPointer' _count' _buffer.Length);                  for (int i = 0; i < _count; ++i)                  {                      InternalLogger.Trace("buffer[{0}] = {1}"' i' _buffer[(_getPointer + i) % _buffer.Length].Message);                  }                    */                    //Console.ReadLine();              }
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,CompareVersion,The following statement contains a magic number: if (parts.Length > 2)              {                  int p = Convert.ToInt32(parts[2]);                  result = v.Build.CompareTo(p);                  if (result != 0)                      return result;              }
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,CompareVersion,The following statement contains a magic number: if (parts.Length > 2)              {                  int p = Convert.ToInt32(parts[2]);                  result = v.Build.CompareTo(p);                  if (result != 0)                      return result;              }
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,CompareVersion,The following statement contains a magic number: if (parts.Length > 3)              {                  int p = Convert.ToInt32(parts[3]);                  result = v.Revision.CompareTo(p);                  if (result != 0)                      return result;              }
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,CompareVersion,The following statement contains a magic number: if (parts.Length > 3)              {                  int p = Convert.ToInt32(parts[3]);                  result = v.Revision.CompareTo(p);                  if (result != 0)                      return result;              }
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,GetCurrentRuntimeOS,The following statement contains a magic number: if ((int)platformID == 4 || (int)platformID == 128)                  return RuntimeOS.Unix;
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,GetCurrentRuntimeOS,The following statement contains a magic number: if ((int)platformID == 4 || (int)platformID == 128)                  return RuntimeOS.Unix;
Magic Number,NLog.Internal,PlatformDetector,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\PlatformDetector.cs,GetCurrentRuntimeOS,The following statement contains a magic number: if ((int)platformID == 3)                  return RuntimeOS.WindowsCE;
Magic Number,NLog.Internal,TargetWithFilterChain,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\TargetWithFilterChain.cs,PrecalculateNeedsStackTrace,The following statement contains a magic number: for (TargetWithFilterChain awf = this; awf != null; awf = awf.Next)              {                  if (_needsStackTrace >= 2)                      break;                  Target app = awf.Target;                    int nst = app.NeedsStackTrace();                  _needsStackTrace = Math.Max(_needsStackTrace' nst);                    FilterCollection filterChain = awf.FilterChain;                    for (int i = 0; i < filterChain.Count; ++i)                  {                      Filter filter = filterChain[i];                        nst = filter.NeedsStackTrace();                      _needsStackTrace = Math.Max(_needsStackTrace' nst);                  }              }
Magic Number,NLog.Internal,Win32ThreadIDHelper,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\ThreadIDHelper.cs,Win32ThreadIDHelper,The following statement contains a magic number: StringBuilder sb = new StringBuilder(512);
Magic Number,NLog.Internal.FileAppenders,BaseFileAppender,C:\repos\WCell_WCell\Libraries\Source\NLog\Internal\FileAppenders\BaseFileAppender.cs,CreateFileStream,The following statement contains a magic number: for (int i = 0; i < _createParameters.ConcurrentWriteAttempts; ++i)              {                  try                  {                      try                      {                          return TryCreateFileStream(allowConcurrentWrite);                      }                      catch (DirectoryNotFoundException)                      {                          if (!_createParameters.CreateDirs)                              throw;                            Directory.CreateDirectory(Path.GetDirectoryName(FileName));                          return TryCreateFileStream(allowConcurrentWrite);                      }                  }                  catch (IOException)                  {                      if (!_createParameters.ConcurrentWrites || !allowConcurrentWrite || i + 1 == _createParameters.ConcurrentWriteAttempts)                          throw; // rethrow                        int actualDelay = _random.Next(currentDelay);                      InternalLogger.Warn("Attempt #{0} to open {1} failed. Sleeping for {2}ms"' i' FileName' actualDelay);                      currentDelay *= 2;                      System.Threading.Thread.Sleep(actualDelay);                  }              }
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,ReplaceNumber,The following statement contains a magic number: int lastPart = pattern.IndexOf("#}") + 2;
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,ReplaceNumber,The following statement contains a magic number: int numDigits = lastPart - firstPart - 2;
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,ReplaceNumber,The following statement contains a magic number: return pattern.Substring(0' firstPart) + Convert.ToString(value' 10).PadLeft(numDigits' '0') + pattern.Substring(lastPart);
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,SequentialArchive,The following statement contains a magic number: int lastPart = baseNamePattern.IndexOf("#}") + 2;
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,Initialize,The following statement contains a magic number: if ((OpenFileCacheSize > 0 || EnableFileDelete) && OpenFileCacheTimeout > 0)              {                  _autoClosingTimer = new Timer(new TimerCallback(this.AutoClosingTimerCallback)' null' OpenFileCacheTimeout * 1000' OpenFileCacheTimeout * 1000);              }
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,Initialize,The following statement contains a magic number: if ((OpenFileCacheSize > 0 || EnableFileDelete) && OpenFileCacheTimeout > 0)              {                  _autoClosingTimer = new Timer(new TimerCallback(this.AutoClosingTimerCallback)' null' OpenFileCacheTimeout * 1000' OpenFileCacheTimeout * 1000);              }
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,WriteToFile,The following statement contains a magic number: if (!justData)              {                  if (!_initializedFiles.ContainsKey(fileName))                  {                      if (DeleteOldFileOnStartup)                      {                          try                          {                              File.Delete(fileName);                          }                          catch (Exception ex)                          {                              InternalLogger.Warn("Unable to delete old log file '{0}': {1}"' fileName' ex);                          }                      }                      _initializedFiles.Add(fileName' DateTime.Now);                      _initializedFilesCounter++;                      writeHeader = true;                        if (_initializedFilesCounter >= 100)                      {                          _initializedFilesCounter = 0;                          CleanupInitializedFiles();                      }                  }                  _initializedFiles[fileName] = DateTime.Now;              }
Magic Number,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,CleanupInitializedFiles,The following statement contains a magic number: CleanupInitializedFiles(DateTime.Now.AddDays(-2));
Magic Number,NLog.Targets,NLogViewerTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\NLogViewer.cs,NeedsStackTrace,The following statement contains a magic number: if (IncludeSourceInfo)                  return 2;
Magic Number,NLog.Targets.Wrappers,ASPNetBufferingTargetWrapper,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\ASPNetBufferingTargetWrapper.cs,ASPNetBufferingTargetWrapper,The following statement contains a magic number: BufferSize = 100;
Magic Number,NLog.Targets.Wrappers,ASPNetBufferingTargetWrapper,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\ASPNetBufferingTargetWrapper.cs,Close,The following statement contains a magic number: Flush(TimeSpan.FromSeconds(3));
Magic Number,NLog.Targets.Wrappers,BufferingTargetWrapper,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\BufferingTargetWrapper.cs,BufferingTargetWrapper,The following statement contains a magic number: BufferSize = 100;
Magic Number,NLog.Targets.Wrappers,BufferingTargetWrapper,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\BufferingTargetWrapper.cs,Close,The following statement contains a magic number: Flush(TimeSpan.FromSeconds(3));
Magic Number,NLog.Win32.LayoutRenderers,ASPApplicationValueLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\LayoutRenderers\ASPApplication.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.Win32.LayoutRenderers,ASPRequestValueLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\LayoutRenderers\ASPRequest.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.Win32.LayoutRenderers,ASPSessionValueLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\LayoutRenderers\ASPSession.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 64;
Magic Number,NLog.Win32.LayoutRenderers,RegistryLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\LayoutRenderers\Registry.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.Win32.LayoutRenderers,WindowsIdentityLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\LayoutRenderers\WindowsIdentity.cs,GetEstimatedBufferSize,The following statement contains a magic number: return 32;
Magic Number,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorizeEscapeSequences,The following statement contains a magic number: lock (this)              {                  int colorStackLength = 0;                  _colorStack[colorStackLength++] = startingAttribute;                    ConsoleWin32Api.SetConsoleTextAttribute(hConsole' startingAttribute);                    int p0 = 0;                    while (p0 < message.Length)                  {                      int p1 = p0;                      while (p1 < message.Length && message[p1] >= 32)                      {                          p1++;                      }                      // text                      if (p1 != p0)                      {                          output.Write(message.Substring(p0' p1 - p0));                      }                      if (p1 >= message.Length)                      {                          p0 = p1;                          break;                      }                        // control characters                      char c1 = message[p1];                      char c2 = (char)0;                                        if (p1 + 1 < message.Length)                          c2 = message[p1 + 1];                        if (c1 == '\a' && c2 == '\a')                      {                          output.Write('\a');                          p0 = p1 + 2;                          continue;                      }                      if (c1 == '\r' || c1 == '\n')                      {                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' defaultAttribute);                          output.Write(c1);                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                          p0 = p1 + 1;                          continue;                      }                      if (c1 == '\a')                      {                          if (c2 == 'X')                          {                              colorStackLength--;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                              p0 = p1 + 2;                              continue;                          }                          else                          {                              ConsoleOutputColor foreground = (ConsoleOutputColor)(int)(c2 - 'A');                              ConsoleOutputColor background = (ConsoleOutputColor)(int)(message[p1 + 2] - 'A');                              ushort newColor = ColorFromForegroundAndBackground(                                  _colorStack[colorStackLength - 1]' foreground' background);                                _colorStack[colorStackLength++] = newColor;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' newColor);                              p0 = p1 + 3;                              continue;                          }                      }                        output.Write(c1);                      p0 = p1 + 1;                  }                  if (p0 < message.Length)                      output.Write(message.Substring(p0));              }
Magic Number,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorizeEscapeSequences,The following statement contains a magic number: lock (this)              {                  int colorStackLength = 0;                  _colorStack[colorStackLength++] = startingAttribute;                    ConsoleWin32Api.SetConsoleTextAttribute(hConsole' startingAttribute);                    int p0 = 0;                    while (p0 < message.Length)                  {                      int p1 = p0;                      while (p1 < message.Length && message[p1] >= 32)                      {                          p1++;                      }                      // text                      if (p1 != p0)                      {                          output.Write(message.Substring(p0' p1 - p0));                      }                      if (p1 >= message.Length)                      {                          p0 = p1;                          break;                      }                        // control characters                      char c1 = message[p1];                      char c2 = (char)0;                                        if (p1 + 1 < message.Length)                          c2 = message[p1 + 1];                        if (c1 == '\a' && c2 == '\a')                      {                          output.Write('\a');                          p0 = p1 + 2;                          continue;                      }                      if (c1 == '\r' || c1 == '\n')                      {                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' defaultAttribute);                          output.Write(c1);                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                          p0 = p1 + 1;                          continue;                      }                      if (c1 == '\a')                      {                          if (c2 == 'X')                          {                              colorStackLength--;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                              p0 = p1 + 2;                              continue;                          }                          else                          {                              ConsoleOutputColor foreground = (ConsoleOutputColor)(int)(c2 - 'A');                              ConsoleOutputColor background = (ConsoleOutputColor)(int)(message[p1 + 2] - 'A');                              ushort newColor = ColorFromForegroundAndBackground(                                  _colorStack[colorStackLength - 1]' foreground' background);                                _colorStack[colorStackLength++] = newColor;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' newColor);                              p0 = p1 + 3;                              continue;                          }                      }                        output.Write(c1);                      p0 = p1 + 1;                  }                  if (p0 < message.Length)                      output.Write(message.Substring(p0));              }
Magic Number,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorizeEscapeSequences,The following statement contains a magic number: lock (this)              {                  int colorStackLength = 0;                  _colorStack[colorStackLength++] = startingAttribute;                    ConsoleWin32Api.SetConsoleTextAttribute(hConsole' startingAttribute);                    int p0 = 0;                    while (p0 < message.Length)                  {                      int p1 = p0;                      while (p1 < message.Length && message[p1] >= 32)                      {                          p1++;                      }                      // text                      if (p1 != p0)                      {                          output.Write(message.Substring(p0' p1 - p0));                      }                      if (p1 >= message.Length)                      {                          p0 = p1;                          break;                      }                        // control characters                      char c1 = message[p1];                      char c2 = (char)0;                                        if (p1 + 1 < message.Length)                          c2 = message[p1 + 1];                        if (c1 == '\a' && c2 == '\a')                      {                          output.Write('\a');                          p0 = p1 + 2;                          continue;                      }                      if (c1 == '\r' || c1 == '\n')                      {                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' defaultAttribute);                          output.Write(c1);                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                          p0 = p1 + 1;                          continue;                      }                      if (c1 == '\a')                      {                          if (c2 == 'X')                          {                              colorStackLength--;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                              p0 = p1 + 2;                              continue;                          }                          else                          {                              ConsoleOutputColor foreground = (ConsoleOutputColor)(int)(c2 - 'A');                              ConsoleOutputColor background = (ConsoleOutputColor)(int)(message[p1 + 2] - 'A');                              ushort newColor = ColorFromForegroundAndBackground(                                  _colorStack[colorStackLength - 1]' foreground' background);                                _colorStack[colorStackLength++] = newColor;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' newColor);                              p0 = p1 + 3;                              continue;                          }                      }                        output.Write(c1);                      p0 = p1 + 1;                  }                  if (p0 < message.Length)                      output.Write(message.Substring(p0));              }
Magic Number,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorizeEscapeSequences,The following statement contains a magic number: lock (this)              {                  int colorStackLength = 0;                  _colorStack[colorStackLength++] = startingAttribute;                    ConsoleWin32Api.SetConsoleTextAttribute(hConsole' startingAttribute);                    int p0 = 0;                    while (p0 < message.Length)                  {                      int p1 = p0;                      while (p1 < message.Length && message[p1] >= 32)                      {                          p1++;                      }                      // text                      if (p1 != p0)                      {                          output.Write(message.Substring(p0' p1 - p0));                      }                      if (p1 >= message.Length)                      {                          p0 = p1;                          break;                      }                        // control characters                      char c1 = message[p1];                      char c2 = (char)0;                                        if (p1 + 1 < message.Length)                          c2 = message[p1 + 1];                        if (c1 == '\a' && c2 == '\a')                      {                          output.Write('\a');                          p0 = p1 + 2;                          continue;                      }                      if (c1 == '\r' || c1 == '\n')                      {                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' defaultAttribute);                          output.Write(c1);                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                          p0 = p1 + 1;                          continue;                      }                      if (c1 == '\a')                      {                          if (c2 == 'X')                          {                              colorStackLength--;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                              p0 = p1 + 2;                              continue;                          }                          else                          {                              ConsoleOutputColor foreground = (ConsoleOutputColor)(int)(c2 - 'A');                              ConsoleOutputColor background = (ConsoleOutputColor)(int)(message[p1 + 2] - 'A');                              ushort newColor = ColorFromForegroundAndBackground(                                  _colorStack[colorStackLength - 1]' foreground' background);                                _colorStack[colorStackLength++] = newColor;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' newColor);                              p0 = p1 + 3;                              continue;                          }                      }                        output.Write(c1);                      p0 = p1 + 1;                  }                  if (p0 < message.Length)                      output.Write(message.Substring(p0));              }
Magic Number,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorizeEscapeSequences,The following statement contains a magic number: lock (this)              {                  int colorStackLength = 0;                  _colorStack[colorStackLength++] = startingAttribute;                    ConsoleWin32Api.SetConsoleTextAttribute(hConsole' startingAttribute);                    int p0 = 0;                    while (p0 < message.Length)                  {                      int p1 = p0;                      while (p1 < message.Length && message[p1] >= 32)                      {                          p1++;                      }                      // text                      if (p1 != p0)                      {                          output.Write(message.Substring(p0' p1 - p0));                      }                      if (p1 >= message.Length)                      {                          p0 = p1;                          break;                      }                        // control characters                      char c1 = message[p1];                      char c2 = (char)0;                                        if (p1 + 1 < message.Length)                          c2 = message[p1 + 1];                        if (c1 == '\a' && c2 == '\a')                      {                          output.Write('\a');                          p0 = p1 + 2;                          continue;                      }                      if (c1 == '\r' || c1 == '\n')                      {                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' defaultAttribute);                          output.Write(c1);                          ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                          p0 = p1 + 1;                          continue;                      }                      if (c1 == '\a')                      {                          if (c2 == 'X')                          {                              colorStackLength--;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' _colorStack[colorStackLength - 1]);                              p0 = p1 + 2;                              continue;                          }                          else                          {                              ConsoleOutputColor foreground = (ConsoleOutputColor)(int)(c2 - 'A');                              ConsoleOutputColor background = (ConsoleOutputColor)(int)(message[p1 + 2] - 'A');                              ushort newColor = ColorFromForegroundAndBackground(                                  _colorStack[colorStackLength - 1]' foreground' background);                                _colorStack[colorStackLength++] = newColor;                              ConsoleWin32Api.SetConsoleTextAttribute(hConsole' newColor);                              p0 = p1 + 3;                              continue;                          }                      }                        output.Write(c1);                      p0 = p1 + 1;                  }                  if (p0 < message.Length)                      output.Write(message.Substring(p0));              }
Magic Number,NLog.Win32.Targets,ColoredConsoleTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\ColoredConsole.cs,ColorFromForegroundAndBackground,The following statement contains a magic number: if (backgroundColor != ConsoleOutputColor.NoChange)              {                  newColor = (ushort)(newColor & ~0xF0);                  newColor |= (ushort)(((int)backgroundColor) << 4);              }
Magic Number,NLog.Win32.Targets,EventLogTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\EventLog.cs,Write,The following statement contains a magic number: if (message.Length > 16384)              {                  // limitation of EventLog API                  message = message.Substring(0' 16384);              }
Magic Number,NLog.Win32.Targets,EventLogTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Win32\Targets\EventLog.cs,Write,The following statement contains a magic number: if (message.Length > 16384)              {                  // limitation of EventLog API                  message = message.Substring(0' 16384);              }
Duplicate Code,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,Initialize,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 33)' (38' 60))
Missing Default,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureFromXmlElement,The following switch statement is missing a default case: switch (GetCaseInsensitiveAttribute(configElement' "autoReload"))              {                  case "true":                      AutoReload = true;                      break;                    case "false":                      AutoReload = false;                      break;              }
Missing Default,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureFromXmlElement,The following switch statement is missing a default case: switch (GetCaseInsensitiveAttribute(configElement' "throwExceptions"))              {                  case "true":                      LogManager.ThrowExceptions = true;                      break;                    case "false":                      LogManager.ThrowExceptions = false;                      break;              }
Missing Default,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureFromXmlElement,The following switch statement is missing a default case: switch (GetCaseInsensitiveAttribute(configElement' "internalLogToConsole"))              {                  case "true":                      InternalLogger.LogToConsole = true;                      break;                    case "false":                      InternalLogger.LogToConsole = false;                      break;              }
Missing Default,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureFromXmlElement,The following switch statement is missing a default case: switch (GetCaseInsensitiveAttribute(configElement' "internalLogToConsoleError"))              {                  case "true":                      InternalLogger.LogToConsoleError = true;                      break;                    case "false":                      InternalLogger.LogToConsoleError = false;                      break;              }
Missing Default,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureFromXmlElement,The following switch statement is missing a default case: switch (el.LocalName.ToLower())                  {                      case "extensions":                          AddExtensionsFromElement(el' baseDirectory);                          break;                        case "include":                          IncludeFileFromElement(el' baseDirectory);                          break;                        case "appenders":                      case "targets":                          ConfigureTargetsFromElement(el);                          break;                        case "variable":                          SetVariable(el);                          break;                        case "rules":                          ConfigureRulesFromElement(this' LoggingRules' el);                          break;                  }
Missing Default,NLog.Config,XmlLoggingConfiguration,C:\repos\WCell_WCell\Libraries\Source\NLog\Config\XmlLoggingConfiguration.cs,ConfigureTargetsFromElement,The following switch statement is missing a default case: switch (name)                  {                      case "default-wrapper":                          defaultWrapperElement = targetElement;                          break;                        case "default-target-parameters":                          typeNameToDefaultTargetParametersElement.Add(type' targetElement);                          break;                        case "target":                      case "appender":                      case "wrapper":                      case "wrapper-target":                      case "compound-target":                          Target newTarget = TargetFactory.CreateTarget(type);                            XmlElement defaultParametersElement;  						if (typeNameToDefaultTargetParametersElement.TryGetValue(type' out defaultParametersElement))                              ConfigureTargetFromXmlElement(newTarget' defaultParametersElement);                            ConfigureTargetFromXmlElement(newTarget' targetElement);                            if (asyncWrap)                              newTarget = WrapWithAsyncTarget(newTarget);                            if (defaultWrapperElement != null)                              newTarget = WrapWithDefaultWrapper(newTarget' defaultWrapperElement);                            InternalLogger.Info("Adding target {0}"' newTarget);                          AddTarget(newTarget.Name' newTarget);                          break;                  }
Missing Default,NLog.LayoutRenderers,GCLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\GC.cs,Append,The following switch statement is missing a default case: switch (_property)              {                  case GCProperty.TotalMemory:                      value = GC.GetTotalMemory(false);                      break;                    case GCProperty.TotalMemoryForceCollection:                      value = GC.GetTotalMemory(true);                      break;    #if DOTNET2                  case GCProperty.CollectionCount0:                      value = GC.CollectionCount(0);                      break;                    case GCProperty.CollectionCount1:                      value = GC.CollectionCount(1);                      break;                    case GCProperty.CollectionCount2:                      value = GC.CollectionCount(2);                      break;  #endif                    case GCProperty.MaxGeneration:                      value = GC.MaxGeneration;                      break;              }
Missing Default,NLog.LayoutRenderers,StackTraceLayoutRenderer,C:\repos\WCell_WCell\Libraries\Source\NLog\LayoutRenderers\StackTrace.cs,Append,The following switch statement is missing a default case: switch (Format)              {                  case StackTraceFormat.Raw:                      for (int i = startingFrame; i >= logEvent.UserStackFrameNumber; --i)                      {                          StackFrame f = logEvent.StackTrace.GetFrame(i);                          builder.Append(f.ToString());                      }                      break;                    case StackTraceFormat.Flat:                      for (int i = startingFrame; i >= logEvent.UserStackFrameNumber; --i)                      {                          StackFrame f = logEvent.StackTrace.GetFrame(i);                          if (!first)                              builder.Append(_separator);                            builder.Append(f.GetMethod().DeclaringType.Name);                          builder.Append(".");                          builder.Append(f.GetMethod().Name);                          first = false;                      }                      break;                    case StackTraceFormat.DetailedFlat:                      for (int i = startingFrame; i >= logEvent.UserStackFrameNumber; --i)                      {                          StackFrame f = logEvent.StackTrace.GetFrame(i);                          if (!first)                              builder.Append(_separator);                            builder.Append("[");                          builder.Append(f.GetMethod());                          builder.Append("]");                          first = false;                      }                      break;              }
Missing Default,NLog.Layouts,CsvLayout,C:\repos\WCell_WCell\Libraries\Source\NLog\Layouts\CsvLayout.cs,Initialize,The following switch statement is missing a default case: switch (Delimiter)              {                  case ColumnDelimiterMode.Auto:                      _actualColumnDelimiter = CultureInfo.CurrentCulture.TextInfo.ListSeparator;                      break;                    case ColumnDelimiterMode.Comma:                      _actualColumnDelimiter = "'";                      break;                    case ColumnDelimiterMode.Semicolon:                      _actualColumnDelimiter = ";";                      break;                    case ColumnDelimiterMode.Pipe:                      _actualColumnDelimiter = "|";                      break;                    case ColumnDelimiterMode.Tab:                      _actualColumnDelimiter = "\t";                      break;                    case ColumnDelimiterMode.Space:                      _actualColumnDelimiter = " ";                      break;                    case ColumnDelimiterMode.Custom:                      _actualColumnDelimiter = _customColumnDelimiter;                      break;              }
Missing Default,NLog.Targets,FileTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\File.cs,DoAutoArchive,The following switch statement is missing a default case: switch (ArchiveNumbering)              {                  case ArchiveNumberingMode.Rolling:                      RecursiveRollingRename(fi.FullName' fileNamePattern' 0);                      break;                    case ArchiveNumberingMode.Sequence:                      SequentialArchive(fi.FullName' fileNamePattern);                      break;              }
Missing Default,NLog.Targets,WebServiceTarget,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\WebService.cs,DoInvoke,The following switch statement is missing a default case: switch (_protocol)              {                  case WebServiceProtocol.Soap11:                      InvokeSoap11(parameters);                      break;                    case WebServiceProtocol.Soap12:                      InvokeSoap12(parameters);                      break;                    case WebServiceProtocol.HttpGet:                      InvokeHttpGet(parameters);                      break;                    case WebServiceProtocol.HttpPost:                      InvokeHttpPost(parameters);                      break;              }
Missing Default,NLog.Targets.Wrappers,AsyncRequestQueue,C:\repos\WCell_WCell\Libraries\Source\NLog\Targets\Wrappers\AsyncTargetWrapper.cs,Enqueue,The following switch statement is missing a default case: switch (OnOverflow)                          {                              case AsyncTargetWrapperOverflowAction.Discard:                                  return;                                case AsyncTargetWrapperOverflowAction.Grow:                                  break;    #if !NETCF                              case AsyncTargetWrapperOverflowAction.Block:                                  while (_queue.Count >= RequestLimit)                                  {                                      InternalLogger.Debug("Blocking...");                                      if (System.Threading.Monitor.Wait(this))                                      {                                          InternalLogger.Debug("Entered critical section.");                                      }                                      else                                      {                                          InternalLogger.Debug("Failed to enter critical section.");                                      }                                  }                                  InternalLogger.Debug("Limit ok.");                                  break;  #endif                          }
