Implementation smell,Namespace,Class,File,Method,Description
Long Method,Terra,Subdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Geometry\Subdivision.cs,Locate,The method has 106 lines of code.
Long Parameter List,Terra,Terra,C:\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,Terra,The method has 5 parameters. Parameters: errorThreshold' pointCountLimit' heightScale' heightValues' importanceMask
Long Parameter List,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangleLine,The method has 5 parameters. Parameters: plane' y' x1' x2' candidate
Magic Number,Terra,Index2,C:\repos\WCell_WCell\WCell-Terrain\Terra\Index2.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  return (X*397) ^ Y;              }
Magic Number,Terra,Subdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Geometry\Subdivision.cs,Spoke,The following statement contains a magic number: var newFaces = new LinkedListTriangle[4];
Magic Number,Terra,Terra,C:\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: var newIndices = new List<int>((int)mesh.PointCount*3);
Magic Number,Terra,Terra,C:\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra,Terra,C:\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra,Terra,C:\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra,Terra,C:\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,GreedySubdivision,The following statement contains a magic number: heap = new Heap(128);
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,GreedySubdivision,The following statement contains a magic number: PointCount = 4;
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: var dx2 = (vecArray[2].X - vecArray[0].X)/(vecArray[2].Y - vecArray[0].Y);
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: var dx2 = (vecArray[2].X - vecArray[0].X)/(vecArray[2].Y - vecArray[0].Y);
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: dx1 = (vecArray[2].X - vecArray[1].X)/(vecArray[2].Y - vecArray[1].Y);
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: dx1 = (vecArray[2].X - vecArray[1].X)/(vecArray[2].Y - vecArray[1].Y);
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: endY = (int) vecArray[2].Y;
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: if (candidate.Importance < 1e-4f)              {                  if (tri.Token != Heap.NOT_IN_HEAP)                  {                      heap.Kill(tri.Token);                  }                  tri.SetCandidate(-69' -69' 0.0f);                  return;              }
Magic Number,Terra.Greedy,GreedySubdivision,C:\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: if (candidate.Importance < 1e-4f)              {                  if (tri.Token != Heap.NOT_IN_HEAP)                  {                      heap.Kill(tri.Token);                  }                  tri.SetCandidate(-69' -69' 0.0f);                  return;              }
Magic Number,Terra.Memory,Heap,C:\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Insert,The following statement contains a magic number: if (m_Size == m_Capacity)              {                  Resize(2*m_Size);              }
Magic Number,Terra.Memory,Heap,C:\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Parent,The following statement contains a magic number: return (i - 1)/2;
Magic Number,Terra.Memory,Heap,C:\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Left,The following statement contains a magic number: return (i*2 + 1);
Magic Number,Terra.Memory,Heap,C:\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Right,The following statement contains a magic number: return (i*2 + 2);
Magic Number,Terra.Memory,Heap,C:\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Right,The following statement contains a magic number: return (i*2 + 2);
