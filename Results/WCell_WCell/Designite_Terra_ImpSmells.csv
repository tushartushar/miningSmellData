Implementation smell,Namespace,Class,File,Method,Description
Long Method,Terra,Subdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Geometry\Subdivision.cs,Locate,The method has 106 lines of code.
Complex Method,Terra,Subdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Geometry\Subdivision.cs,Locate,Cyclomatic complexity of the method is 9
Long Parameter List,Terra,Terra,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,Terra,The method has 5 parameters. Parameters: errorThreshold' pointCountLimit' heightScale' heightValues' importanceMask
Long Parameter List,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangleLine,The method has 5 parameters. Parameters: plane' y' x1' x2' candidate
Magic Number,Terra,Index2,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Index2.cs,GetHashCode,The following statement contains a magic number: return (X*397) ^ Y;
Magic Number,Terra,Subdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Geometry\Subdivision.cs,Spoke,The following statement contains a magic number: var newFaces = new LinkedListTriangle[4];
Magic Number,Terra,Terra,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: var newIndices = new List<int>((int)mesh.PointCount*3);
Magic Number,Terra,Terra,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra,Terra,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra,Terra,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra,Terra,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Terra.cs,GenerateOutput,The following statement contains a magic number: mesh.OverFaces((tri' obj) =>              {                  var triVertices = new[]                  {                      tri.Point1'                      tri.Point2'                      tri.Point3                  };                    foreach (var holeMarker in outputCull)                  {                      var count = 0;                      foreach (var vertex in triVertices)                      {                          var idx = new Index2                          {                              X = (int)vertex.X'                              Y = (int)vertex.Y                          };                            // The triangle abuts one of the hole markers                          if (holeMarker == idx) return;                                                    // The triangle is within the hole markers neighborhood                          if (Index2.Abs(idx - holeMarker) <= Index2.One) count++;                      }                      if (count > 2) return;                  }                    if (GeometryHelpers.IsCounterClockwise(triVertices[0]' triVertices[1]' triVertices[2]))                  {                      var temp = triVertices[1];                      triVertices[1] = triVertices[2];                      triVertices[2] = temp;                  }                    foreach (var vertex in triVertices)                  {                      if (vertexArrayPositions[(int) vertex.X' (int) vertex.Y] == -1)                      {                          vertexArrayPositions[(int) vertex.X' (int) vertex.Y] = newVertices.Count;                          newVertices.Add(new Vector3(vertex' heightMap.Eval(vertex.X' vertex.Y)));                      }                        newIndices.Add(vertexArrayPositions[(int) vertex.X' (int) vertex.Y]);                  }                });
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,GreedySubdivision,The following statement contains a magic number: heap = new Heap(128);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,GreedySubdivision,The following statement contains a magic number: PointCount = 4;
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: var dx2 = (vecArray[2].X - vecArray[0].X)/(vecArray[2].Y - vecArray[0].Y);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: var dx2 = (vecArray[2].X - vecArray[0].X)/(vecArray[2].Y - vecArray[0].Y);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: dx1 = (vecArray[2].X - vecArray[1].X)/(vecArray[2].Y - vecArray[1].Y);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: dx1 = (vecArray[2].X - vecArray[1].X)/(vecArray[2].Y - vecArray[1].Y);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: endY = (int) vecArray[2].Y;
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: tri.SetCandidate(-69' -69' 0.0f);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: tri.SetCandidate(-69' -69' 0.0f);
Magic Number,Terra.Greedy,GreedySubdivision,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Greedy\GreedySubdivision.cs,ScanTriangle,The following statement contains a magic number: candidate.Importance < 1e-4f
Magic Number,Terra.Memory,Heap,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Insert,The following statement contains a magic number: Resize(2*m_Size);
Magic Number,Terra.Memory,Heap,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Parent,The following statement contains a magic number: return (i - 1)/2;
Magic Number,Terra.Memory,Heap,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Left,The following statement contains a magic number: return (i*2 + 1);
Magic Number,Terra.Memory,Heap,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Right,The following statement contains a magic number: return (i*2 + 2);
Magic Number,Terra.Memory,Heap,D:\research\architectureSmells\repos\WCell_WCell\WCell-Terrain\Terra\Memory\Heap.cs,Right,The following statement contains a magic number: return (i*2 + 2);
