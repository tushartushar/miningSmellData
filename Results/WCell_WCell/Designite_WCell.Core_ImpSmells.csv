Implementation smell,Namespace,Class,File,Method,Description
Long Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The method has 103 lines of code.
Complex Method,WCell.Core,SelfRunningTaskQueue,C:\repos\WCell_WCell\Core\WCell.Core\SelfRunningTaskQueue.cs,QueueUpdateCallback,Cyclomatic complexity of the method is 9
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 8
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,multiByteDivide,Cyclomatic complexity of the method is 16
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,singleByteDivide,Cyclomatic complexity of the method is 10
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ModPow,Cyclomatic complexity of the method is 11
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BarrettReduction,Cyclomatic complexity of the method is 13
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,FermatLittleTest,Cyclomatic complexity of the method is 11
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,RabinMillerTest,Cyclomatic complexity of the method is 17
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,SolovayStrassenTest,Cyclomatic complexity of the method is 12
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,Cyclomatic complexity of the method is 15
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,IsProbablePrime,Cyclomatic complexity of the method is 15
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Jacobi,Cyclomatic complexity of the method is 13
Complex Method,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequenceHelper,Cyclomatic complexity of the method is 10
Long Parameter List,WCell.Core.Cryptography,ARC4,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\ARC4.cs,InternalTransformBlock,The method has 5 parameters. Parameters: inputBuffer' inputOffset' inputCount' outputBuffer' outputOffset
Long Parameter List,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequenceHelper,The method has 6 parameters. Parameters: P' Q' k' n' constant' s
Long Parameter List,WCell.Core.Initialization,InitializationStep,C:\repos\WCell_WCell\Core\WCell.Core\Initialization\InitializationStep.cs,InitializationStep,The method has 5 parameters. Parameters: pass' initStepName' isRequired' initContext' initMethod
Long Parameter List,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,DisposableRealmPacketIn,The method has 5 parameters. Parameters: segment' offset' length' contentLength' packetId
Long Parameter List,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The method has 5 parameters. Parameters: opCode' outPacketContent' contentOffset' contentLength' segment
Long Parameter List,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,CopyTo,The method has 5 parameters. Parameters: bytes' fromOffset' length' target' toOffset
Long Parameter List,WCell.RealmServer,RealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\RealmPacketIn.cs,RealmPacketIn,The method has 5 parameters. Parameters: segment' offset' length' opcode' headerSize
Long Identifier,WCell.Core,WCellConstants,C:\repos\WCell_WCell\Core\WCell.Core\WCellConstants.cs,,The length of the parameter DBC_SPELLITEMENCHANTMENTCONDITION is 33.
Long Identifier,WCell.Core,WCellConstants,C:\repos\WCell_WCell\Core\WCell.Core\WCellConstants.cs,,The length of the parameter MAX_UNCOMPRESSED_UPDATE_PACKET is 30.
Long Statement,WCell.Core.Addons,WCellAddonContext,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonContext.cs,InitAddon,The length of the statement  "						"please make sure that it and it's dependencies were built against the current build and all it's dependencies are available."' this)' e); " is 138.
Long Statement,WCell.Core.Addons,WCellAddonMgr,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonMgr.cs,LoadAddons,The length of the statement  "			var ignores = ignoreString.Split(new[] { ';' }' StringSplitOptions.RemoveEmptyEntries).TransformArray(s => s.ToLower().Trim().Replace(".dll"' "")); " is 147.
Long Statement,WCell.Core.Addons,WCellAddonMgr,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonMgr.cs,RecurseLoadAddons,The length of the statement  "							LogManager.GetCurrentClassLogger().Warn("The core Assembly \"" + file.FullName + "\" has been found in the Addon folder where it does not belong." + " is 148.
Long Statement,WCell.Core.Addons,WCellAddonMgr,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonMgr.cs,LoadAddon,The length of the statement  "				LogManager.GetCurrentClassLogger().Error("Failed to load Assembly \"{0}\" because it has the wrong format - Make sure that you only load .NET assemblies that are compiled for the correct target platform: {1}"'  " is 209.
Long Statement,WCell.Core.Addons,WCellAddonMgr,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonMgr.cs,RegisterAddon,The length of the statement  "				LogManager.GetCurrentClassLogger().Warn("Addon of Type \"{0}\" did not specify a ShortName."' context.Addon.GetType().FullName); " is 128.
Long Statement,WCell.Core.Addons,WCellAddonMgr,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonMgr.cs,RegisterAddon,The length of the statement  "					LogManager.GetCurrentClassLogger().Warn("The Addon ShortName \"{0}\" contains the word \"Addon\" - The name should be short and not contain unnecessary information."' context.ShortName); " is 186.
Long Statement,WCell.Core.Addons,WCellAddonUtil,C:\repos\WCell_WCell\Core\WCell.Core\Addons\WCellAddonMgr.cs,GetDefaultDescription,The length of the statement  "			return String.Format("{0} v{1} by {2} ({3})"' addon.Name' addon.GetType().Assembly.GetName().Version' addon.Author' addon.Website); " is 131.
Long Statement,WCell.Core,ServerApp<T>,C:\repos\WCell_WCell\Core\WCell.Core\ServerApp.cs,LogSystemInfo,The length of the statement  "			logger(string.Format("Using: {0}"' DatabaseUtil.Dialect != null ? DatabaseUtil.Dialect.GetType().Name : "<not initialized>")); " is 126.
Long Statement,WCell.Core,Statistics,C:\repos\WCell_WCell\Core\WCell.Core\Statistics.cs,GetStats,The length of the statement  "			statLines.Add(string.Format("+ CPU Usage: {0:0.00}% <-> Memory Usage: {1}"' cpuUsage' WCellUtil.FormatBytes(memUsage))); " is 120.
Long Statement,WCell.Core,Statistics,C:\repos\WCell_WCell\Core\WCell.Core\Statistics.cs,GetStats,The length of the statement  "			statLines.Add(string.Format("+ Thread Count: {0} - GC Counts: {1}"' thisProcess.Threads.Count' gcCounts.ToString("' "))); " is 121.
Long Statement,WCell.Core.Database,DatabaseConfiguration,C:\repos\WCell_WCell\Core\WCell.Core\Database\DatabaseConfiguration.cs,GetARConfiguration,The length of the statement  "            if ((dbTypeLowerCase == "mysql" || dbTypeLowerCase == "mysql5") && !connString.ToLower().Contains("convert zero datetime")) " is 123.
Long Statement,WCell.Core.Initialization,InitMgr,C:\repos\WCell_WCell\Core\WCell.Core\Initialization\InitMgr.cs,AddStepsOfAsm,The length of the statement  "            //s_log.Info(string.Format(Resources.InitStepsLoaded' totalStepCount.ToString()' (totalStepCount == 1 ? "step" : "steps"))); " is 124.
Long Statement,WCell.Core.DBC,DBCReader<TConverter>,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCReader.cs,MapRecords,The length of the statement  "				throw new Exception("Error when reading DBC-file \"" + m_fileName + "\" (Required client version: " + WCellInfo.RequiredVersion + ")"' e); " is 138.
Complex Conditional,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The conditional expression  "(lucas[0].dataLength == 1 && lucas[0].data[0] == 0) ||                  (lucas[1].dataLength == 1 && lucas[1].data[0] == 0)"  is complex.
Virtual Method Call from Constructor,WCell.AuthServer,AuthPacketOut,C:\repos\WCell_WCell\Core\WCell.Core\Network\AuthPacketOut.cs,AuthPacketOut,The constructor "AuthPacketOut" calls a virtual method "WriteByte".
Empty Catch Block,WCell.Core,ClientInformation,C:\repos\WCell_WCell\Core\WCell.Core\ClientInformation.cs,ClientInformation,The method has an empty catch block.
Empty Catch Block,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToString,The method has an empty catch block.
Magic Number,WCell.Core,ClientTypeUtility,C:\repos\WCell_WCell\Core\WCell.Core\ClientInformationUtil.cs,Lookup,The following statement contains a magic number: try              {                  clientInstallationType = clientInstallationType.Substring(0' 4);              }              catch (ArgumentOutOfRangeException)              {                  return ClientType.Invalid;              }
Magic Number,WCell.Core,ClientLocaleUtility,C:\repos\WCell_WCell\Core\WCell.Core\ClientInformationUtil.cs,Lookup,The following statement contains a magic number: try              {                  locale = locale.Substring(0' 4);              }              catch (ArgumentOutOfRangeException)              {                  return WCellConstants.DefaultLocale;              }
Magic Number,WCell.Core,CommandUtil,C:\repos\WCell_WCell\Core\WCell.Core\CommandUtil.cs,ListCfgValues,The following statement contains a magic number: var vars = new List<IVariableDefinition>(50);
Magic Number,WCell.Core,ServerApp<T>,C:\repos\WCell_WCell\Core\WCell.Core\ServerApp.cs,_OnShutdown,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,WCell.Core,Statistics,C:\repos\WCell_WCell\Core\WCell.Core\Statistics.cs,Change,The following statement contains a magic number: if (seconds > 0)  			{  				seconds *= 1000;  			}
Magic Number,WCell.Core,AppConfig,C:\repos\WCell_WCell\Core\WCell.Core\AppConfig.cs,GetNoneNesting,The following statement contains a magic number: if (num2 > 1)  			{  				while ((val[num1] == '(') && (val[(num2 - num1) - 1] == ')'))  				{  					num1++;  				}  				if ((num1 > 0) &&  					(string.Compare(NullString' 0' val' num1' num2 - (2 * num1)' StringComparison.Ordinal) != 0))  				{  					num1 = 0;  				}  			}
Magic Number,WCell.Core,AppConfig,C:\repos\WCell_WCell\Core\WCell.Core\AppConfig.cs,GetValue,The following statement contains a magic number: return cfgVal.Substring(1' cfgVal.Length - 2);
Magic Number,WCell.Core,EntityId,C:\repos\WCell_WCell\Core\WCell.Core\EntityId.cs,ReadPacked,The following statement contains a magic number: var rawId = new byte[8];
Magic Number,WCell.Core,ClientInformation,C:\repos\WCell_WCell\Core\WCell.Core\ClientInformation.cs,ClientInformation,The following statement contains a magic number: try              {                  ProtocolVersion = packet.ReadByte();                  var claimedRemainingLength = packet.ReadUInt16();                  if (packet.RemainingLength != claimedRemainingLength)                  {                      Log.Warn(WCell_Core.Auth_Logon_with_invalid_length' claimedRemainingLength' packet.RemainingLength);                  }                    var clientInstallationType = packet.ReadFourCC();                  _clientInstallationType = ClientTypeUtility.Lookup(clientInstallationType);                    Version = new ClientVersion(packet.ReadBytes(5));                  Architecture = packet.ReadFourCC().TrimEnd('\0');                  OS = packet.ReadFourCC().TrimEnd('\0');                    var locale = packet.ReadFourCC();                  _locale = ClientLocaleUtility.Lookup(locale);                    TimeZone = BitConverter.ToUInt32(packet.ReadBytes(4)' 0);                  IPAddress = new XmlIPAddress(packet.ReadBytes(4));                    Log.Info(WCell_Core.ClientInformationFourCCs' ProtocolVersion' ClientInstallationType' Version' Architecture' OS' Locale' TimeZone' IPAddress);              }              catch              {              }
Magic Number,WCell.Core,ClientInformation,C:\repos\WCell_WCell\Core\WCell.Core\ClientInformation.cs,ClientInformation,The following statement contains a magic number: try              {                  ProtocolVersion = packet.ReadByte();                  var claimedRemainingLength = packet.ReadUInt16();                  if (packet.RemainingLength != claimedRemainingLength)                  {                      Log.Warn(WCell_Core.Auth_Logon_with_invalid_length' claimedRemainingLength' packet.RemainingLength);                  }                    var clientInstallationType = packet.ReadFourCC();                  _clientInstallationType = ClientTypeUtility.Lookup(clientInstallationType);                    Version = new ClientVersion(packet.ReadBytes(5));                  Architecture = packet.ReadFourCC().TrimEnd('\0');                  OS = packet.ReadFourCC().TrimEnd('\0');                    var locale = packet.ReadFourCC();                  _locale = ClientLocaleUtility.Lookup(locale);                    TimeZone = BitConverter.ToUInt32(packet.ReadBytes(4)' 0);                  IPAddress = new XmlIPAddress(packet.ReadBytes(4));                    Log.Info(WCell_Core.ClientInformationFourCCs' ProtocolVersion' ClientInstallationType' Version' Architecture' OS' Locale' TimeZone' IPAddress);              }              catch              {              }
Magic Number,WCell.Core,ClientInformation,C:\repos\WCell_WCell\Core\WCell.Core\ClientInformation.cs,ClientInformation,The following statement contains a magic number: try              {                  ProtocolVersion = packet.ReadByte();                  var claimedRemainingLength = packet.ReadUInt16();                  if (packet.RemainingLength != claimedRemainingLength)                  {                      Log.Warn(WCell_Core.Auth_Logon_with_invalid_length' claimedRemainingLength' packet.RemainingLength);                  }                    var clientInstallationType = packet.ReadFourCC();                  _clientInstallationType = ClientTypeUtility.Lookup(clientInstallationType);                    Version = new ClientVersion(packet.ReadBytes(5));                  Architecture = packet.ReadFourCC().TrimEnd('\0');                  OS = packet.ReadFourCC().TrimEnd('\0');                    var locale = packet.ReadFourCC();                  _locale = ClientLocaleUtility.Lookup(locale);                    TimeZone = BitConverter.ToUInt32(packet.ReadBytes(4)' 0);                  IPAddress = new XmlIPAddress(packet.ReadBytes(4));                    Log.Info(WCell_Core.ClientInformationFourCCs' ProtocolVersion' ClientInstallationType' Version' Architecture' OS' Locale' TimeZone' IPAddress);              }              catch              {              }
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,ToHex,The following statement contains a magic number: for (int i = start; i < end; i += 16)  			{  				var text = new StringBuilder();  				var hex = new StringBuilder();  				hex.Append("|");    				for (int j = 0; j < 16; j++)  				{  					if (j + i < end)  					{  						byte val = arr[j + i];  						hex.Append(arr[j + i].ToString("X2"));  						hex.Append(" ");  						if (val >= 32 && val <= 127)  						{  							text.Append((char)val);  						}  						else  						{  							text.Append(".");  						}  					}  					else  					{  						hex.Append("   ");  						text.Append(" ");  					}  				}  				hex.Append("|");  				hex.Append(text + "|");  				hex.Append('\n');  				hexDump.Append(hex.ToString());  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,ToHex,The following statement contains a magic number: for (int i = start; i < end; i += 16)  			{  				var text = new StringBuilder();  				var hex = new StringBuilder();  				hex.Append("|");    				for (int j = 0; j < 16; j++)  				{  					if (j + i < end)  					{  						byte val = arr[j + i];  						hex.Append(arr[j + i].ToString("X2"));  						hex.Append(" ");  						if (val >= 32 && val <= 127)  						{  							text.Append((char)val);  						}  						else  						{  							text.Append(".");  						}  					}  					else  					{  						hex.Append("   ");  						text.Append(" ");  					}  				}  				hex.Append("|");  				hex.Append(text + "|");  				hex.Append('\n');  				hexDump.Append(hex.ToString());  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,ToHex,The following statement contains a magic number: for (int i = start; i < end; i += 16)  			{  				var text = new StringBuilder();  				var hex = new StringBuilder();  				hex.Append("|");    				for (int j = 0; j < 16; j++)  				{  					if (j + i < end)  					{  						byte val = arr[j + i];  						hex.Append(arr[j + i].ToString("X2"));  						hex.Append(" ");  						if (val >= 32 && val <= 127)  						{  							text.Append((char)val);  						}  						else  						{  							text.Append(".");  						}  					}  					else  					{  						hex.Append("   ");  						text.Append(" ");  					}  				}  				hex.Append("|");  				hex.Append(text + "|");  				hex.Append('\n');  				hexDump.Append(hex.ToString());  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,ToHex,The following statement contains a magic number: for (int i = start; i < end; i += 16)  			{  				var text = new StringBuilder();  				var hex = new StringBuilder();  				hex.Append("|");    				for (int j = 0; j < 16; j++)  				{  					if (j + i < end)  					{  						byte val = arr[j + i];  						hex.Append(arr[j + i].ToString("X2"));  						hex.Append(" ");  						if (val >= 32 && val <= 127)  						{  							text.Append((char)val);  						}  						else  						{  							text.Append(".");  						}  					}  					else  					{  						hex.Append("   ");  						text.Append(" ");  					}  				}  				hex.Append("|");  				hex.Append(text + "|");  				hex.Append('\n');  				hexDump.Append(hex.ToString());  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,FormatBytes,The following statement contains a magic number: if (num >= 1024.0)  			{  				num /= 1024.0; numPrefix = "kb";  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,FormatBytes,The following statement contains a magic number: if (num >= 1024.0)  			{  				num /= 1024.0; numPrefix = "kb";  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,FormatBytes,The following statement contains a magic number: if (num >= 1024.0)  			{  				num /= 1024.0; numPrefix = "MB";  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,FormatBytes,The following statement contains a magic number: if (num >= 1024.0)  			{  				num /= 1024.0; numPrefix = "MB";  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,FormatBytes,The following statement contains a magic number: if (num >= 1024.0)  			{  				num /= 1024.0; numPrefix = "GB";  			}
Magic Number,WCell.Core,WCellUtil,C:\repos\WCell_WCell\Core\WCell.Core\WCellUtil.cs,FormatBytes,The following statement contains a magic number: if (num >= 1024.0)  			{  				num /= 1024.0; numPrefix = "GB";  			}
Magic Number,WCell.Core.Cryptography,ARC4,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\ARC4.cs,ARC4,The following statement contains a magic number: state = new byte[256];
Magic Number,WCell.Core.Cryptography,ARC4,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\ARC4.cs,KeySetup,The following statement contains a magic number: for (int counter = 0; counter < 256; counter++)              {                  state[counter] = (byte) counter;              }
Magic Number,WCell.Core.Cryptography,ARC4,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\ARC4.cs,KeySetup,The following statement contains a magic number: for (int counter = 0; counter < 256; counter++)              {                  index2 = (byte)(key[index1] + state[counter] + index2);                  // swap byte                  byte tmp = state[counter];                  state[counter] = state[index2];                  state[index2] = tmp;                  index1 = (byte)((index1 + 1) % key.Length);              }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,WriteServerChallenge,The following statement contains a magic number: packet.WriteBigInt(m_srp.PublicEphemeralValueB' 32);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,WriteServerChallenge,The following statement contains a magic number: packet.WriteBigIntLength(m_srp.Modulus' 32);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: m_srp.PublicEphemeralValueA = packet.ReadBigInteger(32);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: BigInteger proof = packet.ReadBigInteger(20);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: byte[] arr = packet.ReadBytes(20);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: for (int i = 0; i < keyCount; i++)  		    {  		        ushort keyUnk1 = packet.ReadUInt16();  		        uint keyUnk2 = packet.ReadUInt32();  		        byte[] keyUnkArray = packet.ReadBytes(4);                  // sha of the SRP's PublicEphemeralValueA' PublicEphemeralValueB'                   // and 20 unknown bytes  		        byte[] keyUnkSha = packet.ReadBytes(20);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: for (int i = 0; i < keyCount; i++)  		    {  		        ushort keyUnk1 = packet.ReadUInt16();  		        uint keyUnk2 = packet.ReadUInt32();  		        byte[] keyUnkArray = packet.ReadBytes(4);                  // sha of the SRP's PublicEphemeralValueA' PublicEphemeralValueB'                   // and 20 unknown bytes  		        byte[] keyUnkSha = packet.ReadBytes(20);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: if ((securityFlags & 1) != 0)  		    {  		        // PIN  		        byte[] pinRandom = packet.ReadBytes(16);  		        byte[] pinSha = packet.ReadBytes(20);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: if ((securityFlags & 1) != 0)  		    {  		        // PIN  		        byte[] pinRandom = packet.ReadBytes(16);  		        byte[] pinSha = packet.ReadBytes(20);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: if ((securityFlags & 2) != 0)  		    {  		        byte[] security2Buf = packet.ReadBytes(20);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: if ((securityFlags & 2) != 0)  		    {  		        byte[] security2Buf = packet.ReadBytes(20);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsClientProofValid,The following statement contains a magic number: if ((securityFlags & 4) != 0)  		    {  		        byte arrLen = packet.ReadByte();  		        byte[] security4Buf = packet.ReadBytes(arrLen);  		    }
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,WriteServerProof,The following statement contains a magic number: packet.WriteBigInt(m_srp.ServerSessionKeyProof' 20);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,WriteReconnectChallenge,The following statement contains a magic number: ReconnectProof = new byte[16];
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsReconnectProofValid,The following statement contains a magic number: byte[] md5Hash = packet.ReadBytes(16);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsReconnectProofValid,The following statement contains a magic number: byte[] shaHash1 = packet.ReadBytes(20);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsReconnectProofValid,The following statement contains a magic number: byte[] shaHash2 = packet.ReadBytes(20);
Magic Number,WCell.Core.Cryptography,Authenticator,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\Authenticator.cs,IsReconnectProofValid,The following statement contains a magic number: for (int i = 0; i < 20; i++)              {                  if (shaHash1[i] != hash[i])                      return false;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: while (value != 0 && dataLength < maxLength)              {                  data[dataLength] = (uint) (value & 0xFFFFFFFF);                  value >>= 32;                  dataLength++;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: while (value != 0 && dataLength < maxLength)              {                  data[dataLength] = (uint) (value & 0xFFFFFFFF);                  value >>= 32;                  dataLength++;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = value.Length - 1; i >= limit; i--)              {                  int posVal = value[i];                    if (posVal >= '0' && posVal <= '9')                      posVal -= '0';                  else if (posVal >= 'A' && posVal <= 'Z')                      posVal = (posVal - 'A') + 10;                  else                      posVal = 9999999; // arbitrary large                      if (posVal >= radix)                      throw (new ArithmeticException("Invalid string in constructor."));                  else                  {                      if (value[0] == '-')                          posVal = -posVal;                        result = result + (multiplier*posVal);                        if ((i - 1) >= limit)                          multiplier = multiplier*radix;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = value.Length - 1; i >= limit; i--)              {                  int posVal = value[i];                    if (posVal >= '0' && posVal <= '9')                      posVal -= '0';                  else if (posVal >= 'A' && posVal <= 'Z')                      posVal = (posVal - 'A') + 10;                  else                      posVal = 9999999; // arbitrary large                      if (posVal >= radix)                      throw (new ArithmeticException("Invalid string in constructor."));                  else                  {                      if (value[0] == '-')                          posVal = -posVal;                        result = result + (multiplier*posVal);                        if ((i - 1) >= limit)                          multiplier = multiplier*radix;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: dataLength = inData.Length >> 2;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: dataLength = inLen >> 2;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inLen - 1' j = 0; i >= 3; i -= 4' j++)              {                  data[j] = (uint) ((inData[i - 3] << 24) + (inData[i - 2] << 16) +                                    (inData[i - 1] << 8) + inData[i]);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following statement contains a magic number: if (leftOver == 1)                  data[dataLength - 1] = inData[0];              else if (leftOver == 2)                  data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);              else if (leftOver == 3)                  data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data[bi2.dataLength - 2];
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)              {                  ulong dividend = ((ulong) remainder[pos] << 32) + remainder[pos - 1];                  //Console.WriteLine("dividend = {0}"' dividend);                    ulong q_hat = dividend/firstDivisorByte;                  ulong r_hat = dividend%firstDivisorByte;                    //Console.WriteLine("q_hat = {0:X}' r_hat = {1:X}"' q_hat' r_hat);                    bool done = false;                  while (!done)                  {                      done = true;                        if (q_hat == 0x100000000 ||                          (q_hat*secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                      {                          q_hat--;                          r_hat += firstDivisorByte;                            if (r_hat < 0x100000000)                              done = false;                      }                  }                    for (int h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    BigInteger kk = new BigInteger(dividendPart);                  BigInteger ss = bi2*(long) q_hat;                    //Console.WriteLine("ss before = " + ss);                  while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                      //Console.WriteLine(ss);                  }                  BigInteger yy = kk - ss;                    //Console.WriteLine("ss = " + ss);                  //Console.WriteLine("kk = " + kk);                  //Console.WriteLine("yy = " + yy);                    for (int h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy.data[bi2.dataLength - h];                    /*                  Console.WriteLine("dividend = ");                  for(int q = remainderLen - 1; q >= 0; q--)                          Console.Write("{0:x2}"' remainder[q]);                  Console.WriteLine("\n************ q_hat = {0:X}\n"' q_hat);                  */                    result[resultPos++] = (uint) q_hat;                    pos--;                  j--;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)              {                  ulong dividend = ((ulong) remainder[pos] << 32) + remainder[pos - 1];                  //Console.WriteLine("dividend = {0}"' dividend);                    ulong q_hat = dividend/firstDivisorByte;                  ulong r_hat = dividend%firstDivisorByte;                    //Console.WriteLine("q_hat = {0:X}' r_hat = {1:X}"' q_hat' r_hat);                    bool done = false;                  while (!done)                  {                      done = true;                        if (q_hat == 0x100000000 ||                          (q_hat*secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                      {                          q_hat--;                          r_hat += firstDivisorByte;                            if (r_hat < 0x100000000)                              done = false;                      }                  }                    for (int h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    BigInteger kk = new BigInteger(dividendPart);                  BigInteger ss = bi2*(long) q_hat;                    //Console.WriteLine("ss before = " + ss);                  while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                      //Console.WriteLine(ss);                  }                  BigInteger yy = kk - ss;                    //Console.WriteLine("ss = " + ss);                  //Console.WriteLine("kk = " + kk);                  //Console.WriteLine("yy = " + yy);                    for (int h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy.data[bi2.dataLength - h];                    /*                  Console.WriteLine("dividend = ");                  for(int q = remainderLen - 1; q >= 0; q--)                          Console.Write("{0:x2}"' remainder[q]);                  Console.WriteLine("\n************ q_hat = {0:X}\n"' q_hat);                  */                    result[resultPos++] = (uint) q_hat;                    pos--;                  j--;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0)              {                  ulong dividend = ((ulong) remainder[pos] << 32) + remainder[pos - 1];                  //Console.WriteLine("dividend = {0}"' dividend);                    ulong q_hat = dividend/firstDivisorByte;                  ulong r_hat = dividend%firstDivisorByte;                    //Console.WriteLine("q_hat = {0:X}' r_hat = {1:X}"' q_hat' r_hat);                    bool done = false;                  while (!done)                  {                      done = true;                        if (q_hat == 0x100000000 ||                          (q_hat*secondDivisorByte) > ((r_hat << 32) + remainder[pos - 2]))                      {                          q_hat--;                          r_hat += firstDivisorByte;                            if (r_hat < 0x100000000)                              done = false;                      }                  }                    for (int h = 0; h < divisorLen; h++)                      dividendPart[h] = remainder[pos - h];                    BigInteger kk = new BigInteger(dividendPart);                  BigInteger ss = bi2*(long) q_hat;                    //Console.WriteLine("ss before = " + ss);                  while (ss > kk)                  {                      q_hat--;                      ss -= bi2;                      //Console.WriteLine(ss);                  }                  BigInteger yy = kk - ss;                    //Console.WriteLine("ss = " + ss);                  //Console.WriteLine("kk = " + kk);                  //Console.WriteLine("yy = " + yy);                    for (int h = 0; h < divisorLen; h++)                      remainder[pos - h] = yy.data[bi2.dataLength - h];                    /*                  Console.WriteLine("dividend = ");                  for(int q = remainderLen - 1; q >= 0; q--)                          Console.Write("{0:x2}"' remainder[q]);                  Console.WriteLine("\n************ q_hat = {0:X}\n"' q_hat);                  */                    result[resultPos++] = (uint) q_hat;                    pos--;                  j--;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,singleByteDivide,The following statement contains a magic number: while (pos >= 0)              {                  //Console.WriteLine(pos);                    dividend = ((ulong) outRemainder.data[pos + 1] << 32) + outRemainder.data[pos];                  ulong quotient = dividend/divisor;                  result[resultPos++] = (uint) quotient;                    outRemainder.data[pos + 1] = 0;                  outRemainder.data[pos--] = (uint) (dividend%divisor);                  //Console.WriteLine(">>>> " + bi1);              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,shiftLeft,The following statement contains a magic number: int shiftAmount = 32;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,shiftLeft,The following statement contains a magic number: for (int count = shiftVal; count > 0;)              {                  if (count < shiftAmount)                      shiftAmount = count;                    //Console.WriteLine("shiftAmount = {0}"' shiftAmount);                    ulong carry = 0;                  for (int i = 0; i < bufLen; i++)                  {                      ulong val = ((ulong) buffer[i]) << shiftAmount;                      val |= carry;                        buffer[i] = (uint) (val & 0xFFFFFFFF);                      carry = val >> 32;                  }                    if (carry != 0)                  {                      if (bufLen + 1 <= buffer.Length)                      {                          buffer[bufLen] = (uint) carry;                          bufLen++;                      }                  }                  count -= shiftAmount;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,shiftRight,The following statement contains a magic number: int shiftAmount = 32;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,shiftRight,The following statement contains a magic number: for (int count = shiftVal; count > 0;)              {                  if (count < shiftAmount)                  {                      shiftAmount = count;                      invShift = 32 - shiftAmount;                  }                    //Console.WriteLine("shiftAmount = {0}"' shiftAmount);                    ulong carry = 0;                  for (int i = bufLen - 1; i >= 0; i--)                  {                      ulong val = ((ulong) buffer[i]) >> shiftAmount;                      val |= carry;                        carry = ((ulong) buffer[i]) << invShift;                      buffer[i] = (uint) (val);                  }                    count -= shiftAmount;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: return "0x" + ToString(16);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < 2 || radix > 36)                  throw (new ArgumentException("Radix must be >= 2 and <= 36"));
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: if (radix < 2 || radix > 36)                  throw (new ArgumentException("Radix must be >= 2 and <= 36"));
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: if (a.dataLength == 1 && a.data[0] == 0)                  result = "0";              else              {                  while (a.dataLength > 1 || (a.dataLength == 1 && a.data[0] != 0))                  {                      singleByteDivide(a' biRadix' quotient' remainder);                        if (remainder.data[0] < 10)                          result = remainder.data[0] + result;                      else                          result = charSet[(int) remainder.data[0] - 10] + result;                        a = quotient;                  }                  if (negative)                      result = "-" + result;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToString,The following statement contains a magic number: if (a.dataLength == 1 && a.data[0] == 0)                  result = "0";              else              {                  while (a.dataLength > 1 || (a.dataLength == 1 && a.data[0] != 0))                  {                      singleByteDivide(a' biRadix' quotient' remainder);                        if (remainder.data[0] < 10)                          result = remainder.data[0] + result;                      else                          result = charSet[(int) remainder.data[0] - 10] + result;                        a = quotient;                  }                  if (negative)                      result = "-" + result;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ToHexString,The following statement contains a magic number: for (int i = dataLength - 2; i >= 0; i--)              {                  result += data[i].ToString("X8");              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ModPow,The following statement contains a magic number: for (int pos = 0; pos < exp.dataLength; pos++)              {                  uint mask = 0x01;                  //Console.WriteLine("pos = " + pos);                    for (int index = 0; index < 32; index++)                  {                      if ((exp.data[pos] & mask) != 0)                          resultNum = BarrettReduction(resultNum*tempNum' n' constant);                        mask <<= 1;                        tempNum = BarrettReduction(tempNum*tempNum' n' constant);                          if (tempNum.dataLength == 1 && tempNum.data[0] == 1)                      {                          if (thisNegative && (exp.data[0] & 0x1) != 0) //odd exp                              return -resultNum;                          return resultNum;                      }                      count++;                      if (count == totalBits)                          break;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BarrettReduction,The following statement contains a magic number: for (int i = 0; i < q3.dataLength; i++)              {                  if (q3.data[i] == 0) continue;                    ulong mcarry = 0;                  int t = i;                  for (int j = 0; j < n.dataLength && t < kPlusOne; j++' t++)                  {                      // t = i + j                      ulong val = ((ulong) q3.data[i]*(ulong) n.data[j]) +                                  r2.data[t] + mcarry;                        r2.data[t] = (uint) (val & 0xFFFFFFFF);                      mcarry = (val >> 32);                  }                    if (t < kPlusOne)                      r2.data[t] = (uint) mcarry;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GenerateRandomBits,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GenerateRandomBits,The following statement contains a magic number: if (remBits != 0)              {                  uint mask = (uint) (0x01 << (remBits - 1));                  data[dwords - 1] |= mask;                    mask = 0xFFFFFFFF >> (32 - remBits);                  data[dwords - 1] &= mask;              }              else                  data[dwords - 1] |= 0x80000000;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BitCount,The following statement contains a magic number: int bits = 32;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BitCount,The following statement contains a magic number: bits += ((dataLength - 1) << 5);
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,FermatLittleTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,FermatLittleTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,FermatLittleTest,The following statement contains a magic number: for (int round = 0; round < confidence; round++)              {                  bool done = false;                    while (!done) // generate a < n                  {                      int testBits = 0;                        // make sure "a" has at least 2 bits                      while (testBits < 2)                          testBits = (int) (rand.NextDouble()*bits);                        a.GenerateRandomBits(testBits' rand);                        int byteLen = a.dataLength;                        // make sure "a" is not 0                      if (byteLen > 1 || (byteLen == 1 && a.data[0] != 1))                          done = true;                  }                    // check whether a factor exists (fix for version 1.03)                  BigInteger gcdTest = a.GCD(thisVal);                  if (gcdTest.dataLength == 1 && gcdTest.data[0] != 1)                      return false;                    // calculate a^(p-1) mod p                  BigInteger expResult = a.ModPow(p_sub1' thisVal);                    int resultLen = expResult.dataLength;                    // is NOT prime is a^(p-1) mod p != 1                    if (resultLen > 1 || (resultLen == 1 && expResult.data[0] != 1))                  {                      //Console.WriteLine("a = " + a.ToString());                      return false;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: for (int index = 0; index < p_sub1.dataLength; index++)              {                  uint mask = 0x01;                    for (int i = 0; i < 32; i++)                  {                      if ((p_sub1.data[index] & mask) != 0)                      {                          index = p_sub1.dataLength; // to break the outer loop                          break;                      }                      mask <<= 1;                      s++;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,RabinMillerTest,The following statement contains a magic number: for (int round = 0; round < confidence; round++)              {                  bool done = false;                    while (!done) // generate a < n                  {                      int testBits = 0;                        // make sure "a" has at least 2 bits                      while (testBits < 2)                          testBits = (int) (rand.NextDouble()*bits);                        a.GenerateRandomBits(testBits' rand);                        int byteLen = a.dataLength;                        // make sure "a" is not 0                      if (byteLen > 1 || (byteLen == 1 && a.data[0] != 1))                          done = true;                  }                    // check whether a factor exists (fix for version 1.03)                  BigInteger gcdTest = a.GCD(thisVal);                  if (gcdTest.dataLength == 1 && gcdTest.data[0] != 1)                      return false;                    BigInteger b = a.ModPow(t' thisVal);                    /*                  Console.WriteLine("a = " + a.ToString(10));                  Console.WriteLine("b = " + b.ToString(10));                  Console.WriteLine("t = " + t.ToString(10));                  Console.WriteLine("s = " + s);                  */                    bool result = false;                    if (b.dataLength == 1 && b.data[0] == 1) // a^t mod p = 1                      result = true;                    for (int j = 0; result == false && j < s; j++)                  {                      if (b == p_sub1) // a^((2^j)*t) mod p = p-1 for some 0 <= j <= s-1                      {                          result = true;                          break;                      }                        b = (b*b)%thisVal;                  }                    if (result == false)                      return false;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,SolovayStrassenTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,SolovayStrassenTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,SolovayStrassenTest,The following statement contains a magic number: for (int round = 0; round < confidence; round++)              {                  bool done = false;                    while (!done) // generate a < n                  {                      int testBits = 0;                        // make sure "a" has at least 2 bits                      while (testBits < 2)                          testBits = (int) (rand.NextDouble()*bits);                        a.GenerateRandomBits(testBits' rand);                        int byteLen = a.dataLength;                        // make sure "a" is not 0                      if (byteLen > 1 || (byteLen == 1 && a.data[0] != 1))                          done = true;                  }                    // check whether a factor exists (fix for version 1.03)                  BigInteger gcdTest = a.GCD(thisVal);                  if (gcdTest.dataLength == 1 && gcdTest.data[0] != 1)                      return false;                    // calculate a^((p-1)/2) mod p                    BigInteger expResult = a.ModPow(p_sub1_shift' thisVal);                  if (expResult == p_sub1)                      expResult = (BigInteger) (-1);                    // calculate Jacobi symbol                  BigInteger jacob = (BigInteger) Jacobi((BigInteger) a' (BigInteger) thisVal);                    //Console.WriteLine("a = " + a.ToString(10) + " b = " + thisVal.ToString(10));                  //Console.WriteLine("expResult = " + expResult.ToString(10) + " Jacob = " + jacob.ToString(10));                    // if they are different then it is not prime                  if (expResult != jacob)                      return false;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTest,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: long D = 5' sign = -1' dCount = 0;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: while (!done)              {                  int Jresult = Jacobi((BigInteger) D' (BigInteger) thisVal);                    if (Jresult == -1)                      done = true; // J(D' this) = 1                  else                  {                      if (Jresult == 0 && thisVal > Math.Abs(D)) // divisor found                          return false;                        if (dCount == 20)                      {                          // check for square                          BigInteger root = thisVal.Sqrt();                          if (root*root == thisVal)                              return false;                      }                        //Console.WriteLine(D);                      D = (Math.Abs(D) + 2)*sign;                      sign = -sign;                  }                  dCount++;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: while (!done)              {                  int Jresult = Jacobi((BigInteger) D' (BigInteger) thisVal);                    if (Jresult == -1)                      done = true; // J(D' this) = 1                  else                  {                      if (Jresult == 0 && thisVal > Math.Abs(D)) // divisor found                          return false;                        if (dCount == 20)                      {                          // check for square                          BigInteger root = thisVal.Sqrt();                          if (root*root == thisVal)                              return false;                      }                        //Console.WriteLine(D);                      D = (Math.Abs(D) + 2)*sign;                      sign = -sign;                  }                  dCount++;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: long Q = (1 - D) >> 2;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: for (int index = 0; index < p_add1.dataLength; index++)              {                  uint mask = 0x01;                    for (int i = 0; i < 32; i++)                  {                      if ((p_add1.data[index] & mask) != 0)                      {                          index = p_add1.dataLength; // to break the outer loop                          break;                      }                      mask <<= 1;                      s++;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: for (int i = 1; i < s; i++)              {                  if (!isPrime)                  {                      // doubling of index                      lucas[1] = BarrettReduction(lucas[1]*lucas[1]' thisVal' constant);                      lucas[1] = (lucas[1] - (lucas[2] << 1))%thisVal;                        //lucas[1] = ((lucas[1] * lucas[1]) - (lucas[2] << 1)) % thisVal;                        if ((lucas[1].dataLength == 1 && lucas[1].data[0] == 0))                          isPrime = true;                  }                    lucas[2] = BarrettReduction(lucas[2]*lucas[2]' thisVal' constant); //Q^k              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: for (int i = 1; i < s; i++)              {                  if (!isPrime)                  {                      // doubling of index                      lucas[1] = BarrettReduction(lucas[1]*lucas[1]' thisVal' constant);                      lucas[1] = (lucas[1] - (lucas[2] << 1))%thisVal;                        //lucas[1] = ((lucas[1] * lucas[1]) - (lucas[2] << 1)) % thisVal;                        if ((lucas[1].dataLength == 1 && lucas[1].data[0] == 0))                          isPrime = true;                  }                    lucas[2] = BarrettReduction(lucas[2]*lucas[2]' thisVal' constant); //Q^k              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: for (int i = 1; i < s; i++)              {                  if (!isPrime)                  {                      // doubling of index                      lucas[1] = BarrettReduction(lucas[1]*lucas[1]' thisVal' constant);                      lucas[1] = (lucas[1] - (lucas[2] << 1))%thisVal;                        //lucas[1] = ((lucas[1] * lucas[1]) - (lucas[2] << 1)) % thisVal;                        if ((lucas[1].dataLength == 1 && lucas[1].data[0] == 0))                          isPrime = true;                  }                    lucas[2] = BarrettReduction(lucas[2]*lucas[2]' thisVal' constant); //Q^k              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: for (int i = 1; i < s; i++)              {                  if (!isPrime)                  {                      // doubling of index                      lucas[1] = BarrettReduction(lucas[1]*lucas[1]' thisVal' constant);                      lucas[1] = (lucas[1] - (lucas[2] << 1))%thisVal;                        //lucas[1] = ((lucas[1] * lucas[1]) - (lucas[2] << 1)) % thisVal;                        if ((lucas[1].dataLength == 1 && lucas[1].data[0] == 0))                          isPrime = true;                  }                    lucas[2] = BarrettReduction(lucas[2]*lucas[2]' thisVal' constant); //Q^k              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: if (isPrime) // additional checks for composite numbers              {                  // If n is prime and gcd(n' Q) == 1' then                  // Q^((n+1)/2) = Q * Q^((n-1)/2) is congruent to (Q * J(Q' n)) mod n                    BigInteger g = thisVal.GCD((BigInteger) Q);                  if (g.dataLength == 1 && g.data[0] == 1) // gcd(this' Q) == 1                  {                      if ((lucas[2].data[maxLength - 1] & 0x80000000) != 0)                          lucas[2] += thisVal;                        BigInteger temp = (BigInteger) ((Q*Jacobi((BigInteger) Q' thisVal))%thisVal);                      if ((temp.data[maxLength - 1] & 0x80000000) != 0)                          temp += thisVal;                        if (lucas[2] != temp)                          isPrime = false;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: if (isPrime) // additional checks for composite numbers              {                  // If n is prime and gcd(n' Q) == 1' then                  // Q^((n+1)/2) = Q * Q^((n-1)/2) is congruent to (Q * J(Q' n)) mod n                    BigInteger g = thisVal.GCD((BigInteger) Q);                  if (g.dataLength == 1 && g.data[0] == 1) // gcd(this' Q) == 1                  {                      if ((lucas[2].data[maxLength - 1] & 0x80000000) != 0)                          lucas[2] += thisVal;                        BigInteger temp = (BigInteger) ((Q*Jacobi((BigInteger) Q' thisVal))%thisVal);                      if ((temp.data[maxLength - 1] & 0x80000000) != 0)                          temp += thisVal;                        if (lucas[2] != temp)                          isPrime = false;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasStrongTestHelper,The following statement contains a magic number: if (isPrime) // additional checks for composite numbers              {                  // If n is prime and gcd(n' Q) == 1' then                  // Q^((n+1)/2) = Q * Q^((n-1)/2) is congruent to (Q * J(Q' n)) mod n                    BigInteger g = thisVal.GCD((BigInteger) Q);                  if (g.dataLength == 1 && g.data[0] == 1) // gcd(this' Q) == 1                  {                      if ((lucas[2].data[maxLength - 1] & 0x80000000) != 0)                          lucas[2] += thisVal;                        BigInteger temp = (BigInteger) ((Q*Jacobi((BigInteger) Q' thisVal))%thisVal);                      if ((temp.data[maxLength - 1] & 0x80000000) != 0)                          temp += thisVal;                        if (lucas[2] != temp)                          isPrime = false;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,IsProbablePrime,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,IsProbablePrime,The following statement contains a magic number: if (thisVal.dataLength == 1)              {                  // test small numbers                  if (thisVal.data[0] == 0 || thisVal.data[0] == 1)                      return false;                  else if (thisVal.data[0] == 2 || thisVal.data[0] == 3)                      return true;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,IsProbablePrime,The following statement contains a magic number: for (int index = 0; index < p_sub1.dataLength; index++)              {                  uint mask = 0x01;                    for (int i = 0; i < 32; i++)                  {                      if ((p_sub1.data[index] & mask) != 0)                      {                          index = p_sub1.dataLength; // to break the outer loop                          break;                      }                      mask <<= 1;                      s++;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,IsProbablePrime,The following statement contains a magic number: BigInteger a = (BigInteger) 2;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LongValue,The following statement contains a magic number: try              {                  // exception if maxLength = 1                  val |= (long) data[1] << 32;              }              catch (Exception)              {                  if ((data[0] & 0x80000000) != 0) // negative                      val = (int) data[0];              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Jacobi,The following statement contains a magic number: for (int index = 0; index < a.dataLength; index++)              {                  uint mask = 0x01;                    for (int i = 0; i < 32; i++)                  {                      if ((a.data[index] & mask) != 0)                      {                          index = a.dataLength; // to break the outer loop                          break;                      }                      mask <<= 1;                      e++;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Jacobi,The following statement contains a magic number: if ((e & 0x1) != 0 && ((b.data[0] & 0x7) == 3 || (b.data[0] & 0x7) == 5))                  s = -1;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Jacobi,The following statement contains a magic number: if ((e & 0x1) != 0 && ((b.data[0] & 0x7) == 3 || (b.data[0] & 0x7) == 5))                  s = -1;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Jacobi,The following statement contains a magic number: if ((b.data[0] & 0x3) == 3 && (a1.data[0] & 0x3) == 3)                  s = -s;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Jacobi,The following statement contains a magic number: if ((b.data[0] & 0x3) == 3 && (a1.data[0] & 0x3) == 3)                  s = -s;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,ModInverse,The following statement contains a magic number: BigInteger[] q = new BigInteger[2];
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytesBE,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: int realNumBytes = numBits >> 3;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < realNumBytes; i++)              {                  for (int b = 0; b < 4; b++)                  {                      if (i*4 + b >= realNumBytes)                          return result;                      result[i*4 + b] = (byte) (data[i] >> (b*8) & 0xff);                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < realNumBytes; i++)              {                  for (int b = 0; b < 4; b++)                  {                      if (i*4 + b >= realNumBytes)                          return result;                      result[i*4 + b] = (byte) (data[i] >> (b*8) & 0xff);                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < realNumBytes; i++)              {                  for (int b = 0; b < 4; b++)                  {                      if (i*4 + b >= realNumBytes)                          return result;                      result[i*4 + b] = (byte) (data[i] >> (b*8) & 0xff);                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,GetBytes,The following statement contains a magic number: for (int i = 0; i < realNumBytes; i++)              {                  for (int b = 0; b < 4; b++)                  {                      if (i*4 + b >= realNumBytes)                          return result;                      result[i*4 + b] = (byte) (data[i] >> (b*8) & 0xff);                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Reverse,The following statement contains a magic number: for (int i = 0; i < length/2; i++)              {                  T temp = buffer[i];                  buffer[i] = buffer[length - i - 1];                  buffer[length - i - 1] = temp;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,SetBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,UnsetBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,Sqrt,The following statement contains a magic number: uint bytePos = numBits >> 5;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequence,The following statement contains a magic number: if (k.dataLength == 1 && k.data[0] == 0)              {                  BigInteger[] result = new BigInteger[3];                    result[0] = (BigInteger) 0;                  result[1] = 2%n;                  result[2] = 1%n;                  return result;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequence,The following statement contains a magic number: if (k.dataLength == 1 && k.data[0] == 0)              {                  BigInteger[] result = new BigInteger[3];                    result[0] = (BigInteger) 0;                  result[1] = 2%n;                  result[2] = 1%n;                  return result;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequence,The following statement contains a magic number: if (k.dataLength == 1 && k.data[0] == 0)              {                  BigInteger[] result = new BigInteger[3];                    result[0] = (BigInteger) 0;                  result[1] = 2%n;                  result[2] = 1%n;                  return result;              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequence,The following statement contains a magic number: for (int index = 0; index < k.dataLength; index++)              {                  uint mask = 0x01;                    for (int i = 0; i < 32; i++)                  {                      if ((k.data[index] & mask) != 0)                      {                          index = k.dataLength; // to break the outer loop                          break;                      }                      mask <<= 1;                      s++;                  }              }
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequenceHelper,The following statement contains a magic number: BigInteger[] result = new BigInteger[3];
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequenceHelper,The following statement contains a magic number: BigInteger v = 2%n'                         Q_k = 1%n'                         v1 = P%n'                         u1 = Q_k;
Magic Number,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,LucasSequenceHelper,The following statement contains a magic number: result[2] = Q_k;
Magic Number,WCell.Core.Cryptography,SecureRemotePassword,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\SecureRemotePassword.cs,GenerateCredentialsHash,The following statement contains a magic number: if (buf.Length > 20)  			{  				// should never happen' since we're using SHA1' which always outputs a 20byte hash  			    throw new CryptographicException("SHA-1 hash too long - " + buf.Length + " bytes' should be 20!");  			}
Magic Number,WCell.Core.Database,SqlUtil,C:\repos\WCell_WCell\Core\WCell.Core\Database\SqlUtil.cs,PrepareInsertBuilder,The following statement contains a magic number: var sb = new StringBuilder(150);
Magic Number,WCell.Core.Initialization,InitMgr,C:\repos\WCell_WCell\Core\WCell.Core\Initialization\InitMgr.cs,Execute,The following statement contains a magic number: if (success)              {                  // Step succeeded                    totalSuccess++;                  if (!string.IsNullOrEmpty(step.InitStepName))                  {                      var span = DateTime.Now - start;                      if (m_MeasureSteps)                      {                          // save stats for later use                      }                      var timeStr = span.Minutes.ToString().PadLeft(2' '0') + ":" + span.Seconds.ToString().PadLeft(2' '0')                                    + "." + span.Milliseconds.ToString().PadLeft(2' '0');                      s_log.Info(string.Format(Resources.InitStepSucceeded' step.InitStepName' timeStr));                  }              }              else              {                  if (!failHandler(this' step))                  {                      // Step failed                      if (step.IsRequired)                      {                          // It was required.  Log this' and cease any further initialization.                          s_log.Fatal(string.Format(Resources.InitStepWasRequired' step.InitStepName' step.InitMethod.Name));                            return false;                      }                      else                      {                          totalFails++;                      }                  }              }
Magic Number,WCell.Core.Initialization,InitMgr,C:\repos\WCell_WCell\Core\WCell.Core\Initialization\InitMgr.cs,Execute,The following statement contains a magic number: if (success)              {                  // Step succeeded                    totalSuccess++;                  if (!string.IsNullOrEmpty(step.InitStepName))                  {                      var span = DateTime.Now - start;                      if (m_MeasureSteps)                      {                          // save stats for later use                      }                      var timeStr = span.Minutes.ToString().PadLeft(2' '0') + ":" + span.Seconds.ToString().PadLeft(2' '0')                                    + "." + span.Milliseconds.ToString().PadLeft(2' '0');                      s_log.Info(string.Format(Resources.InitStepSucceeded' step.InitStepName' timeStr));                  }              }              else              {                  if (!failHandler(this' step))                  {                      // Step failed                      if (step.IsRequired)                      {                          // It was required.  Log this' and cease any further initialization.                          s_log.Fatal(string.Format(Resources.InitStepWasRequired' step.InitStepName' step.InitMethod.Name));                            return false;                      }                      else                      {                          totalFails++;                      }                  }              }
Magic Number,WCell.Core.Initialization,InitMgr,C:\repos\WCell_WCell\Core\WCell.Core\Initialization\InitMgr.cs,Execute,The following statement contains a magic number: if (success)              {                  // Step succeeded                    totalSuccess++;                  if (!string.IsNullOrEmpty(step.InitStepName))                  {                      var span = DateTime.Now - start;                      if (m_MeasureSteps)                      {                          // save stats for later use                      }                      var timeStr = span.Minutes.ToString().PadLeft(2' '0') + ":" + span.Seconds.ToString().PadLeft(2' '0')                                    + "." + span.Milliseconds.ToString().PadLeft(2' '0');                      s_log.Info(string.Format(Resources.InitStepSucceeded' step.InitStepName' timeStr));                  }              }              else              {                  if (!failHandler(this' step))                  {                      // Step failed                      if (step.IsRequired)                      {                          // It was required.  Log this' and cease any further initialization.                          s_log.Fatal(string.Format(Resources.InitStepWasRequired' step.InitStepName' step.InitMethod.Name));                            return false;                      }                      else                      {                          totalFails++;                      }                  }              }
Magic Number,WCell.Core.Network,IOExtensions,C:\repos\WCell_WCell\Core\WCell.Core\Network\IOExtensions.cs,WritePackedUInt64,The following statement contains a magic number: for (var i = 0; i < 8; i++)  			{  				if (buffer[i] != 0)  				{  					mask |= (byte)(1 << i);  					binWriter.Write(buffer[i]);  				}  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var opcode = (RealmServerOpCode)(outPacket[index + 2] | (outPacket[index + 3] << 8));
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var opcode = (RealmServerOpCode)(outPacket[index + 2] | (outPacket[index + 3] << 8));
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var opcode = (RealmServerOpCode)(outPacket[index + 2] | (outPacket[index + 3] << 8));
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var segment = BufferManager.GetSegment(totalLength + 2);
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var opcode = (RealmServerOpCode)(oldSegment.Buffer.Array[index + 2] | (oldSegment.Buffer.Array[index + 3] << 8));
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var opcode = (RealmServerOpCode)(oldSegment.Buffer.Array[index + 2] | (oldSegment.Buffer.Array[index + 3] << 8));
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,CreateFromOutPacket,The following statement contains a magic number: var opcode = (RealmServerOpCode)(oldSegment.Buffer.Array[index + 2] | (oldSegment.Buffer.Array[index + 3] << 8));
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: var packetSize = totalLength - (headerSize - 4);
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,DisposableRealmPacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\DisposableRealmPacketIn.cs,Create,The following statement contains a magic number: if (headerSize == LARGE_PACKET_HEADER_SIZE)  			{  				segment.Buffer.Array[segment.Offset] = (byte)((packetSize >> 16) | 0x80);  				segment.Buffer.Array[segment.Offset + 1] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 2] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 3] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 4] = (byte)(((int)opCode.RawId) >> 8);  			}  			else  			{  				segment.Buffer.Array[segment.Offset] = (byte)(packetSize >> 8);  				segment.Buffer.Array[segment.Offset + 1] = (byte)packetSize;    				segment.Buffer.Array[segment.Offset + 2] = (byte)((int)opCode.RawId);  				segment.Buffer.Array[segment.Offset + 3] = (byte)(((int)opCode.RawId) >> 8);  			}
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadUInt16BE,The following statement contains a magic number: return (ushort)((ReadByte() << 8) | ReadByte());
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadFourCC,The following statement contains a magic number: if (!EnsureData(4))              {                  return "";              }
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadFourCC,The following statement contains a magic number: char[] chrs = ReadChars(4);
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadFourCC,The following statement contains a magic number: if(chrs[3] == 0)              {                  var temp = chrs[2];                  chrs[2] = chrs[0];                  chrs[0] = temp;              }              else              {                  (chrs).Reverse();              }
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadFourCC,The following statement contains a magic number: if(chrs[3] == 0)              {                  var temp = chrs[2];                  chrs[2] = chrs[0];                  chrs[0] = temp;              }              else              {                  (chrs).Reverse();              }
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadFourCC,The following statement contains a magic number: if(chrs[3] == 0)              {                  var temp = chrs[2];                  chrs[2] = chrs[0];                  chrs[0] = temp;              }              else              {                  (chrs).Reverse();              }
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadIPAddress,The following statement contains a magic number: if (!EnsureData(4))  			{  				return new XmlIPAddress();  			}
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadIPAddress,The following statement contains a magic number: byte[] data = ReadBytes(4);
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadEntityId,The following statement contains a magic number: EnsureData(8);
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadEntityId,The following statement contains a magic number: return new EntityId(ReadBytes(8));
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadPackedEntityId,The following statement contains a magic number: var guid = new byte[8];
Magic Number,WCell.Core.Network,PacketIn,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketIn.cs,ReadPackedEntityId,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				if ((mask & (1 << i)) != 0)  				{  					guid[i] = ReadByte();  				}  			}
Magic Number,WCell.Core.Network,PacketOut,C:\repos\WCell_WCell\Core\WCell.Core\Network\PacketOut.cs,Reverse,The following statement contains a magic number: for (int i = 0; i < length/2; i++)              {                  T temp = buffer[i];                  buffer[i] = buffer[length - i - 1];                  buffer[length - i - 1] = temp;              }
Magic Number,WCell.Core.Network,PrimitiveWriter,C:\repos\WCell_WCell\Core\WCell.Core\Network\PrimitiveWriter.cs,WriteUShortBE,The following statement contains a magic number: Write((byte)((val & 0xFF00) >> 8));
Magic Number,WCell.Core.Timers,TimerRunner,C:\repos\WCell_WCell\Core\WCell.Core\Timers\TimerRunner.cs,TimerRunner,The following statement contains a magic number: AddBucket(TimerPriority.OneHour' 60 * 60f);
Magic Number,WCell.Core.Timers,TimerEntry,C:\repos\WCell_WCell\Core\WCell.Core\Timers\TimerEntry.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				var result = IntervalMillis*397 ^ (Action != null ? Action.GetHashCode() : 0);  				return result;  			}
Magic Number,WCell.Core.DBC,DBCReader<TConverter>,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCReader.cs,MapRecords,The following statement contains a magic number: try  			{  				binReader.BaseStream.Position = 20;    				for (currentIndex = 0; currentIndex < m_recordCount; currentIndex++)  				{  					Convert(binReader.ReadBytes(m_recordSize));  				}  			}  			catch (Exception e)  			{  				throw new Exception("Error when reading DBC-file \"" + m_fileName + "\" (Required client version: " + WCellInfo.RequiredVersion + ")"' e);  			}
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,CopyTo,The following statement contains a magic number: if (length % 4 != 0)  			{  				throw new Exception("Cannot copy to object " + target + " because it's size is not a multiple of 4.");  			}
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,CopyTo,The following statement contains a magic number: try  			{  				var handle = GCHandle.Alloc(target' GCHandleType.Pinned);  				try  				{  					Marshal.Copy(bytes' fromOffset * 4' new IntPtr(handle.AddrOfPinnedObject().ToInt64() + toOffset)' length);  				}  				finally  				{  					handle.Free();  				}  			}  			catch (Exception e)  			{  				throw new Exception(string.Format("Unable to copy bytes to object {0} of type {1}"' target' target.GetType())' e);  			}
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetUInt32,The following statement contains a magic number: int startIndex = field * 4;
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetUInt32,The following statement contains a magic number: if (startIndex + 4 > data.Length)                  throw new IndexOutOfRangeException();
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetInt32,The following statement contains a magic number: int startIndex = field * 4;
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetInt32,The following statement contains a magic number: if (startIndex + 4 > data.Length)                  throw new IndexOutOfRangeException();
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetFloat,The following statement contains a magic number: int startIndex = field * 4;
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetFloat,The following statement contains a magic number: if (startIndex + 4 > data.Length)                  throw new IndexOutOfRangeException();
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetUInt64,The following statement contains a magic number: int startIndex = startingField * 4;
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetUInt64,The following statement contains a magic number: if (startIndex + 8 > data.Length)                  throw new IndexOutOfRangeException();
Magic Number,WCell.Core.DBC,DBCRecordConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecordConverter.cs,GetString,The following statement contains a magic number: offset += 17;
Magic Number,WCell.Core.DBC,CharStartOutfitConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecords.cs,ConvertTo,The following statement contains a magic number: outfit.Class = (ClassId)((temp & 0xFF00) >> 8);
Magic Number,WCell.Core.DBC,CharStartOutfitConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecords.cs,ConvertTo,The following statement contains a magic number: outfit.Gender = (GenderType)((temp & 0xFF0000) >> 16);
Magic Number,WCell.Core.DBC,CharStartOutfitConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecords.cs,ConvertTo,The following statement contains a magic number: for (int i = 0; i < 12; i++)  			{  				outfit.ItemIds[i] = GetUInt32(rawData' currIndex++);  			}
Magic Number,WCell.Core.DBC,CharStartOutfitConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecords.cs,ConvertTo,The following statement contains a magic number: currIndex += 12;
Magic Number,WCell.Core.DBC,CharStartOutfitConverter,C:\repos\WCell_WCell\Core\WCell.Core\DBC\DBCRecords.cs,ConvertTo,The following statement contains a magic number: for (int i = 0; i < 12; i++)  			{  				outfit.ItemSlots[i] = (InventorySlotType)GetUInt32(rawData' currIndex++);  			}
Magic Number,WCell.RealmServer,RealmPacketOut,C:\repos\WCell_WCell\Core\WCell.Core\Network\RealmPacketOut.cs,RealmPacketOut,The following statement contains a magic number: Position += 2;
Magic Number,WCell.RealmServer,RealmPacketOut,C:\repos\WCell_WCell\Core\WCell.Core\Network\RealmPacketOut.cs,FinalizeWrite,The following statement contains a magic number: WriteUShortBE((ushort)(BaseStream.Length - 2));
Magic Number,WCell.Core.WDB,WDBReader<TEntry;TConverter>,C:\repos\WCell_WCell\Core\WCell.Core\WDB\WDBReader.cs,WDBReader,The following statement contains a magic number: using (FileStream fileStream = new FileStream(m_fileName' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  using (BinaryReader binReader = new BinaryReader(fileStream))                  {                      m_magic = binReader.ReadUInt32();                      m_build = binReader.ReadUInt32();                      m_locale = binReader.ReadUInt32();                      m_unkHeader1 = binReader.ReadUInt32();                      m_unkHeader2 = binReader.ReadUInt32();                        //T record;                      TConverter converter = new TConverter();                      // 20 for Header' 8 0x00 Bytes at the end                      while (binReader.BaseStream.Position < (binReader.BaseStream.Length - 20 - 8))                      {                          TEntry entry = converter.Convert(binReader);                          m_list.Add(entry);                      }                  }              }
Magic Number,WCell.Core.WDB,WDBReader<TEntry;TConverter>,C:\repos\WCell_WCell\Core\WCell.Core\WDB\WDBReader.cs,WDBReader,The following statement contains a magic number: using (FileStream fileStream = new FileStream(m_fileName' FileMode.Open' FileAccess.Read' FileShare.Read))              {                  using (BinaryReader binReader = new BinaryReader(fileStream))                  {                      m_magic = binReader.ReadUInt32();                      m_build = binReader.ReadUInt32();                      m_locale = binReader.ReadUInt32();                      m_unkHeader1 = binReader.ReadUInt32();                      m_unkHeader2 = binReader.ReadUInt32();                        //T record;                      TConverter converter = new TConverter();                      // 20 for Header' 8 0x00 Bytes at the end                      while (binReader.BaseStream.Position < (binReader.BaseStream.Length - 20 - 8))                      {                          TEntry entry = converter.Convert(binReader);                          m_list.Add(entry);                      }                  }              }
Magic Number,WCell.Core.WDB,CreatureCacheConverter,C:\repos\WCell_WCell\Core\WCell.Core\WDB\WDBRecords.cs,Convert,The following statement contains a magic number: cache.Names = new string[4];
Magic Number,WCell.Core.WDB,CreatureCacheConverter,C:\repos\WCell_WCell\Core\WCell.Core\WDB\WDBRecords.cs,Convert,The following statement contains a magic number: cache.QuestItem = new uint[6];
Missing Default,WCell.Core,AppConfig,C:\repos\WCell_WCell\Core\WCell.Core\AppConfig.cs,GetValue,The following switch statement is missing a default case: switch (GetNoneNesting(cfgVal))  			{  				case 0:  					return cfgVal;    				case 1:  					return null;  			}
Missing Default,WCell.Core.Cryptography,BigInteger,C:\repos\WCell_WCell\Core\WCell.Core\Cryptography\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver)              {                  case 1:                      data[dataLength - 1] = inData[0];                      break;                  case 2:                      data[dataLength - 1] = (uint) ((inData[0] << 8) + inData[1]);                      break;                  case 3:                      data[dataLength - 1] = (uint) ((inData[0] << 16) + (inData[1] << 8) + inData[2]);                      break;              }
