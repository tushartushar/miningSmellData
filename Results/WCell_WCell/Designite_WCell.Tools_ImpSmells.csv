Implementation smell,Namespace,Class,File,Method,Description
Complex Method,WCell.Tools.Domi.Output,GOOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\GOOutput.cs,Write,Cyclomatic complexity of the method is 13
Complex Method,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteSpellFamilies,Cyclomatic complexity of the method is 16
Complex Method,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,CreateMaps,Cyclomatic complexity of the method is 8
Complex Method,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,FindAbilities,Cyclomatic complexity of the method is 10
Complex Method,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,AddSpell,Cyclomatic complexity of the method is 15
Complex Method,WCell.Tools.PATools,PATool,C:\repos\WCell_WCell\Utilities\WCell.Tools\PATools\PATool.cs,DefaultOpCodeValidator,Cyclomatic complexity of the method is 16
Complex Method,WCell.Tools.PATools,PATool,C:\repos\WCell_WCell\Utilities\WCell.Tools\PATools\PATool.cs,OnLoad,Cyclomatic complexity of the method is 9
Long Parameter List,WCell.Tools.Domi,WCellEnumWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\WCellEnumWriter.cs,WriteEnum,The method has 7 parameters. Parameters: enumName' enumSuffix' group' values' validator' getNameDelegate' getIdDelegate
Long Parameter List,WCell.Tools.Domi,WCellEnumWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\WCellEnumWriter.cs,WriteEnum,The method has 10 parameters. Parameters: enumName' enumSuffix' group' values' hexadecimal' validator' getNameDelegate' getCommentDelegate' getDuplNameDelegate' getIdDelegate
Long Parameter List,WCell.Tools.Domi.Output,NPCOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\NPCOutput.cs,WritePerByte,The method has 5 parameters. Parameters: bytes0' no' name' enumType' convertType
Long Parameter List,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteFields,The method has 5 parameters. Parameters: writer' obj' fields' prefix' lookedUp
Long Parameter List,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteField,The method has 5 parameters. Parameters: writer' nameAndPrefix' fieldType' obj' lookedUp
Long Parameter List,WCell.Tools.PATools,PATool,C:\repos\WCell_WCell\Utilities\WCell.Tools\PATools\PATool.cs,Init,The method has 5 parameters. Parameters: parentCfg' filename' selectedDir' outputTarget' defaultParser
Long Parameter List,WCell.Tools,VariablePurifier,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\VariablePurifier.cs,PurifyFiles,The method has 5 parameters. Parameters: dirName' filter' recursive' backupDir' ignore
Long Parameter List,WCell.Tools,VariablePurifier,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\VariablePurifier.cs,PurifyFiles,The method has 5 parameters. Parameters: dir' filter' recursive' backupDir' ignore
Long Statement,WCell.Tools.Commands,PASelectDirCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "				EnglishDescription = "Selects the given directory or -if directory is ommited- shows the currently selected directory."; " is 120.
Long Statement,WCell.Tools.Commands,PASelectParserCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "				EnglishDescription = "Selects the given log-parser. Make sure to choose the right one for the format of your log files."; " is 121.
Long Statement,WCell.Tools.Commands,PAAddSelectedFilesCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "					"Parameters can either be fully qualified file-names (relative or absolute) or numbers that correspond to the index within the currently selected Directory. The -l switch optionally lists all files (with numbers) of the given directory."; " is 238.
Long Statement,WCell.Tools.Commands,PARemoveSelectedFilesCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "					"Removes either all (-a) or the given log-file(s) to the list of selected log-files. Only selected log-files will be parsed. " + " is 128.
Long Statement,WCell.Tools.Commands,PARemoveSelectedFilesCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "					"Parameters can either be fully qualified file-names (relative or absolute) or numbers that correspond to the index of the currently selected files."; " is 150.
Long Statement,WCell.Tools.Commands,PARemoveIncOrFilterCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "					EnglishDescription = "Removes inclusive Or-filters. - A packet is only parsed if its opcode contains at least one these." + " is 123.
Long Statement,WCell.Tools.Commands,PARemoveExcAndFilterCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "					EnglishDescription = "Removes exclusive And-filters. - A packet is only parsed if *no* opcode contains *all* of these." + " is 121.
Long Statement,WCell.Tools.Commands,PARemoveExcOrFilterCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Initialize,The length of the statement  "					EnglishDescription = "Removes exclusive Or-filters. - A packet is only parsed if *no* opcode contains *any* of these." + " is 120.
Long Statement,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,WriteSpellLines,The length of the statement  "			using (writer = new CodeFileWriter(outputFileName' "WCell.RealmServer.Spells"' "SpellLines"' "static partial class"' ""' " is 120.
Long Statement,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,FindTalents,The length of the statement  "					((spell.Talent == null || spell.ClassId == 0) && (spell.Ability == null || spell.Rank == 0 || spell.Ability.Skill.Category != SkillCategory.Profession)) || " is 155.
Long Statement,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,FindTalents,The length of the statement  "					spell.HasEffectWith(effect => effect.EffectType == SpellEffectType.LearnPetSpell || effect.EffectType == SpellEffectType.LearnSpell)) " is 133.
Long Statement,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,AddSpell,The length of the statement  "					(spll.Description.Contains(spell.Id.ToString()) || spll.CategoryCooldownTime > 0 || (spll.CastDelay >0 && spell.CastDelay == 0)))) " is 130.
Long Statement,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,AddSpell,The length of the statement  "					(spell.Description.Contains(spll.Id.ToString()) || spll.CategoryCooldownTime == 0 || (spll.CastDelay > 0 && spell.CastDelay == 0))); " is 132.
Long Statement,WCell.Tools.PATools,PATool,C:\repos\WCell_WCell\Utilities\WCell.Tools\PATools\PATool.cs,OnLoad,The length of the statement  "			m_parser = new GenericLogParser(m_LogParseHandler' new LogHandler(DefaultOpCodeValidator' HandlePackets' HandleUpdatePackets)); " is 127.
Long Statement,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellWithSpellClassMaskAndSpellClassSet,The length of the statement  "			            where ((spell.SpellClassMask[0] & u1) != 0) || ((spell.SpellClassMask[1] & u2) != 0) || ((spell.SpellClassMask[2] & u3) != 0) " is 125.
Complex Conditional,WCell.Tools.Domi.Output,GOOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\GOOutput.cs,Write,The conditional expression  "field.Name != "Names" && field.Name != "Id" && field.Name != "Fields" &&  				    field.Name != "InteractRadius" && field.Name != "Type" && field.Name != "Lock" &&  					field.Name != "LockId" && field.Name != "LinkedTrapId" && field.Name != "Templates" &&  					field.Name != "Id" && field.Name != "GOId""  is complex.
Complex Conditional,WCell.Tools.Domi.Output,GOOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\GOOutput.cs,IsDefaultVal,The conditional expression  "(val is int && ((int) val) == 0) ||  			    (val is uint && ((uint) val == 0 || (uint) val == uint.MaxValue)) ||  			    (val is float && ((float) val) == 0) ||  			    (val is bool && !(bool) val)"  is complex.
Complex Conditional,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteField,The conditional expression  "!(obj is string) && !(obj is Spell) && fieldFields.Length > 0 && !fieldType.IsEnum"  is complex.
Complex Conditional,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteSpellFamilies,The conditional expression  "spell.SpellClassSet != SpellClassSet.Generic && spell.Ability != null &&  				    IsEnhancer(spell) && !IsAbility(spell)"  is complex.
Complex Conditional,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,FindTalents,The conditional expression  "spell == null ||  					((spell.Talent == null || spell.ClassId == 0) && (spell.Ability == null || spell.Rank == 0 || spell.Ability.Skill.Category != SkillCategory.Profession)) ||  					spell.IsTriggeredSpell ||  					spell.HasEffectWith(effect => effect.EffectType == SpellEffectType.LearnPetSpell || effect.EffectType == SpellEffectType.LearnSpell)"  is complex.
Complex Conditional,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,AddSpell,The conditional expression  "line.Any(spll => spell.Rank == spll.Rank &&  					(spll.Description.Contains(spell.Id.ToString()) || spll.CategoryCooldownTime > 0 || (spll.CastDelay >0 && spell.CastDelay == 0)))"  is complex.
Magic Number,WCell.Tools.Commands,PASubCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Remove,The following statement contains a magic number: if (!trigger.Text.HasNext)  				{  					trigger.Reply("No arguments specified - " + CreateInfo(trigger));  				}  				else  				{  					if (trigger.Text.NextModifiers() == "a")  					{  						list.Clear();  						trigger.Reply("Filters removed.");  					}  					else  					{  						var parts = trigger.Text.Remainder.Split(''').TransformArray(part => part.Trim());  						var indices = new List<int>(3);  						var strings = new List<string>(3);  						foreach (var part in parts)  						{  							int index;  							if (int.TryParse(part' out index) && index >= 0 && index < list.Count)  							{  								indices.Add(index);  							}  							else  							{  								strings.Add(part);  							}  						}    						var removed = new List<string>(3);  						indices.Sort();  						for (var i = indices.Count - 1; i >= 0; i--)  						{  							var index = indices[i];  							removed.Add(list[i]);  							list.RemoveAt(index);  						}    						foreach (var part in strings)  						{  							if (list.Remove(part))  							{  								removed.Add(part);  							}  						}  						trigger.Reply("Removed {0} filters: " + removed.ToString("' ")' removed.Count());  					}  				}
Magic Number,WCell.Tools.Commands,PASubCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Remove,The following statement contains a magic number: if (!trigger.Text.HasNext)  				{  					trigger.Reply("No arguments specified - " + CreateInfo(trigger));  				}  				else  				{  					if (trigger.Text.NextModifiers() == "a")  					{  						list.Clear();  						trigger.Reply("Filters removed.");  					}  					else  					{  						var parts = trigger.Text.Remainder.Split(''').TransformArray(part => part.Trim());  						var indices = new List<int>(3);  						var strings = new List<string>(3);  						foreach (var part in parts)  						{  							int index;  							if (int.TryParse(part' out index) && index >= 0 && index < list.Count)  							{  								indices.Add(index);  							}  							else  							{  								strings.Add(part);  							}  						}    						var removed = new List<string>(3);  						indices.Sort();  						for (var i = indices.Count - 1; i >= 0; i--)  						{  							var index = indices[i];  							removed.Add(list[i]);  							list.RemoveAt(index);  						}    						foreach (var part in strings)  						{  							if (list.Remove(part))  							{  								removed.Add(part);  							}  						}  						trigger.Reply("Removed {0} filters: " + removed.ToString("' ")' removed.Count());  					}  				}
Magic Number,WCell.Tools.Commands,PASubCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\PacketAnalyzerCommand.cs,Remove,The following statement contains a magic number: if (!trigger.Text.HasNext)  				{  					trigger.Reply("No arguments specified - " + CreateInfo(trigger));  				}  				else  				{  					if (trigger.Text.NextModifiers() == "a")  					{  						list.Clear();  						trigger.Reply("Filters removed.");  					}  					else  					{  						var parts = trigger.Text.Remainder.Split(''').TransformArray(part => part.Trim());  						var indices = new List<int>(3);  						var strings = new List<string>(3);  						foreach (var part in parts)  						{  							int index;  							if (int.TryParse(part' out index) && index >= 0 && index < list.Count)  							{  								indices.Add(index);  							}  							else  							{  								strings.Add(part);  							}  						}    						var removed = new List<string>(3);  						indices.Sort();  						for (var i = indices.Count - 1; i >= 0; i--)  						{  							var index = indices[i];  							removed.Add(list[i]);  							list.RemoveAt(index);  						}    						foreach (var part in strings)  						{  							if (list.Remove(part))  							{  								removed.Add(part);  							}  						}  						trigger.Reply("Removed {0} filters: " + removed.ToString("' ")' removed.Count());  					}  				}
Magic Number,WCell.Tools.Commands,RandomWPCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\WPCommands.cs,Process,The following statement contains a magic number: var min = text.NextInt(3);
Magic Number,WCell.Tools.Commands,RandomWPCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\WPCommands.cs,Process,The following statement contains a magic number: var max = text.NextInt(5);
Magic Number,WCell.Tools.Commands,RandomWPCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\WPCommands.cs,Process,The following statement contains a magic number: var minDist = text.NextFloat(5);
Magic Number,WCell.Tools.Commands,RandomWPCommand,C:\repos\WCell_WCell\Utilities\WCell.Tools\Commands\WPCommands.cs,Process,The following statement contains a magic number: var maxDist = text.NextFloat(10);
Magic Number,WCell.Tools.Domi,WCellEnumWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\WCellEnumWriter.cs,WriteSpellLinesEnum,The following statement contains a magic number: var list = new List<string>(2000);
Magic Number,WCell.Tools.Domi,DistanceConverter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\WCellEnumWriter.cs,ConvertTo,The following statement contains a magic number: entry.Distance = GetFloat(rawData' 3);
Magic Number,WCell.Tools.Domi,DistanceConverter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\WCellEnumWriter.cs,ConvertTo,The following statement contains a magic number: entry.Name = GetString(rawData' 6);
Magic Number,WCell.Tools.Domi.Output,QuestOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\QuestOutput.cs,WriteQuests,The following statement contains a magic number: using (var writer = new IndentTextWriter(new StreamWriter(ToolConfig.OutputDir + fileName + ".txt"' false)))  			{  				var quests = new List<QuestTemplate>(10000);  				foreach (var quest in QuestMgr.Templates)  				{  					if (quest == null)  						continue;    					//if (filter == null || filter(quest' quests))  					//{  					//    quests[quest.Title] = quest;  					//}  					quests.Add(quest);  				}      				writer.WriteLine("Found {0} Quests:"' quests.Count);  				writer.WriteLine();    				if (extraOuput != null)  				{  					foreach (var quest in quests)  					{  						writer.WriteLine("{0} (Id: {1})"' quest.DefaultTitle' quest.Id);    						extraOuput(writer' quest);  					}  				}    				writer.WriteLine();  				writer.WriteLine("##########################################");  				writer.WriteLine();    				foreach (var spell in quests)  				{  					DumpQuest(writer' spell);  				}  			}
Magic Number,WCell.Tools.Domi.Output,GOOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\GOOutput.cs,Write,The following statement contains a magic number: if (entry.Lock != null)  			{  				var attrs = new List<string>(2);  				if (entry.Lock.IsUnlocked)  				{  					attrs.Add("Open");  				}  				if (entry.Lock.CanBeClosed)  				{  					attrs.Add("Closable");  				}    				writer.WriteLine(indent + "Lock (Id: {0}{1})"' entry.Lock.Id' attrs.Count > 0 ? ("; " + attrs.ToString("' ")) : "");    				if (entry.Lock.Keys.Length > 0)  				{  					writer.WriteLine(indent + "\tPossible Keys: " + entry.Lock.Keys.ToString("' "));  				}  				if (entry.Lock.OpeningMethods.Length > 0)  				{  					writer.WriteLine(indent + "\tOpening Methods:");  					foreach (var method in entry.Lock.OpeningMethods)  					{  						string reqStr;  						if (method.RequiredSkill != SkillId.None)  						{  							reqStr = string.Format(" needs {0} in {1}"' method.RequiredSkillValue' method.RequiredSkill);  						}  						else  						{  							reqStr = "";  						}    						writer.WriteLine(indent + "\t{0}{1}"' method.InteractionType' reqStr);  					}  				}  			}
Magic Number,WCell.Tools.Domi.Output,NPCOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\NPCOutput.cs,WritePetState,The following statement contains a magic number: WritePerByte(false' 2' "PetState"' typeof (PetState)' typeof (byte));
Magic Number,WCell.Tools.Domi.Output,NPCOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\NPCOutput.cs,WritePerByte,The following statement contains a magic number: using (var writer = new StreamWriter(ToolConfig.OutputDir + "/NPCBytes" + name + ".txt"' false))  			{  				var set = new Dictionary<uint' NPCSpawnEntry>();  				foreach (var spawn in NPCMgr.SpawnEntries)  				{  					if (spawn == null)  						continue;    					set[spawn.Entry.Id] = spawn;  				}    				foreach (var spawn in set.Values)  				{  					var data = spawn.AddonData ?? spawn.Entry.AddonData;  					if (data != null)  					{  						uint byteSet = ((bytes0 ? data.Bytes : data.Bytes2) >> (no * 8)) & 0xff;  						if (byteSet != 0)  						{  							string str;  							if (enumType != null)  							{  								var obj = Convert.ChangeType(byteSet' convertType);  								str = Enum.Format(enumType' obj' "g");  							}  							else  								str = byteSet.ToString();  							writer.WriteLine("Spawn #{0} (Entry:{1}' {2}): {3}"' spawn.SpawnId' spawn.Entry.Id' spawn.Entry.DefaultName' str);  							//return;  						}  					}  				}  			}
Magic Number,WCell.Tools.Domi.Output,NPCOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\NPCOutput.cs,WriteArr,The following statement contains a magic number: var strs = Utility.ToJoinedStringArr(col' 10' "' ");
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,GetSpellsByType,The following statement contains a magic number: var SpellsByType = new Dictionary<SpellEffectType' List<Spell>>(200);
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,GetSpellsByType,The following statement contains a magic number: foreach (var effect in AllEffectTypes)  			{  				SpellsByType.Add(effect' new List<Spell>(2000));  			}
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteChanneledSpells,The following statement contains a magic number: List<Spell> spells = new List<Spell>(1000);
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteInvisSpells,The following statement contains a magic number: using (StreamWriter writer = new StreamWriter(ToolConfig.OutputDir + "InvisSpells.txt"' false))  			{  				var invisSpells = new List<Spell>(100);  				var detectSpells = new List<Spell>(100);  				foreach (var spell in SpellHandler.ById)  				{  					if (spell == null)  						continue;    					if (spell.HasEffectWith((effect) => { return effect.AuraType == AuraType.ModInvisibility; }))  					{  						invisSpells.Add(spell);  					}  					else if (spell.HasEffectWith((effect) => { return effect.AuraType == AuraType.ModInvisibilityDetection; }))  					{  						detectSpells.Add(spell);  					}  				}    				writer.WriteLine("Invis spells:");  				foreach (Spell spell in invisSpells)  				{  					string type = null;  					spell.HasEffectWith((effect) =>{  					                    	if (effect.AuraType == AuraType.ModInvisibility)  					                    	{  					                    		if (type != null)  					                    		{  					                    			if (type.Contains(effect.MiscValue.ToString()))  					                    			{  					                    				type += "' " + effect.MiscValue;  					                    			}  					                    		}  					                    		else  					                    		{  					                    			type = effect.MiscValue.ToString();  					                    		}  					                    		return true;  					                    	}  					                    	return false;  					                    });  					writer.WriteLine("\t{0} (Id: {1}) - Type: {2}"' spell.Name' spell.Id' type);  				}    				writer.WriteLine();  				writer.WriteLine();    				writer.WriteLine("Detect spells:");  				foreach (Spell spell in detectSpells)  				{  					string type = null;  					spell.HasEffectWith((effect) =>{  					                    	if (effect.AuraType == AuraType.ModInvisibilityDetection)  					                    	{  					                    		if (type != null)  					                    		{  					                    			if (type.Contains(effect.MiscValue.ToString()))  					                    			{  					                    				type += "' " + effect.MiscValue;  					                    			}  					                    		}  					                    		else  					                    		{  					                    			type = effect.MiscValue.ToString();  					                    		}  					                    		return true;  					                    	}  					                    	return false;  					                    });  					writer.WriteLine("\t{0} (Id: {1}) - Type: {2}"' spell.Name' spell.Id' type);  				}    				writer.WriteLine();    				foreach (Spell spell in invisSpells)  				{  					DumpSpell(writer' spell);  				}  				foreach (Spell spell in detectSpells)  				{  					DumpSpell(writer' spell);  				}  			}
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteInvisSpells,The following statement contains a magic number: using (StreamWriter writer = new StreamWriter(ToolConfig.OutputDir + "InvisSpells.txt"' false))  			{  				var invisSpells = new List<Spell>(100);  				var detectSpells = new List<Spell>(100);  				foreach (var spell in SpellHandler.ById)  				{  					if (spell == null)  						continue;    					if (spell.HasEffectWith((effect) => { return effect.AuraType == AuraType.ModInvisibility; }))  					{  						invisSpells.Add(spell);  					}  					else if (spell.HasEffectWith((effect) => { return effect.AuraType == AuraType.ModInvisibilityDetection; }))  					{  						detectSpells.Add(spell);  					}  				}    				writer.WriteLine("Invis spells:");  				foreach (Spell spell in invisSpells)  				{  					string type = null;  					spell.HasEffectWith((effect) =>{  					                    	if (effect.AuraType == AuraType.ModInvisibility)  					                    	{  					                    		if (type != null)  					                    		{  					                    			if (type.Contains(effect.MiscValue.ToString()))  					                    			{  					                    				type += "' " + effect.MiscValue;  					                    			}  					                    		}  					                    		else  					                    		{  					                    			type = effect.MiscValue.ToString();  					                    		}  					                    		return true;  					                    	}  					                    	return false;  					                    });  					writer.WriteLine("\t{0} (Id: {1}) - Type: {2}"' spell.Name' spell.Id' type);  				}    				writer.WriteLine();  				writer.WriteLine();    				writer.WriteLine("Detect spells:");  				foreach (Spell spell in detectSpells)  				{  					string type = null;  					spell.HasEffectWith((effect) =>{  					                    	if (effect.AuraType == AuraType.ModInvisibilityDetection)  					                    	{  					                    		if (type != null)  					                    		{  					                    			if (type.Contains(effect.MiscValue.ToString()))  					                    			{  					                    				type += "' " + effect.MiscValue;  					                    			}  					                    		}  					                    		else  					                    		{  					                    			type = effect.MiscValue.ToString();  					                    		}  					                    		return true;  					                    	}  					                    	return false;  					                    });  					writer.WriteLine("\t{0} (Id: {1}) - Type: {2}"' spell.Name' spell.Id' type);  				}    				writer.WriteLine();    				foreach (Spell spell in invisSpells)  				{  					DumpSpell(writer' spell);  				}  				foreach (Spell spell in detectSpells)  				{  					DumpSpell(writer' spell);  				}  			}
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteSpellFocusSpells,The following statement contains a magic number: using (StreamWriter writer = new StreamWriter(ToolConfig.OutputDir + "SpellFocus.txt"' false))  			{  				Dictionary<SpellFocus' Dictionary<string' Spell>> spells =  					new Dictionary<SpellFocus' Dictionary<string' Spell>>(5000);  				foreach (var spell in SpellHandler.ById)  				{  					if (spell == null)  						continue;    					if (spell.RequiredSpellFocus != SpellFocus.None)  					{  						Dictionary<string' Spell> focusSpells;  						if (!spells.TryGetValue(spell.RequiredSpellFocus' out focusSpells))  						{  							focusSpells = new Dictionary<string' Spell>();  							spells.Add(spell.RequiredSpellFocus' focusSpells);  						}  						focusSpells[spell.Name] = spell;  					}  				}    				foreach (var dict in spells)  				{  					writer.WriteLine(dict.Key);  					foreach (var spell in dict.Value.Values)  					{  						writer.WriteLine("\t{0} (Id: {1})"' spell.Name' spell.Id);  					}  					writer.WriteLine();  					writer.WriteLine("##############################");  					writer.WriteLine();  				}  			}
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteSpells,The following statement contains a magic number: using (var writer = new StreamWriter(ToolConfig.OutputDir + name + ".txt"' false))  			{  				var spells = new Dictionary<string' Spell>(5000);  				foreach (var spell in SpellHandler.ById)  				{  					if (spell == null)  						continue;    					if (filter(spell' spells))  					{  						spells[spell.Name] = spell;  					}  				}      				writer.WriteLine("Found {0} \"{1}\" - spells:"' spells.Count' name);  				writer.WriteLine();      				foreach (var spell in spells.Values)  				{  					writer.WriteLine("{0} (Id: {1})"' spell.Name' spell.Id);    					if (extraOuput != null)  					{  						extraOuput(writer' spell);  					}  				}    				writer.WriteLine();  				writer.WriteLine("##########################################");  				writer.WriteLine();    				foreach (var spell in spells.Values)  				{  					DumpSpell(writer' spell);  				}  			}
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteAllFields,The following statement contains a magic number: var testSpell = SpellHandler.ById[100];
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteMissingItemIds,The following statement contains a magic number: var items = new Dictionary<uint' Spell>(500);
Magic Number,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteSpellFamilies,The following statement contains a magic number: var spells = new Dictionary<SpellClassSet' Dictionary<Spell' List<Spell>>>(100);
Magic Number,WCell.Tools.Mokrago,CombatRatingsOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Mokrago\CombatRatingsOutput.cs,WriteTableByClassLevel,The following statement contains a magic number: for (int i = 1; i < 12; i++)              {                  writer.WriteLine("{0} - {1}:"' tableName' Enum.GetName(typeof(ClassId)' i));                    for (int k = 1; k < 101; k++)                  {                      writer.WriteLine("Level {0}: {1}"' (k)' table[100*i+k-101]);                  }                  writer.WriteLine();              }
Magic Number,WCell.Tools.Mokrago,CombatRatingsOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Mokrago\CombatRatingsOutput.cs,WriteTableByClassLevel,The following statement contains a magic number: for (int i = 1; i < 12; i++)              {                  writer.WriteLine("{0} - {1}:"' tableName' Enum.GetName(typeof(ClassId)' i));                    for (int k = 1; k < 101; k++)                  {                      writer.WriteLine("Level {0}: {1}"' (k)' table[100*i+k-101]);                  }                  writer.WriteLine();              }
Magic Number,WCell.Tools.Mokrago,CombatRatingsOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Mokrago\CombatRatingsOutput.cs,WriteTableByClassLevel,The following statement contains a magic number: for (int i = 1; i < 12; i++)              {                  writer.WriteLine("{0} - {1}:"' tableName' Enum.GetName(typeof(ClassId)' i));                    for (int k = 1; k < 101; k++)                  {                      writer.WriteLine("Level {0}: {1}"' (k)' table[100*i+k-101]);                  }                  writer.WriteLine();              }
Magic Number,WCell.Tools.Mokrago,CombatRatingsOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Mokrago\CombatRatingsOutput.cs,WriteTableByClassLevel,The following statement contains a magic number: for (int i = 1; i < 12; i++)              {                  writer.WriteLine("{0} - {1}:"' tableName' Enum.GetName(typeof(ClassId)' i));                    for (int k = 1; k < 101; k++)                  {                      writer.WriteLine("Level {0}: {1}"' (k)' table[100*i+k-101]);                  }                  writer.WriteLine();              }
Magic Number,WCell.Tools.Mokrago,CombatRatingsOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Mokrago\CombatRatingsOutput.cs,WriteTableByClassLevel,The following statement contains a magic number: for (int i = 1; i < 12; i++)              {                  writer.WriteLine("{0} - {1}:"' tableName' Enum.GetName(typeof(ClassId)' i));                    for (int k = 1; k < 101; k++)                  {                      writer.WriteLine("Level {0}: {1}"' (k)' funct(k' (ClassId)i));                  }                  writer.WriteLine();              }
Magic Number,WCell.Tools.Mokrago,CombatRatingsOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Mokrago\CombatRatingsOutput.cs,WriteTableByClassLevel,The following statement contains a magic number: for (int i = 1; i < 12; i++)              {                  writer.WriteLine("{0} - {1}:"' tableName' Enum.GetName(typeof(ClassId)' i));                    for (int k = 1; k < 101; k++)                  {                      writer.WriteLine("Level {0}: {1}"' (k)' funct(k' (ClassId)i));                  }                  writer.WriteLine();              }
Magic Number,WCell.Tools.Spells,SpellFocusObjectReader,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellFocusObject.DBC.cs,Read,The following statement contains a magic number: var dict = new Dictionary<uint' string>(300);
Magic Number,WCell.Tools.Spells,SpellLineWriter,C:\repos\WCell_WCell\Utilities\WCell.Tools\Spells\SpellLineWriter.cs,AddSpell,The following statement contains a magic number: if (map == null)  			{  				Maps[(int)clss] = map = new Dictionary<string' HashSet<Spell>>(100);  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,SpellHasMask,The following statement contains a magic number: foreach (var effect in spell.Effects)  			{  				if (effect.AffectMask[0] > 0 || effect.AffectMask[1] > 0 || effect.AffectMask[2] > 0)  					return true;  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellsWithEffectMasks,The following statement contains a magic number: foreach (var spell in query)  			{  				Console.WriteLine("{0}: {1} \t {2}{3}{4}"' spell.Id' spell.Name' spell.SpellClassMask[0].ToString("X8")'  				                  spell.SpellClassMask[1].ToString("X8")' spell.SpellClassMask[2].ToString("X8"));  				foreach (var effect in spell.Effects)  				{  					Console.WriteLine("{0} - {1}{2}{3}"' effect.EffectType' effect.AffectMask[0].ToString("X8")'  					                  effect.AffectMask[1].ToString("X8")' effect.AffectMask[2].ToString("X8"));  				}  				i++;  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellsWithEffectMasks,The following statement contains a magic number: foreach (var spell in query)  			{  				Console.WriteLine("{0}: {1} \t {2}{3}{4}"' spell.Id' spell.Name' spell.SpellClassMask[0].ToString("X8")'  				                  spell.SpellClassMask[1].ToString("X8")' spell.SpellClassMask[2].ToString("X8"));  				foreach (var effect in spell.Effects)  				{  					Console.WriteLine("{0} - {1}{2}{3}"' effect.EffectType' effect.AffectMask[0].ToString("X8")'  					                  effect.AffectMask[1].ToString("X8")' effect.AffectMask[2].ToString("X8"));  				}  				i++;  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellsWithFamilyMask,The following statement contains a magic number: var query = from spell in SpellHandler.ById  			            where spell != null  			            where spell.SpellClassMask[0] == u1 && spell.SpellClassMask[1] == u2 && spell.SpellClassMask[2] == u3  			            select spell;
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellsWithFamilyMask,The following statement contains a magic number: foreach (var spell in query)  			{  				Console.WriteLine("{0}: {1} \t {2}{3}{4}"' spell.Id' spell.Name' spell.SpellClassMask[0].ToString("X8")'  				                  spell.SpellClassMask[1].ToString("X8")' spell.SpellClassMask[2].ToString("X8"));  				foreach (var effect in spell.Effects)  				{  					Console.WriteLine("{0} - {1}{2}{3}"' effect.EffectType' effect.AffectMask[0].ToString("X8")'  					                  effect.AffectMask[1].ToString("X8")' effect.AffectMask[2].ToString("X8"));  				}  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellsWithFamilyMask,The following statement contains a magic number: foreach (var spell in query)  			{  				Console.WriteLine("{0}: {1} \t {2}{3}{4}"' spell.Id' spell.Name' spell.SpellClassMask[0].ToString("X8")'  				                  spell.SpellClassMask[1].ToString("X8")' spell.SpellClassMask[2].ToString("X8"));  				foreach (var effect in spell.Effects)  				{  					Console.WriteLine("{0} - {1}{2}{3}"' effect.EffectType' effect.AffectMask[0].ToString("X8")'  					                  effect.AffectMask[1].ToString("X8")' effect.AffectMask[2].ToString("X8"));  				}  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindFubecasFrickinSpells,The following statement contains a magic number: var spell = SpellHandler.ById[53270];
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindFubecasFrickinSpells,The following statement contains a magic number: FindSpellWithSpellClassMaskAndSpellClassSet(spellMask0[0]' spellMask0[1]' spellMask0[2]' spellSet);
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindFubecasFrickinSpells,The following statement contains a magic number: FindSpellWithSpellClassMaskAndSpellClassSet(spellMask1[0]' spellMask1[1]' spellMask1[2]' spellSet);
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellWithSpellClassMaskAndSpellClassSet,The following statement contains a magic number: var query = from spell in SpellHandler.ById  			            where spell != null  			            where ((spell.SpellClassMask[0] & u1) != 0) || ((spell.SpellClassMask[1] & u2) != 0) || ((spell.SpellClassMask[2] & u3) != 0)                          where spell.SpellClassSet == set  			            select spell;
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellWithSpellClassMaskAndSpellClassSet,The following statement contains a magic number: foreach (var spell in query)  			{  				Console.WriteLine("{0}: {1} \t {2}{3}{4}"' spell.Id' spell.Name' spell.SpellClassMask[0].ToString("X8")'  				                  spell.SpellClassMask[1].ToString("X8")' spell.SpellClassMask[2].ToString("X8"));  				foreach (var effect in spell.Effects)  				{  					Console.WriteLine("\t{0} - {1}{2}{3}"' effect.EffectType' effect.AffectMask[0].ToString("X8")'  					                  effect.AffectMask[1].ToString("X8")' effect.AffectMask[2].ToString("X8"));  				}                  Console.WriteLine("");  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,FindSpellWithSpellClassMaskAndSpellClassSet,The following statement contains a magic number: foreach (var spell in query)  			{  				Console.WriteLine("{0}: {1} \t {2}{3}{4}"' spell.Id' spell.Name' spell.SpellClassMask[0].ToString("X8")'  				                  spell.SpellClassMask[1].ToString("X8")' spell.SpellClassMask[2].ToString("X8"));  				foreach (var effect in spell.Effects)  				{  					Console.WriteLine("\t{0} - {1}{2}{3}"' effect.EffectType' effect.AffectMask[0].ToString("X8")'  					                  effect.AffectMask[1].ToString("X8")' effect.AffectMask[2].ToString("X8"));  				}                  Console.WriteLine("");  			}
Magic Number,WCell.Tools.Ralek,SpellStudies,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\SpellStudies.cs,DisplayInfo,The following statement contains a magic number: if (spell != null)  			{  				Console.WriteLine("{0}: {1}"' spell.Id' spell.Name);    				Console.WriteLine("A: {0}"' spell.Attributes);  				Console.WriteLine("AEx: {0}"' spell.AttributesEx);  				Console.WriteLine("AExB: {0}"' spell.AttributesExB);  				Console.WriteLine("AExC: {0}"' spell.AttributesExC);  				Console.WriteLine("AExD: {0}"' spell.AttributesExD);  				Console.WriteLine("AExE: {0}"' spell.AttributesExE);  				Console.WriteLine("AExF: {0}"' spell.AttributesExF);  				Console.WriteLine("FacingFlags: {0}"' spell.FacingFlags);    				Console.WriteLine("TargetType: {0}"' spell.TargetFlags);  				Console.WriteLine("SpellClassMask: {0:X8}{1:X8}{2:X8}"' spell.SpellClassMask[0]' spell.SpellClassMask[1]'  				                  spell.SpellClassMask[2]);  				Console.WriteLine("Effects");  				foreach (var effect in spell.Effects)  				{  					effect.DumpInfo(Console.Out' "");  				}  				Console.WriteLine("Effects End");      				Console.WriteLine("PreventionType: {0}"' spell.PreventionType);    				Console.WriteLine("DamageType: {0}"' spell.DamageType);      				Console.WriteLine();  			}
Magic Number,WCell.Tools.Ralek,Extensions,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Extensions.cs,Reverse,The following statement contains a magic number: for (int i = 0; i < length/2; i++)  			{  				T temp = array[i];  				array[i] = array[length - i - 1];  				array[length - i - 1] = temp;  			}
Magic Number,WCell.Tools.Ralek,Extensions,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Extensions.cs,ReadPackedGUID,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				if ((guidMask & (1 << i)) != 0)  				{  					fullGUID |= ((ulong) binReader.ReadByte() << (i*8));  				}  			}
Magic Number,WCell.Tools.Ralek,Extensions,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Extensions.cs,ReadPackedGUID,The following statement contains a magic number: for (int i = 0; i < 8; i++)  			{  				if ((guidMask & (1 << i)) != 0)  				{  					fullGUID |= ((ulong) binReader.ReadByte() << (i*8));  				}  			}
Magic Number,WCell.Tools,VariablePurifier,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\VariablePurifier.cs,Purify,The following statement contains a magic number: while (match.Success)  			{  				string var = match.Groups[1].Value;  				// variable parts seperated by "_"  				CaptureCollection captures = match.Groups[2].Captures;    				result.Append(text.Substring(pos' match.Index - pos));  				//result.AppendLine();    				// check  				if (!ignoreSet.Contains(var) && (VarFilter == null || VarFilter(var)))  				{  					// purify  					result.Append(var[0] + captures[0].Value.ToLower());  					for (int i = 1; i < captures.Count; i++)  					{  						string part = captures[i].Value;  						result.Append(part[0] + part.Substring(1).ToLower());  					}  					count++;  				}  				else  				{  					result.Append(var);  				}    				// next match  				pos = match.Index + var.Length;  				match = match.NextMatch();  			}
Magic Number,WCell.Tools.Ralek.Utility,Stats,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,ComputeStats,The following statement contains a magic number: if (Count > 0)              {                  data.Sort();                  if (Count%2 == 1)                      median = this[Count/2];                  else                      median = (this[(Count/2) - 1] + this[Count/2])/2;                  mean = (float) (total/Count);                    double squares = 0.0;                  foreach (float dataPoint in this)                  {                      double diffFromMean = dataPoint - mean;                      squares += diffFromMean*diffFromMean;                  }                  standardDeviation = (float) Math.Sqrt(squares/Count);              }
Magic Number,WCell.Tools.Ralek.Utility,Stats,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,ComputeStats,The following statement contains a magic number: if (Count > 0)              {                  data.Sort();                  if (Count%2 == 1)                      median = this[Count/2];                  else                      median = (this[(Count/2) - 1] + this[Count/2])/2;                  mean = (float) (total/Count);                    double squares = 0.0;                  foreach (float dataPoint in this)                  {                      double diffFromMean = dataPoint - mean;                      squares += diffFromMean*diffFromMean;                  }                  standardDeviation = (float) Math.Sqrt(squares/Count);              }
Magic Number,WCell.Tools.Ralek.Utility,Stats,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,ComputeStats,The following statement contains a magic number: if (Count > 0)              {                  data.Sort();                  if (Count%2 == 1)                      median = this[Count/2];                  else                      median = (this[(Count/2) - 1] + this[Count/2])/2;                  mean = (float) (total/Count);                    double squares = 0.0;                  foreach (float dataPoint in this)                  {                      double diffFromMean = dataPoint - mean;                      squares += diffFromMean*diffFromMean;                  }                  standardDeviation = (float) Math.Sqrt(squares/Count);              }
Magic Number,WCell.Tools.Ralek.Utility,Stats,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,ComputeStats,The following statement contains a magic number: if (Count > 0)              {                  data.Sort();                  if (Count%2 == 1)                      median = this[Count/2];                  else                      median = (this[(Count/2) - 1] + this[Count/2])/2;                  mean = (float) (total/Count);                    double squares = 0.0;                  foreach (float dataPoint in this)                  {                      double diffFromMean = dataPoint - mean;                      squares += diffFromMean*diffFromMean;                  }                  standardDeviation = (float) Math.Sqrt(squares/Count);              }
Magic Number,WCell.Tools.Ralek.Utility,Stats,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,ComputeStats,The following statement contains a magic number: if (Count > 0)              {                  data.Sort();                  if (Count%2 == 1)                      median = this[Count/2];                  else                      median = (this[(Count/2) - 1] + this[Count/2])/2;                  mean = (float) (total/Count);                    double squares = 0.0;                  foreach (float dataPoint in this)                  {                      double diffFromMean = dataPoint - mean;                      squares += diffFromMean*diffFromMean;                  }                  standardDeviation = (float) Math.Sqrt(squares/Count);              }
Magic Number,WCell.Tools.Ralek.Utility,CodeTimer,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,GetOverhead,The following statement contains a magic number: if (!overheadValid)              {                  if (computingOverhead)                      return 0.0F;                  computingOverhead = true;                    // Compute the average over 5 runs;                   overhead = 0.0F;                  for (int i = 0; i < 5; i++)                      overhead += Measure(null' delegate { });                  overhead = overhead/5;                      computingOverhead = false;                  overheadValid = true;              }
Magic Number,WCell.Tools.Ralek.Utility,CodeTimer,C:\repos\WCell_WCell\Utilities\WCell.Tools\Ralek\Utility\CodeTimers.cs,GetOverhead,The following statement contains a magic number: if (!overheadValid)              {                  if (computingOverhead)                      return 0.0F;                  computingOverhead = true;                    // Compute the average over 5 runs;                   overhead = 0.0F;                  for (int i = 0; i < 5; i++)                      overhead += Measure(null' delegate { });                  overhead = overhead/5;                      computingOverhead = false;                  overheadValid = true;              }
Duplicate Code,WCell.Tools.Domi.Output,SpellOutput,C:\repos\WCell_WCell\Utilities\WCell.Tools\Domi\Output\SpellOutput.cs,WriteInvisSpells,The method contains a code clone-set at the following line numbers (starting from the method definition): ((27' 46)' (55' 74))
