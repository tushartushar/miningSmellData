Implementation smell,Namespace,Class,File,Method,Description
Long Method,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The method has 169 lines of code.
Long Method,WCell.MPQTool,DBCTool,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBCTool.cs,Dump,The method has 129 lines of code.
Complex Method,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,Cyclomatic complexity of the method is 25
Complex Method,WCell.MPQTool.DBC.Compare,DBCDirComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCDirComparer.cs,Compare,Cyclomatic complexity of the method is 8
Complex Method,WCell.MPQTool,DBCTool,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBCTool.cs,Dump,Cyclomatic complexity of the method is 9
Complex Method,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,AdjustTree,Cyclomatic complexity of the method is 10
Complex Method,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,LoadBlock,Cyclomatic complexity of the method is 9
Complex Method,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,DecompressMulti,Cyclomatic complexity of the method is 11
Long Parameter List,WCell.MPQTool.StormLibWrapper,NativeMethods,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\StormLibWrapper\NativeMethods.cs,ReadFile,The method has 5 parameters. Parameters: fileHandle' buffer' numberOfBytes' numberOfBytesRead' overlapped
Long Parameter List,WCell.MPQTool.StormLibWrapper,NativeMethods,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\StormLibWrapper\NativeMethods.cs,Compress,The method has 7 parameters. Parameters: outBuffer' outLength' inBuffer' inLength' cmp' cmpType' cmpLevel
Long Statement,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The length of the statement  "				change = string.Format("Column Count {0} from {1} to {2}"' oldReader.ColumnCount > newReader.ColumnCount ? "decreased" : "increased"' " is 133.
Long Statement,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The length of the statement  "				change += string.Format("Record Size {0} from {1} to {2}"' oldReader.RecordSize > newReader.RecordSize ? "decreased" : "increased"' " is 131.
Long Statement,WCell.MPQTool.DBC.Compare,DBCDirComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCDirComparer.cs,Compare,The length of the statement  "			writer.WriteLine("Changes in files{0}:"' maxTestAmount != int.MaxValue ? " - Testing with first " + maxTestAmount + " rows" : ""); " is 130.
Long Statement,WCell.MPQTool,DBCTool,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBCTool.cs,Dump,The length of the statement  "					Console.WriteLine("Output Directory: {0} ({1})"' outputDir.FullName' outputDir.Exists ? "already exists" : "does not exist"); " is 125.
Long Statement,WCell.MPQTool.StormLibWrapper,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\StormLibWrapper\MpqStream.cs,ReadCoTaskMem,The length of the statement  "            ErrorHandler.ThrowOnFailure(NativeMethods.ReadFile(fileHandle' buffer' (uint)count' out bytesRead' (IntPtr)null)' "Could not read file content."); " is 146.
Magic Number,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The following statement contains a magic number: if (newReader.RecordSize != (newReader.ColumnCount * 4))  			{  				change += " (Row Length IRREGULAR: " + newReader.RecordSize + ")";  			}
Magic Number,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The following statement contains a magic number: if (structureChange)  			{  				var name = new FileInfo(oldReader.FileName).Name.Replace(".dbc"' "");  				writer.WriteLine("{0}' {1} Records ({2})"' name' newReader.RecordCount' change);    				testAmount = Math.Min(testAmount' oldReader.RecordCount);  				testAmount = Math.Min(testAmount' newReader.RecordCount);    				// arrays' indexed by id (assume first column to be id column)  				var oldRows = new byte[oldReader.RecordCount * 3][];  				var newRows = new byte[newReader.RecordCount * 3][];  				uint highestNewId = 0' highestOldId = 0;  				for (uint i = 0; i < testAmount; i++)  				{  					var oldRow = oldReader.GetRow(i);  					var newRow = newReader.GetRow(i);    					var oldId = oldRow.GetUInt32(0);  					var newId = oldRow.GetUInt32(0);    					ArrayUtil.Set(ref oldRows' oldId' oldRow);  					ArrayUtil.Set(ref newRows' newId' newRow);    					highestNewId = Math.Max(highestNewId' newId);  					highestOldId = Math.Max(highestNewId' oldId);  				}      				//var cols = Math.Max(oldReader.ColumnCount' newReader.ColumnCount);  				var minColCount = Math.Min(oldReader.ColumnCount' newReader.ColumnCount);  				int[] changes = new int[minColCount];    				uint highestId = Math.Max(highestNewId' highestOldId);  				int addedCount = 0' deprecatedCount = 0;  				for (uint i = 1; i <= highestId; i++)  				{  					var oldRow = oldRows.Get(i);  					var newRow = newRows.Get(i);    					if ((oldRow != null) != (newRow != null))  					{  						if (newRow == null)  						{  							// row doesn't exit anymore  							deprecatedCount++;  						}  						else  						{  							// row got added  							addedCount++;  						}  					}  					else if (oldRow != null && newRow != null)  					{  						for (uint j = 1; j < changes.Length; j++)  						{  							if (oldRow.GetUInt32(j) != newRow.GetUInt32(j))  							{  								changes[j]++;  							}  						}  					}  				}    				if (addedCount > 0)  				{  					writer.WriteLine("- {0} new records"' addedCount);  				}  				if (deprecatedCount > 0)  				{  					writer.WriteLine("- {0} deprecated records"' deprecatedCount);  				}    				List<uint> changedCols = new List<uint>();  				for (uint col = 0; col < changes.Length; col++)  				{  					var percent = changes[col] / (float)testAmount * 100;  					if (percent >= MinColumnChangePct)  					{  						writer.Write("\t\tField {0}: {1} changes ({2}%"' col + 1' changes[col]' percent);  						var strChance = oldReader.GetStringMatchPct(col' MinStringUniquePct);  						bool mightBeStringCol;  						if (strChance >= MinStringMatchPct)  						{  							mightBeStringCol = true;  							writer.Write(" - String column probability: " + strChance + "%");  						}  						else  						{  							mightBeStringCol = false;  						}  						writer.Write(")");  						changedCols.Add(col);  						//continue;    						var matches = 0;    						if (!mightBeStringCol)  						{  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++)  							{  								var matchCount = 0;  								var zeros = 0;  								for (uint r = 1; r <= highestId; r++)  								{  									var oldRow = oldRows.Get(r);  									var newRow = newRows.Get(r);    									if (oldRow != null && newRow != null)  									{  										var oldVal = oldRow.GetUInt32(col);  										var newVal = newRow.GetUInt32(newCol);  										if (oldVal == 0)  										{  											zeros++;  										}  										if (oldVal == newVal)  										{  											matchCount++;  										}  									}  								}    								if (newCol == 1)  								{  									writer.Write(" and {0} Zeros - Might have moved to:"' zeros);  								}  								var matchPercent = matchCount / (float)testAmount * 100;  								if (matchPercent >= MinColumnMatchPct)  								{  									// possible column match  									writer.Write(newCol + " (" + matchPercent + "%)' ");  									matches++;  								}  							}  						}  						else  						{  							writer.Write(" - Might have moved to: ");  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++) {  								var newStrChance = newReader.GetStringMatchPct(newCol' MinStringUniquePct);  								if (newStrChance >= MinStringMatchPct)  								{  									writer.Write(newCol + " (" + newStrChance + "%)' ");  									matches++;  								}  							}  						}    						if (matches == 0)  						{  							writer.Write("-none-");  						}  						writer.WriteLine();  					}  				}    				foreach (var col in changedCols)  				{  				}  			}
Magic Number,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The following statement contains a magic number: if (structureChange)  			{  				var name = new FileInfo(oldReader.FileName).Name.Replace(".dbc"' "");  				writer.WriteLine("{0}' {1} Records ({2})"' name' newReader.RecordCount' change);    				testAmount = Math.Min(testAmount' oldReader.RecordCount);  				testAmount = Math.Min(testAmount' newReader.RecordCount);    				// arrays' indexed by id (assume first column to be id column)  				var oldRows = new byte[oldReader.RecordCount * 3][];  				var newRows = new byte[newReader.RecordCount * 3][];  				uint highestNewId = 0' highestOldId = 0;  				for (uint i = 0; i < testAmount; i++)  				{  					var oldRow = oldReader.GetRow(i);  					var newRow = newReader.GetRow(i);    					var oldId = oldRow.GetUInt32(0);  					var newId = oldRow.GetUInt32(0);    					ArrayUtil.Set(ref oldRows' oldId' oldRow);  					ArrayUtil.Set(ref newRows' newId' newRow);    					highestNewId = Math.Max(highestNewId' newId);  					highestOldId = Math.Max(highestNewId' oldId);  				}      				//var cols = Math.Max(oldReader.ColumnCount' newReader.ColumnCount);  				var minColCount = Math.Min(oldReader.ColumnCount' newReader.ColumnCount);  				int[] changes = new int[minColCount];    				uint highestId = Math.Max(highestNewId' highestOldId);  				int addedCount = 0' deprecatedCount = 0;  				for (uint i = 1; i <= highestId; i++)  				{  					var oldRow = oldRows.Get(i);  					var newRow = newRows.Get(i);    					if ((oldRow != null) != (newRow != null))  					{  						if (newRow == null)  						{  							// row doesn't exit anymore  							deprecatedCount++;  						}  						else  						{  							// row got added  							addedCount++;  						}  					}  					else if (oldRow != null && newRow != null)  					{  						for (uint j = 1; j < changes.Length; j++)  						{  							if (oldRow.GetUInt32(j) != newRow.GetUInt32(j))  							{  								changes[j]++;  							}  						}  					}  				}    				if (addedCount > 0)  				{  					writer.WriteLine("- {0} new records"' addedCount);  				}  				if (deprecatedCount > 0)  				{  					writer.WriteLine("- {0} deprecated records"' deprecatedCount);  				}    				List<uint> changedCols = new List<uint>();  				for (uint col = 0; col < changes.Length; col++)  				{  					var percent = changes[col] / (float)testAmount * 100;  					if (percent >= MinColumnChangePct)  					{  						writer.Write("\t\tField {0}: {1} changes ({2}%"' col + 1' changes[col]' percent);  						var strChance = oldReader.GetStringMatchPct(col' MinStringUniquePct);  						bool mightBeStringCol;  						if (strChance >= MinStringMatchPct)  						{  							mightBeStringCol = true;  							writer.Write(" - String column probability: " + strChance + "%");  						}  						else  						{  							mightBeStringCol = false;  						}  						writer.Write(")");  						changedCols.Add(col);  						//continue;    						var matches = 0;    						if (!mightBeStringCol)  						{  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++)  							{  								var matchCount = 0;  								var zeros = 0;  								for (uint r = 1; r <= highestId; r++)  								{  									var oldRow = oldRows.Get(r);  									var newRow = newRows.Get(r);    									if (oldRow != null && newRow != null)  									{  										var oldVal = oldRow.GetUInt32(col);  										var newVal = newRow.GetUInt32(newCol);  										if (oldVal == 0)  										{  											zeros++;  										}  										if (oldVal == newVal)  										{  											matchCount++;  										}  									}  								}    								if (newCol == 1)  								{  									writer.Write(" and {0} Zeros - Might have moved to:"' zeros);  								}  								var matchPercent = matchCount / (float)testAmount * 100;  								if (matchPercent >= MinColumnMatchPct)  								{  									// possible column match  									writer.Write(newCol + " (" + matchPercent + "%)' ");  									matches++;  								}  							}  						}  						else  						{  							writer.Write(" - Might have moved to: ");  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++) {  								var newStrChance = newReader.GetStringMatchPct(newCol' MinStringUniquePct);  								if (newStrChance >= MinStringMatchPct)  								{  									writer.Write(newCol + " (" + newStrChance + "%)' ");  									matches++;  								}  							}  						}    						if (matches == 0)  						{  							writer.Write("-none-");  						}  						writer.WriteLine();  					}  				}    				foreach (var col in changedCols)  				{  				}  			}
Magic Number,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The following statement contains a magic number: if (structureChange)  			{  				var name = new FileInfo(oldReader.FileName).Name.Replace(".dbc"' "");  				writer.WriteLine("{0}' {1} Records ({2})"' name' newReader.RecordCount' change);    				testAmount = Math.Min(testAmount' oldReader.RecordCount);  				testAmount = Math.Min(testAmount' newReader.RecordCount);    				// arrays' indexed by id (assume first column to be id column)  				var oldRows = new byte[oldReader.RecordCount * 3][];  				var newRows = new byte[newReader.RecordCount * 3][];  				uint highestNewId = 0' highestOldId = 0;  				for (uint i = 0; i < testAmount; i++)  				{  					var oldRow = oldReader.GetRow(i);  					var newRow = newReader.GetRow(i);    					var oldId = oldRow.GetUInt32(0);  					var newId = oldRow.GetUInt32(0);    					ArrayUtil.Set(ref oldRows' oldId' oldRow);  					ArrayUtil.Set(ref newRows' newId' newRow);    					highestNewId = Math.Max(highestNewId' newId);  					highestOldId = Math.Max(highestNewId' oldId);  				}      				//var cols = Math.Max(oldReader.ColumnCount' newReader.ColumnCount);  				var minColCount = Math.Min(oldReader.ColumnCount' newReader.ColumnCount);  				int[] changes = new int[minColCount];    				uint highestId = Math.Max(highestNewId' highestOldId);  				int addedCount = 0' deprecatedCount = 0;  				for (uint i = 1; i <= highestId; i++)  				{  					var oldRow = oldRows.Get(i);  					var newRow = newRows.Get(i);    					if ((oldRow != null) != (newRow != null))  					{  						if (newRow == null)  						{  							// row doesn't exit anymore  							deprecatedCount++;  						}  						else  						{  							// row got added  							addedCount++;  						}  					}  					else if (oldRow != null && newRow != null)  					{  						for (uint j = 1; j < changes.Length; j++)  						{  							if (oldRow.GetUInt32(j) != newRow.GetUInt32(j))  							{  								changes[j]++;  							}  						}  					}  				}    				if (addedCount > 0)  				{  					writer.WriteLine("- {0} new records"' addedCount);  				}  				if (deprecatedCount > 0)  				{  					writer.WriteLine("- {0} deprecated records"' deprecatedCount);  				}    				List<uint> changedCols = new List<uint>();  				for (uint col = 0; col < changes.Length; col++)  				{  					var percent = changes[col] / (float)testAmount * 100;  					if (percent >= MinColumnChangePct)  					{  						writer.Write("\t\tField {0}: {1} changes ({2}%"' col + 1' changes[col]' percent);  						var strChance = oldReader.GetStringMatchPct(col' MinStringUniquePct);  						bool mightBeStringCol;  						if (strChance >= MinStringMatchPct)  						{  							mightBeStringCol = true;  							writer.Write(" - String column probability: " + strChance + "%");  						}  						else  						{  							mightBeStringCol = false;  						}  						writer.Write(")");  						changedCols.Add(col);  						//continue;    						var matches = 0;    						if (!mightBeStringCol)  						{  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++)  							{  								var matchCount = 0;  								var zeros = 0;  								for (uint r = 1; r <= highestId; r++)  								{  									var oldRow = oldRows.Get(r);  									var newRow = newRows.Get(r);    									if (oldRow != null && newRow != null)  									{  										var oldVal = oldRow.GetUInt32(col);  										var newVal = newRow.GetUInt32(newCol);  										if (oldVal == 0)  										{  											zeros++;  										}  										if (oldVal == newVal)  										{  											matchCount++;  										}  									}  								}    								if (newCol == 1)  								{  									writer.Write(" and {0} Zeros - Might have moved to:"' zeros);  								}  								var matchPercent = matchCount / (float)testAmount * 100;  								if (matchPercent >= MinColumnMatchPct)  								{  									// possible column match  									writer.Write(newCol + " (" + matchPercent + "%)' ");  									matches++;  								}  							}  						}  						else  						{  							writer.Write(" - Might have moved to: ");  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++) {  								var newStrChance = newReader.GetStringMatchPct(newCol' MinStringUniquePct);  								if (newStrChance >= MinStringMatchPct)  								{  									writer.Write(newCol + " (" + newStrChance + "%)' ");  									matches++;  								}  							}  						}    						if (matches == 0)  						{  							writer.Write("-none-");  						}  						writer.WriteLine();  					}  				}    				foreach (var col in changedCols)  				{  				}  			}
Magic Number,WCell.MPQTool.DBC.Compare,DBCFileComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCFileComparer.cs,Compare,The following statement contains a magic number: if (structureChange)  			{  				var name = new FileInfo(oldReader.FileName).Name.Replace(".dbc"' "");  				writer.WriteLine("{0}' {1} Records ({2})"' name' newReader.RecordCount' change);    				testAmount = Math.Min(testAmount' oldReader.RecordCount);  				testAmount = Math.Min(testAmount' newReader.RecordCount);    				// arrays' indexed by id (assume first column to be id column)  				var oldRows = new byte[oldReader.RecordCount * 3][];  				var newRows = new byte[newReader.RecordCount * 3][];  				uint highestNewId = 0' highestOldId = 0;  				for (uint i = 0; i < testAmount; i++)  				{  					var oldRow = oldReader.GetRow(i);  					var newRow = newReader.GetRow(i);    					var oldId = oldRow.GetUInt32(0);  					var newId = oldRow.GetUInt32(0);    					ArrayUtil.Set(ref oldRows' oldId' oldRow);  					ArrayUtil.Set(ref newRows' newId' newRow);    					highestNewId = Math.Max(highestNewId' newId);  					highestOldId = Math.Max(highestNewId' oldId);  				}      				//var cols = Math.Max(oldReader.ColumnCount' newReader.ColumnCount);  				var minColCount = Math.Min(oldReader.ColumnCount' newReader.ColumnCount);  				int[] changes = new int[minColCount];    				uint highestId = Math.Max(highestNewId' highestOldId);  				int addedCount = 0' deprecatedCount = 0;  				for (uint i = 1; i <= highestId; i++)  				{  					var oldRow = oldRows.Get(i);  					var newRow = newRows.Get(i);    					if ((oldRow != null) != (newRow != null))  					{  						if (newRow == null)  						{  							// row doesn't exit anymore  							deprecatedCount++;  						}  						else  						{  							// row got added  							addedCount++;  						}  					}  					else if (oldRow != null && newRow != null)  					{  						for (uint j = 1; j < changes.Length; j++)  						{  							if (oldRow.GetUInt32(j) != newRow.GetUInt32(j))  							{  								changes[j]++;  							}  						}  					}  				}    				if (addedCount > 0)  				{  					writer.WriteLine("- {0} new records"' addedCount);  				}  				if (deprecatedCount > 0)  				{  					writer.WriteLine("- {0} deprecated records"' deprecatedCount);  				}    				List<uint> changedCols = new List<uint>();  				for (uint col = 0; col < changes.Length; col++)  				{  					var percent = changes[col] / (float)testAmount * 100;  					if (percent >= MinColumnChangePct)  					{  						writer.Write("\t\tField {0}: {1} changes ({2}%"' col + 1' changes[col]' percent);  						var strChance = oldReader.GetStringMatchPct(col' MinStringUniquePct);  						bool mightBeStringCol;  						if (strChance >= MinStringMatchPct)  						{  							mightBeStringCol = true;  							writer.Write(" - String column probability: " + strChance + "%");  						}  						else  						{  							mightBeStringCol = false;  						}  						writer.Write(")");  						changedCols.Add(col);  						//continue;    						var matches = 0;    						if (!mightBeStringCol)  						{  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++)  							{  								var matchCount = 0;  								var zeros = 0;  								for (uint r = 1; r <= highestId; r++)  								{  									var oldRow = oldRows.Get(r);  									var newRow = newRows.Get(r);    									if (oldRow != null && newRow != null)  									{  										var oldVal = oldRow.GetUInt32(col);  										var newVal = newRow.GetUInt32(newCol);  										if (oldVal == 0)  										{  											zeros++;  										}  										if (oldVal == newVal)  										{  											matchCount++;  										}  									}  								}    								if (newCol == 1)  								{  									writer.Write(" and {0} Zeros - Might have moved to:"' zeros);  								}  								var matchPercent = matchCount / (float)testAmount * 100;  								if (matchPercent >= MinColumnMatchPct)  								{  									// possible column match  									writer.Write(newCol + " (" + matchPercent + "%)' ");  									matches++;  								}  							}  						}  						else  						{  							writer.Write(" - Might have moved to: ");  							for (uint newCol = 1; newCol < newReader.ColumnCount; newCol++) {  								var newStrChance = newReader.GetStringMatchPct(newCol' MinStringUniquePct);  								if (newStrChance >= MinStringMatchPct)  								{  									writer.Write(newCol + " (" + newStrChance + "%)' ");  									matches++;  								}  							}  						}    						if (matches == 0)  						{  							writer.Write("-none-");  						}  						writer.WriteLine();  					}  				}    				foreach (var col in changedCols)  				{  				}  			}
Magic Number,WCell.MPQTool.DBC.Compare,DBCDirComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCDirComparer.cs,Compare,The following statement contains a magic number: foreach (var file in existingFiles)  			{  				var comparer = new DBCFileComparer(Path.Combine(oldDir' file)' Path.Combine(newDir' file)' maxTestAmount' null);  				if (comparer.NewReader.IrregularColumnSize)  				{  					writer.WriteLine("Skipping {0} (IRREGULAR Column Size)"' file);  				}  				else if (comparer.NewReader.ColumnCount != comparer.OldReader.ColumnCount &&  				         (comparer.NewReader.ColumnCount < 2 || comparer.OldReader.ColumnCount < 2))  				{  					writer.WriteLine("Skipping {0} (Only 1 column or less)"' file);  				}  				else  				{  					comparer.Compare(writer);  				}  			}
Magic Number,WCell.MPQTool.DBC.Compare,DBCDirComparer,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\Compare\DBCDirComparer.cs,Compare,The following statement contains a magic number: foreach (var file in existingFiles)  			{  				var comparer = new DBCFileComparer(Path.Combine(oldDir' file)' Path.Combine(newDir' file)' maxTestAmount' null);  				if (comparer.NewReader.IrregularColumnSize)  				{  					writer.WriteLine("Skipping {0} (IRREGULAR Column Size)"' file);  				}  				else if (comparer.NewReader.ColumnCount != comparer.OldReader.ColumnCount &&  				         (comparer.NewReader.ColumnCount < 2 || comparer.OldReader.ColumnCount < 2))  				{  					writer.WriteLine("Skipping {0} (Only 1 column or less)"' file);  				}  				else  				{  					comparer.Compare(writer);  				}  			}
Magic Number,WCell.MPQTool,DBCTool,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBCTool.cs,ProcessMPQ,The following statement contains a magic number: foreach (var mpqFileName in lstAllMPQFiles)  		    {  		        //Directory.CreateDirectory(Path.Combine(DBCOutputDir' Path.GetFileNameWithoutExtension(mpqFileName)));    		        using (var oArchive = new MpqArchive(mpqFileName))  		        {  		            var dbcFiles = oArchive.FindAllFiles("*.dbc");  		            //var dbcsFiles = from a in oArchive.Files  		            //                where a.Name.EndsWith(".dbc")  		            //                select a.Name;    		            foreach (var strFileName in dbcFiles)  		            {  		                var strLocalFilePath = string.Format(@"{0}\{1}"' DBCOutputDir' Path.GetFileName(strFileName));  		                //var strLocalFilePath = Path.Combine(DBCOutputDir' Path.GetFileNameWithoutExtension(mpqFileName));  		                //strLocalFilePath = Path.Combine(strLocalFilePath' Path.GetFileName(strFileName));                            if (File.Exists(strLocalFilePath)) continue;    		                using (Stream stmOutput = new FileStream(strLocalFilePath' FileMode.Create))  		                {  		                    using (Stream stmInput = oArchive.OpenFile(strFileName).GetStream())  		                    {  		                        // Writing...  		                        Console.Write(string.Format("Writing File {0}...."' Path.GetFileName(strFileName)));    		                        // Create an 8kb buffer  		                        var byFileContents = new byte[8192];    		                        // Loop until we're out of data  		                        while (true)  		                        {  		                            // Read from the MPQ  		                            int intBytesRead = stmInput.Read(byFileContents' 0' byFileContents.Length);    		                            // Was there anything to read?  		                            if (intBytesRead == 0)  		                                break;    		                            // Write to the file  		                            stmOutput.Write(byFileContents' 0' intBytesRead);  		                        }  		                    }    		                    Console.WriteLine("Done");  		                }  		            }  		        }  		    }
Magic Number,WCell.MPQTool,DBCTool,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBCTool.cs,GetLocale,The following statement contains a magic number: for (int intFolder = 0; intFolder < arrFoundFolders.Length; intFolder++)  			{  				//Get this folders info  				var dirInfo = new DirectoryInfo(arrFoundFolders[intFolder]);    				//4 Characters long' could be enGB for example and contains mpq files  				if (dirInfo.Name.Length == 4 && dirInfo.GetFiles("*.mpq").Length > 0)  				{  					//Let's just use this one.  					strLocale = dirInfo.Name;  					//No point still looping  					break;  				}  			}
Magic Number,WCell.MPQTool,MpqLibrarian,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\MpqLibrarian.cs,MpqLibrarian,The following statement contains a magic number: foreach (var localeDir in localeDirectorys)              {                  var locale = localeDir.Substring(localeDir.Length - 4' 4);                  switch(locale)                  {                      case "enUS":                      case "enGB":                      case "koKR":                      case "frFR":                      case "deDE":                      case "zhCN":                      case "zhTW":                      case "esES":                      case "esMX":                      case "ruRU":                          break;                      default:                          continue;                  }                  mpqNames.Add(Path.Combine("Data\\"' locale' "patch-" + locale + "-3.MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "patch-" + locale + "-2.MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "patch-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "lichking-locale-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "expansion-locale-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "locale-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "base-" + locale + ".MPQ"));              }
Magic Number,WCell.MPQTool,MpqLibrarian,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\MpqLibrarian.cs,MpqLibrarian,The following statement contains a magic number: foreach (var localeDir in localeDirectorys)              {                  var locale = localeDir.Substring(localeDir.Length - 4' 4);                  switch(locale)                  {                      case "enUS":                      case "enGB":                      case "koKR":                      case "frFR":                      case "deDE":                      case "zhCN":                      case "zhTW":                      case "esES":                      case "esMX":                      case "ruRU":                          break;                      default:                          continue;                  }                  mpqNames.Add(Path.Combine("Data\\"' locale' "patch-" + locale + "-3.MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "patch-" + locale + "-2.MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "patch-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "lichking-locale-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "expansion-locale-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "locale-" + locale + ".MPQ"));                  mpqNames.Add(Path.Combine("Data\\"' locale' "base-" + locale + ".MPQ"));              }
Magic Number,WCell.MPQTool.DBC,DBCReader,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\DBCReader.cs,DBCReader,The following statement contains a magic number: Readers[(int)CellType.Float] = delegate(DBCReader reader' byte[] bytes' uint index' out object value) {  			                               	value = bytes.GetFloat(index);  			                               	return 4;  			                               };
Magic Number,WCell.MPQTool.DBC,DBCReader,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\DBCReader.cs,DBCReader,The following statement contains a magic number: Readers[(int)CellType.Int] = delegate(DBCReader reader' byte[] bytes' uint index' out object value) {  			                             	value = bytes.GetInt32(index);  			                             	return 4;  			                             };
Magic Number,WCell.MPQTool.DBC,DBCReader,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\DBCReader.cs,DBCReader,The following statement contains a magic number: Readers[(int)CellType.UInt] = delegate(DBCReader reader' byte[] bytes' uint index' out object value) {  			                              	value = bytes.GetUInt32(index);  			                              	return 4;  			                              };
Magic Number,WCell.MPQTool.DBC,DBCReader,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\DBCReader.cs,DBCReader,The following statement contains a magic number: Readers[(int)CellType.String] = delegate(DBCReader reader' byte[] bytes' uint index' out object value) {  			                                	var offset = bytes.GetUInt32(index);  			                                	value = reader.GetString(offset);  			                                	return 4;  			                                };
Magic Number,WCell.MPQTool.DBC,DBCReader,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\DBCReader.cs,DBCReader,The following statement contains a magic number: if (fileStream.Length < 4)  			{  				return;  			}
Magic Number,WCell.MPQTool.DBC,DBCReader,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\DBC\DBCReader.cs,DBCReader,The following statement contains a magic number: binReader.BaseStream.Position = 20;
Magic Number,MpqReader,BitStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\BitStream.cs,ReadBits,The following statement contains a magic number: if (BitCount > 16)  				throw new ArgumentOutOfRangeException("BitCount"' "Maximum BitCount is 16");
Magic Number,MpqReader,BitStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\BitStream.cs,ReadBits,The following statement contains a magic number: int result = mCurrent & (0xffff >> (16 - BitCount));
Magic Number,MpqReader,BitStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\BitStream.cs,PeekByte,The following statement contains a magic number: if (EnsureBits(8) == false) return -1;
Magic Number,MpqReader,BitStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\BitStream.cs,EnsureBits,The following statement contains a magic number: mBitCount += 8;
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,HashString,The following statement contains a magic number: foreach (char c in Input)  			{  				int val = char.ToUpper(c);  				seed1 = sStormBuffer[Offset + val] ^ (seed1 + seed2);  				seed2 = (uint)val + seed1 + seed2 + (seed2 << 5) + 3;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,HashString,The following statement contains a magic number: foreach (char c in Input)  			{  				int val = char.ToUpper(c);  				seed1 = sStormBuffer[Offset + val] ^ (seed1 + seed2);  				seed2 = (uint)val + seed1 + seed2 + (seed2 << 5) + 3;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length - 3; i += 4)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];    				uint result = BitConverter.ToUInt32(Data' i);    				result ^= (Seed1 + seed2);    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				if (BitConverter.IsLittleEndian)  				{  					Data[i + 0] = ((byte)(result & 0xff));  					Data[i + 1] = ((byte)((result >> 8) & 0xff));  					Data[i + 2] = ((byte)((result >> 16) & 0xff));  					Data[i + 3] = ((byte)((result >> 24) & 0xff));  				}  				else  				{  					Data[i + 3] = ((byte)(result & 0xff));  					Data[i + 2] = ((byte)((result >> 8) & 0xff));  					Data[i + 1] = ((byte)((result >> 16) & 0xff));  					Data[i + 0] = ((byte)((result >> 24) & 0xff));  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DecryptBlock,The following statement contains a magic number: for (int i = 0; i < Data.Length; i++)  			{  				seed2 += sStormBuffer[0x400 + (Seed1 & 0xff)];  				uint result = Data[i];  				result ^= Seed1 + seed2;    				Seed1 = ((~Seed1 << 21) + 0x11111111) | (Seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;  				Data[i] = result;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);    				if ((result & 0xfffc0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);    				if ((result & 0xfffc0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);    				if ((result & 0xfffc0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = value0 ^ (seed1 + seed2);    				if (result != Decrypted)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = value1 ^ (seed1 + seed2);    				if ((result & 0xfffc0000) == 0)  					return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = Value0 ^ (seed1 + seed2);    				if (result != Decrypted1)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = Value1 ^ (seed1 + seed2);    				if (result == Decrypted2) return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = Value0 ^ (seed1 + seed2);    				if (result != Decrypted1)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = Value1 ^ (seed1 + seed2);    				if (result == Decrypted2) return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = Value0 ^ (seed1 + seed2);    				if (result != Decrypted1)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = Value1 ^ (seed1 + seed2);    				if (result == Decrypted2) return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,DetectFileSeed,The following statement contains a magic number: for (int i = 0; i < 0x100; i++)  			{  				uint seed1 = temp - sStormBuffer[0x400 + i];  				uint seed2 = 0xeeeeeeee + sStormBuffer[0x400 + (seed1 & 0xff)];  				uint result = Value0 ^ (seed1 + seed2);    				if (result != Decrypted1)  					continue;    				uint saveseed1 = seed1;    				// Test this result against the 2nd value  				seed1 = ((~seed1 << 21) + 0x11111111) | (seed1 >> 11);  				seed2 = result + seed2 + (seed2 << 5) + 3;    				seed2 += sStormBuffer[0x400 + (seed1 & 0xff)];  				result = Value1 ^ (seed1 + seed2);    				if (result == Decrypted2) return saveseed1;  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for (uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for (int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2] = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for (uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for (int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2] = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for (uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for (int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2] = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for (uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for (int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2] = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for (uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for (int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2] = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqArchive,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqArchive.cs,BuildStormBuffer,The following statement contains a magic number: for (uint index1 = 0; index1 < 0x100; index1++)  			{  				uint index2 = index1;  				for (int i = 0; i < 5; i++' index2 += 0x100)  				{  					seed = (seed * 125 + 3) % 0x2aaaab;  					uint temp = (seed & 0xffff) << 16;  					seed = (seed * 125 + 3) % 0x2aaaab;    					result[index2] = temp | (seed & 0xffff);  				}  			}
Magic Number,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,Decompress,The following statement contains a magic number: do  			{  				LinkedNode node = Decode(bitstream' head);  				decoded = node.DecompressedValue;  				switch(decoded)  				{  					case 256:  						break;  					case 257:  						int newvalue = bitstream.ReadBits(8);  						outputstream.WriteByte((byte)newvalue);  						tail = InsertNode(tail' newvalue);  						break;  					default:  						outputstream.WriteByte((byte)decoded);  						break;  				}  			} while (decoded != 256);
Magic Number,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,BuildList,The following statement contains a magic number: var root = new LinkedNode(256' 1);
Magic Number,MpqReader,MpqHuffman,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqHuffman.cs,BuildList,The following statement contains a magic number: root = root.Insert(new LinkedNode(257' 1));
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,LoadBlockPositions,The following statement contains a magic number: uint blockpossize = (uint) blockposcount * 4;
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,LoadBlock,The following statement contains a magic number: if (mBlock.IsEncrypted && mBlock.FileSize > 3)              {                  if (mSeed1 == 0)                  {                      uint value0 = BitConverter.ToUInt32(data' 0);                      uint value1 = BitConverter.ToUInt32(data' 4);  					mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x2fbfbbef' 0x3d3d3d2f); // .J unicode magic                      if (mSeed1 == 0)                      {                          mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x3d3d2f2f' 0x3d3d3d3d); // .J ascii  	                    if (mSeed1 == 0)  	                    {                              mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x46464952' mBlock.FileSize - 8); // RIFF                              if (mSeed1 == 0) throw new MpqParserException("Unable to determine encryption key");                      	}                      }                  }                  MpqArchive.DecryptBlock(data' (uint)(mSeed1 + BlockIndex));              }
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,LoadBlock,The following statement contains a magic number: if (mBlock.IsEncrypted && mBlock.FileSize > 3)              {                  if (mSeed1 == 0)                  {                      uint value0 = BitConverter.ToUInt32(data' 0);                      uint value1 = BitConverter.ToUInt32(data' 4);  					mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x2fbfbbef' 0x3d3d3d2f); // .J unicode magic                      if (mSeed1 == 0)                      {                          mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x3d3d2f2f' 0x3d3d3d3d); // .J ascii  	                    if (mSeed1 == 0)  	                    {                              mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x46464952' mBlock.FileSize - 8); // RIFF                              if (mSeed1 == 0) throw new MpqParserException("Unable to determine encryption key");                      	}                      }                  }                  MpqArchive.DecryptBlock(data' (uint)(mSeed1 + BlockIndex));              }
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,LoadBlock,The following statement contains a magic number: if (mBlock.IsEncrypted && mBlock.FileSize > 3)              {                  if (mSeed1 == 0)                  {                      uint value0 = BitConverter.ToUInt32(data' 0);                      uint value1 = BitConverter.ToUInt32(data' 4);  					mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x2fbfbbef' 0x3d3d3d2f); // .J unicode magic                      if (mSeed1 == 0)                      {                          mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x3d3d2f2f' 0x3d3d3d3d); // .J ascii  	                    if (mSeed1 == 0)  	                    {                              mSeed1 = MpqArchive.DetectFileSeed(value0' value1' 0x46464952' mBlock.FileSize - 8); // RIFF                              if (mSeed1 == 0) throw new MpqParserException("Unable to determine encryption key");                      	}                      }                  }                  MpqArchive.DecryptBlock(data' (uint)(mSeed1 + BlockIndex));              }
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,DecompressMulti,The following statement contains a magic number: if ((comptype & 8) != 0)              {                  byte[] result = PKDecompress(sinput' OutputLength);                  comptype &= 0xF7;                  if (comptype == 0) return result;                  sinput = new MemoryStream(result);              }
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,DecompressMulti,The following statement contains a magic number: if ((comptype & 2) != 0)              {                  byte[] result = ZlibDecompress(sinput' OutputLength);                  comptype &= 0xFD;                  if (comptype == 0) return result;                  sinput = new MemoryStream(result);              }
Magic Number,MpqReader,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqStream.cs,DecompressMulti,The following statement contains a magic number: if ((comptype & 0x80) != 0)              {                  byte[] result = MpqWavCompression.Decompress(sinput' 2);                  comptype &= 0x7f;                  if (comptype == 0) return result;                  sinput = new MemoryStream(result);              }
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,MpqWavCompression,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\MpqWavCompression.cs,Decompress,The following statement contains a magic number: while(Data.Position < Data.Length)  			{  				byte value = input.ReadByte();    				if (ChannelCount == 2) channel = 1 - channel;  				  				if ((value & 0x80) != 0)  				{  					switch (value & 0x7f)  					{  						case 0:  							if(Array1[channel] != 0) Array1[channel]--;  							output.Write((short)Array2[channel]);  							break;  						case 1:  							Array1[channel] += 8;  							if(Array1[channel] > 0x58) Array1[channel] = 0x58;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  						case 2:  							break;  						default:  							Array1[channel] -= 8;  							if(Array1[channel] < 0) Array1[channel] = 0;  							if (ChannelCount == 2) channel = 1 - channel;  							break;  					}  				} else  				{  					int temp1 = sLookup[Array1[channel]];  					int temp2 = temp1 >> shift;    					if ((value & 1) != 0)  						temp2 += (temp1 >> 0);  					if ((value & 2) != 0)  						temp2 += (temp1 >> 1);  					if ((value & 4) != 0)  						temp2 += (temp1 >> 2);  					if ((value & 8) != 0)  						temp2 += (temp1 >> 3);  					if ((value & 0x10) != 0)  						temp2 += (temp1 >> 4);  					if ((value & 0x20) != 0)  						temp2 += (temp1 >> 5);    					int temp3 = Array2[channel];  					if ((value & 0x40) != 0)  					{  						temp3 -= temp2;  						if(temp3 <= short.MinValue) temp3 = short.MinValue;  					} else  					{  						temp3 += temp2;  						if(temp3 >= short.MaxValue) temp3 = short.MaxValue;  					}  					Array2[channel] = temp3;  					output.Write((short)temp3);  					  					Array1[channel] += sLookup2[value & 0x1f];    					if(Array1[channel] < 0)   						Array1[channel] = 0;  					else   						if(Array1[channel] > 0x58) Array1[channel] = 0x58;  				}  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,PKLibDecompress,The following statement contains a magic number: if(4 > mDSizeBits || mDSizeBits > 6)                  throw new MpqParserException("Invalid dictionary size: " + mDSizeBits);
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,PKLibDecompress,The following statement contains a magic number: if(4 > mDSizeBits || mDSizeBits > 6)                  throw new MpqParserException("Invalid dictionary size: " + mDSizeBits);
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,DecodeLit,The following statement contains a magic number: switch(mStream.ReadBits(1))  			{  				case -1:  					return -1;  					  				case 1:  					// The next bits are position in buffers  					int pos = sPosition2[mStream.PeekByte()];    					// Skip the bits we just used  					if (mStream.ReadBits(sLenBits[pos]) == -1) return -1;  	  					int nbits = sExLenBits[pos];  					if(nbits != 0)  					{  						// TODO: Verify this conversion  						int val2 = mStream.ReadBits(nbits);  						if (val2 == -1 && (pos + val2 != 0x10e)) return -1;    						pos = sLenBase[pos] + val2;  					}  					return pos + 0x100; // Return number of bytes to repeat    				case 0:  					if (mCType == CompressionType.Binary)  						return mStream.ReadBits(8);    					// TODO: Text mode  					throw new NotImplementedException("Text mode is not yet implemented");  				default:  					return 0;  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if (mStream.EnsureBits(8) == false) return 0;
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,DecodeDist,The following statement contains a magic number: if(Length == 2)  			{  				if (mStream.EnsureBits(2) == false) return 0;  				pos = (pos << 2) | mStream.ReadBits(2);  			} else  			{  				if (mStream.EnsureBits(mDSizeBits) == false) return 0;  				pos = ((pos << mDSizeBits)) | mStream.ReadBits(mDSizeBits);  			}
Magic Number,MpqReader,PKLibDecompress,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\SCSharp.Mpq\PKLibDecompress.cs,GenerateDecodeTable,The following statement contains a magic number: var result = new byte[256];
Magic Number,WCell.MPQTool.StormLibWrapper,MpqFile,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\StormLibWrapper\MpqFile.cs,GetFileSize,The following statement contains a magic number: return ((long)highBits << 32) + lowBits;
Magic Number,WCell.MPQTool.StormLibWrapper,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\StormLibWrapper\MpqStream.cs,Seek,The following statement contains a magic number: var distanceToMoveHigh = (int)(Math.Abs(offset) >> 32) * Math.Sign(offset);
Magic Number,WCell.MPQTool.StormLibWrapper,MpqStream,C:\repos\WCell_WCell\Utilities\WCell.MPQTool\StormLibWrapper\MpqStream.cs,Seek,The following statement contains a magic number: return position = ((long)distanceToMoveHigh << 32) + newPosition;
