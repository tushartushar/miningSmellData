Implementation smell,Namespace,Class,File,Method,Description
Long Method,WCell.Terrain.Legacy,OBB,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OBB.cs,Intersects,The method has 159 lines of code.
Long Method,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersection,The method has 102 lines of code.
Long Method,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindPath,The method has 120 lines of code.
Long Method,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindPathStringPull,The method has 122 lines of code.
Long Method,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The method has 201 lines of code.
Long Method,WCell.Terrain.Tools,MapBoundaryUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\MapBoundaryUtil.cs,ExportBoundaries,The method has 102 lines of code.
Long Method,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetInterpolatedHeight,The method has 182 lines of code.
Long Method,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadADT,The method has 109 lines of code.
Long Method,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadOptionalChunks,The method has 174 lines of code.
Long Method,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadWMO,The method has 195 lines of code.
Long Method,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,TransformWMO,The method has 141 lines of code.
Complex Method,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,Clip,Cyclomatic complexity of the method is 8
Complex Method,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,Cyclomatic complexity of the method is 10
Complex Method,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GetNeighborsOf,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GenerateLiquidMesh,Cyclomatic complexity of the method is 16
Complex Method,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,Intersect,Cyclomatic complexity of the method is 11
Complex Method,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectSegmentCylinder,Cyclomatic complexity of the method is 12
Complex Method,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectSegmentRectangle2D,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain.Legacy,OBB,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OBB.cs,Intersects,Cyclomatic complexity of the method is 16
Complex Method,WCell.Terrain.Legacy.BSPTree,BSPTree,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\BSPTree\BSPTree.cs,FindRootNode,Cyclomatic complexity of the method is 8
Complex Method,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,Cyclomatic complexity of the method is 12
Complex Method,WCell.Terrain.Legacy.OCTree,OCTree,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTree.cs,MoveSphere,Cyclomatic complexity of the method is 11
Complex Method,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,Cyclomatic complexity of the method is 10
Complex Method,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindPathStringPull,Cyclomatic complexity of the method is 8
Complex Method,WCell.Terrain.Tools,ZoneTileSetWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneGridWriter.cs,WriteMethod,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain.Tools,ZoneBoundaryWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneBoundaryWriter.cs,GetTileSets,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithTerraSimplification,Cyclomatic complexity of the method is 14
Complex Method,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetTerrainMesh,Cyclomatic complexity of the method is 13
Complex Method,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,AppendWMOandM2Info,Cyclomatic complexity of the method is 11
Complex Method,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadChunk,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadADT,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ProcessMH2O,Cyclomatic complexity of the method is 8
Complex Method,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadRequiredChunks,Cyclomatic complexity of the method is 9
Complex Method,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadOptionalChunks,Cyclomatic complexity of the method is 24
Complex Method,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadWMO,Cyclomatic complexity of the method is 10
Complex Method,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,TransformWMO,Cyclomatic complexity of the method is 21
Complex Method,WCell.Terrain.MPQ.WMOs,WMOBSPTree,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\WMOs\WMOBSPNode.cs,FindRootNodeId,Cyclomatic complexity of the method is 8
Long Parameter List,WCell.Terrain,CollisionUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\CollisionUtil.cs,RayTriangleIntersect,The method has 6 parameters. Parameters: vert0' vert1' vert2' ray' u' v
Long Parameter List,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,BilinearInterpolate,The method has 6 parameters. Parameters: topLeft' topRight' bottomLeft' bottomRight' xf' yf
Long Parameter List,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetInsideOrderedEdgePoints,The method has 5 parameters. Parameters: shape' tri' edge' right' left
Long Parameter List,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetOutsideOrderedEdgePointsPlusApex,The method has 6 parameters. Parameters: shape' tri' edge' right' left' apex
Long Parameter List,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetOutsideOrderedEdgePoints,The method has 5 parameters. Parameters: shape' tri' edge' right' left
Long Parameter List,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetEdgePointIndices,The method has 5 parameters. Parameters: shape' tri' edge' right' left
Long Parameter List,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetOutsideOrderedEdgePointsPlusApex,The method has 5 parameters. Parameters: triangle' edge' right' left' apex
Long Parameter List,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The method has 5 parameters. Parameters: tileName' mapId' mapName' tileX' tileY
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Barycentric,The method has 5 parameters. Parameters: a' b' c' p' uvw
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Barycentric2,The method has 5 parameters. Parameters: a' b' c' p' uv
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,ClosestPointOnSegment,The method has 5 parameters. Parameters: c' a' b' t' d
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,ClosestPointOnLine,The method has 5 parameters. Parameters: c' a' b' t' p
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,ClosestPointOnLine,The method has 5 parameters. Parameters: c' a' b' t' p
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,ClosestPtPointRect,The method has 5 parameters. Parameters: p' a' b' c' q
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,ClosestPtPointSegment2D,The method has 5 parameters. Parameters: c' a' b' t' d
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectionOfTwoLines,The method has 5 parameters. Parameters: a' b' c' d' result
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectionOfLineSegments2D,The method has 5 parameters. Parameters: a' b' c' d' result
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectMovingSpherePlane,The method has 5 parameters. Parameters: s' v' p' t' q
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectRaySphere,The method has 5 parameters. Parameters: p' d' s' t' q
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectSegmentCylinder,The method has 6 parameters. Parameters: sa' sb' p' q' r' t
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectSegmentPlane,The method has 5 parameters. Parameters: a' b' p' t' q
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectSegmentPolyhedron,The method has 6 parameters. Parameters: a' b' p' n' tfirst' tlast
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectSegmentTriangle,The method has 9 parameters. Parameters: p' q' a' b' c' u' v' w' t
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,RayTriangleIntersect,The method has 5 parameters. Parameters: r' t1' t2' t3' distance
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,RayTriangleIntersect,The method has 8 parameters. Parameters: ray_origin' ray_direction' vert0' vert1' vert2' t' u' v
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Test2DSegmentSegment,The method has 6 parameters. Parameters: a' b' c' d' t' p
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,TestMovingSphereSphere,The method has 5 parameters. Parameters: s0' s1' v0' v1' t
Long Parameter List,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,TriArea2D,The method has 6 parameters. Parameters: x1' y1' x2' y2' x3' y3
Long Parameter List,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,OCTreeBuilder,The method has 5 parameters. Parameters: maxPolygonsPerNode' maxSubdivisions' makeSquare' weldDelta' expandBoundsFactor
Long Parameter List,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The method has 5 parameters. Parameters: node' PolyList' center' extents' depth
Long Parameter List,WCell.Terrain.Pathfinding,SearchItem,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\SearchItem.cs,SearchItem,The method has 5 parameters. Parameters: triangle' edge' directDistToDest' pointOfReference' previous
Long Parameter List,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The method has 10 parameters. Parameters: userId' vertComponentCount' polyCount' vertComponentsPtr' totalPolyIndexCount' pIndexCountsPtr' pIndicesPtr' pNeighborsPtr' pFlagsPtr' polyAreasAndTypesPtr
Long Parameter List,WCell.Terrain.Recast,RecastAPI,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\RecastAPI.cs,BuildMeshFromFile,The method has 5 parameters. Parameters: userId' inputFilename' navMeshFilename' callback' numCores
Long Parameter List,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,TryGetADTPath,The method has 5 parameters. Parameters: mapId' x' y' filePath' mpqFinder
Long Parameter List,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,TryGetADTPath,The method has 5 parameters. Parameters: mapId' x' y' filePath' mpqFinder
Long Statement,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,ReadXml,The length of the statement  "                    "Malformed TileIdentifer entry in the config Xml. TileY should be the fifth element. ... (Speaking of Fifth Element' what a great show' yeah?)"); " is 145.
Long Statement,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The length of the statement  "            var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) }; " is 578.
Long Statement,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The length of the statement  "                            if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4)) " is 187.
Long Statement,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The length of the statement  "                                    closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]); " is 151.
Long Statement,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,BuildMesh,The length of the statement  "				throw new Exception("Could not build mesh for tile " + TerrainConstants.GetTileName(tile.TileX' tile.TileY) + " in map " + Terrain.MapId); " is 138.
Long Statement,WCell.Terrain.Tools,ZoneBoundaryWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneBoundaryWriter.cs,GetTileSets,The length of the statement  "						tileSet.ZoneGrids[y' x] = grid = new ZoneGrid(new uint[TerrainConstants.ChunksPerTileSide' TerrainConstants.ChunksPerTileSide]); " is 128.
Complex Conditional,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,IntersectionOfTwoLines,The conditional expression  "(((num < 0.0) || (num > 1.0)) || (num2 < 0.0)) || (num2 > 1.0)"  is complex.
Complex Conditional,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The conditional expression  "((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f))"  is complex.
Complex Conditional,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateLiquidVertices,The conditional expression  "((xStep < bounds.X) || ((xStep - bounds.X) > bounds.Height)) ||  						((yStep < bounds.Y) || ((yStep - bounds.Y) > bounds.Width))"  is complex.
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: var newPoly = new VertCoord[4];
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: if (count == 3)              {                  for (var i = 0; i < 3; i++)                  {                      face.VertIdxs[i] = newPoly[i];                  }                  return ClipperResponse.SomeClipped;              }
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: if (count == 3)              {                  for (var i = 0; i < 3; i++)                  {                      face.VertIdxs[i] = newPoly[i];                  }                  return ClipperResponse.SomeClipped;              }
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: face.VertIdxs = new[] {newFaces[0]' newFaces[1]' newFaces[2]};
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: newFace = new CFace(new[]{newFaces[3]' newFaces[4]' newFaces[5]});
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: newFace = new CFace(new[]{newFaces[3]' newFaces[4]' newFaces[5]});
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipFace,The following statement contains a magic number: newFace = new CFace(new[]{newFaces[3]' newFaces[4]' newFaces[5]});
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: if (poly.Length < 4) return poly;
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: var edge03 = CVertices[poly[3]].Point - CVertices[poly[0]].Point;
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: var edge21 = CVertices[poly[1]].Point - CVertices[poly[2]].Point;
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: var edge23 = CVertices[poly[3]].Point - CVertices[poly[2]].Point;
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: var edge23 = CVertices[poly[3]].Point - CVertices[poly[2]].Point;
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: return ((alpha + beta) >= Math.PI)                         ? new[] {poly[0]' poly[1]' poly[3]' poly[1]' poly[2]' poly[3]}                         : new[] {poly[0]' poly[2]' poly[3]' poly[0]' poly[1]' poly[2]};
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: return ((alpha + beta) >= Math.PI)                         ? new[] {poly[0]' poly[1]' poly[3]' poly[1]' poly[2]' poly[3]}                         : new[] {poly[0]' poly[2]' poly[3]' poly[0]' poly[1]' poly[2]};
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: return ((alpha + beta) >= Math.PI)                         ? new[] {poly[0]' poly[1]' poly[3]' poly[1]' poly[2]' poly[3]}                         : new[] {poly[0]' poly[2]' poly[3]' poly[0]' poly[1]' poly[2]};
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: return ((alpha + beta) >= Math.PI)                         ? new[] {poly[0]' poly[1]' poly[3]' poly[1]' poly[2]' poly[3]}                         : new[] {poly[0]' poly[2]' poly[3]' poly[0]' poly[1]' poly[2]};
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: return ((alpha + beta) >= Math.PI)                         ? new[] {poly[0]' poly[1]' poly[3]' poly[1]' poly[2]' poly[3]}                         : new[] {poly[0]' poly[2]' poly[3]' poly[0]' poly[1]' poly[2]};
Magic Number,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ReTriangulate,The following statement contains a magic number: return ((alpha + beta) >= Math.PI)                         ? new[] {poly[0]' poly[1]' poly[3]' poly[1]' poly[2]' poly[3]}                         : new[] {poly[0]' poly[2]' poly[3]' poly[0]' poly[1]' poly[2]};
Magic Number,WCell.Terrain,VertCoord,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int result = I;                      result = (result*397) ^ J;                      result = (result*397) ^ K;                      return result;                  }
Magic Number,WCell.Terrain,VertCoord,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,GetHashCode,The following statement contains a magic number: unchecked                  {                      int result = I;                      result = (result*397) ^ J;                      result = (result*397) ^ K;                      return result;                  }
Magic Number,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GetPotentialColliders,The following statement contains a magic number: for (var i = 0; i < TerrainIndices.Length; i += 3)  			{  				yield return i;  			}
Magic Number,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GetNeighborsOf,The following statement contains a magic number: for (var i = 0; i < indices.Length; i += 3)  			{  				if (i != triIndex)	// don't return itself  				{  					var a2 = indices[i];  					var b2 = indices[i + 1];  					var c2 = indices[i + 2];    					var nCount = 0;  					var mask = 0;  					if (a == a2 || a == b2 || a == c2)  					{  						// some vertex matches the first vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointA;  					}  					if (b == a2 || b == b2 || b == c2)  					{  						// some vertex matches the second vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointB;  					}  					if (c == a2 || c == b2 || c == c2)  					{  						// some vertex matches the third vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointC;  					}    					if (nCount == 2)  					{  						// we have a neighbor  						switch (mask)  						{  							case TerrainUtil.ABEdgeMask:  								// neighbor shares a and b  								neighbors[TerrainUtil.ABEdgeIndex] = i;  								break;  							case TerrainUtil.ACEdgeMask:  								// second shares a and c  								neighbors[TerrainUtil.CAEdgeIndex] = i;  								break;  							case TerrainUtil.BCEdgeMask:  								// neighbor shares b and c  								neighbors[TerrainUtil.BCEdgeIndex] = i;  								break;    						}  					}  				}  			}
Magic Number,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GetNeighborsOf,The following statement contains a magic number: for (var i = 0; i < indices.Length; i += 3)  			{  				if (i != triIndex)	// don't return itself  				{  					var a2 = indices[i];  					var b2 = indices[i + 1];  					var c2 = indices[i + 2];    					var nCount = 0;  					var mask = 0;  					if (a == a2 || a == b2 || a == c2)  					{  						// some vertex matches the first vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointA;  					}  					if (b == a2 || b == b2 || b == c2)  					{  						// some vertex matches the second vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointB;  					}  					if (c == a2 || c == b2 || c == c2)  					{  						// some vertex matches the third vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointC;  					}    					if (nCount == 2)  					{  						// we have a neighbor  						switch (mask)  						{  							case TerrainUtil.ABEdgeMask:  								// neighbor shares a and b  								neighbors[TerrainUtil.ABEdgeIndex] = i;  								break;  							case TerrainUtil.ACEdgeMask:  								// second shares a and c  								neighbors[TerrainUtil.CAEdgeIndex] = i;  								break;  							case TerrainUtil.BCEdgeMask:  								// neighbor shares b and c  								neighbors[TerrainUtil.BCEdgeIndex] = i;  								break;    						}  					}  				}  			}
Magic Number,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GetNeighborsOf,The following statement contains a magic number: for (var i = 0; i < indices.Length; i += 3)  			{  				if (i != triIndex)	// don't return itself  				{  					var a2 = indices[i];  					var b2 = indices[i + 1];  					var c2 = indices[i + 2];    					var nCount = 0;  					var mask = 0;  					if (a == a2 || a == b2 || a == c2)  					{  						// some vertex matches the first vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointA;  					}  					if (b == a2 || b == b2 || b == c2)  					{  						// some vertex matches the second vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointB;  					}  					if (c == a2 || c == b2 || c == c2)  					{  						// some vertex matches the third vertex of the triangle  						nCount++;  						mask |= TerrainUtil.TrianglePointC;  					}    					if (nCount == 2)  					{  						// we have a neighbor  						switch (mask)  						{  							case TerrainUtil.ABEdgeMask:  								// neighbor shares a and b  								neighbors[TerrainUtil.ABEdgeIndex] = i;  								break;  							case TerrainUtil.ACEdgeMask:  								// second shares a and c  								neighbors[TerrainUtil.CAEdgeIndex] = i;  								break;  							case TerrainUtil.BCEdgeMask:  								// neighbor shares b and c  								neighbors[TerrainUtil.BCEdgeIndex] = i;  								break;    						}  					}  				}  			}
Magic Number,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetEdgePointIndices,The following statement contains a magic number: switch (edge)  			{  				case TerrainUtil.ABEdgeIndex:  					left = 0;  					right = 1;  					break;  				case TerrainUtil.CAEdgeIndex:  					left = 2;  					right = 0;  					break;  				case TerrainUtil.BCEdgeIndex:  					left = 1;  					right = 2;  					break;  				default:  					throw new Exception("Impossible");  			}
Magic Number,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetEdgePointIndices,The following statement contains a magic number: switch (edge)  			{  				case TerrainUtil.ABEdgeIndex:  					left = 0;  					right = 1;  					break;  				case TerrainUtil.CAEdgeIndex:  					left = 2;  					right = 0;  					break;  				case TerrainUtil.BCEdgeIndex:  					left = 1;  					right = 2;  					break;  				default:  					throw new Exception("Impossible");  			}
Magic Number,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetEdgePointIndices,The following statement contains a magic number: switch (edge)  			{  				case TerrainUtil.ABEdgeIndex:  					third = 2;  					break;  				case TerrainUtil.CAEdgeIndex:  					third = 1;  					break;  				case TerrainUtil.BCEdgeIndex:  					third = 0;  					break;  				default:  					throw new Exception("Impossible");  			}
Magic Number,WCell.Terrain,TerrainUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainUtil.cs,GetEdgePointIndices,The following statement contains a magic number: var p2 = (rightP + leftP) / 2;
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,TileIdentifier,The following statement contains a magic number: try  			{  				InternalMapNames = new Dictionary<MapId' string>((int) MapId.End);  				foreach (var mapInfo in MapInfo.GetMapEntries())  				{  					InternalMapNames.Add(mapInfo.Id' mapInfo.InternalName);  				}    				Redridge = new TileIdentifier  					{  						TileName = "Redridge"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 36  					};    				CenterTile = new TileIdentifier  					{  						TileName = "Map Center"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 32'  						Y = 32  					};    				Stormwind = new TileIdentifier  					{  						TileName = "Stormwind"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 48'  						Y = 30  					};    				BurningSteppes = new TileIdentifier  					{  						TileName = "Burning Steppes"'  						MapId = MapId.EasternKingdoms'  						MapName = InternalMapNames[MapId.EasternKingdoms]'  						X = 49'  						Y = 33  					};  			}  			catch (Exception e)  			{  				LogUtil.ErrorException(e' "Could not initialize Tile identifiers");  			}
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,ReadXml,The following statement contains a magic number: if (!reader.IsStartElement("TileX"))              {                  Console.WriteLine(                      "Malformed TileIdentifer entry in the config Xml. TileX should be fourth element.");                  X = 32;              }              else              {                  X = reader.ReadElementContentAsInt();              }
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,ReadXml,The following statement contains a magic number: if (!reader.IsStartElement("TileY"))              {                  Console.WriteLine(                      "Malformed TileIdentifer entry in the config Xml. TileY should be the fifth element. ... (Speaking of Fifth Element' what a great show' yeah?)");                  Y = 32;              }              else              {                  Y = reader.ReadElementContentAsInt();              }
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = MapId.GetHashCode();                  result = (result*397) ^ X;                  result = (result*397) ^ Y;                  return result;              }
Magic Number,WCell.Terrain,TileIdentifier,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TileIdentifier.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = MapId.GetHashCode();                  result = (result*397) ^ X;                  result = (result*397) ^ Y;                  return result;              }
Magic Number,WCell.Terrain.Legacy,CollisionUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\CollisionUtil.cs,GetTriangle,The following statement contains a magic number: return new Triangle(vertices[indices[index]]' vertices[indices[index + 1]]' vertices[indices[index + 2]]);
Magic Number,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Corner,The following statement contains a magic number: var vector = new Vector3  			{  				X = ((n & 1) == 1) ? b.Max.X : b.Min.X'  				Y = ((n & 2) == 2) ? b.Max.Y : b.Min.Y'  				Z = ((n & 4) == 4) ? b.Max.Z : b.Min.Z  			};
Magic Number,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Corner,The following statement contains a magic number: var vector = new Vector3  			{  				X = ((n & 1) == 1) ? b.Max.X : b.Min.X'  				Y = ((n & 2) == 2) ? b.Max.Y : b.Min.Y'  				Z = ((n & 4) == 4) ? b.Max.Z : b.Min.Z  			};
Magic Number,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Corner,The following statement contains a magic number: var vector = new Vector3  			{  				X = ((n & 1) == 1) ? b.Max.X : b.Min.X'  				Y = ((n & 2) == 2) ? b.Max.Y : b.Min.Y'  				Z = ((n & 4) == 4) ? b.Max.Z : b.Min.Z  			};
Magic Number,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,Corner,The following statement contains a magic number: var vector = new Vector3  			{  				X = ((n & 1) == 1) ? b.Max.X : b.Min.X'  				Y = ((n & 2) == 2) ? b.Max.Y : b.Min.Y'  				Z = ((n & 4) == 4) ? b.Max.Z : b.Min.Z  			};
Magic Number,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,PointInsidePoly,The following statement contains a magic number: uint index = 2;
Magic Number,WCell.Terrain.Legacy,Intersection,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\Intersection.cs,PointInsidePoly,The following statement contains a magic number: for (uint i = 0; i < 3; i++)  			{  				var vector = vectorArray[index];  				var vector2 = vectorArray[i];  				var vector3 = Vector3.Cross(vector2 - vector' plane.Normal);  				var num5 = Vector3.Dot(p' vector3) - Vector3.Dot(vector' vector3);  				if (num5 > Epsilon)  				{  					num++;  				}  				else if (num5 < -Epsilon)  				{  					num2++;  				}  				if ((num | num2) != 0)  				{  					return false;  				}  				index = i;  			}
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,IntermediateOCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\IntermediateOCTreeNode.cs,Build,The following statement contains a magic number: if ((Polys != null) && (Polys.Length > 0))              {                  var list = new List<Vector3>();                  var list2 = new List<int>();                  for (num = 0; num < Polys.Length; num++)                  {                      for (var i = 0; i < 3; i++)                      {                          var vector = Polys[num].Verts[i];                          var item = -1;                          for (var j = 0; j < list.Count; j++)                          {                              if (list[j].NearlyEqual(vector' WeldDelta))                              {                                  item = j;                                  goto Label_00DD;                              }                          }                      Label_00DD:                          if (item != -1)                          {                              list2.Add(item);                          }                          else                          {                              list.Add(Polys[num].Verts[i]);                              list2.Add(list.Count - 1);                          }                      }                  }                  var list3 = new List<int>();                  for (num = 0; num < (list2.Count / 3); num++)                  {                      if (((Vector3.DistanceSquared(list[list2[num * 3]]' list[list2[(num * 3) + 1]]) > MathExtensions.Epsilon) &&                           (Vector3.DistanceSquared(list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]) >                            MathExtensions.Epsilon)) &&                          (Vector3.DistanceSquared(list[list2[(num * 3) + 2]]' list[list2[num * 3]]) > MathExtensions.Epsilon))                      {                          var plane = new Plane(list[list2[num * 3]]' list[list2[(num * 3) + 1]]' list[list2[(num * 3) + 2]]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list3.Add(list2[num * 3]);                              list3.Add(list2[(num * 3) + 1]);                              list3.Add(list2[(num * 3) + 2]);                          }                      }                  }                  node.Indices = list3.ToArray();                  node.Vertices = list.ToArray();                  node.Planes = new Plane[node.Indices.Length / 3];                  for (num = 0; num < (node.Indices.Length / 3); num++)                  {                      node.Planes[num] = new Plane(node.Vertices[node.Indices[num * 3]]'                                                   node.Vertices[node.Indices[(num * 3) + 2]]'                                                   node.Vertices[node.Indices[(num * 3) + 1]]);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTPoly,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTPoly.cs,OCTPoly,The following statement contains a magic number: Verts = new[] { poly.Verts[0]' poly.Verts[1]' poly.Verts[2] };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTree,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTree.cs,MoveSphere,The following statement contains a magic number: for (var i = 0; i < 5; i++)              {                  var num2 = 0;                  for (var j = 0; j < list.Count; j++)                  {                      var intersection = list[j];                      if (intersection.Node.UpdateIntersection(ref intersection' ref sphere2' ref velocityNormal) &&                          (sphere2.Contains(intersection.IntersectionPoint) != ContainmentType.Disjoint))                      {                          num2++;                          var vector3 =                              (intersection.IntersectionNormal * (intersection.IntersectionDepth + 0.001f));                          sphere2.Center += vector3;                          vector = sphere2.Center - sphere.Center;                          velocityNormal = Vector3.Normalize(vector);                          var flag = false;                          num4 = 0;                          while (num4 < sphereColliders.Count)                          {                              if ((sphereColliders[num4].Node == intersection.Node) &&                                  (sphereColliders[num4].PolygonIndex == intersection.PolygonIndex))                              {                                  flag = true;                                  break;                              }                              num4++;                          }                          if (!flag)                          {                              sphereColliders.Add(intersection);                          }                      }                  }                  if (num2 == 0)                  {                      break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Build,The following statement contains a magic number: for (var i = 0; i < (indexArray.Length / 3); i++)              {                  var a = vertexArray[indexArray[i * 3]];                  var b = vertexArray[indexArray[(i * 3) + 1]];                  var c = vertexArray[indexArray[(i * 3) + 2]];                  list.Add(new OCTPoly(a' b' c));              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Build,The following statement contains a magic number: for (var i = 0; i < (indexArray.Length / 3); i++)              {                  var a = vertexArray[indexArray[i * 3]];                  var b = vertexArray[indexArray[(i * 3) + 1]];                  var c = vertexArray[indexArray[(i * 3) + 2]];                  list.Add(new OCTPoly(a' b' c));              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Build,The following statement contains a magic number: for (var i = 0; i < (indexArray.Length / 3); i++)              {                  var a = vertexArray[indexArray[i * 3]];                  var b = vertexArray[indexArray[(i * 3) + 1]];                  var c = vertexArray[indexArray[(i * 3) + 2]];                  list.Add(new OCTPoly(a' b' c));              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Build,The following statement contains a magic number: for (var i = 0; i < (indexArray.Length / 3); i++)              {                  var a = vertexArray[indexArray[i * 3]];                  var b = vertexArray[indexArray[(i * 3) + 1]];                  var c = vertexArray[indexArray[(i * 3) + 2]];                  list.Add(new OCTPoly(a' b' c));              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Build,The following statement contains a magic number: for (var i = 0; i < (indexArray.Length / 3); i++)              {                  var a = vertexArray[indexArray[i * 3]];                  var b = vertexArray[indexArray[(i * 3) + 1]];                  var c = vertexArray[indexArray[(i * 3) + 2]];                  list.Add(new OCTPoly(a' b' c));              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,CalculateBounds,The following statement contains a magic number: for (var i = 0; i < polyList.Length; i++)              {                  for (var j = 0; j < 3; j++)                  {                      Vector3.Min(ref vector' ref polyList[i].Verts[j]' out vector);                      Vector3.Max(ref vector2' ref polyList[i].Verts[j]' out vector2);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: var planeArray = new[] { MathExtensions.PlaneFromPointNormal(center + (planeOffsets[0] * extents)' planeNormals[0])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[1] * extents)' planeNormals[1])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[2] * extents)' planeNormals[2])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[3] * extents)' planeNormals[3])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[4] * extents)' planeNormals[4])' MathExtensions.PlaneFromPointNormal(center + (planeOffsets[5] * extents)' planeNormals[5]) };
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: for (var i = 0; i < planeArray.Length; i++)              {                  var list = new List<OCTPoly>();                  for (var j = 0; j < polyArray.Length; j++)                  {                      int num4;                      var newPolys = new OCTPoly[2];                      Split(polyArray[j]' planeArray[i]' ref newPolys' out num4);                      index = 0;                      while (index < num4)                      {                          var plane = new Plane(newPolys[index].Verts[0]' newPolys[index].Verts[1]' newPolys[index].Verts[2]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list.Add(newPolys[index]);                          }                          index++;                      }                  }                  polyArray = new OCTPoly[list.Count];                  index = 0;                  while (index < list.Count)                  {                      polyArray[index] = new OCTPoly(list[index]);                      index++;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: for (var i = 0; i < planeArray.Length; i++)              {                  var list = new List<OCTPoly>();                  for (var j = 0; j < polyArray.Length; j++)                  {                      int num4;                      var newPolys = new OCTPoly[2];                      Split(polyArray[j]' planeArray[i]' ref newPolys' out num4);                      index = 0;                      while (index < num4)                      {                          var plane = new Plane(newPolys[index].Verts[0]' newPolys[index].Verts[1]' newPolys[index].Verts[2]);                          if (!float.IsNaN(plane.Normal.X))                          {                              list.Add(newPolys[index]);                          }                          index++;                      }                  }                  polyArray = new OCTPoly[list.Count];                  index = 0;                  while (index < list.Count)                  {                      polyArray[index] = new OCTPoly(list[index]);                      index++;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: if ((polyArray.Length <= MaxPolygonsPerNode) || (depth >= MaxSubdivisions))              {                  node.Polys = new OCTPoly[polyArray.Length];                  if (polyArray.Length > 0)                  {                      for (index = 0; index < polyArray.Length; index++)                      {                          node.Polys[index] = new OCTPoly(polyArray[index]);                      }                  }              }              else              {                  node.Children = new IntermediateOCTreeNode[8];                  for (index = 0; index < 8; index++)                  {                      node.Children[index] = new IntermediateOCTreeNode();                      var vector = (extents * 0.5f);                      var vector2 = center + (nodeOffsets[index] * vector);                      node.Children[index].Bounds = new BoundingBox(vector2 - vector' vector2 + vector);                      RecursiveBuild(node.Children[index]' PolyList' vector2' vector' depth + 1);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,RecursiveBuild,The following statement contains a magic number: if ((polyArray.Length <= MaxPolygonsPerNode) || (depth >= MaxSubdivisions))              {                  node.Polys = new OCTPoly[polyArray.Length];                  if (polyArray.Length > 0)                  {                      for (index = 0; index < polyArray.Length; index++)                      {                          node.Polys[index] = new OCTPoly(polyArray[index]);                      }                  }              }              else              {                  node.Children = new IntermediateOCTreeNode[8];                  for (index = 0; index < 8; index++)                  {                      node.Children[index] = new IntermediateOCTreeNode();                      var vector = (extents * 0.5f);                      var vector2 = center + (nodeOffsets[index] * vector);                      node.Children[index].Bounds = new BoundingBox(vector2 - vector' vector2 + vector);                      RecursiveBuild(node.Children[index]' PolyList' vector2' vector' depth + 1);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: var num3 = p.DotCoordinate(poly.Verts[2]);
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: var vector = MathExtensions.NormalFromPoints(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following statement contains a magic number: if (((num > 0f) && (num2 > 0f)) && (num3 > 0f))              {                  newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                  numPolys = 1;              }              else if (((num < 0f) && (num2 < 0f)) && (num3 < 0f))              {                  numPolys = 0;              }              else if (((num == 0f) && (num2 == 0f)) && (num3 == 0f))              {                  if (p.DotNormal(vector) >= 0f)                  {                      newPolys[0] = new OCTPoly(poly.Verts[0]' poly.Verts[1]' poly.Verts[2]);                      numPolys = 1;                  }                  else                  {                      numPolys = 0;                  }              }              else              {                  var vectorArray = new Vector3[4];                  var num4 = 0;                  for (var i = 0; i < 3; i++)                  {                      var vector2 = poly.Verts[i];                      var vector3 = poly.Verts[((i + 1) > 2) ? 0 : (i + 1)];                      var num6 = p.DotCoordinate(vector2);                      var num7 = p.DotCoordinate(vector3);                      if (num6 >= 0f)                      {                          vectorArray[num4++] = vector2;                      }                      if (((num7 <= 0f) && (num6 > 0f)) || ((num7 >= 0f) && (num6 < 0f)))                      {  						Vector3 point;                          if (Intersection.LineSegmentIntersectsPlane(vector2' vector3' p' out point))                          {                              vectorArray[num4++] = point;                          }                      }                  }                  switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygon,The following statement contains a magic number: if (Indices != null)              {                  var nullable = ray.Intersects(Bounds);                  if (nullable.HasValue)                  {                      var num = (closest.IntersectType == OCTreeIntersectionType.None) ? float.MaxValue : closest.DistanceSquared;                      if (nullable.Value < num)                      {                          for (var i = 0; i < (Indices.Length / 3); i++)                          {                              float num2;                              float num3;                              float num4;                              if (Intersection.RayTriangleIntersect(ray.Position' ray.Direction' Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]' out num2' out num3' out num4))                              {                                  var vector = ray.Position + ((ray.Direction * num2));                                  var num6 = Vector3.DistanceSquared(vector' ray.Position);                                  if (num6 < num)                                  {                                      num = num6;                                      closest.IntersectionNormal = MathExtensions.NormalFromPoints(Vertices[Indices[i * 3]]' Vertices[Indices[(i * 3) + 1]]' Vertices[Indices[(i * 3) + 2]]);                                      closest.IntersectionPoint = vector;                                      closest.Node = this;                                      closest.PolygonIndex = i;                                      closest.DistanceSquared = num6;                                      closest.IntersectType = OCTreeIntersectionType.Inside;                                  }                              }                          }                      }                  }              }              else if (Children != null)              {                  for (var j = 0; j < Children.Length; j++)                  {                      Children[j].GetIntersectingPolygon(ref ray' ref closest);                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersectingPolygons,The following statement contains a magic number: if (Bounds.Contains(sphere) != ContainmentType.Disjoint)              {                  if (Indices != null)                  {                      for (var i = 0; i < (Indices.Length / 3); i++)                      {                          OCTreeIntersection intersection;                          if (GetIntersection(ref sphere' ref velocityNormal' i' out intersection))                          {                              nodes.Add(intersection);                          }                      }                  }                  if (Children != null)                  {                      for (var j = 0; j < Children.Length; j++)                      {                          Children[j].GetIntersectingPolygons(ref sphere' ref velocityNormal' ref nodes);                      }                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersection,The following statement contains a magic number: if (plane.DotNormal(velocityNormal) < 0f)              {                  if (plane.DotCoordinate(sphere.Center) < 0f)                  {                      return false;                  }                  if (plane.Intersects(sphere) != PlaneIntersectionType.Intersecting)                  {                      return false;                  }                  var a = Vertices[Indices[polyIndex * 3]];                  var b = Vertices[Indices[(polyIndex * 3) + 1]];                  var c = Vertices[Indices[(polyIndex * 3) + 2]];                  var p = Intersection.ClosestPointOnPlane(sphere.Center' plane);                  if (Intersection.PointInTriangle(p' a' b' c))                  {                      intersection.IntersectionPoint = p;                      intersection.IntersectionNormal = plane.Normal;                      intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(p' sphere.Center);                      intersection.Node = this;                      intersection.PolygonIndex = polyIndex;                      intersection.IntersectType = OCTreeIntersectionType.Inside;                      flag = true;                  }                  else                  {                      float num;                      Vector3 vector5;                      if (sphere.Contains(a) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = a;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - a);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(a' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(b) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = b;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - b);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(b' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(c) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = c;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - c);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(c' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' a' b' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' b' c' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          flag = true;                      }                      else                      {                          Intersection.ClosestPointOnSegment(sphere.Center' c' a' out num' out vector5);                          if (sphere.Contains(vector5) != ContainmentType.Disjoint)                          {                              intersection.IntersectionPoint = vector5;                              intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                              intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                              intersection.IntersectType = OCTreeIntersectionType.Edge;                              intersection.Node = this;                              intersection.PolygonIndex = polyIndex;                              flag = true;                          }                      }                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersection,The following statement contains a magic number: if (plane.DotNormal(velocityNormal) < 0f)              {                  if (plane.DotCoordinate(sphere.Center) < 0f)                  {                      return false;                  }                  if (plane.Intersects(sphere) != PlaneIntersectionType.Intersecting)                  {                      return false;                  }                  var a = Vertices[Indices[polyIndex * 3]];                  var b = Vertices[Indices[(polyIndex * 3) + 1]];                  var c = Vertices[Indices[(polyIndex * 3) + 2]];                  var p = Intersection.ClosestPointOnPlane(sphere.Center' plane);                  if (Intersection.PointInTriangle(p' a' b' c))                  {                      intersection.IntersectionPoint = p;                      intersection.IntersectionNormal = plane.Normal;                      intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(p' sphere.Center);                      intersection.Node = this;                      intersection.PolygonIndex = polyIndex;                      intersection.IntersectType = OCTreeIntersectionType.Inside;                      flag = true;                  }                  else                  {                      float num;                      Vector3 vector5;                      if (sphere.Contains(a) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = a;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - a);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(a' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(b) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = b;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - b);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(b' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(c) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = c;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - c);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(c' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' a' b' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' b' c' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          flag = true;                      }                      else                      {                          Intersection.ClosestPointOnSegment(sphere.Center' c' a' out num' out vector5);                          if (sphere.Contains(vector5) != ContainmentType.Disjoint)                          {                              intersection.IntersectionPoint = vector5;                              intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                              intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                              intersection.IntersectType = OCTreeIntersectionType.Edge;                              intersection.Node = this;                              intersection.PolygonIndex = polyIndex;                              flag = true;                          }                      }                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersection,The following statement contains a magic number: if (plane.DotNormal(velocityNormal) < 0f)              {                  if (plane.DotCoordinate(sphere.Center) < 0f)                  {                      return false;                  }                  if (plane.Intersects(sphere) != PlaneIntersectionType.Intersecting)                  {                      return false;                  }                  var a = Vertices[Indices[polyIndex * 3]];                  var b = Vertices[Indices[(polyIndex * 3) + 1]];                  var c = Vertices[Indices[(polyIndex * 3) + 2]];                  var p = Intersection.ClosestPointOnPlane(sphere.Center' plane);                  if (Intersection.PointInTriangle(p' a' b' c))                  {                      intersection.IntersectionPoint = p;                      intersection.IntersectionNormal = plane.Normal;                      intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(p' sphere.Center);                      intersection.Node = this;                      intersection.PolygonIndex = polyIndex;                      intersection.IntersectType = OCTreeIntersectionType.Inside;                      flag = true;                  }                  else                  {                      float num;                      Vector3 vector5;                      if (sphere.Contains(a) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = a;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - a);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(a' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(b) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = b;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - b);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(b' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(c) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = c;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - c);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(c' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' a' b' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' b' c' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          flag = true;                      }                      else                      {                          Intersection.ClosestPointOnSegment(sphere.Center' c' a' out num' out vector5);                          if (sphere.Contains(vector5) != ContainmentType.Disjoint)                          {                              intersection.IntersectionPoint = vector5;                              intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                              intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                              intersection.IntersectType = OCTreeIntersectionType.Edge;                              intersection.Node = this;                              intersection.PolygonIndex = polyIndex;                              flag = true;                          }                      }                  }              }
Magic Number,WCell.Terrain.Legacy.OCTree,OCTreeNode,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeNode.cs,GetIntersection,The following statement contains a magic number: if (plane.DotNormal(velocityNormal) < 0f)              {                  if (plane.DotCoordinate(sphere.Center) < 0f)                  {                      return false;                  }                  if (plane.Intersects(sphere) != PlaneIntersectionType.Intersecting)                  {                      return false;                  }                  var a = Vertices[Indices[polyIndex * 3]];                  var b = Vertices[Indices[(polyIndex * 3) + 1]];                  var c = Vertices[Indices[(polyIndex * 3) + 2]];                  var p = Intersection.ClosestPointOnPlane(sphere.Center' plane);                  if (Intersection.PointInTriangle(p' a' b' c))                  {                      intersection.IntersectionPoint = p;                      intersection.IntersectionNormal = plane.Normal;                      intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(p' sphere.Center);                      intersection.Node = this;                      intersection.PolygonIndex = polyIndex;                      intersection.IntersectType = OCTreeIntersectionType.Inside;                      flag = true;                  }                  else                  {                      float num;                      Vector3 vector5;                      if (sphere.Contains(a) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = a;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - a);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(a' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(b) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = b;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - b);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(b' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      if (sphere.Contains(c) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = c;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - c);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(c' sphere.Center);                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          intersection.IntersectType = OCTreeIntersectionType.Point;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' a' b' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          return true;                      }                      Intersection.ClosestPointOnSegment(sphere.Center' b' c' out num' out vector5);                      if (sphere.Contains(vector5) != ContainmentType.Disjoint)                      {                          intersection.IntersectionPoint = vector5;                          intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                          intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                          intersection.IntersectType = OCTreeIntersectionType.Edge;                          intersection.Node = this;                          intersection.PolygonIndex = polyIndex;                          flag = true;                      }                      else                      {                          Intersection.ClosestPointOnSegment(sphere.Center' c' a' out num' out vector5);                          if (sphere.Contains(vector5) != ContainmentType.Disjoint)                          {                              intersection.IntersectionPoint = vector5;                              intersection.IntersectionNormal = Vector3.Normalize(sphere.Center - vector5);                              intersection.IntersectionDepth = sphere.Radius - Vector3.Distance(vector5' sphere.Center);                              intersection.IntersectType = OCTreeIntersectionType.Edge;                              intersection.Node = this;                              intersection.PolygonIndex = polyIndex;                              flag = true;                          }                      }                  }              }
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (corridor.NodeCount < 3)  			{  				if (corridor.NodeCount == 2)  				{  					// Two neighboring nodes:    					Vector3 newPoint;  					Vector3 right' left;    					// TODO: Project into 2d' so we can intersect two lines instead of a line and a plane    					// greedily span a vertical plane over the line between start and destination  					var start = corridor.Previous.PointOfReference;  					//var plane = new Plane(start' destination' new Vector3(start.X' start.Y' start.Z + 10));                        var startXY = corridor.Previous.PointOfReference.XY;  				    var endXY = destination.XY;    					// and then intersect the plane with the edge that we want to traverse  					mesh.GetInsideOrderedEdgePoints(corridor.Previous.Triangle' corridor.Edge' out right' out left);  				    var rightXY = right.XY;  				    var leftXY = left.XY;    					//if (!Intersection.ClosestPointToPlane(right' left' plane' out newPoint))  					//{  						// this is geometrically impossible but might happen due to numerical inaccuracy  						//Debugger.Break();  					//	newPoint = right;  					//}    				    Vector2 newPointXY;  				    if (Intersection.IntersectionOfLineSegments2D(startXY' endXY' rightXY' leftXY' out newPointXY))  				    {  				        float newZ;  				        if (newPointXY.LerpZ(start' destination' out newZ))  				        {  				            newPoint = new Vector3(newPointXY' newZ);  				        }  				        else  				        {  				            // this is geometrically impossible but might happen due to numerical inaccuracy  				            Debugger.Break();  				            newPoint = right;  				        }  				    }  				    else  				    {  				        // this is geometrically impossible but might happen due to numerical inaccuracy  				        Debugger.Break();  				        newPoint = right;  				    }                        path.Add(newPoint);  				}  			}  			else  			{  				// More than two nodes:  				    							//// if distance to new point is smaller than the threshold' replace' rather than add  							//var distToLast = lastLeft  							//if (distToLast < MinWaypointThreshold)  							//{    							//}  				// steer backwards through the corridor  				//Vector3 leftOrigin = destination' rightOrigin = destination;  				var origin = destination;  				Vector3 lastRight' lastLeft;  				int lastLeftIdx = -1' lastRightIdx = -1;  				var current = corridor;  				mesh.GetInsideOrderedEdgePoints(current.Previous.Triangle' current.Edge' out lastRight' out lastLeft);  				for (var i = corridor.NodeCount - 2; i > 0; i--)  				{  					current = current.Previous;    					// get the two points that span the traversed edge  					int leftIndex' rightIndex;  					mesh.GetEdgePointIndices(current.Previous.Triangle' current.Edge' out rightIndex' out leftIndex);    					var addedLeft = false;  					if (leftIndex != lastLeftIdx)  					{  						// cast new ray and see if the last point is still inside the corridor  						var left = mesh.Vertices[leftIndex];  						var lastLeft2D = lastRight.XY;  						var dir = left.XY - origin.XY;  						var normal = dir.RightNormal();    						var leftOrig2D = origin.XY;  						var toLastLeft = lastLeft2D - leftOrig2D;    						var dist = Vector2.Dot(toLastLeft' normal);    						if (dist - MathUtil.Epsilonf > 0)  						{  							// right of the left ray -> put obstructing vertex into path  							origin = lastLeft;  							path.Add(lastLeft);  							addedLeft = true;  						}    						lastLeft = left;  						lastLeftIdx = leftIndex;  					}    					if (rightIndex != lastRightIdx)  					{  						var right = mesh.Vertices[rightIndex];  						if (!addedLeft)  						{  							// cast new ray and see if the last point is still inside the corridor  							var lastRight2D = lastLeft.XY;  							var dir = right.XY - origin.XY;  							var normal = dir.RightNormal();    							var rightOrig2D = origin.XY;  							var toLastRight = lastRight2D - rightOrig2D;    							var dist = Vector2.Dot(toLastRight' normal);    							if (dist + MathUtil.Epsilonf < 0)  							{  								// left of the right ray -> put obstructing vertex into path  								origin = lastRight;  								path.Add(lastRight);  							}  						}  						lastRight = right;  						lastRightIdx = rightIndex;  					}      				}  			}
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (corridor.NodeCount < 3)  			{  				if (corridor.NodeCount == 2)  				{  					// Two neighboring nodes:    					Vector3 newPoint;  					Vector3 right' left;    					// TODO: Project into 2d' so we can intersect two lines instead of a line and a plane    					// greedily span a vertical plane over the line between start and destination  					var start = corridor.Previous.PointOfReference;  					//var plane = new Plane(start' destination' new Vector3(start.X' start.Y' start.Z + 10));                        var startXY = corridor.Previous.PointOfReference.XY;  				    var endXY = destination.XY;    					// and then intersect the plane with the edge that we want to traverse  					mesh.GetInsideOrderedEdgePoints(corridor.Previous.Triangle' corridor.Edge' out right' out left);  				    var rightXY = right.XY;  				    var leftXY = left.XY;    					//if (!Intersection.ClosestPointToPlane(right' left' plane' out newPoint))  					//{  						// this is geometrically impossible but might happen due to numerical inaccuracy  						//Debugger.Break();  					//	newPoint = right;  					//}    				    Vector2 newPointXY;  				    if (Intersection.IntersectionOfLineSegments2D(startXY' endXY' rightXY' leftXY' out newPointXY))  				    {  				        float newZ;  				        if (newPointXY.LerpZ(start' destination' out newZ))  				        {  				            newPoint = new Vector3(newPointXY' newZ);  				        }  				        else  				        {  				            // this is geometrically impossible but might happen due to numerical inaccuracy  				            Debugger.Break();  				            newPoint = right;  				        }  				    }  				    else  				    {  				        // this is geometrically impossible but might happen due to numerical inaccuracy  				        Debugger.Break();  				        newPoint = right;  				    }                        path.Add(newPoint);  				}  			}  			else  			{  				// More than two nodes:  				    							//// if distance to new point is smaller than the threshold' replace' rather than add  							//var distToLast = lastLeft  							//if (distToLast < MinWaypointThreshold)  							//{    							//}  				// steer backwards through the corridor  				//Vector3 leftOrigin = destination' rightOrigin = destination;  				var origin = destination;  				Vector3 lastRight' lastLeft;  				int lastLeftIdx = -1' lastRightIdx = -1;  				var current = corridor;  				mesh.GetInsideOrderedEdgePoints(current.Previous.Triangle' current.Edge' out lastRight' out lastLeft);  				for (var i = corridor.NodeCount - 2; i > 0; i--)  				{  					current = current.Previous;    					// get the two points that span the traversed edge  					int leftIndex' rightIndex;  					mesh.GetEdgePointIndices(current.Previous.Triangle' current.Edge' out rightIndex' out leftIndex);    					var addedLeft = false;  					if (leftIndex != lastLeftIdx)  					{  						// cast new ray and see if the last point is still inside the corridor  						var left = mesh.Vertices[leftIndex];  						var lastLeft2D = lastRight.XY;  						var dir = left.XY - origin.XY;  						var normal = dir.RightNormal();    						var leftOrig2D = origin.XY;  						var toLastLeft = lastLeft2D - leftOrig2D;    						var dist = Vector2.Dot(toLastLeft' normal);    						if (dist - MathUtil.Epsilonf > 0)  						{  							// right of the left ray -> put obstructing vertex into path  							origin = lastLeft;  							path.Add(lastLeft);  							addedLeft = true;  						}    						lastLeft = left;  						lastLeftIdx = leftIndex;  					}    					if (rightIndex != lastRightIdx)  					{  						var right = mesh.Vertices[rightIndex];  						if (!addedLeft)  						{  							// cast new ray and see if the last point is still inside the corridor  							var lastRight2D = lastLeft.XY;  							var dir = right.XY - origin.XY;  							var normal = dir.RightNormal();    							var rightOrig2D = origin.XY;  							var toLastRight = lastRight2D - rightOrig2D;    							var dist = Vector2.Dot(toLastRight' normal);    							if (dist + MathUtil.Epsilonf < 0)  							{  								// left of the right ray -> put obstructing vertex into path  								origin = lastRight;  								path.Add(lastRight);  							}  						}  						lastRight = right;  						lastRightIdx = rightIndex;  					}      				}  			}
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindPath,The following statement contains a magic number: if (corridor.NodeCount < 3)  			{  				if (corridor.NodeCount == 2)  				{  					// Two neighboring nodes:    					Vector3 newPoint;  					Vector3 right' left;    					// TODO: Project into 2d' so we can intersect two lines instead of a line and a plane    					// greedily span a vertical plane over the line between start and destination  					var start = corridor.Previous.PointOfReference;  					//var plane = new Plane(start' destination' new Vector3(start.X' start.Y' start.Z + 10));                        var startXY = corridor.Previous.PointOfReference.XY;  				    var endXY = destination.XY;    					// and then intersect the plane with the edge that we want to traverse  					mesh.GetInsideOrderedEdgePoints(corridor.Previous.Triangle' corridor.Edge' out right' out left);  				    var rightXY = right.XY;  				    var leftXY = left.XY;    					//if (!Intersection.ClosestPointToPlane(right' left' plane' out newPoint))  					//{  						// this is geometrically impossible but might happen due to numerical inaccuracy  						//Debugger.Break();  					//	newPoint = right;  					//}    				    Vector2 newPointXY;  				    if (Intersection.IntersectionOfLineSegments2D(startXY' endXY' rightXY' leftXY' out newPointXY))  				    {  				        float newZ;  				        if (newPointXY.LerpZ(start' destination' out newZ))  				        {  				            newPoint = new Vector3(newPointXY' newZ);  				        }  				        else  				        {  				            // this is geometrically impossible but might happen due to numerical inaccuracy  				            Debugger.Break();  				            newPoint = right;  				        }  				    }  				    else  				    {  				        // this is geometrically impossible but might happen due to numerical inaccuracy  				        Debugger.Break();  				        newPoint = right;  				    }                        path.Add(newPoint);  				}  			}  			else  			{  				// More than two nodes:  				    							//// if distance to new point is smaller than the threshold' replace' rather than add  							//var distToLast = lastLeft  							//if (distToLast < MinWaypointThreshold)  							//{    							//}  				// steer backwards through the corridor  				//Vector3 leftOrigin = destination' rightOrigin = destination;  				var origin = destination;  				Vector3 lastRight' lastLeft;  				int lastLeftIdx = -1' lastRightIdx = -1;  				var current = corridor;  				mesh.GetInsideOrderedEdgePoints(current.Previous.Triangle' current.Edge' out lastRight' out lastLeft);  				for (var i = corridor.NodeCount - 2; i > 0; i--)  				{  					current = current.Previous;    					// get the two points that span the traversed edge  					int leftIndex' rightIndex;  					mesh.GetEdgePointIndices(current.Previous.Triangle' current.Edge' out rightIndex' out leftIndex);    					var addedLeft = false;  					if (leftIndex != lastLeftIdx)  					{  						// cast new ray and see if the last point is still inside the corridor  						var left = mesh.Vertices[leftIndex];  						var lastLeft2D = lastRight.XY;  						var dir = left.XY - origin.XY;  						var normal = dir.RightNormal();    						var leftOrig2D = origin.XY;  						var toLastLeft = lastLeft2D - leftOrig2D;    						var dist = Vector2.Dot(toLastLeft' normal);    						if (dist - MathUtil.Epsilonf > 0)  						{  							// right of the left ray -> put obstructing vertex into path  							origin = lastLeft;  							path.Add(lastLeft);  							addedLeft = true;  						}    						lastLeft = left;  						lastLeftIdx = leftIndex;  					}    					if (rightIndex != lastRightIdx)  					{  						var right = mesh.Vertices[rightIndex];  						if (!addedLeft)  						{  							// cast new ray and see if the last point is still inside the corridor  							var lastRight2D = lastLeft.XY;  							var dir = right.XY - origin.XY;  							var normal = dir.RightNormal();    							var rightOrig2D = origin.XY;  							var toLastRight = lastRight2D - rightOrig2D;    							var dist = Vector2.Dot(toLastRight' normal);    							if (dist + MathUtil.Epsilonf < 0)  							{  								// left of the right ray -> put obstructing vertex into path  								origin = lastRight;  								path.Add(lastRight);  							}  						}  						lastRight = right;  						lastRightIdx = rightIndex;  					}      				}  			}
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,StringPull,The following statement contains a magic number: if (pairs.Count < 3) return;
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,StringPull,The following statement contains a magic number: for (var curIndex = 0; curIndex < (pairs.Count - 2); curIndex++)              {                  var curPair = pairs[curIndex];                  for (var nextIndex = (curIndex + 2); nextIndex < pairs.Count; nextIndex++)                  {                      var nextPair = pairs[nextIndex];                                            if (!HasLOSXY(curPair' nextPair)) continue;                        var removeAt = curIndex + 1;                      while(removeAt < nextIndex)                      {                          pairs.RemoveAt(removeAt);                          nextIndex--;                      }                  }              }
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,StringPull,The following statement contains a magic number: for (var curIndex = 0; curIndex < (pairs.Count - 2); curIndex++)              {                  var curPair = pairs[curIndex];                  for (var nextIndex = (curIndex + 2); nextIndex < pairs.Count; nextIndex++)                  {                      var nextPair = pairs[nextIndex];                                            if (!HasLOSXY(curPair' nextPair)) continue;                        var removeAt = curIndex + 1;                      while(removeAt < nextIndex)                      {                          pairs.RemoveAt(removeAt);                          nextIndex--;                      }                  }              }
Magic Number,WCell.Terrain.Pathfinding,Pathfinder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Pathfinding\Pathfinder.cs,FindCorridor,The following statement contains a magic number: do  			{  				// next round  				current = fringe.DeleteMin();    				// get the vertices and neighbors of the current triangle  				//var triangle = mesh.GetTriangle(current.Triangle);  				var neighbors = mesh.GetNeighborsOf(current.Triangle);    				//var poly = ((NavMesh)Mesh).Polygons[current.Triangle / 3];    				// iterate over all neighbors  				for (var edge = 0; edge < TerrainUtil.NeighborsPerTriangle; edge++)  				{  					var neighbor = neighbors[edge] * 3;    					if (neighbor < 0 || visited.Contains(neighbor)) continue;    					//var npoly = ((NavMesh)Mesh).Polygons[neighbor / 3];  					//var ntri = Mesh.GetTriangle(neighbor);    					visited.Add(neighbor);      					// determine the edge that we want to traverse    					Vector3 left' right;                      mesh.GetInsideOrderedEdgePoints(current.Triangle' edge' out right' out left);                      //switch (edge)                      //{                      //    case TerrainUtil.ABEdgeIndex:                      //        left = triangle.Point1;                      //        right = triangle.Point2;                      //        break;                      //    case TerrainUtil.CAEdgeIndex:                      //        left = triangle.Point3;                      //        right = triangle.Point1;                      //        break;                      //    case TerrainUtil.BCEdgeIndex:                      //        left = triangle.Point2;                      //        right = triangle.Point3;                      //        break;                      //    default:                      //        throw new Exception("Impossible");                      //}    					var refPoint = (left + right) / 2.0f;		// the middle of the edge to be traversed  					var dist = Vector3.Distance(refPoint' destination);  					var newItem = new SearchItem(neighbor' edge' dist' ref refPoint' current);    					if (triEnd == neighbor)  					{  						// we are done  						corridor = newItem;  						goto Done;  					}    				    fringe.Add(newItem);  				}  			} while (!fringe.IsEmpty);
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,ExportRecastInputMesh,The following statement contains a magic number: using (var file = new StreamWriter(filename))  			{  				foreach (var vertex in verts)  				{  					var v = vertex;  					RecastUtil.TransformWoWCoordsToRecastCoords(ref v);  					file.WriteLine("v {0} {1} {2}"' v.X' v.Y' v.Z);  				}    				// write faces  				var terrain = tile.Terrain;  				for (var i = 0; i < indices.Length; i += 3)  				{  					// ignore triangles that are completely submerged in a liquid  					var v1 = verts[indices[i]];  					var v2 = verts[indices[i+1]];  					var v3 = verts[indices[i+2]];  					                      if (terrain.GetLiquidType(v1) != LiquidType.None &&  						terrain.GetLiquidType(v2) != LiquidType.None &&  						terrain.GetLiquidType(v3) != LiquidType.None)  					{                          var triBottom = Single.MaxValue;  				        var triTop = Single.MinValue;  				        triBottom = Math.Min(triBottom' v1.Z);                          triBottom = Math.Min(triBottom' v2.Z);                          triBottom = Math.Min(triBottom' v3.Z);  				        triTop = Math.Max(triTop' v1.Z);                          triTop = Math.Max(triTop' v2.Z);                          triTop = Math.Max(triTop' v3.Z);    					    var triHeightAvg = (triTop - triBottom)*0.5f;                          var liqHeight = terrain.GetLiquidHeight(v1);  					    var avgTriLiqDepth = liqHeight - triHeightAvg;                                                    if (avgTriLiqDepth > 1.0f) continue;  					}    				    //file.WriteLine("f {0} {1} {2}"' indices[i] + 1' indices[i + 1] + 1' indices[i + 2] + 1);  					file.WriteLine("f {0} {1} {2}"' indices[i + 2] + 1' indices[i + 1] + 1' indices[i] + 1);  				}  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,ExportRecastInputMesh,The following statement contains a magic number: using (var file = new StreamWriter(filename))  			{  				foreach (var vertex in verts)  				{  					var v = vertex;  					RecastUtil.TransformWoWCoordsToRecastCoords(ref v);  					file.WriteLine("v {0} {1} {2}"' v.X' v.Y' v.Z);  				}    				// write faces  				var terrain = tile.Terrain;  				for (var i = 0; i < indices.Length; i += 3)  				{  					// ignore triangles that are completely submerged in a liquid  					var v1 = verts[indices[i]];  					var v2 = verts[indices[i+1]];  					var v3 = verts[indices[i+2]];  					                      if (terrain.GetLiquidType(v1) != LiquidType.None &&  						terrain.GetLiquidType(v2) != LiquidType.None &&  						terrain.GetLiquidType(v3) != LiquidType.None)  					{                          var triBottom = Single.MaxValue;  				        var triTop = Single.MinValue;  				        triBottom = Math.Min(triBottom' v1.Z);                          triBottom = Math.Min(triBottom' v2.Z);                          triBottom = Math.Min(triBottom' v3.Z);  				        triTop = Math.Max(triTop' v1.Z);                          triTop = Math.Max(triTop' v2.Z);                          triTop = Math.Max(triTop' v3.Z);    					    var triHeightAvg = (triTop - triBottom)*0.5f;                          var liqHeight = terrain.GetLiquidHeight(v1);  					    var avgTriLiqDepth = liqHeight - triHeightAvg;                                                    if (avgTriLiqDepth > 1.0f) continue;  					}    				    //file.WriteLine("f {0} {1} {2}"' indices[i] + 1' indices[i + 1] + 1' indices[i + 2] + 1);  					file.WriteLine("f {0} {1} {2}"' indices[i + 2] + 1' indices[i + 1] + 1' indices[i] + 1);  				}  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,ExportRecastInputMesh,The following statement contains a magic number: using (var file = new StreamWriter(filename))  			{  				foreach (var vertex in verts)  				{  					var v = vertex;  					RecastUtil.TransformWoWCoordsToRecastCoords(ref v);  					file.WriteLine("v {0} {1} {2}"' v.X' v.Y' v.Z);  				}    				// write faces  				var terrain = tile.Terrain;  				for (var i = 0; i < indices.Length; i += 3)  				{  					// ignore triangles that are completely submerged in a liquid  					var v1 = verts[indices[i]];  					var v2 = verts[indices[i+1]];  					var v3 = verts[indices[i+2]];  					                      if (terrain.GetLiquidType(v1) != LiquidType.None &&  						terrain.GetLiquidType(v2) != LiquidType.None &&  						terrain.GetLiquidType(v3) != LiquidType.None)  					{                          var triBottom = Single.MaxValue;  				        var triTop = Single.MinValue;  				        triBottom = Math.Min(triBottom' v1.Z);                          triBottom = Math.Min(triBottom' v2.Z);                          triBottom = Math.Min(triBottom' v3.Z);  				        triTop = Math.Max(triTop' v1.Z);                          triTop = Math.Max(triTop' v2.Z);                          triTop = Math.Max(triTop' v3.Z);    					    var triHeightAvg = (triTop - triBottom)*0.5f;                          var liqHeight = terrain.GetLiquidHeight(v1);  					    var avgTriLiqDepth = liqHeight - triHeightAvg;                                                    if (avgTriLiqDepth > 1.0f) continue;  					}    				    //file.WriteLine("f {0} {1} {2}"' indices[i] + 1' indices[i + 1] + 1' indices[i + 2] + 1);  					file.WriteLine("f {0} {1} {2}"' indices[i + 2] + 1' indices[i + 1] + 1' indices[i] + 1);  				}  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,ExportRecastInputMesh,The following statement contains a magic number: Console.WriteLine("Done. - Exported {0} triangles in: {1:0.000}s"'  									indices.Length / 3' (DateTime.Now - start).TotalSeconds);
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: var vertCount = vertComponentCount / 3;
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,SmashMesh,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out vertexList))  			{  				var min = new Vector3(Single.MaxValue' Single.MaxValue' Single.MaxValue);  				var max = new Vector3(Single.MinValue' Single.MinValue' Single.MinValue);    				for (int i = 0' v = 0; i < vertCount; i++' v += 3)  				{  					var vert = new Vector3(vertComponents[v]' vertComponents[v + 1]' vertComponents[v + 2]);  					RecastUtil.TransformRecastCoordsToWoWCoords(ref vert);  					vertexList.Add(vert);    					// expand bounding box  					min.X = Math.Min(min.X' vert.X);  					min.Y = Math.Min(min.Y' vert.Y);  					min.Z = Math.Min(min.Z' vert.Z);    					max.X = Math.Max(max.X' vert.X);  					max.Y = Math.Max(max.Y' vert.Y);  					max.Z = Math.Max(max.Z' vert.Z);  				}    				Min = min;  				Max = max;    				var vertices = EliminateDoubleVertices(vertexList' pIndices' totalPolyIndexCount);    				// polygon first pass -> Create polygons  				var polys = new NavMeshPolygon[polyCount];  				var polyEdgeIndex = 0;  				var p = 0;  				for (var i = 0; i < polyCount; i++)  				{  					var polyIndexCount = pIndexCounts[i];  					var poly = polys[i] = new NavMeshPolygon();  					poly.Indices = new int[polyIndexCount];  					poly.Neighbors = new int[polyIndexCount];    					Debug.Assert(3 == polyIndexCount);    					for (var j = 0; j < polyIndexCount; j++)  					{  						var idx = (int)pIndices[polyEdgeIndex + j];  						indices[p++] = idx;  						poly.Indices[j] = idx;  						poly.Neighbors[j] = -1;    						Debug.Assert(poly.Indices[j] >= 0 && poly.Indices[j] < vertCount);  					}    					// switch first and third index because our collision test needs the triangles to go in the other direction  					var tmp = poly.Indices[0];  					indices[p - 3] = poly.Indices[0] = poly.Indices[2];  					indices[p - 1] = poly.Indices[2] = tmp;    					polyEdgeIndex += polyIndexCount;  				}    				// polygon second pass -> Initialize neighbors  				polyEdgeIndex = 0;    				var undecidedNeighborRelations = new List<Tuple<int' int>>();  				for (var i = 0; i < polyCount; i++)  				{  					var poly = polys[i];  					var polyIndexCount = pIndexCounts[i];  					var a = poly.Indices[0];  					var b = poly.Indices[1];  					var c = poly.Indices[2];    					for (var j = 0; j < polyIndexCount; j++)  					{  						var neighbor = (int)pNeighbors[polyEdgeIndex + j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];    						// sort the neighbor poly into the array of neighbors' correctly  						var a2 = neighborPoly.Indices[0];  						var b2 = neighborPoly.Indices[1];  						var c2 = neighborPoly.Indices[2];      						var nCount = 0;  						var mask = 0;  						if (a == a2 || a == b2 || a == c2)  						{  							// some vertex matches the first vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointA;  						}  						if (b == a2 || b == b2 || b == c2)  						{  							// some vertex matches the second vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointB;  						}  						if (c == a2 || c == b2 || c == c2)  						{  							// some vertex matches the third vertex of the triangle  							nCount++;  							mask |= TerrainUtil.TrianglePointC;  						}      						//var va = vertices[a];  						//var vb = vertices[b];  						//var vc = vertices[c];  						//var ua = vertices[a2];  						//var ub = vertices[b2];  						//var uc = vertices[c2];    						//var vs = new List<Vector3>() { va' vb' vc };  						//var us = new List<Vector3>() { ua' ub' uc };  						//var mc = 0;  						//for (var ii = 0; ii < vs.Count; ii++)  						//{  						//    var vv = vs[ii];  						//    for (var jj = 0; jj < us.Count; jj++)  						//    {  						//        var uu = us[jj];  						//        if (vv.Equals(uu))  						//        {  						//            mc++;  						//            break;  						//        }  						//    }  						//}  						//Debug.Assert(mc == 2);  						//Debug.Assert(nCount == 2);    						if (nCount < 2)  						{  							undecidedNeighborRelations.Add(Tuple.Create(i' neighbor));  						}    						var edge = TerrainUtil.GetEdge(mask);  						if (edge != -1)  						{  							poly.Neighbors[edge] = neighbor;  						}  					}    					polyEdgeIndex += polyIndexCount;  				}    				// these relations are incorrect for some reason  				// the actual neighbor that is to replace the undecided neighbor is also in this set' though  				for (var i = 0; i < undecidedNeighborRelations.Count; i++)  				{  					var rel = undecidedNeighborRelations[i];    					var poly = polys[rel.Item1];  					var tri = poly.GetTriangle(vertices);    					for (var j = 0; j < undecidedNeighborRelations.Count; j++)  					{  						if (i == j) continue;    						var index2 = undecidedNeighborRelations[j].Item1;  						var poly2 = polys[index2];  						var tri2 = poly2.GetTriangle(vertices);    						var sharedMask = tri.GetSharedEdgeMask(tri2);  						var edge = TerrainUtil.GetEdge(sharedMask);  						if (edge != -1)  						{  							// the two share an edge  							poly.Neighbors[edge] = index2;  							break;  						}  					}  				}    				// make sure' the neighbor relation is symmetric  				for (var i = 0; i < polys.Length; i++)  				{  					var poly = polys[i];  					for (int j = 0; j < poly.Neighbors.Length; j++)  					{  						var neighbor = poly.Neighbors[j];  						if (neighbor == -1) continue;    						var neighborPoly = polys[neighbor];  						var found = false;  						for (var k = 0; k < neighborPoly.Neighbors.Length; k++)  						{  							var neighneigh = neighborPoly.Neighbors[k];  							if (neighneigh == i)  							{  								found = true;  								break;  							}  						}    						if (!found)  						{  							// neighbor of poly does not have poly as neighor  							// find the edge and insert the neighbor  							var tri = poly.GetTriangle(vertices);  							var tri2 = neighborPoly.GetTriangle(vertices);  							var sharedMask = tri2.GetSharedEdgeMask(tri);  							var edge = TerrainUtil.GetEdge(sharedMask);  							Debug.Assert(neighborPoly.Neighbors[edge] == -1);    							neighborPoly.Neighbors[edge] = i;  							break;  						}  					}  				}    				// create new NavMesh object  				Tile.NavMesh = new NavMesh(Tile' polys' vertices' indices);  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshBuilder.cs,EliminateDoubleVertices,The following statement contains a magic number: using (LargeObjectPools.Vector3ListPool.Borrow(out newVertices))  			{  				// TODO: Also recycle these  				var hashtable = new List<Tuple<int' Vector3>>[vertCount];    				var maxLength = Vector3.Distance(Min' Max);  				var actualIndices = new int[vertCount];  				for (var i = 0; i < vertices.Count; i++)  				{  					var vert = vertices[i];    					// use relative length as hash  					var len = Vector3.Distance(vert' Min) + MathUtil.Epsilonf; // prevent division by zero  					var index = (int)((len / maxLength) * vertCount - 1);    					// search through up to 3 candidate lists for vertices that are equal to this one  					var match = false;  					for (int j = Math.Max(0' index - 1)' maxj = Math.Min(vertCount - 1' index + 1); j < maxj; j++)  					{  						var neighborList = hashtable[j];  						if (neighborList != null)  						{  							foreach (var neighbor in neighborList)  							{  								if (neighbor.Item2.Equals(vert))  								{  									Debug.Assert(vert.Equals(neighbor.Item2));  									// we got a match -> Redirect index  									match = true;  									actualIndices[i] = neighbor.Item1;  								}  							}  						}  					}    					if (!match)  					{  						// no match -> add unique vertex  						var list = hashtable[index];  						if (list == null)  						{  							hashtable[index] = list = new List<Tuple<int' Vector3>>(5);  						}  						var actualIndex = newVertices.Count;  						list.Add(Tuple.Create(actualIndex' vert));  						actualIndices[i] = actualIndex;  						newVertices.Add(vert);  					}  				}    				// set vertices to the new list  				for (var i = 0; i < indexCount; i++)  				{  					var idx = indices[i];  					var origVert = vertices[(int) idx];  					var newVert = newVertices[actualIndices[idx]];  					Debug.Assert(origVert.Equals(newVert));  					indices[i] = (uint)actualIndices[idx];  				}    				return newVertices.ToArray();  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMesh,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMesh.cs,GetPotentialColliders,The following statement contains a magic number: for (var i = 0; i < Indices.Length; i += 3)  			{  				yield return i;  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMesh,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMesh.cs,GetNeighborsOf,The following statement contains a magic number: return Polygons[triIndex/3].Neighbors;
Magic Number,WCell.Terrain.Recast.NavMesh,NavMesh,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMesh.cs,GetTriangles,The following statement contains a magic number: foreach (var poly in Polygons)  			{                  // build indices  				for (var j = 2; j < poly.Indices.Length; j++)  				{  					indices.Add(poly.Indices[0]);  					indices.Add(poly.Indices[j - 1]);  					indices.Add(poly.Indices[j]);  				}  			}
Magic Number,WCell.Terrain.Recast.NavMesh,NavMeshPolygon,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Recast\NavMesh\NavMeshPolygon.cs,GetTriangle,The following statement contains a magic number: return new Triangle(verts[Indices[0]]' verts[Indices[1]]' verts[Indices[2]]);
Magic Number,WCell.Terrain.Tools,MapBoundaryUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\MapBoundaryUtil.cs,ExportBoundaries,The following statement contains a magic number: foreach (var wdt in WDTReader.ReadAllWDTs())  			{  				Vector3 min;  				Vector3 max;    				if (wdt.IsWMOOnly)  				{  					const float maxDim = TerrainConstants.TileSize * (32.0f);    					// No terrain' get the boundaries from the MODF  					min = wdt.WmoDefinitions[0].Extents.Min;  					max = wdt.WmoDefinitions[0].Extents.Max;    					var diff = Math.Max(max.X - min.X' max.Y - min.Y);  					if ((min.X + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.X - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.X = min.X - newdiff;  					}    					if ((min.Y + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.Y - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.Y = min.Y - newdiff;  					}    					max.X = min.X + diff;  					max.Y = min.Y + diff;  				}  				else  				{  					var minX = TerrainConstants.TilesPerMapSide;  					var maxX = 0;  					var minY = TerrainConstants.TilesPerMapSide;  					var maxY = 0;  					for (var y = 0; y < TerrainConstants.TilesPerMapSide; y++)  					{  						for (var x = 0; x < TerrainConstants.TilesPerMapSide; x++)  						{  							if (!wdt.TileProfile[x' y]) continue;  							minX = Math.Min(minX' x);  							maxX = Math.Max(maxX' x);  							minY = Math.Min(minY' y);  							maxY = Math.Max(maxY' y);  						}  					}    					var diff = Math.Max(maxX - minX' maxY - minY);  					if ((minX + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minX - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minX = minX - newdiff;  					}    					if ((minY + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minY - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minY = minY - newdiff;  					}    					maxX = minX + diff;  					maxY = minY + diff;    					var maxXLoc = TerrainConstants.TileSize * (32 - minX);  					var maxYLoc = TerrainConstants.TileSize * (32 - minY);  					var minXLoc = TerrainConstants.TileSize * (31 - maxX);  					var minYLoc = TerrainConstants.TileSize * (31 - maxY);    					//var maxXLoc = TerrainConstants.TileSize * (maxX - 32);  					//var maxYLoc = TerrainConstants.TileSize * (maxY - 32);  					//var minXLoc = TerrainConstants.TileSize * (minX - 32);  					//var minYLoc = TerrainConstants.TileSize * (minY - 32);    					min = new Vector3(minXLoc' minYLoc' -2048.0f);  					max = new Vector3(maxXLoc' maxYLoc' 2048.0f);    					// Convert to in-game coordinates  					var temp = min.X;  					min.X = min.Y;  					min.Y = temp;    					temp = max.X;  					max.X = max.Y;  					max.Y = temp;  				}    				// TODO: Map bounds that in the file are a little off  				min.X -= 200.0f;  				min.Y -= 200.0f;  				max.X += 200.0f;  				max.Y += 200.0f;    				// Some bounding boxes (specifically the ones for the WMO-only tiles) have incorrect Z spans  				min.Z = -2048.0f;  				max.Z = 2048.0f;    				//text.WriteLine(dbcMapEntry.Id + "\t" + wdtName + "\tMin: " + min + "\tMax: " + max);  				Boundaries[(int)wdt.Entry.Id] = new BoundingBox(min' max);  			}
Magic Number,WCell.Terrain.Tools,MapBoundaryUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\MapBoundaryUtil.cs,ExportBoundaries,The following statement contains a magic number: foreach (var wdt in WDTReader.ReadAllWDTs())  			{  				Vector3 min;  				Vector3 max;    				if (wdt.IsWMOOnly)  				{  					const float maxDim = TerrainConstants.TileSize * (32.0f);    					// No terrain' get the boundaries from the MODF  					min = wdt.WmoDefinitions[0].Extents.Min;  					max = wdt.WmoDefinitions[0].Extents.Max;    					var diff = Math.Max(max.X - min.X' max.Y - min.Y);  					if ((min.X + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.X - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.X = min.X - newdiff;  					}    					if ((min.Y + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.Y - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.Y = min.Y - newdiff;  					}    					max.X = min.X + diff;  					max.Y = min.Y + diff;  				}  				else  				{  					var minX = TerrainConstants.TilesPerMapSide;  					var maxX = 0;  					var minY = TerrainConstants.TilesPerMapSide;  					var maxY = 0;  					for (var y = 0; y < TerrainConstants.TilesPerMapSide; y++)  					{  						for (var x = 0; x < TerrainConstants.TilesPerMapSide; x++)  						{  							if (!wdt.TileProfile[x' y]) continue;  							minX = Math.Min(minX' x);  							maxX = Math.Max(maxX' x);  							minY = Math.Min(minY' y);  							maxY = Math.Max(maxY' y);  						}  					}    					var diff = Math.Max(maxX - minX' maxY - minY);  					if ((minX + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minX - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minX = minX - newdiff;  					}    					if ((minY + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minY - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minY = minY - newdiff;  					}    					maxX = minX + diff;  					maxY = minY + diff;    					var maxXLoc = TerrainConstants.TileSize * (32 - minX);  					var maxYLoc = TerrainConstants.TileSize * (32 - minY);  					var minXLoc = TerrainConstants.TileSize * (31 - maxX);  					var minYLoc = TerrainConstants.TileSize * (31 - maxY);    					//var maxXLoc = TerrainConstants.TileSize * (maxX - 32);  					//var maxYLoc = TerrainConstants.TileSize * (maxY - 32);  					//var minXLoc = TerrainConstants.TileSize * (minX - 32);  					//var minYLoc = TerrainConstants.TileSize * (minY - 32);    					min = new Vector3(minXLoc' minYLoc' -2048.0f);  					max = new Vector3(maxXLoc' maxYLoc' 2048.0f);    					// Convert to in-game coordinates  					var temp = min.X;  					min.X = min.Y;  					min.Y = temp;    					temp = max.X;  					max.X = max.Y;  					max.Y = temp;  				}    				// TODO: Map bounds that in the file are a little off  				min.X -= 200.0f;  				min.Y -= 200.0f;  				max.X += 200.0f;  				max.Y += 200.0f;    				// Some bounding boxes (specifically the ones for the WMO-only tiles) have incorrect Z spans  				min.Z = -2048.0f;  				max.Z = 2048.0f;    				//text.WriteLine(dbcMapEntry.Id + "\t" + wdtName + "\tMin: " + min + "\tMax: " + max);  				Boundaries[(int)wdt.Entry.Id] = new BoundingBox(min' max);  			}
Magic Number,WCell.Terrain.Tools,MapBoundaryUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\MapBoundaryUtil.cs,ExportBoundaries,The following statement contains a magic number: foreach (var wdt in WDTReader.ReadAllWDTs())  			{  				Vector3 min;  				Vector3 max;    				if (wdt.IsWMOOnly)  				{  					const float maxDim = TerrainConstants.TileSize * (32.0f);    					// No terrain' get the boundaries from the MODF  					min = wdt.WmoDefinitions[0].Extents.Min;  					max = wdt.WmoDefinitions[0].Extents.Max;    					var diff = Math.Max(max.X - min.X' max.Y - min.Y);  					if ((min.X + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.X - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.X = min.X - newdiff;  					}    					if ((min.Y + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.Y - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.Y = min.Y - newdiff;  					}    					max.X = min.X + diff;  					max.Y = min.Y + diff;  				}  				else  				{  					var minX = TerrainConstants.TilesPerMapSide;  					var maxX = 0;  					var minY = TerrainConstants.TilesPerMapSide;  					var maxY = 0;  					for (var y = 0; y < TerrainConstants.TilesPerMapSide; y++)  					{  						for (var x = 0; x < TerrainConstants.TilesPerMapSide; x++)  						{  							if (!wdt.TileProfile[x' y]) continue;  							minX = Math.Min(minX' x);  							maxX = Math.Max(maxX' x);  							minY = Math.Min(minY' y);  							maxY = Math.Max(maxY' y);  						}  					}    					var diff = Math.Max(maxX - minX' maxY - minY);  					if ((minX + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minX - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minX = minX - newdiff;  					}    					if ((minY + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minY - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minY = minY - newdiff;  					}    					maxX = minX + diff;  					maxY = minY + diff;    					var maxXLoc = TerrainConstants.TileSize * (32 - minX);  					var maxYLoc = TerrainConstants.TileSize * (32 - minY);  					var minXLoc = TerrainConstants.TileSize * (31 - maxX);  					var minYLoc = TerrainConstants.TileSize * (31 - maxY);    					//var maxXLoc = TerrainConstants.TileSize * (maxX - 32);  					//var maxYLoc = TerrainConstants.TileSize * (maxY - 32);  					//var minXLoc = TerrainConstants.TileSize * (minX - 32);  					//var minYLoc = TerrainConstants.TileSize * (minY - 32);    					min = new Vector3(minXLoc' minYLoc' -2048.0f);  					max = new Vector3(maxXLoc' maxYLoc' 2048.0f);    					// Convert to in-game coordinates  					var temp = min.X;  					min.X = min.Y;  					min.Y = temp;    					temp = max.X;  					max.X = max.Y;  					max.Y = temp;  				}    				// TODO: Map bounds that in the file are a little off  				min.X -= 200.0f;  				min.Y -= 200.0f;  				max.X += 200.0f;  				max.Y += 200.0f;    				// Some bounding boxes (specifically the ones for the WMO-only tiles) have incorrect Z spans  				min.Z = -2048.0f;  				max.Z = 2048.0f;    				//text.WriteLine(dbcMapEntry.Id + "\t" + wdtName + "\tMin: " + min + "\tMax: " + max);  				Boundaries[(int)wdt.Entry.Id] = new BoundingBox(min' max);  			}
Magic Number,WCell.Terrain.Tools,MapBoundaryUtil,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\MapBoundaryUtil.cs,ExportBoundaries,The following statement contains a magic number: foreach (var wdt in WDTReader.ReadAllWDTs())  			{  				Vector3 min;  				Vector3 max;    				if (wdt.IsWMOOnly)  				{  					const float maxDim = TerrainConstants.TileSize * (32.0f);    					// No terrain' get the boundaries from the MODF  					min = wdt.WmoDefinitions[0].Extents.Min;  					max = wdt.WmoDefinitions[0].Extents.Max;    					var diff = Math.Max(max.X - min.X' max.Y - min.Y);  					if ((min.X + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.X - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.X = min.X - newdiff;  					}    					if ((min.Y + diff) > maxDim)  					{  						var newdiff = maxDim - diff;  						if ((min.Y - newdiff) < -maxDim)  						{  							throw new Exception("Can't square map: " + wdt.Name);  						}  						min.Y = min.Y - newdiff;  					}    					max.X = min.X + diff;  					max.Y = min.Y + diff;  				}  				else  				{  					var minX = TerrainConstants.TilesPerMapSide;  					var maxX = 0;  					var minY = TerrainConstants.TilesPerMapSide;  					var maxY = 0;  					for (var y = 0; y < TerrainConstants.TilesPerMapSide; y++)  					{  						for (var x = 0; x < TerrainConstants.TilesPerMapSide; x++)  						{  							if (!wdt.TileProfile[x' y]) continue;  							minX = Math.Min(minX' x);  							maxX = Math.Max(maxX' x);  							minY = Math.Min(minY' y);  							maxY = Math.Max(maxY' y);  						}  					}    					var diff = Math.Max(maxX - minX' maxY - minY);  					if ((minX + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minX - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minX = minX - newdiff;  					}    					if ((minY + diff) > TerrainConstants.TilesPerMapSide)  					{  						var newdiff = TerrainConstants.TilesPerMapSide - diff;  						if ((minY - newdiff) < 0)  						{  							throw new Exception("Can't square this map.");  						}  						minY = minY - newdiff;  					}    					maxX = minX + diff;  					maxY = minY + diff;    					var maxXLoc = TerrainConstants.TileSize * (32 - minX);  					var maxYLoc = TerrainConstants.TileSize * (32 - minY);  					var minXLoc = TerrainConstants.TileSize * (31 - maxX);  					var minYLoc = TerrainConstants.TileSize * (31 - maxY);    					//var maxXLoc = TerrainConstants.TileSize * (maxX - 32);  					//var maxYLoc = TerrainConstants.TileSize * (maxY - 32);  					//var minXLoc = TerrainConstants.TileSize * (minX - 32);  					//var minYLoc = TerrainConstants.TileSize * (minY - 32);    					min = new Vector3(minXLoc' minYLoc' -2048.0f);  					max = new Vector3(maxXLoc' maxYLoc' 2048.0f);    					// Convert to in-game coordinates  					var temp = min.X;  					min.X = min.Y;  					min.Y = temp;    					temp = max.X;  					max.X = max.Y;  					max.Y = temp;  				}    				// TODO: Map bounds that in the file are a little off  				min.X -= 200.0f;  				min.Y -= 200.0f;  				max.X += 200.0f;  				max.Y += 200.0f;    				// Some bounding boxes (specifically the ones for the WMO-only tiles) have incorrect Z spans  				min.Z = -2048.0f;  				max.Z = 2048.0f;    				//text.WriteLine(dbcMapEntry.Id + "\t" + wdtName + "\tMin: " + min + "\tMax: " + max);  				Boundaries[(int)wdt.Entry.Id] = new BoundingBox(min' max);  			}
Magic Number,WCell.Terrain.Tools,ZoneTileSetWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneGridWriter.cs,WriteMethod,The following statement contains a magic number: for (var i = 0; i < tileSets.Length; i++)  			{  				var tileSet = tileSets[i];  				var map = (MapId)i;  				if (tileSet == null)  				{  					continue;  				}    				writer.WriteLine("sets[(int)MapId.{0}] = tiles = new ZoneTileSet();"' map);                    // Rows along the x-axis  				for (var x = 0; x < TerrainConstants.TilesPerMapSide; x++)  				{                      // Columns along the y-axis  					for (var y = 0; y < TerrainConstants.TilesPerMapSide; y++)  					{  						var grid = tileSet.ZoneGrids[y' x];  						if (grid is ZoneGrid && ((ZoneGrid)grid).ZoneIds != null)  						{  							var sameId = true;  							var str = new StringBuilder(10000);  							var declStr = string.Format("tiles.ZoneGrids[{0}'{1}] = "' y' x);  							str.Append(string.Format("new ZoneGrid(new uint[{0}'{0}] "' TerrainConstants.ChunksPerTileSide));  							str.Append("{");  							for (var col = 0; col < TerrainConstants.ChunksPerTileSide; col++)  							{  								//str.Append(writer.BaseWriter.Indent + "\t");  								str.Append(GetLine(((ZoneGrid)grid).ZoneIds' col' TerrainConstants.ChunksPerTileSide' ref sameId));  								if (col < TerrainConstants.ChunksPerTileSide - 1)  								{  									str.Append("'");  								}  								//str.AppendLine();  							}  							str.Append("});");  							if (sameId)  							{  								var zoneId = ((ZoneGrid)grid).ZoneIds[0' 0];  								str = new StringBuilder(string.Format("new SimpleZoneGrid({0});"' zoneId));  							}    							writer.WriteLine(declStr + str);  						}  					}  				}  			}
Magic Number,WCell.Terrain.Tools,ZoneTileSetWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneGridWriter.cs,GetLine,The following statement contains a magic number: var str = new StringBuilder("{ "' 1000);
Magic Number,WCell.Terrain.Tools,ZoneBoundaryWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneBoundaryWriter.cs,GetTileSets,The following statement contains a magic number: if (!wdt.IsWMOOnly)  			{  				var tileSet = new ZoneTileSet();  				Tiles[(int) wdt.MapId] = tileSet;    				ZoneGrid grid;                    // Rows are along the x-axis  				for (var x = 0; x < 64; x++)  				{                      // Columns are along the y-axis  					for (var y = 0; y < 64; y++)  					{  						if (!wdt.TileProfile[y' x]) continue;  						++count;  						var adt = ADTReader.ReadADT(wdt' x' y);  						if (adt == null) continue;    						tileSet.ZoneGrids[y' x] = grid = new ZoneGrid(new uint[TerrainConstants.ChunksPerTileSide' TerrainConstants.ChunksPerTileSide]);  						                          // Rows along the x-axis   						for (var chunkX = 0; chunkX < 16; chunkX++)  						{                              // Columns along the y-axis  							for (var chunkY = 0; chunkY < 16; chunkY++)  							{  								var areaId = adt.GetADTChunk(chunkY' chunkX).Header.AreaId;  								if (Enum.IsDefined(typeof(ZoneId)' areaId))  								{  									grid.ZoneIds[chunkY' chunkX] = (uint)areaId;  								}  								else  								{  									grid.ZoneIds[chunkY' chunkX] = 0;  								}  							}  						}  						//return tiles;  					}  				}  			}  			else  			{  				log.Info("Could not read Zones from WMO: " + wdt.MapId);  			}
Magic Number,WCell.Terrain.Tools,ZoneBoundaryWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneBoundaryWriter.cs,GetTileSets,The following statement contains a magic number: if (!wdt.IsWMOOnly)  			{  				var tileSet = new ZoneTileSet();  				Tiles[(int) wdt.MapId] = tileSet;    				ZoneGrid grid;                    // Rows are along the x-axis  				for (var x = 0; x < 64; x++)  				{                      // Columns are along the y-axis  					for (var y = 0; y < 64; y++)  					{  						if (!wdt.TileProfile[y' x]) continue;  						++count;  						var adt = ADTReader.ReadADT(wdt' x' y);  						if (adt == null) continue;    						tileSet.ZoneGrids[y' x] = grid = new ZoneGrid(new uint[TerrainConstants.ChunksPerTileSide' TerrainConstants.ChunksPerTileSide]);  						                          // Rows along the x-axis   						for (var chunkX = 0; chunkX < 16; chunkX++)  						{                              // Columns along the y-axis  							for (var chunkY = 0; chunkY < 16; chunkY++)  							{  								var areaId = adt.GetADTChunk(chunkY' chunkX).Header.AreaId;  								if (Enum.IsDefined(typeof(ZoneId)' areaId))  								{  									grid.ZoneIds[chunkY' chunkX] = (uint)areaId;  								}  								else  								{  									grid.ZoneIds[chunkY' chunkX] = 0;  								}  							}  						}  						//return tiles;  					}  				}  			}  			else  			{  				log.Info("Could not read Zones from WMO: " + wdt.MapId);  			}
Magic Number,WCell.Terrain.Tools,ZoneBoundaryWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneBoundaryWriter.cs,GetTileSets,The following statement contains a magic number: if (!wdt.IsWMOOnly)  			{  				var tileSet = new ZoneTileSet();  				Tiles[(int) wdt.MapId] = tileSet;    				ZoneGrid grid;                    // Rows are along the x-axis  				for (var x = 0; x < 64; x++)  				{                      // Columns are along the y-axis  					for (var y = 0; y < 64; y++)  					{  						if (!wdt.TileProfile[y' x]) continue;  						++count;  						var adt = ADTReader.ReadADT(wdt' x' y);  						if (adt == null) continue;    						tileSet.ZoneGrids[y' x] = grid = new ZoneGrid(new uint[TerrainConstants.ChunksPerTileSide' TerrainConstants.ChunksPerTileSide]);  						                          // Rows along the x-axis   						for (var chunkX = 0; chunkX < 16; chunkX++)  						{                              // Columns along the y-axis  							for (var chunkY = 0; chunkY < 16; chunkY++)  							{  								var areaId = adt.GetADTChunk(chunkY' chunkX).Header.AreaId;  								if (Enum.IsDefined(typeof(ZoneId)' areaId))  								{  									grid.ZoneIds[chunkY' chunkX] = (uint)areaId;  								}  								else  								{  									grid.ZoneIds[chunkY' chunkX] = 0;  								}  							}  						}  						//return tiles;  					}  				}  			}  			else  			{  				log.Info("Could not read Zones from WMO: " + wdt.MapId);  			}
Magic Number,WCell.Terrain.Tools,ZoneBoundaryWriter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Tools\ZoneBoundaryWriter.cs,GetTileSets,The following statement contains a magic number: if (!wdt.IsWMOOnly)  			{  				var tileSet = new ZoneTileSet();  				Tiles[(int) wdt.MapId] = tileSet;    				ZoneGrid grid;                    // Rows are along the x-axis  				for (var x = 0; x < 64; x++)  				{                      // Columns are along the y-axis  					for (var y = 0; y < 64; y++)  					{  						if (!wdt.TileProfile[y' x]) continue;  						++count;  						var adt = ADTReader.ReadADT(wdt' x' y);  						if (adt == null) continue;    						tileSet.ZoneGrids[y' x] = grid = new ZoneGrid(new uint[TerrainConstants.ChunksPerTileSide' TerrainConstants.ChunksPerTileSide]);  						                          // Rows along the x-axis   						for (var chunkX = 0; chunkX < 16; chunkX++)  						{                              // Columns along the y-axis  							for (var chunkY = 0; chunkY < 16; chunkY++)  							{  								var areaId = adt.GetADTChunk(chunkY' chunkX).Header.AreaId;  								if (Enum.IsDefined(typeof(ZoneId)' areaId))  								{  									grid.ZoneIds[chunkY' chunkX] = (uint)areaId;  								}  								else  								{  									grid.ZoneIds[chunkY' chunkX] = 0;  								}  							}  						}  						//return tiles;  					}  				}  			}  			else  			{  				log.Info("Could not read Zones from WMO: " + wdt.MapId);  			}
Magic Number,WCell.Terrain.MPQ.DBC,DBCMapEntryConverter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\DBC\MapDBCEntry.cs,ConvertTo,The following statement contains a magic number: i = 21;
Magic Number,WCell.Terrain.MPQ.DBC,DBCMapEntryConverter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\DBC\MapDBCEntry.cs,ConvertTo,The following statement contains a magic number: i = 39;
Magic Number,WCell.Terrain.MPQ.DBC,DBCMapEntryConverter,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\DBC\MapDBCEntry.cs,ConvertTo,The following statement contains a magic number: i = 56;
Magic Number,WCell.Terrain.MPQ,WDT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\WDT.cs,FillTileProfile,The following statement contains a magic number: foreach(var file in fileList)              {                  var fileName = Path.GetFileNameWithoutExtension(file);                  if (string.IsNullOrEmpty(fileName)) continue;                                    var parts = fileName.Split(new [] {'_'});                  var y = int.Parse(parts[1]);                  var x = int.Parse(parts[2]);                    TileProfile[x' y] = true;              }
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithQSlimSimplification,The following statement contains a magic number: var numTris = (tileIndices.Count / 3);
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithQSlimSimplification,The following statement contains a magic number: slim.Simplify(numTris / 2);
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithTerraSimplification,The following statement contains a magic number: for (var x = 0; x < TerrainConstants.ChunksPerTileSide; x++)  			{  				for (var y = 0; y < TerrainConstants.ChunksPerTileSide; y++)  				{  					var chunk = Chunks[x' y];  					var heights = chunk.Heights.GetLowResMapMatrix();                      var holes = (chunk.HolesMask > 0) ? chunk.HolesMap : EmptyHolesArray;    					// Add the height map values' inserting them into their correct positions  					for (var unitRow = 0; unitRow <= TerrainConstants.UnitsPerChunkSide; unitRow++)  					{  						for (var unitCol = 0; unitCol <= TerrainConstants.UnitsPerChunkSide; unitCol++)  						{  							var tileX = x * TerrainConstants.UnitsPerChunkSide + unitRow;  							var tileY = y * TerrainConstants.UnitsPerChunkSide + unitCol;    							tileHeights[tileX' tileY] = heights[unitRow' unitCol] + chunk.MedianHeight;    							if (unitCol == TerrainConstants.UnitsPerChunkSide) continue;  							if (unitRow == TerrainConstants.UnitsPerChunkSide) continue;    							// Add the hole vertices to the pre-insertion 'script'  							if (!holes[unitRow / 2' unitCol / 2]) continue;    							tileHoles.AddUnique(new Index2  							{  								Y = tileY'  								X = tileX  							});    							tileHoles.AddUnique(new Index2  							{  								Y = Math.Min(tileY + 1' heightsPerTileSide)'  								X = tileX  							});    							tileHoles.AddUnique(new Index2  							{  								Y = tileY'  								X = Math.Min(tileX + 1' heightsPerTileSide)  							});    							tileHoles.AddUnique(new Index2  							{  								Y = Math.Min(tileY + 1' heightsPerTileSide)'  								X = Math.Min(tileX + 1' heightsPerTileSide)  							});  						}  					}  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithTerraSimplification,The following statement contains a magic number: for (var x = 0; x < TerrainConstants.ChunksPerTileSide; x++)  			{  				for (var y = 0; y < TerrainConstants.ChunksPerTileSide; y++)  				{  					var chunk = Chunks[x' y];  					var heights = chunk.Heights.GetLowResMapMatrix();                      var holes = (chunk.HolesMask > 0) ? chunk.HolesMap : EmptyHolesArray;    					// Add the height map values' inserting them into their correct positions  					for (var unitRow = 0; unitRow <= TerrainConstants.UnitsPerChunkSide; unitRow++)  					{  						for (var unitCol = 0; unitCol <= TerrainConstants.UnitsPerChunkSide; unitCol++)  						{  							var tileX = x * TerrainConstants.UnitsPerChunkSide + unitRow;  							var tileY = y * TerrainConstants.UnitsPerChunkSide + unitCol;    							tileHeights[tileX' tileY] = heights[unitRow' unitCol] + chunk.MedianHeight;    							if (unitCol == TerrainConstants.UnitsPerChunkSide) continue;  							if (unitRow == TerrainConstants.UnitsPerChunkSide) continue;    							// Add the hole vertices to the pre-insertion 'script'  							if (!holes[unitRow / 2' unitCol / 2]) continue;    							tileHoles.AddUnique(new Index2  							{  								Y = tileY'  								X = tileX  							});    							tileHoles.AddUnique(new Index2  							{  								Y = Math.Min(tileY + 1' heightsPerTileSide)'  								X = tileX  							});    							tileHoles.AddUnique(new Index2  							{  								Y = tileY'  								X = Math.Min(tileX + 1' heightsPerTileSide)  							});    							tileHoles.AddUnique(new Index2  							{  								Y = Math.Min(tileY + 1' heightsPerTileSide)'  								X = Math.Min(tileX + 1' heightsPerTileSide)  							});  						}  					}  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithTerraSimplification,The following statement contains a magic number: foreach (var index in tileHoles)  			{  				var count = 0;  				for (var i = -1; i < 2; i++)  				{  					for (var j = -1; j < 2; j++)  					{  						if (!tileHoles.Contains(new Index2  						{  							X = index.X + i'  							Y = index.Y + j  						})) continue;  						count++;  					}  				}  				if (count != 9) continue;  				allHoleIndices.AddUnique(index);  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithTerraSimplification,The following statement contains a magic number: foreach (var index in tileHoles)  			{  				var count = 0;  				for (var i = -1; i < 2; i++)  				{  					for (var j = -1; j < 2; j++)  					{  						if (!tileHoles.Contains(new Index2  						{  							X = index.X + i'  							Y = index.Y + j  						})) continue;  						count++;  					}  				}  				if (count != 9) continue;  				allHoleIndices.AddUnique(index);  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateMapWithTerraSimplification,The following statement contains a magic number: foreach (var index in tileHoles)  			{  				var count = 0;  				for (var i = -1; i < 2; i++)  				{  					for (var j = -1; j < 2; j++)  					{  						if (!tileHoles.Contains(new Index2  						{  							X = index.X + i'  							Y = index.Y + j  						})) continue;  						count++;  					}  				}  				if (count != 9) continue;  				allHoleIndices.AddUnique(index);  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateLiquidVertices,The following statement contains a magic number: for (var xStep = 0; xStep <= TerrainConstants.UnitsPerChunkSide; xStep++)  			{  				for (var yStep = 0; yStep < 9; yStep++)  				{  					var xPos = TerrainConstants.CenterPoint - (TileX * TerrainConstants.TileSize) -  							   (indexX * TerrainConstants.ChunkSize) - (xStep * TerrainConstants.UnitSize);  					var yPos = TerrainConstants.CenterPoint - (TileY * TerrainConstants.TileSize) -  							   (indexY * TerrainConstants.ChunkSize) - (yStep * TerrainConstants.UnitSize);    					if (((xStep < bounds.X) || ((xStep - bounds.X) > bounds.Height)) ||  						((yStep < bounds.Y) || ((yStep - bounds.Y) > bounds.Width)))  					{  						continue;  					}    					var zPos = mh2OHeightMap[yStep - bounds.Y' xStep - bounds.X];    					var position = new Vector3(xPos' yPos' zPos);    					vertices.Add(position);  					count++;  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateLiquidIndices,The following statement contains a magic number: for (int r = bounds.X; r < (bounds.X + bounds.Height); r++)  			{  				for (int c = bounds.Y; c < (bounds.Y + bounds.Width); c++)  				{  					var row = r - bounds.X;  					var col = c - bounds.Y;    					if (!renderMap[col' row] && ((bounds.Height != 8) || (bounds.Width != 8))) continue;  					indices.Add(offset + ((row + 1) * (bounds.Width + 1) + col));  					indices.Add(offset + (row * (bounds.Width + 1) + col));  					indices.Add(offset + (row * (bounds.Width + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (bounds.Width + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (bounds.Width + 1) + col));  					indices.Add(offset + (row * (bounds.Width + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateLiquidIndices,The following statement contains a magic number: for (int r = bounds.X; r < (bounds.X + bounds.Height); r++)  			{  				for (int c = bounds.Y; c < (bounds.Y + bounds.Width); c++)  				{  					var row = r - bounds.X;  					var col = c - bounds.Y;    					if (!renderMap[col' row] && ((bounds.Height != 8) || (bounds.Width != 8))) continue;  					indices.Add(offset + ((row + 1) * (bounds.Width + 1) + col));  					indices.Add(offset + (row * (bounds.Width + 1) + col));  					indices.Add(offset + (row * (bounds.Width + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (bounds.Width + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (bounds.Width + 1) + col));  					indices.Add(offset + (row * (bounds.Width + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: var holesMap = new bool[4' 4];
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: var holesMap = new bool[4' 4];
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GenerateHeightIndices,The following statement contains a magic number: for (var row = 0; row < 8; row++)  			{  				for (var col = 0; col < 8; col++)  				{  					if (holesMap[row / 2' col / 2]) continue;  					//{  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));    					//    indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					//    indices.Add(offset + ((row + 1) * (8 + 1) + col));  					//    indices.Add(offset + (row * (8 + 1) + col + 1));  					//    continue;  					//}  					//* The order metter*/  					/*This 3 index add the up triangle  								*  								*0--1--2  								*| /| /  								*|/ |/   								*9  10 11  								*/    					indices.Add(offset + ((row + 1) * (8 + 1) + col)); //9 ... 10  					indices.Add(offset + (row * (8 + 1) + col)); //0 ... 1  					indices.Add(offset + (row * (8 + 1) + col + 1)); //1 ... 2    					/*This 3 index add the low triangle  								 *  								 *0  1   2  								 *  /|  /|  								 * / | / |  								 *9--10--11  								 */    					indices.Add(offset + ((row + 1) * (8 + 1) + col + 1));  					indices.Add(offset + ((row + 1) * (8 + 1) + col));  					indices.Add(offset + (row * (8 + 1) + col + 1));  				}  			}
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetTerrainMesh,The following statement contains a magic number: for (var x = 0; x < TerrainConstants.ChunksPerTileSide; x++)              {                  for (var y = 0; y < TerrainConstants.ChunksPerTileSide; y++)                  {                      var chunk = Chunks[x' y];                      var heights = chunk.Heights.GetLowResMapMatrix();                      var holes = (chunk.HolesMask > 0) ? chunk.HolesMap : EmptyHolesArray;                        // Add the height map values' inserting them into their correct positions                      for (var unitX = 0; unitX <= TerrainConstants.UnitsPerChunkSide; unitX++)                      {                          for (var unitY = 0; unitY <= TerrainConstants.UnitsPerChunkSide; unitY++)                          {                              var tileX = (x*TerrainConstants.UnitsPerChunkSide) + unitX;                              var tileY = (y*TerrainConstants.UnitsPerChunkSide) + unitY;                                var vertIndex = tileVertLocations[tileX' tileY];                              if (vertIndex == -1)                              {                                  var xPos = TerrainConstants.CenterPoint                                             - (TileX * TerrainConstants.TileSize)                                             - (tileX * TerrainConstants.UnitSize);                                  var yPos = TerrainConstants.CenterPoint                                             - (TileY * TerrainConstants.TileSize)                                             - (tileY * TerrainConstants.UnitSize);                                  var zPos = (heights[unitX' unitY] + chunk.MedianHeight);                                  tileVertLocations[tileX' tileY] = tileVerts.Count;                                  tileVerts.Add(new Vector3(xPos' yPos' zPos));                              }                                  if (unitY == TerrainConstants.UnitsPerChunkSide) continue;                              if (unitX == TerrainConstants.UnitsPerChunkSide) continue;                                tileHolesMap[tileX' tileY] = holes[unitX / 2' unitY / 2];                          }                      }                  }              }
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetTerrainMesh,The following statement contains a magic number: for (var x = 0; x < TerrainConstants.ChunksPerTileSide; x++)              {                  for (var y = 0; y < TerrainConstants.ChunksPerTileSide; y++)                  {                      var chunk = Chunks[x' y];                      var heights = chunk.Heights.GetLowResMapMatrix();                      var holes = (chunk.HolesMask > 0) ? chunk.HolesMap : EmptyHolesArray;                        // Add the height map values' inserting them into their correct positions                      for (var unitX = 0; unitX <= TerrainConstants.UnitsPerChunkSide; unitX++)                      {                          for (var unitY = 0; unitY <= TerrainConstants.UnitsPerChunkSide; unitY++)                          {                              var tileX = (x*TerrainConstants.UnitsPerChunkSide) + unitX;                              var tileY = (y*TerrainConstants.UnitsPerChunkSide) + unitY;                                var vertIndex = tileVertLocations[tileX' tileY];                              if (vertIndex == -1)                              {                                  var xPos = TerrainConstants.CenterPoint                                             - (TileX * TerrainConstants.TileSize)                                             - (tileX * TerrainConstants.UnitSize);                                  var yPos = TerrainConstants.CenterPoint                                             - (TileY * TerrainConstants.TileSize)                                             - (tileY * TerrainConstants.UnitSize);                                  var zPos = (heights[unitX' unitY] + chunk.MedianHeight);                                  tileVertLocations[tileX' tileY] = tileVerts.Count;                                  tileVerts.Add(new Vector3(xPos' yPos' zPos));                              }                                  if (unitY == TerrainConstants.UnitsPerChunkSide) continue;                              if (unitX == TerrainConstants.UnitsPerChunkSide) continue;                                tileHolesMap[tileX' tileY] = holes[unitX / 2' unitY / 2];                          }                      }                  }              }
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetSurfaceNormal,The following statement contains a magic number: if (chunk.HolesMap[unitCoord.X / 2' unitCoord.Y / 2]) return Vector3.Zero;
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetSurfaceNormal,The following statement contains a magic number: if (chunk.HolesMap[unitCoord.X / 2' unitCoord.Y / 2]) return Vector3.Zero;
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetInterpolatedHeight,The following statement contains a magic number: if (chunk.HolesMap[unitCoord.X / 2' unitCoord.Y / 2]) return float.NaN;
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,GetInterpolatedHeight,The following statement contains a magic number: if (chunk.HolesMap[unitCoord.X / 2' unitCoord.Y / 2]) return float.NaN;
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,EnsureClockwiseWinding,The following statement contains a magic number: if (indices == null || indices.Count < 3) return;
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,EnsureClockwiseWinding,The following statement contains a magic number: for (var i = 0; i < indices.Count; i += 3)              {                    var vert0 = vertices[indices[i + 0]];                  var vert1 = vertices[indices[i + 1]];                  var vert2 = vertices[indices[i + 2]];                    if (!GeometryHelpers.IsCounterClockwiseXY(vert0' vert1' vert2)) continue;                    var temp = indices[i + 1];                  indices[i + 1] = indices[i + 2];                  indices[i + 2] = temp;              }
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,EnsureClockwiseWinding,The following statement contains a magic number: for (var i = 0; i < indices.Count; i += 3)              {                    var vert0 = vertices[indices[i + 0]];                  var vert1 = vertices[indices[i + 1]];                  var vert2 = vertices[indices[i + 2]];                    if (!GeometryHelpers.IsCounterClockwiseXY(vert0' vert1' vert2)) continue;                    var temp = indices[i + 1];                  indices[i + 1] = indices[i + 2];                  indices[i + 2] = temp;              }
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,EnsureClockwiseWinding,The following statement contains a magic number: for (var i = 0; i < indices.Count; i += 3)              {                    var vert0 = vertices[indices[i + 0]];                  var vert1 = vertices[indices[i + 1]];                  var vert2 = vertices[indices[i + 2]];                    if (!GeometryHelpers.IsCounterClockwiseXY(vert0' vert1' vert2)) continue;                    var temp = indices[i + 1];                  indices[i + 1] = indices[i + 2];                  indices[i + 2] = temp;              }
Magic Number,WCell.Terrain.MPQ,ADT,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADT.cs,EnsureClockwiseWinding,The following statement contains a magic number: for (var i = 0; i < indices.Count; i += 3)              {                    var vert0 = vertices[indices[i + 0]];                  var vert1 = vertices[indices[i + 1]];                  var vert2 = vertices[indices[i + 2]];                    if (!GeometryHelpers.IsCounterClockwiseXY(vert0' vert1' vert2)) continue;                    var temp = indices[i + 1];                  indices[i + 1] = indices[i + 2];                  indices[i + 2] = temp;              }
Magic Number,WCell.Terrain.MPQ,Signatures,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Signatures.cs,ToBin,The following statement contains a magic number: var b2 = (uint) ca[2];
Magic Number,WCell.Terrain.MPQ,Signatures,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Signatures.cs,ToBin,The following statement contains a magic number: var b3 = (uint) ca[3];
Magic Number,WCell.Terrain.MPQ,Signatures,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Signatures.cs,ToBin,The following statement contains a magic number: var r = b3 | (b2 << 8) | (b1 << 16) | (b0 << 24);
Magic Number,WCell.Terrain.MPQ,Signatures,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Signatures.cs,ToBin,The following statement contains a magic number: var r = b3 | (b2 << 8) | (b1 << 16) | (b0 << 24);
Magic Number,WCell.Terrain.MPQ,Signatures,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Signatures.cs,ToBin,The following statement contains a magic number: var r = b3 | (b2 << 8) | (b1 << 16) | (b0 << 24);
Magic Number,WCell.Terrain.MPQ,Index3,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Index3.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = Index0.GetHashCode();                  result = (result*397) ^ Index1.GetHashCode();                  result = (result*397) ^ Index2.GetHashCode();                  return result;              }
Magic Number,WCell.Terrain.MPQ,Index3,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\Index3.cs,GetHashCode,The following statement contains a magic number: unchecked              {                  int result = Index0.GetHashCode();                  result = (result*397) ^ Index1.GetHashCode();                  result = (result*397) ^ Index2.GetHashCode();                  return result;              }
Magic Number,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadMCNK,The following statement contains a magic number: h.predTex = new ushort[8];
Magic Number,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadMCNK,The following statement contains a magic number: for (var i = 0; i < 8; i++)              {                  h.predTex[i] = fileReader.ReadUInt16();              }
Magic Number,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadMCNK,The following statement contains a magic number: h.nEffectDoodad = new byte[8];
Magic Number,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadMCNK,The following statement contains a magic number: for (var i = 0; i < 8; i++)              {                  h.nEffectDoodad[i] = fileReader.ReadByte();              }
Magic Number,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadMCVT,The following statement contains a magic number: for (int i = 0; i < 145; i++)              {                  chunk.Heights.Heights[i] = fileReader.ReadSingle();              }
Magic Number,WCell.Terrain.Serialization,ADTChunkReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTChunkReader.cs,ReadMCNR,The following statement contains a magic number: for (int i = 0; i < 145; i++)              {                  var normalZ = fileReader.ReadSByte();                  var normalX = fileReader.ReadSByte();                  var normalY = fileReader.ReadSByte();                  chunk.Normals.Normals[i] = new Vector3(-(float)normalX / 127.0f' normalY / 127.0f'                                                               -(float)normalZ / 127.0f);              }
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMCIN,The following statement contains a magic number: adt.MapChunkInfo = new MapChunkInfo[256];
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMCIN,The following statement contains a magic number: for (var i = 0; i < 256; i++)  			{  				var mcin = new MapChunkInfo  							   {  								   Offset = fileReader.ReadUInt32()'  								   Size = fileReader.ReadUInt32()'  								   Flags = fileReader.ReadUInt32()'  								   AsyncId = fileReader.ReadUInt32()  							   };    				adt.MapChunkInfo[i] = mcin;  			}
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMMID,The following statement contains a magic number: uint count = size / 4;
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMWID,The following statement contains a magic number: uint count = size / 4;
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMH2O,The following statement contains a magic number: MH20Header[] mh20Header = new MH20Header[256];
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMH2O,The following statement contains a magic number: for (int i = 0; i < 256; i++)  			{  				mh20Header[i].ofsData1 = fileReader.ReadUInt32();  				mh20Header[i].LayerCount = fileReader.ReadUInt32();  				mh20Header[i].ofsData2 = fileReader.ReadUInt32();  			}
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMH2O,The following statement contains a magic number: for (int x = 0; x < 16; x++)  			{  				// Columns  				for (int y = 0; y < 16; y++)  				{  					// Indexing is [col' row]  					adt.LiquidInfo[x' y] = ProcessMH2O(fileReader' mh20Header[x * 16 + y]' ofsMH2O);  				}  			}
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMH2O,The following statement contains a magic number: for (int x = 0; x < 16; x++)  			{  				// Columns  				for (int y = 0; y < 16; y++)  				{  					// Indexing is [col' row]  					adt.LiquidInfo[x' y] = ProcessMH2O(fileReader' mh20Header[x * 16 + y]' ofsMH2O);  				}  			}
Magic Number,WCell.Terrain.Serialization,ADTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\ADTReader.cs,ReadMH2O,The following statement contains a magic number: for (int x = 0; x < 16; x++)  			{  				// Columns  				for (int y = 0; y < 16; y++)  				{  					// Indexing is [col' row]  					adt.LiquidInfo[x' y] = ProcessMH2O(fileReader' mh20Header[x * 16 + y]' ofsMH2O);  				}  			}
Magic Number,WCell.Terrain.Serialization,M2Reader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\M2Reader.cs,ReadVertices,The following statement contains a magic number: for (int i = 0; i < vertInfo.Count; i++)              {                  var mv = new ModelVertices                               {                                   Position = br.ReadVector3()'                                   BoneWeight = br.ReadBytes(4)'                                   BoneIndices = br.ReadBytes(4)'                                   Normal = br.ReadVector3()'                                   TextureCoordinates = br.ReadVector2()'                                   Float_1 = br.ReadSingle()'                                   Float_2 = br.ReadSingle()                               };                    model.Vertices[i] = mv;              }
Magic Number,WCell.Terrain.Serialization,M2Reader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\M2Reader.cs,ReadVertices,The following statement contains a magic number: for (int i = 0; i < vertInfo.Count; i++)              {                  var mv = new ModelVertices                               {                                   Position = br.ReadVector3()'                                   BoneWeight = br.ReadBytes(4)'                                   BoneIndices = br.ReadBytes(4)'                                   Normal = br.ReadVector3()'                                   TextureCoordinates = br.ReadVector2()'                                   Float_1 = br.ReadSingle()'                                   Float_2 = br.ReadSingle()                               };                    model.Vertices[i] = mv;              }
Magic Number,WCell.Terrain.Serialization,M2Reader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\M2Reader.cs,ReadBoundingTriangles,The following statement contains a magic number: model.BoundingTriangles = new Index3[btInfo.Count / 3];
Magic Number,WCell.Terrain.Serialization,M2Reader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\M2Reader.cs,TransformM2,The following statement contains a magic number: var rotateZ = Matrix.CreateRotationZ(MathHelper.ToRadians(mddf.OrientationB + 180));
Magic Number,WCell.Terrain.Serialization,WDTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WDTReader.cs,PrintProfile,The following statement contains a magic number: using (var file = new StreamWriter(wdt.Entry.InternalName + ".wdtprofile.txt"))  			{  				for (var x = 0; x < 64; x++)  				{  					for (var y = 0; y < 64; y++)  					{  						if (wdt.TileProfile[y' x])  						{  							file.Write("X");  						}  						else  						{  							file.Write(".");  						}  					}  					file.WriteLine();  				}  			}
Magic Number,WCell.Terrain.Serialization,WDTReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WDTReader.cs,PrintProfile,The following statement contains a magic number: using (var file = new StreamWriter(wdt.Entry.InternalName + ".wdtprofile.txt"))  			{  				for (var x = 0; x < 64; x++)  				{  					for (var y = 0; y < 64; y++)  					{  						if (wdt.TileProfile[y' x])  						{  							file.Write("X");  						}  						else  						{  							file.Write(".");  						}  					}  					file.WriteLine();  				}  			}
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadRequiredChunks,The following statement contains a magic number: if (type == Signatures.MOGP)              {                  size = 68; // MOGP is stupid and wants to use the entire rest of the file as its size                  ReadMOGP(br' currentWMOGroup);              }              else              {                  Console.WriteLine("ERROR: WMO Group did not have required chunk MOGP");              }
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOGP,The following statement contains a magic number: group.Header.Fogs = file.ReadBytes(4);
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOPY,The following statement contains a magic number: group.TriangleCount = size / 2;
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOVT,The following statement contains a magic number: group.VertexCount = size/(sizeof (float)*3);
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOTV1,The following statement contains a magic number: group.TextureVertices1 = new Vector2[size/8];
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOTV2,The following statement contains a magic number: group.TextureVertices2 = new Vector2[size / 8];
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOBA,The following statement contains a magic number: group.Batches = new RenderBatch[size/24];
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOLR,The following statement contains a magic number: group.LightReferences = new ushort[size/2];
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMODR,The following statement contains a magic number: group.DoodadReferences = new ushort[size / 2];
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOBR,The following statement contains a magic number: uint count = size / 2;
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOCV1,The following statement contains a magic number: group.VertexColors1 = new Color4[size/4];
Magic Number,WCell.Terrain.Serialization,WMOGroupReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOGroupReader.cs,ReadMOCV2,The following statement contains a magic number: group.VertexColors2 = new Color4[size / 4];
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMOPV,The following statement contains a magic number: uint vertexCount = wmo.Header.PortalCount*4;
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMOVV,The following statement contains a magic number: wmo.VisibleVertices = new Vector3[size/12];
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMOVB,The following statement contains a magic number: uint blockCount = size/4;
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMODS,The following statement contains a magic number: for (int i = 0; i < wmo.Header.DoodadSetCount; i++)              {                  var d = new DoodadSet                  {                      SetName = br.ReadFixedString(20)'                      FirstInstanceIndex = br.ReadUInt32()'                      InstanceCount = br.ReadUInt32()                  };                  br.ReadInt32(); // padding                    wmo.DoodadSets[i] = d;              }
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMODD,The following statement contains a magic number: wmo.DoodadDefinitions = new DoodadDefinition[size / 40];
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMFOG,The following statement contains a magic number: wmo.Fogs = new Fog[size/48];
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,ReadMCVP,The following statement contains a magic number: wmo.ComplexVolumePlanes = new Plane[size/(4*sizeof (float))];
Magic Number,WCell.Terrain.Serialization,WMOReader,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Serialization\WMOReader.cs,TransformWMO,The following statement contains a magic number: var rotateZ = Matrix.CreateRotationZ((currentMODF.OrientationB + 180) * MathUtil.RadiansPerDegree);
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: var normals = new Vector3[9' 9];
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: var normals = new Vector3[9' 9];
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapNormals,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapNormals.cs,GetLowResNormalMatrix,The following statement contains a magic number: for (var x = 0; x < 17; x++)              {                  if (x % 2 != 0) continue;                  for (var y = 0; y < 9; y++)                  {                      var count = ((x / 2) * 9) + ((x / 2) * 8) + y;                      normals[y' x / 2] = Normals[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: var heights = new float[81];
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapArray,The following statement contains a magic number: for (var r = 0; r < 17; r++)              {                  if (r % 2 != 0) continue;                  for (var c = 0; c < 9; c++)                  {                      var count = ((r / 2) * 9) + ((r / 2) * 8) + c;                      heights[c + ((r / 2) * 8)] = heights[count];                  }              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapMatrix,The following statement contains a magic number: lowResHeightsMatrix = new float[9'9];
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapMatrix,The following statement contains a magic number: lowResHeightsMatrix = new float[9'9];
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapMatrix,The following statement contains a magic number: for (var x = 0; x < 9; x++)              {                  for (var y = 0; y < 9; y++)                  {                      lowResHeightsMatrix[x' y] = Heights[index++];                  }                  index += 8;              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapMatrix,The following statement contains a magic number: for (var x = 0; x < 9; x++)              {                  for (var y = 0; y < 9; y++)                  {                      lowResHeightsMatrix[x' y] = Heights[index++];                  }                  index += 8;              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetLowResMapMatrix,The following statement contains a magic number: for (var x = 0; x < 9; x++)              {                  for (var y = 0; y < 9; y++)                  {                      lowResHeightsMatrix[x' y] = Heights[index++];                  }                  index += 8;              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetHighResMapMatrix,The following statement contains a magic number: highResHeightsMatrix = new float[8' 8];
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetHighResMapMatrix,The following statement contains a magic number: highResHeightsMatrix = new float[8' 8];
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetHighResMapMatrix,The following statement contains a magic number: var index = 9;
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetHighResMapMatrix,The following statement contains a magic number: for (var x = 0; x < 8; x++)              {                  for (var y = 0; y < 8; y++)                  {                      highResHeightsMatrix[x' y] = Heights[index++];                  }                  index += 9;              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetHighResMapMatrix,The following statement contains a magic number: for (var x = 0; x < 8; x++)              {                  for (var y = 0; y < 8; y++)                  {                      highResHeightsMatrix[x' y] = Heights[index++];                  }                  index += 9;              }
Magic Number,WCell.Terrain.MPQ.ADTs,MapVertices,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MapVertices.cs,GetHighResMapMatrix,The following statement contains a magic number: for (var x = 0; x < 8; x++)              {                  for (var y = 0; y < 8; y++)                  {                      highResHeightsMatrix[x' y] = Heights[index++];                  }                  index += 9;              }
Magic Number,WCell.Terrain.MPQ.ADTs,MH2O,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MPQ\ADTs\MH2O.cs,GetRenderBitMapMatrix,The following statement contains a magic number: if (enabled == null)  			{  				enabled = new bool[TerrainConstants.UnitsPerChunkSide' TerrainConstants.UnitsPerChunkSide];  				for (var r = 0; r < Header.Height; r++)  				{  					for (var c = 7; c >= 0; c--)  					{  						enabled[c' r] = (((RenderBitMap[r] >> c) & 1) == 1);    					}  				}  			}
Missing Default,WCell.Terrain,MeshClipper,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\MeshClipper.cs,ClipMesh,The following switch statement is missing a default case: switch (Clip())              {                  case ClipperResponse.AllClipped:                      {                          return;                      }                  case ClipperResponse.SomeClipped:                      {                          GenerateOutputMesh(outVerts' outIdxs);                          return;                      }                  case ClipperResponse.NoneClipped:                      {                          outVerts = vertices;                          outIdxs = indices;                          return;                      }              }
Missing Default,WCell.Terrain,TerrainTile,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\TerrainTile.cs,GetNeighborsOf,The following switch statement is missing a default case: switch (mask)  						{  							case TerrainUtil.ABEdgeMask:  								// neighbor shares a and b  								neighbors[TerrainUtil.ABEdgeIndex] = i;  								break;  							case TerrainUtil.ACEdgeMask:  								// second shares a and c  								neighbors[TerrainUtil.CAEdgeIndex] = i;  								break;  							case TerrainUtil.BCEdgeMask:  								// neighbor shares b and c  								neighbors[TerrainUtil.BCEdgeIndex] = i;  								break;    						}
Missing Default,WCell.Terrain.Legacy.OCTree,OCTreeBuilder,C:\repos\WCell_WCell\WCell-Terrain\WCell.Terrain\Legacy\OCTree\OCTreeBuilder.cs,Split,The following switch statement is missing a default case: switch (num4)                  {                      case 3:                      case 4:                          newPolys[0] = new OCTPoly(vectorArray[0]' vectorArray[1]' vectorArray[2]);                          numPolys = 1;                          if (num4 == 4)                          {                              newPolys[1] = new OCTPoly(vectorArray[0]' vectorArray[2]' vectorArray[3]);                              numPolys = 2;                          }                          break;                  }
