Implementation smell,Namespace,Class,File,Method,Description
Long Method,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The method has 191 lines of code.
Long Method,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The method has 140 lines of code.
Long Method,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The method has 223 lines of code.
Complex Method,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,Cyclomatic complexity of the method is 9
Complex Method,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,Cyclomatic complexity of the method is 8
Complex Method,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,Cyclomatic complexity of the method is 20
Complex Method,JP.KShoji.Driver.Midi.Util,UsbMidiDeviceUtils,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Util\UsbMidiDeviceUtils.cs,FindMidiEndpoint,Cyclomatic complexity of the method is 10
Complex Method,JP.KShoji.Driver.Usb.Util,DeviceFilter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Usb\Util\DeviceFilter.cs,ParseXml,Cyclomatic complexity of the method is 8
Complex Method,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,SetMessage,Cyclomatic complexity of the method is 8
Complex Method,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetDataLength,Cyclomatic complexity of the method is 28
Complex Method,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,Cyclomatic complexity of the method is 20
Complex Method,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,Cyclomatic complexity of the method is 83
Complex Method,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,Cyclomatic complexity of the method is 105
Complex Method,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,Cyclomatic complexity of the method is 9
Complex Method,Sharpen,HttpURLConnection,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\HttpURLConnection.cs,SetRequestProperty,Cyclomatic complexity of the method is 24
Complex Method,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,Cyclomatic complexity of the method is 23
Complex Method,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Set,Cyclomatic complexity of the method is 20
Complex Method,Sharpen,MessageFormat,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\MessageFormat.cs,Format,Cyclomatic complexity of the method is 9
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiRPNReceived,The method has 6 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiNRPNReceived,The method has 6 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiCableEvents,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiControlChange,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiMiscellaneousFunctionCodes,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiNoteOff,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiNoteOn,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnMidiPolyphonicAftertouch,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiRPNReceived,The method has 6 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiNRPNReceived,The method has 6 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiCableEvents,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiControlChange,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiMiscellaneousFunctionCodes,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiNoteOff,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiNoteOn,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnMidiPolyphonicAftertouch,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Device,MidiInputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiInputDevice.cs,MidiInputDevice,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiMiscellaneousFunctionCodes,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiCableEvents,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiNoteOff,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiNoteOn,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiPolyphonicAftertouch,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiControlChange,The method has 5 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiRPNReceived,The method has 6 parameters.
Long Parameter List,JP.KShoji.Driver.Midi.Listener,OnMidiInputEventListener,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Listener\OnMidiInputEventListener.cs,OnMidiNRPNReceived,The method has 6 parameters.
Long Parameter List,JP.KShoji.Driver.Usb.Util,DeviceFilter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Usb\Util\DeviceFilter.cs,DeviceFilter,The method has 5 parameters.
Long Parameter List,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiDevice.cs,UsbMidiDevice,The method has 5 parameters.
Long Parameter List,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,RegionMatches,The method has 6 parameters.
Long Statement,JP.KShoji.Driver.Midi.Activity,AbstractMultipleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractMultipleMidiActivity.cs,OnCreate,The length of the statement  "	deviceConnectionWatcher = new MidiDeviceConnectionWatcher (GetApplicationContext ()' usbManager' deviceAttachedListener' deviceDetachedListener); " is 145.
Long Statement,JP.KShoji.Driver.Midi.Activity,AbstractSingleMidiActivity,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Activity\AbstractSingleMidiActivity.cs,OnCreate,The length of the statement  "	deviceConnectionWatcher = new MidiDeviceConnectionWatcher (GetApplicationContext ()' usbManager' deviceAttachedListener' deviceDetachedListener); " is 145.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The length of the statement  "	writeBuffer [0] = unchecked((byte)(((cable & unchecked((int)(0xf))) << 4) | (codeIndexNumber & unchecked((int)(0xf))))); " is 120.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,The length of the statement  "		SendMidiMessage (unchecked((int)(0x2))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' 0); " is 122.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,The length of the statement  "		SendMidiMessage (unchecked((int)(0x3))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' bytes [2] & unchecked((int)(0xff))); " is 155.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The length of the statement  "	Log.D (Constants.TAG' string.Empty + buffer.Length + " bytes of " + buffer.Length + " bytes has been queued for transfering."); " is 127.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiNoteOff,The length of the statement  "	SendMidiMessage (unchecked((int)(0x8))' cable' unchecked((int)(0x80)) | (channel & unchecked((int)(0xf)))' note' velocity); " is 123.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiNoteOn,The length of the statement  "	SendMidiMessage (unchecked((int)(0x9))' cable' unchecked((int)(0x90)) | (channel & unchecked((int)(0xf)))' note' velocity); " is 123.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiPolyphonicAftertouch,The length of the statement  "	SendMidiMessage (unchecked((int)(0xa))' cable' unchecked((int)(0xa0)) | (channel & unchecked((int)(0xf)))' note' pressure); " is 123.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiControlChange,The length of the statement  "	SendMidiMessage (unchecked((int)(0xb))' cable' unchecked((int)(0xb0)) | (channel & unchecked((int)(0xf)))' function' value); " is 124.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiChannelAftertouch,The length of the statement  "	SendMidiMessage (unchecked((int)(0xd))' cable' unchecked((int)(0xd0)) | (channel & unchecked((int)(0xf)))' pressure' 0); " is 120.
Long Statement,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiPitchWheel,The length of the statement  "	SendMidiMessage (unchecked((int)(0xe))' cable' unchecked((int)(0xe0)) | (channel & unchecked((int)(0xf)))' amount & unchecked((int)(0x7f))' (amount >> 7) & unchecked((int)(0x7f))); " is 180.
Long Statement,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The length of the statement  "			midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1); " is 170.
Long Statement,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The length of the statement  "				midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1); " is 173.
Long Statement,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The length of the statement  "			midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f))); " is 198.
Long Statement,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The length of the statement  "				midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f))); " is 201.
Long Statement,JP.KShoji.Driver.Midi.Util,UsbMidiDeviceUtils,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Util\UsbMidiDeviceUtils.cs,FindMidiEndpoint,The length of the statement  "			if ((endpoint.GetType () == UsbConstants.USB_ENDPOINT_XFER_BULK || endpoint.GetType () == UsbConstants.USB_ENDPOINT_XFER_INT)) { " is 128.
Long Statement,JP.KShoji.Driver.Usb.Util,DeviceFilter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Usb\Util\DeviceFilter.cs,Matches,The length of the statement  "	return ((usbClass == -1 || clasz == usbClass) && (usbSubclass == -1 || subclass == usbSubclass) && (usbProtocol == -1 || protocol == usbProtocol)); " is 147.
Long Statement,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,WriteMidiValues,The length of the statement  "		data [currentOff++] = unchecked((byte)(((value & (unchecked((int)(0x7f)) << shift)) >> shift) | unchecked((int)(0x80)))); " is 121.
Long Statement,JP.KShoji.Javax.Sound.Midi,MidiSystem,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MidiSystem.cs,FindAllUsbMidiDevices,The length of the statement  "		UsbEndpoint inputEndpoint = UsbMidiDeviceUtils.FindMidiEndpoint (usbDevice' usbInterface' UsbConstants.USB_DIR_IN' deviceFilters); " is 130.
Long Statement,JP.KShoji.Javax.Sound.Midi,MidiSystem,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MidiSystem.cs,FindAllUsbMidiDevices,The length of the statement  "		UsbEndpoint outputEndpoint = UsbMidiDeviceUtils.FindMidiEndpoint (usbDevice' usbInterface' UsbConstants.USB_DIR_OUT' deviceFilters); " is 132.
Long Statement,JP.KShoji.Javax.Sound.Midi,MidiSystem,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MidiSystem.cs,Initialize,The length of the statement  "	deviceConnectionWatcher = new MidiDeviceConnectionWatcher (context' usbManager' deviceAttachedListener' deviceDetachedListener); " is 128.
Long Statement,JP.KShoji.Javax.Sound.Midi,SysexMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\SysexMessage.cs,SetMessage,The length of the statement  "		throw new InvalidMidiDataException ("Invalid status byte for SysexMessage: 0x" + Sharpen.Extensions.ToHexString (status)); " is 122.
Long Statement,JP.KShoji.Javax.Sound.Midi,SysexMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\SysexMessage.cs,SetMessage,The length of the statement  "		throw new InvalidMidiDataException ("Invalid status byte for SysexMessage: 0x" + Sharpen.Extensions.ToHexString (status)); " is 122.
Long Statement,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiDevice.cs,GetDeviceInfo,The length of the statement  "	return new MidiDevice.Info (usbDevice.GetDeviceName ()' string.Format ("vendorId: %x' productId: %x"' usbDevice.GetVendorId ()' usbDevice.GetProductId ())' "deviceId:" + usbDevice.GetDeviceId ()' "interfaceId:" + usbInterface.GetId ()); " is 236.
Long Statement,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The length of the statement  "					outputDevice.SendMidiControlChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ()); " is 125.
Long Statement,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The length of the statement  "					outputDevice.SendMidiPitchWheel (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 () | (shortMessage.GetData2 () << 7)); " is 130.
Long Statement,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The length of the statement  "					outputDevice.SendMidiPolyphonicAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ()); " is 132.
Long Statement,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiTransmitter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiTransmitter.cs,Open,The length of the statement  "	inputDevice = new MidiInputDevice (usbDevice' usbDeviceConnection' usbInterface' inputEndpoint' new UsbMidiTransmitter.OnMidiInputEventListenerImpl (this)); " is 156.
Long Statement,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTime,The length of the statement  "	return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch (); " is 121.
Long Statement,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,ToMillisecondsSinceEpoch,The length of the statement  "	return new DateTimeOffset (DateTime.SpecifyKind (dateTime' DateTimeKind.Utc)' TimeSpan.Zero).ToMillisecondsSinceEpoch (); " is 121.
Long Statement,Sharpen,ResourceBundle,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ResourceBundle.cs,GetBundle,The length of the statement  "	manifestResourceStream = asm.GetManifestResourceStream (bundleClass + "_" + culture.ToString ().Replace ('-'' '_') + ".properties"); " is 132.
Long Statement,Sharpen,ResourceBundle,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ResourceBundle.cs,GetBundle,The length of the statement  "		manifestResourceStream = asm.GetManifestResourceStream (bundleClass + "_" + culture.TwoLetterISOLanguageName + ".properties"); " is 126.
Long Statement,Sharpen,ScheduledThreadPoolExecutor,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ScheduledThreadPoolExecutor.cs,Shutdown,The length of the statement  "			Scheduler.Instance.Shutdown (this' continueExistingPeriodicTasksAfterShutdownPolicy' executeExistingDelayedTasksAfterShutdownPolicy); " is 133.
Long Statement,Sharpen,SimpleDateFormat,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\SimpleDateFormat.cs,Format,The length of the statement  "	return Extensions.MillisToDateTimeOffset (date' (int)GetTimeZone ().BaseUtcOffset.TotalMinutes).DateTime.ToString (format); " is 123.
Complex Conditional,JP.KShoji.Driver.Usb.Util,DeviceFilter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Usb\Util\DeviceFilter.cs,ParseXml,The conditional expression  "vendorId == -1 && productId == -1 && deviceClass == -1 && deviceSubclass == -1 && deviceProtocol == -1"  is complex.
Complex Conditional,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The conditional expression  "buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0"  is complex.
Complex Conditional,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,RegionMatches,The conditional expression  "toOffset < 0 || ooffset < 0 || toOffset + len > str.Length || ooffset + len > other.Length"  is complex.
Empty Catch Block,JP.KShoji.Driver.Midi.Device,MidiInputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiInputDevice.cs,Stop,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The method has an empty catch block.
Empty Catch Block,JP.KShoji.Driver.Midi.Thread,MidiDeviceConnectionWatcher,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Thread\MidiDeviceConnectionWatcher.cs,Stop,The method has an empty catch block.
Empty Catch Block,Sharpen,TaskFuture,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Executors.cs,Cancel,The method has an empty catch block.
Empty Catch Block,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The method has an empty catch block.
Empty Catch Block,Sharpen,FileHelper,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\FileHelper.cs,SetLastModified,The method has an empty catch block.
Empty Catch Block,Sharpen,SystemProcess,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Process.cs,Destroy,The method has an empty catch block.
Empty Catch Block,Sharpen,ThreadPoolExecutor,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ThreadPoolExecutor.cs,RunPoolThread,The method has an empty catch block.
Empty Catch Block,Sharpen,ThreadPoolExecutor,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ThreadPoolExecutor.cs,ShutdownNow,The method has an empty catch block.
Magic Number,JP.KShoji.Driver.Midi.Device,MidiInputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiInputDevice.cs,Stop,The following statement contains a magic number: while (waiterThread.IsAlive ()) {  	try {  		Sharpen.Thread.Sleep (100);  	}  	catch (Exception) {  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiInputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiInputDevice.cs,Stop,The following statement contains a magic number: try {  	Sharpen.Thread.Sleep (100);  }  catch (Exception) {  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiInputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiInputDevice.cs,Stop,The following statement contains a magic number: Sharpen.Thread.Sleep (100);  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The following statement contains a magic number: writeBuffer [0] = unchecked((byte)(((cable & unchecked((int)(0xf))) << 4) | (codeIndexNumber & unchecked((int)(0xf)))));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The following statement contains a magic number: writeBuffer [2] = unchecked((byte)byte2);  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The following statement contains a magic number: writeBuffer [3] = unchecked((byte)byte3);  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The following statement contains a magic number: lock (deviceConnection) {  	if (usbRequest == null) {  		usbRequest = new UsbRequest ();  		usbRequest.Initialize (deviceConnection' outputEndpoint);  	}  	while (usbRequest.Queue (ByteBuffer.Wrap (writeBuffer)' 4) == false) {  		// loop until queue completed  		try {  			Sharpen.Thread.Sleep (1);  		}  		catch (Exception) {  		}  	}  	// ignore exception  	while (usbRequest.Equals (deviceConnection.RequestWait ()) == false) {  		// loop until result received  		try {  			Sharpen.Thread.Sleep (1);  		}  		catch (Exception) {  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiMessage,The following statement contains a magic number: while (usbRequest.Queue (ByteBuffer.Wrap (writeBuffer)' 4) == false) {  	// loop until queue completed  	try {  		Sharpen.Thread.Sleep (1);  	}  	catch (Exception) {  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,The following statement contains a magic number: switch (bytes.Length) {  case 1: {  	SendMidiMessage (unchecked((int)(0x5))' cable' bytes [0] & unchecked((int)(0xff))' 0' 0);  	break;  }  case 2: {  	SendMidiMessage (unchecked((int)(0x2))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' 0);  	break;  }  case 3: {  	SendMidiMessage (unchecked((int)(0x3))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' bytes [2] & unchecked((int)(0xff)));  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,The following statement contains a magic number: switch (bytes.Length) {  case 1: {  	SendMidiMessage (unchecked((int)(0x5))' cable' bytes [0] & unchecked((int)(0xff))' 0' 0);  	break;  }  case 2: {  	SendMidiMessage (unchecked((int)(0x2))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' 0);  	break;  }  case 3: {  	SendMidiMessage (unchecked((int)(0x3))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' bytes [2] & unchecked((int)(0xff)));  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,The following statement contains a magic number: switch (bytes.Length) {  case 1: {  	SendMidiMessage (unchecked((int)(0x5))' cable' bytes [0] & unchecked((int)(0xff))' 0' 0);  	break;  }  case 2: {  	SendMidiMessage (unchecked((int)(0x2))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' 0);  	break;  }  case 3: {  	SendMidiMessage (unchecked((int)(0x3))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' bytes [2] & unchecked((int)(0xff)));  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemCommonMessage,The following statement contains a magic number: SendMidiMessage (unchecked((int)(0x3))' cable' bytes [0] & unchecked((int)(0xff))' bytes [1] & unchecked((int)(0xff))' bytes [2] & unchecked((int)(0xff)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: for (int sysexIndex = 0; sysexIndex < systemExclusive.Length; sysexIndex += 3) {  	if ((sysexIndex + 3 < systemExclusive.Length)) {  		// sysex starts or continues...  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	}  	else {  		switch (systemExclusive.Length % 3) {  		case 1: {  			// sysex end with 1 byte  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			transferDataStream.Write (0);  			break;  		}  		case 2: {  			// sysex end with 2 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (0);  			break;  		}  		case 0: {  			// sysex end with 3 bytes  			transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  			transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  			transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: sysexIndex += 3
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: if ((sysexIndex + 3 < systemExclusive.Length)) {  	// sysex starts or continues...  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  }  else {  	switch (systemExclusive.Length % 3) {  	case 1: {  		// sysex end with 1 byte  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		transferDataStream.Write (0);  		break;  	}  	case 2: {  		// sysex end with 2 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (0);  		break;  	}  	case 0: {  		// sysex end with 3 bytes  		transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  		transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  		transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x4))));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following statement contains a magic number: transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiPitchWheel,The following statement contains a magic number: SendMidiMessage (unchecked((int)(0xe))' cable' unchecked((int)(0xe0)) | (channel & unchecked((int)(0xf)))' amount & unchecked((int)(0x7f))' (amount >> 7) & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendRPNMessage (cable' channel' (function >> 7) & unchecked((int)(0x7f))' function & unchecked((int)(0x7f))' value);  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 101' functionMSB & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 100' functionLSB & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 101' unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 100' unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendNRPNMessage (cable' channel' (function >> 7) & unchecked((int)(0x7f))' function & unchecked((int)(0x7f))' value);  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 99' functionMSB & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 98' functionLSB & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: if ((value >> 7) > 0) {  	SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  	SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  }  else {  	SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 6' (value >> 7) & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 38' value & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 6' value & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 101' unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendNRPNMessage,The following statement contains a magic number: SendMidiControlChange (cable' channel' 100' unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: lock (this) {  	if (midiEventListener == null) {  		return false;  	}  	if (received == null) {  		received = new ByteArrayOutputStream ();  	}  	try {  		received.Write ((byte[])msg.obj);  	}  	catch (IOException) {  	}  	// ignore exception  	if (received.Size () < 4) {  		// more data needed  		return false;  	}  	// USB MIDI data stream: 4 bytes boundary  	byte[] receivedBytes = received.ToByteArray ();  	byte[] read = new byte[receivedBytes.Length / 4 * 4];  	System.Array.Copy (receivedBytes' 0' read' 0' read.Length);  	// Note: received.reset() method don't reset ByteArrayOutputStream's internal buffer.  	received = new ByteArrayOutputStream ();  	// keep unread bytes  	if (receivedBytes.Length - read.Length > 0) {  		byte[] unread = new byte[receivedBytes.Length - read.Length];  		System.Array.Copy (receivedBytes' read.Length' unread' 0' unread.Length);  		try {  			received.Write (unread);  		}  		catch (IOException) {  		}  	}  	// ignore exception  	int cable;  	int codeIndexNumber;  	int byte1;  	int byte2;  	int byte3;  	for (int i = 0; i < read.Length; i += 4) {  		cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  		codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  		byte1 = read [i + 1] & unchecked((int)(0xff));  		byte2 = read [i + 2] & unchecked((int)(0xff));  		byte3 = read [i + 3] & unchecked((int)(0xff));  		switch (codeIndexNumber) {  		case 0: {  			midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 1: {  			midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  			break;  		}  		case 2: {  			// system common message with 2 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 3: {  			// system common message with 3 bytes  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)'  				unchecked((byte)byte2)'  				unchecked((byte)byte3)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			break;  		}  		case 4: {  			// sysex starts' and has next  			lock (this) {  				if (systemExclusive == null) {  					systemExclusive = new ByteArrayOutputStream ();  				}  			}  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  			}  			break;  		}  		case 5: {  			// system common message with 1byte  			// sysex end with 1 byte  			if (systemExclusive == null) {  				byte[] bytes = new byte[] {  					unchecked((byte)byte1)  				};  				midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  			}  			else {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 6: {  			// sysex end with 2 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 7: {  			// sysex end with 3 bytes  			if (systemExclusive != null) {  				lock (systemExclusive) {  					systemExclusive.Write (byte1);  					systemExclusive.Write (byte2);  					systemExclusive.Write (byte3);  					midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  				}  				lock (this) {  					systemExclusive = null;  				}  			}  			break;  		}  		case 8: {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 9: {  			if (byte3 == unchecked((int)(0x00))) {  				midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			else {  				midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			}  			break;  		}  		case 10: {  			// poly key press  			midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			break;  		}  		case 11: {  			// control change  			midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  			ProcessRpnMessages (cable' byte1' byte2' byte3);  			break;  		}  		case 12: {  			// program change  			midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 13: {  			// channel pressure  			midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  			break;  		}  		case 14: {  			// pitch bend  			midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  			break;  		}  		case 15: {  			// single byte  			midiEventListener.OnMidiSingleByte (sender' cable' byte1);  			break;  		}  		default: {  			// do nothing.  			break;  			break;  		}  		}  	}  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: if (received.Size () < 4) {  	// more data needed  	return false;  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: for (int i = 0; i < read.Length; i += 4) {  	cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  	codeIndexNumber = read [i + 0] & unchecked((int)(0xf));  	byte1 = read [i + 1] & unchecked((int)(0xff));  	byte2 = read [i + 2] & unchecked((int)(0xff));  	byte3 = read [i + 3] & unchecked((int)(0xff));  	switch (codeIndexNumber) {  	case 0: {  		midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 1: {  		midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  		break;  	}  	case 2: {  		// system common message with 2 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 3: {  		// system common message with 3 bytes  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)'  			unchecked((byte)byte2)'  			unchecked((byte)byte3)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		break;  	}  	case 4: {  		// sysex starts' and has next  		lock (this) {  			if (systemExclusive == null) {  				systemExclusive = new ByteArrayOutputStream ();  			}  		}  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  		}  		break;  	}  	case 5: {  		// system common message with 1byte  		// sysex end with 1 byte  		if (systemExclusive == null) {  			byte[] bytes = new byte[] {  				unchecked((byte)byte1)  			};  			midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  		}  		else {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 6: {  		// sysex end with 2 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 7: {  		// sysex end with 3 bytes  		if (systemExclusive != null) {  			lock (systemExclusive) {  				systemExclusive.Write (byte1);  				systemExclusive.Write (byte2);  				systemExclusive.Write (byte3);  				midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  			}  			lock (this) {  				systemExclusive = null;  			}  		}  		break;  	}  	case 8: {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 9: {  		if (byte3 == unchecked((int)(0x00))) {  			midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		else {  			midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		}  		break;  	}  	case 10: {  		// poly key press  		midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		break;  	}  	case 11: {  		// control change  		midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  		ProcessRpnMessages (cable' byte1' byte2' byte3);  		break;  	}  	case 12: {  		// program change  		midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 13: {  		// channel pressure  		midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  		break;  	}  	case 14: {  		// pitch bend  		midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  		break;  	}  	case 15: {  		// single byte  		midiEventListener.OnMidiSingleByte (sender' cable' byte1);  		break;  	}  	default: {  		// do nothing.  		break;  		break;  	}  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: i += 4
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: cable = (read [i + 0] >> 4) & unchecked((int)(0xf));  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: byte2 = read [i + 2] & unchecked((int)(0xff));  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: byte3 = read [i + 3] & unchecked((int)(0xff));  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: switch (codeIndexNumber) {  case 0: {  	midiEventListener.OnMidiMiscellaneousFunctionCodes (sender' cable' byte1' byte2' byte3);  	break;  }  case 1: {  	midiEventListener.OnMidiCableEvents (sender' cable' byte1' byte2' byte3);  	break;  }  case 2: {  	// system common message with 2 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 3: {  	// system common message with 3 bytes  	byte[] bytes = new byte[] {  		unchecked((byte)byte1)'  		unchecked((byte)byte2)'  		unchecked((byte)byte3)  	};  	midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	break;  }  case 4: {  	// sysex starts' and has next  	lock (this) {  		if (systemExclusive == null) {  			systemExclusive = new ByteArrayOutputStream ();  		}  	}  	lock (systemExclusive) {  		systemExclusive.Write (byte1);  		systemExclusive.Write (byte2);  		systemExclusive.Write (byte3);  	}  	break;  }  case 5: {  	// system common message with 1byte  	// sysex end with 1 byte  	if (systemExclusive == null) {  		byte[] bytes = new byte[] {  			unchecked((byte)byte1)  		};  		midiEventListener.OnMidiSystemCommonMessage (sender' cable' bytes);  	}  	else {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 6: {  	// sysex end with 2 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 7: {  	// sysex end with 3 bytes  	if (systemExclusive != null) {  		lock (systemExclusive) {  			systemExclusive.Write (byte1);  			systemExclusive.Write (byte2);  			systemExclusive.Write (byte3);  			midiEventListener.OnMidiSystemExclusive (sender' cable' systemExclusive.ToByteArray ());  		}  		lock (this) {  			systemExclusive = null;  		}  	}  	break;  }  case 8: {  	midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 9: {  	if (byte3 == unchecked((int)(0x00))) {  		midiEventListener.OnMidiNoteOff (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	else {  		midiEventListener.OnMidiNoteOn (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	}  	break;  }  case 10: {  	// poly key press  	midiEventListener.OnMidiPolyphonicAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	break;  }  case 11: {  	// control change  	midiEventListener.OnMidiControlChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2' byte3);  	ProcessRpnMessages (cable' byte1' byte2' byte3);  	break;  }  case 12: {  	// program change  	midiEventListener.OnMidiProgramChange (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 13: {  	// channel pressure  	midiEventListener.OnMidiChannelAftertouch (sender' cable' byte1 & unchecked((int)(0xf))' byte2);  	break;  }  case 14: {  	// pitch bend  	midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  	break;  }  case 15: {  	// single byte  	midiEventListener.OnMidiSingleByte (sender' cable' byte1);  	break;  }  default: {  	// do nothing.  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,HandleMessage,The following statement contains a magic number: midiEventListener.OnMidiPitchWheel (sender' cable' byte1 & unchecked((int)(0xf))' byte2 | (byte3 << 7));  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: switch (byte2) {  case 6: {  	rpnValueMSB = byte3 & unchecked((int)(0x7f));  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  		}  	}  	break;  }  case 38: {  	if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  		midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  	else {  		if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  			midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  		}  	}  	break;  }  case 98: {  	nrpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 99: {  	nrpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	rpnStatus = MidiMessageCallback.RPNStatus.NRPN;  	break;  }  case 100: {  	rpnFunctionLSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  case 101: {  	rpnFunctionMSB = byte3 & unchecked((int)(0x7f));  	if (rpnFunctionMSB == unchecked((int)(0x7f)) && rpnFunctionLSB == unchecked((int)(0x7f))) {  		rpnStatus = MidiMessageCallback.RPNStatus.NONE;  	}  	else {  		rpnStatus = MidiMessageCallback.RPNStatus.RPN;  	}  	break;  }  default: {  	break;  	break;  }  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  	midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  }  else {  	if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  		midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  	midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  }  else {  	if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  		midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  	midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' -1);  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  	midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  }  else {  	if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  		midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: if (rpnStatus == MidiMessageCallback.RPNStatus.RPN) {  	midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  }  else {  	if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  		midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: midiEventListener.OnMidiRPNReceived (sender' cable' byte1' ((rpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (rpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: if (rpnStatus == MidiMessageCallback.RPNStatus.NRPN) {  	midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  }  
Magic Number,JP.KShoji.Driver.Midi.Handler,MidiMessageCallback,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Handler\MidiMessageCallback.cs,ProcessRpnMessages,The following statement contains a magic number: midiEventListener.OnMidiNRPNReceived (sender' cable' byte1' ((nrpnFunctionMSB & unchecked((int)(0x7f))) << 7) & (nrpnFunctionLSB & unchecked((int)(0x7f)))' rpnValueMSB' byte3 & unchecked((int)(0x7f)));  
Magic Number,JP.KShoji.Driver.Midi.Thread,MidiDeviceConnectionWatcher,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Thread\MidiDeviceConnectionWatcher.cs,Stop,The following statement contains a magic number: while (thread.IsAlive ()) {  	try {  		Sharpen.Thread.Sleep (100);  	}  	catch (Exception) {  	}  }  
Magic Number,JP.KShoji.Driver.Midi.Thread,MidiDeviceConnectionWatcher,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Thread\MidiDeviceConnectionWatcher.cs,Stop,The following statement contains a magic number: try {  	Sharpen.Thread.Sleep (100);  }  catch (Exception) {  }  
Magic Number,JP.KShoji.Driver.Midi.Thread,MidiDeviceConnectionWatcher,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Thread\MidiDeviceConnectionWatcher.cs,Stop,The following statement contains a magic number: Sharpen.Thread.Sleep (100);  
Magic Number,JP.KShoji.Driver.Midi.Util,UsbMidiDeviceUtils,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Util\UsbMidiDeviceUtils.cs,FindMidiEndpoint,The following statement contains a magic number: if (usbInterface.GetInterfaceClass () == 1 && usbInterface.GetInterfaceSubclass () == 3) {  	for (int endpointIndex = 0; endpointIndex < endpointCount; endpointIndex++) {  		UsbEndpoint endpoint = usbInterface.GetEndpoint (endpointIndex);  		if (endpoint.GetDirection () == direction) {  			return endpoint;  		}  	}  }  else {  	bool filterMatched = false;  	foreach (DeviceFilter deviceFilter in deviceFilters) {  		if (deviceFilter.Matches (usbDevice)) {  			filterMatched = true;  			break;  		}  	}  	if (filterMatched == false) {  		Log.D (Constants.TAG' "unsupported interface: " + usbInterface);  		return null;  	}  	// non standard USB MIDI interface  	for (int endpointIndex = 0; endpointIndex < endpointCount; endpointIndex++) {  		UsbEndpoint endpoint = usbInterface.GetEndpoint (endpointIndex);  		if ((endpoint.GetType () == UsbConstants.USB_ENDPOINT_XFER_BULK || endpoint.GetType () == UsbConstants.USB_ENDPOINT_XFER_INT)) {  			if (endpoint.GetDirection () == direction) {  				return endpoint;  			}  		}  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,MetaMessage,The following statement contains a magic number: if (data.Length >= 3) {  	dataLength = data.Length - 3;  	int pos = 2;  	while (pos < data.Length && (data [pos] & unchecked((int)(0x80))) != 0) {  		dataLength--;  		pos++;  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,MetaMessage,The following statement contains a magic number: if (data.Length >= 3) {  	dataLength = data.Length - 3;  	int pos = 2;  	while (pos < data.Length && (data [pos] & unchecked((int)(0x80))) != 0) {  		dataLength--;  		pos++;  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,MetaMessage,The following statement contains a magic number: if (data.Length >= 3) {  	dataLength = data.Length - 3;  	int pos = 2;  	while (pos < data.Length && (data [pos] & unchecked((int)(0x80))) != 0) {  		dataLength--;  		pos++;  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,MetaMessage,The following statement contains a magic number: dataLength = data.Length - 3;  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,SetMessage,The following statement contains a magic number: if (type >= 128 || type < 0) {  	throw new InvalidMidiDataException ("Invalid meta event. type: " + type);  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,SetMessage,The following statement contains a magic number: this.data = new byte[2 + GetMidiValuesLength (data.Length) + data.Length];  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,SetMessage,The following statement contains a magic number: WriteMidiValues (this.data' 2' data.Length);  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,GetType,The following statement contains a magic number: if (data.Length >= 2) {  	return data [1] & unchecked((int)(0xff));  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,GetMidiValuesLength,The following statement contains a magic number: do {  	currentValue = currentValue >> 7;  	length++;  }  while (currentValue > 0);  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,GetMidiValuesLength,The following statement contains a magic number: currentValue = currentValue >> 7;  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,WriteMidiValues,The following statement contains a magic number: while ((shift > 0) && ((value & (unchecked((int)(0x7f)) << shift)) == 0)) {  	shift -= 7;  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,WriteMidiValues,The following statement contains a magic number: shift -= 7;  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,WriteMidiValues,The following statement contains a magic number: while (shift > 0) {  	data [currentOff++] = unchecked((byte)(((value & (unchecked((int)(0x7f)) << shift)) >> shift) | unchecked((int)(0x80))));  	shift -= 7;  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,MetaMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\MetaMessage.cs,WriteMidiValues,The following statement contains a magic number: shift -= 7;  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,SetMessage,The following statement contains a magic number: if (data.Length > 1) {  	data [1] = unchecked((byte)(data1 & unchecked((int)(0xff))));  	if (data.Length > 2) {  		data [2] = unchecked((byte)(data2 & unchecked((int)(0xff))));  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,SetMessage,The following statement contains a magic number: if (data.Length > 1) {  	data [1] = unchecked((byte)(data1 & unchecked((int)(0xff))));  	if (data.Length > 2) {  		data [2] = unchecked((byte)(data2 & unchecked((int)(0xff))));  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,SetMessage,The following statement contains a magic number: if (data.Length > 2) {  	data [2] = unchecked((byte)(data2 & unchecked((int)(0xff))));  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,SetMessage,The following statement contains a magic number: if (data.Length > 2) {  	data [2] = unchecked((byte)(data2 & unchecked((int)(0xff))));  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,SetMessage,The following statement contains a magic number: data [2] = unchecked((byte)(data2 & unchecked((int)(0xff))));  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetData2,The following statement contains a magic number: if (data.Length > 2) {  	return (data [2] & unchecked((int)(0xff)));  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetData2,The following statement contains a magic number: if (data.Length > 2) {  	return (data [2] & unchecked((int)(0xff)));  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetData2,The following statement contains a magic number: return (data [2] & unchecked((int)(0xff)));  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetDataLength,The following statement contains a magic number: switch (status) {  case TUNE_REQUEST:  case END_OF_EXCLUSIVE:  case TIMING_CLOCK:  case unchecked((int)(0xf9)):  case START:  case CONTINUE:  case STOP:  case unchecked((int)(0xfd)):  case ACTIVE_SENSING:  case SYSTEM_RESET: {  	return 0;  }  case MIDI_TIME_CODE:  case SONG_SELECT: {  	return 1;  }  case SONG_POSITION_POINTER: {  	return 2;  }  default: {  	break;  }  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetDataLength,The following statement contains a magic number: return 2;  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetDataLength,The following statement contains a magic number: switch (status & unchecked((int)(0xf0))) {  case NOTE_OFF:  case NOTE_ON:  case POLY_PRESSURE:  case CONTROL_CHANGE:  case PITCH_BEND: {  	return 2;  }  case PROGRAM_CHANGE:  case CHANNEL_PRESSURE: {  	return 1;  }  default: {  	throw new InvalidMidiDataException ("Invalid status byte: " + status);  }  }  
Magic Number,JP.KShoji.Javax.Sound.Midi,ShortMessage,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\ShortMessage.cs,GetDataLength,The following statement contains a magic number: return 2;  
Magic Number,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The following statement contains a magic number: if (message is MetaMessage) {  	MetaMessage metaMessage = (MetaMessage)message;  	outputDevice.SendMidiSystemCommonMessage (cableId' metaMessage.GetData ());  }  else {  	if (message is SysexMessage) {  		SysexMessage sysexMessage = (SysexMessage)message;  		outputDevice.SendMidiSystemExclusive (cableId' sysexMessage.GetData ());  	}  	else {  		if (message is ShortMessage) {  			ShortMessage shortMessage = (ShortMessage)message;  			switch (shortMessage.GetCommand ()) {  			case ShortMessage.CHANNEL_PRESSURE: {  				outputDevice.SendMidiChannelAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  				break;  			}  			case ShortMessage.CONTROL_CHANGE: {  				outputDevice.SendMidiControlChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  				break;  			}  			case ShortMessage.NOTE_OFF: {  				outputDevice.SendMidiNoteOff (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  				break;  			}  			case ShortMessage.NOTE_ON: {  				outputDevice.SendMidiNoteOn (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  				break;  			}  			case ShortMessage.PITCH_BEND: {  				outputDevice.SendMidiPitchWheel (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 () | (shortMessage.GetData2 () << 7));  				break;  			}  			case ShortMessage.POLY_PRESSURE: {  				outputDevice.SendMidiPolyphonicAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  				break;  			}  			case ShortMessage.PROGRAM_CHANGE: {  				outputDevice.SendMidiProgramChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  				break;  			}  			default: {  				break;  			}  			}  		}  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The following statement contains a magic number: if (message is SysexMessage) {  	SysexMessage sysexMessage = (SysexMessage)message;  	outputDevice.SendMidiSystemExclusive (cableId' sysexMessage.GetData ());  }  else {  	if (message is ShortMessage) {  		ShortMessage shortMessage = (ShortMessage)message;  		switch (shortMessage.GetCommand ()) {  		case ShortMessage.CHANNEL_PRESSURE: {  			outputDevice.SendMidiChannelAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  			break;  		}  		case ShortMessage.CONTROL_CHANGE: {  			outputDevice.SendMidiControlChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  			break;  		}  		case ShortMessage.NOTE_OFF: {  			outputDevice.SendMidiNoteOff (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  			break;  		}  		case ShortMessage.NOTE_ON: {  			outputDevice.SendMidiNoteOn (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  			break;  		}  		case ShortMessage.PITCH_BEND: {  			outputDevice.SendMidiPitchWheel (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 () | (shortMessage.GetData2 () << 7));  			break;  		}  		case ShortMessage.POLY_PRESSURE: {  			outputDevice.SendMidiPolyphonicAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  			break;  		}  		case ShortMessage.PROGRAM_CHANGE: {  			outputDevice.SendMidiProgramChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  			break;  		}  		default: {  			break;  		}  		}  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The following statement contains a magic number: if (message is ShortMessage) {  	ShortMessage shortMessage = (ShortMessage)message;  	switch (shortMessage.GetCommand ()) {  	case ShortMessage.CHANNEL_PRESSURE: {  		outputDevice.SendMidiChannelAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  		break;  	}  	case ShortMessage.CONTROL_CHANGE: {  		outputDevice.SendMidiControlChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  		break;  	}  	case ShortMessage.NOTE_OFF: {  		outputDevice.SendMidiNoteOff (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  		break;  	}  	case ShortMessage.NOTE_ON: {  		outputDevice.SendMidiNoteOn (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  		break;  	}  	case ShortMessage.PITCH_BEND: {  		outputDevice.SendMidiPitchWheel (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 () | (shortMessage.GetData2 () << 7));  		break;  	}  	case ShortMessage.POLY_PRESSURE: {  		outputDevice.SendMidiPolyphonicAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  		break;  	}  	case ShortMessage.PROGRAM_CHANGE: {  		outputDevice.SendMidiProgramChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  		break;  	}  	default: {  		break;  	}  	}  }  
Magic Number,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The following statement contains a magic number: switch (shortMessage.GetCommand ()) {  case ShortMessage.CHANNEL_PRESSURE: {  	outputDevice.SendMidiChannelAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  	break;  }  case ShortMessage.CONTROL_CHANGE: {  	outputDevice.SendMidiControlChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  	break;  }  case ShortMessage.NOTE_OFF: {  	outputDevice.SendMidiNoteOff (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  	break;  }  case ShortMessage.NOTE_ON: {  	outputDevice.SendMidiNoteOn (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  	break;  }  case ShortMessage.PITCH_BEND: {  	outputDevice.SendMidiPitchWheel (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 () | (shortMessage.GetData2 () << 7));  	break;  }  case ShortMessage.POLY_PRESSURE: {  	outputDevice.SendMidiPolyphonicAftertouch (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ()' shortMessage.GetData2 ());  	break;  }  case ShortMessage.PROGRAM_CHANGE: {  	outputDevice.SendMidiProgramChange (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 ());  	break;  }  default: {  	break;  }  }  
Magic Number,JP.KShoji.Javax.Sound.Midi.Usb,UsbMidiReceiver,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Javax\Sound\Midi\Usb\UsbMidiReceiver.cs,Send,The following statement contains a magic number: outputDevice.SendMidiPitchWheel (cableId' shortMessage.GetChannel ()' shortMessage.GetData1 () | (shortMessage.GetData2 () << 7));  
Magic Number,Sharpen,ByteBuffer,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ByteBuffer.cs,GetInt,The following statement contains a magic number: CheckGetLimit (4);  
Magic Number,Sharpen,ByteBuffer,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ByteBuffer.cs,GetInt,The following statement contains a magic number: index += 4;  
Magic Number,Sharpen,ByteBuffer,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ByteBuffer.cs,GetShort,The following statement contains a magic number: CheckGetLimit (2);  
Magic Number,Sharpen,ByteBuffer,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\ByteBuffer.cs,GetShort,The following statement contains a magic number: index += 2;  
Magic Number,Sharpen,CRC32,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\CRC32.cs,Update,The following statement contains a magic number: this._value = (this._value >> 8) ^ CrcTable [(int)((IntPtr)((this._value & 0xff) ^ value))];  
Magic Number,Sharpen,CRC32,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\CRC32.cs,Update,The following statement contains a magic number: this._value = CrcTable [(int)((IntPtr)((this._value ^ value) & 0xff))] ^ (this._value >> 8);  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (b.description [b.i]) {  case '^':  	b.conv = BigEndian;  	return false;  case '_':  	b.conv = LittleEndian;  	return false;  case '%':  	b.conv = Native;  	return false;  case '!':  	b.align = -1;  	return false;  case 'x':  	b.Add (new byte[] {  		0  	});  	return false;  // Type Conversions  case 'i':  	b.Add (b.conv.GetBytes (Convert.ToInt32 (oarg)));  	break;  case 'I':  	b.Add (b.conv.GetBytes (Convert.ToUInt32 (oarg)));  	break;  case 's':  	b.Add (b.conv.GetBytes (Convert.ToInt16 (oarg)));  	break;  case 'S':  	b.Add (b.conv.GetBytes (Convert.ToUInt16 (oarg)));  	break;  case 'l':  	b.Add (b.conv.GetBytes (Convert.ToInt64 (oarg)));  	break;  case 'L':  	b.Add (b.conv.GetBytes (Convert.ToUInt64 (oarg)));  	break;  case 'f':  	b.Add (b.conv.GetBytes (Convert.ToSingle (oarg)));  	break;  case 'd':  	b.Add (b.conv.GetBytes (Convert.ToDouble (oarg)));  	break;  case 'b':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  case 'c':  	b.Add (new byte[] {  		(byte)(Convert.ToSByte (oarg))  	});  	break;  case 'C':  	b.Add (new byte[] {  		Convert.ToByte (oarg)  	});  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	b.repeat = ((short)b.description [b.i]) - ((short)'0');  	return false;  case '*':  	b.repeat = Int32.MaxValue;  	return false;  case '[':  	int count = -1' j;  	for (j = b.i + 1; j < b.description.Length; j++) {  		if (b.description [j] == ']')  			break;  		n = ((short)b.description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	b.i = j;  	b.repeat = count;  	return false;  case '$':  case 'z':  	bool add_null = b.description [b.i] == 'z';  	b.i++;  	if (b.i >= b.description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = b.description [b.i];  	Encoding e;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	if (b.align == -1)  		b.align = 4;  	b.Add (e.GetBytes (Convert.ToString (oarg)));  	if (add_null)  		b.Add (new byte[n]);  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' b.description [b.i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: for (j = b.i + 1; j < b.description.Length; j++) {  	if (b.description [j] == ']')  		break;  	n = ((short)b.description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: for (j = b.i + 1; j < b.description.Length; j++) {  	if (b.description [j] == ']')  		break;  	n = ((short)b.description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (count == -1)  	count = n;  else  	count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: e = Encoding.GetEncoding (12000);  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: e = Encoding.GetEncoding (12001);  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: if (b.align == -1)  	b.align = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,PackOne,The following statement contains a magic number: b.align = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (int i = 0; i < description.Length && idx < buffer.Length;) {  	int save = i;  	switch (description [i]) {  	case '^':  		conv = BigEndian;  		break;  	case '_':  		conv = LittleEndian;  		break;  	case '%':  		conv = Native;  		break;  	case 'x':  		idx++;  		break;  	case '!':  		align = true;  		break;  	// Type Conversions  	case 'i':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 'I':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetUInt32 (buffer' idx));  			idx += 4;  		}  		break;  	case 's':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'S':  		if (Prepare (buffer' ref idx' 2' ref align)) {  			result.Add (conv.GetUInt16 (buffer' idx));  			idx += 2;  		}  		break;  	case 'l':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'L':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetUInt64 (buffer' idx));  			idx += 8;  		}  		break;  	case 'f':  		if (Prepare (buffer' ref idx' 4' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 4;  		}  		break;  	case 'd':  		if (Prepare (buffer' ref idx' 8' ref align)) {  			result.Add (conv.GetDouble (buffer' idx));  			idx += 8;  		}  		break;  	case 'b':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			result.Add (buffer [idx]);  			idx++;  		}  		break;  	case 'c':  	case 'C':  		if (Prepare (buffer' ref idx' 1' ref align)) {  			char c;  			if (description [i] == 'c')  				c = ((char)((sbyte)buffer [idx]));  			else  				c = ((char)((byte)buffer [idx]));  			result.Add (c);  			idx++;  		}  		break;  	// Repeat acount;  	case '1':  	case '2':  	case '3':  	case '4':  	case '5':  	case '6':  	case '7':  	case '8':  	case '9':  		repeat = ((short)description [i]) - ((short)'0');  		save = i + 1;  		break;  	case '*':  		repeat = Int32.MaxValue;  		break;  	case '[':  		int count = -1' j;  		for (j = i + 1; j < description.Length; j++) {  			if (description [j] == ']')  				break;  			n = ((short)description [j]) - ((short)'0');  			if (n >= 0 && n <= 9) {  				if (count == -1)  					count = n;  				else  					count = count * 10 + n;  			}  		}  		if (count == -1)  			throw new ArgumentException ("invalid size specification");  		i = j;  		save = i + 1;  		repeat = count;  		break;  	case '$':  	case 'z':  		// bool with_null = description [i] == 'z';  		i++;  		if (i >= description.Length)  			throw new ArgumentException ("$ description needs a type specified"' "description");  		char d = description [i];  		Encoding e;  		if (align) {  			idx = Align (idx' 4);  			align = false;  		}  		if (idx >= buffer.Length)  			break;  		switch (d) {  		case '8':  			e = Encoding.UTF8;  			n = 1;  			break;  		case '6':  			e = Encoding.Unicode;  			n = 2;  			break;  		case '7':  			e = Encoding.UTF7;  			n = 1;  			break;  		case 'b':  			e = Encoding.BigEndianUnicode;  			n = 2;  			break;  		case '3':  			e = Encoding.GetEncoding (12000);  			n = 4;  			break;  		case '4':  			e = Encoding.GetEncoding (12001);  			n = 4;  			break;  		default:  			throw new ArgumentException ("Invalid format for $ specifier"' "description");  		}  		int k = idx;  		switch (n) {  		case 1:  			for (; k < buffer.Length && buffer [k] != 0; k++)  				;  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 1;  			break;  		case 2:  			for (; k < buffer.Length; k++) {  				if (k + 1 == buffer.Length) {  					k++;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 2;  			break;  		case 4:  			for (; k < buffer.Length; k++) {  				if (k + 3 >= buffer.Length) {  					k = buffer.Length;  					break;  				}  				if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  					break;  			}  			result.Add (e.GetChars (buffer' idx' k - idx));  			if (k == buffer.Length)  				idx = k;  			else  				idx = k + 4;  			break;  		}  		break;  	default:  		throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  	}  	if (repeat > 0) {  		if (--repeat > 0)  			i = save;  	}  	else  		i++;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (description [i]) {  case '^':  	conv = BigEndian;  	break;  case '_':  	conv = LittleEndian;  	break;  case '%':  	conv = Native;  	break;  case 'x':  	idx++;  	break;  case '!':  	align = true;  	break;  // Type Conversions  case 'i':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 'I':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetUInt32 (buffer' idx));  		idx += 4;  	}  	break;  case 's':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'S':  	if (Prepare (buffer' ref idx' 2' ref align)) {  		result.Add (conv.GetUInt16 (buffer' idx));  		idx += 2;  	}  	break;  case 'l':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'L':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetUInt64 (buffer' idx));  		idx += 8;  	}  	break;  case 'f':  	if (Prepare (buffer' ref idx' 4' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 4;  	}  	break;  case 'd':  	if (Prepare (buffer' ref idx' 8' ref align)) {  		result.Add (conv.GetDouble (buffer' idx));  		idx += 8;  	}  	break;  case 'b':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		result.Add (buffer [idx]);  		idx++;  	}  	break;  case 'c':  case 'C':  	if (Prepare (buffer' ref idx' 1' ref align)) {  		char c;  		if (description [i] == 'c')  			c = ((char)((sbyte)buffer [idx]));  		else  			c = ((char)((byte)buffer [idx]));  		result.Add (c);  		idx++;  	}  	break;  // Repeat acount;  case '1':  case '2':  case '3':  case '4':  case '5':  case '6':  case '7':  case '8':  case '9':  	repeat = ((short)description [i]) - ((short)'0');  	save = i + 1;  	break;  case '*':  	repeat = Int32.MaxValue;  	break;  case '[':  	int count = -1' j;  	for (j = i + 1; j < description.Length; j++) {  		if (description [j] == ']')  			break;  		n = ((short)description [j]) - ((short)'0');  		if (n >= 0 && n <= 9) {  			if (count == -1)  				count = n;  			else  				count = count * 10 + n;  		}  	}  	if (count == -1)  		throw new ArgumentException ("invalid size specification");  	i = j;  	save = i + 1;  	repeat = count;  	break;  case '$':  case 'z':  	// bool with_null = description [i] == 'z';  	i++;  	if (i >= description.Length)  		throw new ArgumentException ("$ description needs a type specified"' "description");  	char d = description [i];  	Encoding e;  	if (align) {  		idx = Align (idx' 4);  		align = false;  	}  	if (idx >= buffer.Length)  		break;  	switch (d) {  	case '8':  		e = Encoding.UTF8;  		n = 1;  		break;  	case '6':  		e = Encoding.Unicode;  		n = 2;  		break;  	case '7':  		e = Encoding.UTF7;  		n = 1;  		break;  	case 'b':  		e = Encoding.BigEndianUnicode;  		n = 2;  		break;  	case '3':  		e = Encoding.GetEncoding (12000);  		n = 4;  		break;  	case '4':  		e = Encoding.GetEncoding (12001);  		n = 4;  		break;  	default:  		throw new ArgumentException ("Invalid format for $ specifier"' "description");  	}  	int k = idx;  	switch (n) {  	case 1:  		for (; k < buffer.Length && buffer [k] != 0; k++)  			;  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 1;  		break;  	case 2:  		for (; k < buffer.Length; k++) {  			if (k + 1 == buffer.Length) {  				k++;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 2;  		break;  	case 4:  		for (; k < buffer.Length; k++) {  			if (k + 3 >= buffer.Length) {  				k = buffer.Length;  				break;  			}  			if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  				break;  		}  		result.Add (e.GetChars (buffer' idx' k - idx));  		if (k == buffer.Length)  			idx = k;  		else  			idx = k + 4;  		break;  	}  	break;  default:  	throw new ArgumentException (String.Format ("invalid format specified `{0}'"' description [i]));  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetUInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetUInt32 (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetUInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 2' ref align)) {  	result.Add (conv.GetUInt16 (buffer' idx));  	idx += 2;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetUInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetUInt64 (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 4' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 4;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (Prepare (buffer' ref idx' 8' ref align)) {  	result.Add (conv.GetDouble (buffer' idx));  	idx += 8;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx += 8;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (j = i + 1; j < description.Length; j++) {  	if (description [j] == ']')  		break;  	n = ((short)description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (j = i + 1; j < description.Length; j++) {  	if (description [j] == ']')  		break;  	n = ((short)description [j]) - ((short)'0');  	if (n >= 0 && n <= 9) {  		if (count == -1)  			count = n;  		else  			count = count * 10 + n;  	}  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (n >= 0 && n <= 9) {  	if (count == -1)  		count = n;  	else  		count = count * 10 + n;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (count == -1)  	count = n;  else  	count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: count = count * 10 + n;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (align) {  	idx = Align (idx' 4);  	align = false;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx = Align (idx' 4);  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (d) {  case '8':  	e = Encoding.UTF8;  	n = 1;  	break;  case '6':  	e = Encoding.Unicode;  	n = 2;  	break;  case '7':  	e = Encoding.UTF7;  	n = 1;  	break;  case 'b':  	e = Encoding.BigEndianUnicode;  	n = 2;  	break;  case '3':  	e = Encoding.GetEncoding (12000);  	n = 4;  	break;  case '4':  	e = Encoding.GetEncoding (12001);  	n = 4;  	break;  default:  	throw new ArgumentException ("Invalid format for $ specifier"' "description");  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: e = Encoding.GetEncoding (12000);  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: e = Encoding.GetEncoding (12001);  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: n = 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (k == buffer.Length)  	idx = k;  else  	idx = k + 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx = k + 2;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: for (; k < buffer.Length; k++) {  	if (k + 3 >= buffer.Length) {  		k = buffer.Length;  		break;  	}  	if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  		break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (k + 3 >= buffer.Length) {  	k = buffer.Length;  	break;  }  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  	break;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  	break;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: if (k == buffer.Length)  	idx = k;  else  	idx = k + 4;  
Magic Number,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following statement contains a magic number: idx = k + 4;  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,BitCount,The following statement contains a magic number: for (int i = 0; i < 32; i++) {  	if ((num & 1) != 0) {  		count++;  	}  	num >>= 1;  }  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (tzone.Length <= 4) {  	foreach (var timezone in TimeZoneInfo.GetSystemTimeZones ()) {  		var parts = timezone.Id.Split (new[] {  			' '  		}' StringSplitOptions.RemoveEmptyEntries);  		if (parts.Length == tzone.Length) {  			bool found = true;  			for (int i = 0; i < parts.Length; i++)  				found &= parts [i] [0] == tzone [i];  			if (found)  				return timezone;  		}  	}  }  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (strArray.Length == 1 && strArray [0].Length > 2) {  	hours = int.Parse (strArray [0].Substring (0' 2));  	minutes = int.Parse (strArray [0].Substring (2));  }  else {  	hours = int.Parse (strArray [0]);  	minutes = (strArray.Length <= 1) ? 0 : int.Parse (strArray [1]);  }  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (strArray.Length == 1 && strArray [0].Length > 2) {  	hours = int.Parse (strArray [0].Substring (0' 2));  	minutes = int.Parse (strArray [0].Substring (2));  }  else {  	hours = int.Parse (strArray [0]);  	minutes = (strArray.Length <= 1) ? 0 : int.Parse (strArray [1]);  }  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (strArray.Length == 1 && strArray [0].Length > 2) {  	hours = int.Parse (strArray [0].Substring (0' 2));  	minutes = int.Parse (strArray [0].Substring (2));  }  else {  	hours = int.Parse (strArray [0]);  	minutes = (strArray.Length <= 1) ? 0 : int.Parse (strArray [1]);  }  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: hours = int.Parse (strArray [0].Substring (0' 2));  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: minutes = int.Parse (strArray [0].Substring (2));  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTimeZone,The following statement contains a magic number: if (tzone [3] == '-')  	t = -t;  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,ToOctalString,The following statement contains a magic number: return Convert.ToString (val' 8);  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,ToHexString,The following statement contains a magic number: return Convert.ToString (val' 16);  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTotalInFixed,The following statement contains a magic number: if (inf.TotalIn > 0)  	return Convert.ToInt32 (inf.TotalIn) + 4;  else  	return 0;  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetTotalInFixed,The following statement contains a magic number: return Convert.ToInt32 (inf.TotalIn) + 4;  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: if (inf.RemainingInput >= 4)  	return inf.RemainingInput - 4;  else  	return 0;  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: if (inf.RemainingInput >= 4)  	return inf.RemainingInput - 4;  else  	return 0;  
Magic Number,Sharpen,Extensions,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Extensions.cs,GetRemainingInputFixed,The following statement contains a magic number: return inf.RemainingInput - 4;  
Magic Number,Sharpen,FileChannel,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\FileChannel.cs,TransferFrom,The following statement contains a magic number: if (buffer == null)  	buffer = new byte[8092];  
Magic Number,Sharpen,FileChannel,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\FileChannel.cs,TransferFrom,The following statement contains a magic number: buffer = new byte[8092];  
Magic Number,Sharpen,FilePath,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\FilePath.cs,CreateTempFile,The following statement contains a magic number: if (prefix.Length < 3) {  	throw new ArgumentException ("prefix must have at least 3 characters");  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value);  	break;  case 1:  	Time.AddMinutes (value);  	break;  case 2:  	Time.AddSeconds (value);  	break;  case 3:  	Time.AddMilliseconds (value);  	break;  case 5:  	Time.AddYears (value);  	break;  case 6:  	Time.AddMonths (value);  	break;  case 7:  	Time.AddDays (7 * value);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Add,The following statement contains a magic number: Time.AddDays (7 * value);  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,JavaCalendar,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\JavaCalendar.cs,Set,The following statement contains a magic number: switch (type) {  case 0:  	Time.AddHours (value - Time.Hour);  	break;  case 1:  	Time.AddMinutes (value - Time.Minute);  	break;  case 2:  	Time.AddSeconds (value - Time.Second);  	break;  case 3:  	Time.AddMilliseconds (value - Time.Millisecond);  	break;  case 5:  	Time.AddYears (value - Time.Year);  	break;  case 6:  	Time.AddMonths (value - Time.Month);  	break;  default:  	throw new NotSupportedException ();  }  
Magic Number,Sharpen,MessageFormat,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\MessageFormat.cs,AddFormatted,The following statement contains a magic number: if (placeholderArgs.Count > 3)  	throw new ArgumentException ("Invalid format pattern: {" + string.Join ("'"' placeholderArgs.ToArray ()) + "}");  
Magic Number,Sharpen,Pattern,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Pattern.cs,Compile,The following statement contains a magic number: if ((flags & 2) != DOTALL) {  	compiled |= RegexOptions.Singleline;  }  
Magic Number,Sharpen,Pattern,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Pattern.cs,Compile,The following statement contains a magic number: if ((flags & 4) != MULTILINE) {  	compiled |= RegexOptions.Multiline;  }  
Magic Number,Sharpen,RandomAccessFile,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\RandomAccessFile.cs,Write,The following statement contains a magic number: stream.Write (BitConverter.GetBytes (value)' 0' 4);  
Magic Number,Sharpen,Runtime,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Runtime.cs,NanoTime,The following statement contains a magic number: return Environment.TickCount * 1000 * 1000;  
Magic Number,Sharpen,Runtime,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\Runtime.cs,NanoTime,The following statement contains a magic number: return Environment.TickCount * 1000 * 1000;  
Missing Default,JP.KShoji.Driver.Midi.Device,MidiOutputDevice,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Driver\Midi\Device\MidiOutputDevice.cs,SendMidiSystemExclusive,The following switch statement is missing a default case: switch (systemExclusive.Length % 3) {  case 1: {  	// sysex end with 1 byte  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x5))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	transferDataStream.Write (0);  	break;  }  case 2: {  	// sysex end with 2 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x6))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (0);  	break;  }  case 0: {  	// sysex end with 3 bytes  	transferDataStream.Write ((((cable & unchecked((int)(0xf))) << 4) | unchecked((int)(0x7))));  	transferDataStream.Write (systemExclusive [sysexIndex + 0] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 1] & unchecked((int)(0xff)));  	transferDataStream.Write (systemExclusive [sysexIndex + 2] & unchecked((int)(0xff)));  	break;  }  }  
Missing Default,Sharpen,DataConverter,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\DataConverter.cs,Unpack,The following switch statement is missing a default case: switch (n) {  case 1:  	for (; k < buffer.Length && buffer [k] != 0; k++)  		;  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 1;  	break;  case 2:  	for (; k < buffer.Length; k++) {  		if (k + 1 == buffer.Length) {  			k++;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 2;  	break;  case 4:  	for (; k < buffer.Length; k++) {  		if (k + 3 >= buffer.Length) {  			k = buffer.Length;  			break;  		}  		if (buffer [k] == 0 && buffer [k + 1] == 0 && buffer [k + 2] == 0 && buffer [k + 3] == 0)  			break;  	}  	result.Add (e.GetChars (buffer' idx' k - idx));  	if (k == buffer.Length)  		idx = k;  	else  		idx = k + 4;  	break;  }  
Missing Default,Sharpen,MessageDigest,C:\repos\stusherwin_observable-midi\JP.KShoji.Midi2\Sharpen\MessageDigest.cs,GetInstance,The following switch statement is missing a default case: switch (algorithm.ToLower ()) {  case "sha-1":  	return new MessageDigest<SHA1Managed> ();  case "md5":  	return new MessageDigest<MD5CryptoServiceProvider> ();  }  
