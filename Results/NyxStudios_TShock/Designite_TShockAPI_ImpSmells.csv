Implementation smell,Namespace,Class,File,Method,Description
Long Method,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The method has 247 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,InitCommands,The method has 425 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The method has 113 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The method has 127 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The method has 293 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The method has 127 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TP,The method has 119 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The method has 154 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The method has 397 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The method has 184 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The method has 158 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The method has 158 lines of code.
Long Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The method has 541 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The method has 125 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The method has 103 lines of code.
Long Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The method has 270 lines of code.
Long Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The method has 168 lines of code.
Long Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The method has 121 lines of code.
Long Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The method has 113 lines of code.
Long Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,Initialize,The method has 168 lines of code.
Long Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The method has 197 lines of code.
Long Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The method has 103 lines of code.
Long Method,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasHackedItemStacks,The method has 197 lines of code.
Long Method,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,GroupManager,The method has 132 lines of code.
Complex Method,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,CopyCharacter,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,Cyclomatic complexity of the method is 47
Complex Method,TShockAPI,RegionHandler,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\RegionHandler.cs,OnTileEdit,Cyclomatic complexity of the method is 14
Complex Method,TShockAPI,SqlLog,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\SqlLog.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,PaginationTools,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,SendPage,Cyclomatic complexity of the method is 23
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,HandleCommand,Cyclomatic complexity of the method is 15
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ParseParameters,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,Cyclomatic complexity of the method is 19
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,Cyclomatic complexity of the method is 36
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,OverrideSSC,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,UploadJoinData,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,Cyclomatic complexity of the method is 21
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TP,Cyclomatic complexity of the method is 32
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPHere,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,Cyclomatic complexity of the method is 25
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,Cyclomatic complexity of the method is 49
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,Cyclomatic complexity of the method is 26
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,Cyclomatic complexity of the method is 22
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,Cyclomatic complexity of the method is 22
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,Cyclomatic complexity of the method is 78
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Help,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ListConnectedPlayers,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,FireWork,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,Cyclomatic complexity of the method is 16
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,Cyclomatic complexity of the method is 17
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleConnecting,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,Cyclomatic complexity of the method is 23
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePassword,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,Cyclomatic complexity of the method is 17
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,Cyclomatic complexity of the method is 14
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,Cyclomatic complexity of the method is 43
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,Cyclomatic complexity of the method is 25
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,Cyclomatic complexity of the method is 20
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerBuff,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNPCAddBuff,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,Cyclomatic complexity of the method is 18
Complex Method,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerDamage,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetItemByName,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,Initialize,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,Cyclomatic complexity of the method is 41
Complex Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnJoin,Cyclomatic complexity of the method is 14
Complex Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,FindByNameOrID,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasHackedItemStacks,Cyclomatic complexity of the method is 37
Complex Method,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasBuildPermission,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI.CLI,CommandLineParser,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\CLI\CommandLineParser.cs,ParseFromSource,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,LoadPermisions,Cyclomatic complexity of the method is 13
Complex Method,Rests,Rest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,ProcessRequest,Cyclomatic complexity of the method is 11
Complex Method,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,ExecuteCommand,Cyclomatic complexity of the method is 8
Complex Method,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,Cyclomatic complexity of the method is 21
Complex Method,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,Cyclomatic complexity of the method is 11
Long Parameter List,TShockAPI,PaginationTools,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,SendPage,The method has 5 parameters. Parameters: player' pageNumber' dataToPaginate' dataToPaginateCount' settings
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerInfo,The method has 7 parameters. Parameters: player' data' _plrid' _hair' _style' _difficulty' _name
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerSlot,The method has 7 parameters. Parameters: player' data' _plr' _slot' _stack' _prefix' _type
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerUpdate,The method has 8 parameters. Parameters: player' data' plr' control' item' position' velocity' pulley
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerHP,The method has 5 parameters. Parameters: player' data' _plr' _cur' _max
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnTileEdit,The method has 8 parameters. Parameters: ply' data' x' y' action' editDetail' editData' style
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnSendTileSquare,The method has 5 parameters. Parameters: player' data' size' tilex' tiley
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnItemDrop,The method has 9 parameters. Parameters: player' data' id' pos' vel' stacks' prefix' noDelay' type
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnNewProjectile,The method has 10 parameters. Parameters: data' ident' pos' vel' knockback' dmg' owner' type' index' player
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnNPCStrike,The method has 7 parameters. Parameters: player' data' id' dir' dmg' knockback' crit
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnProjectileKill,The method has 5 parameters. Parameters: player' data' identity' owner' index
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerSpawn,The method has 5 parameters. Parameters: player' data' pid' spawnX' spawnY
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnChestItemChange,The method has 7 parameters. Parameters: player' data' id' slot' stacks' prefix' type
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlaceChest,The method has 5 parameters. Parameters: player' data' flag' tilex' tiley
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerZone,The method has 7 parameters. Parameters: player' data' plr' zone1' zone2' zone3' zone4
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerMana,The method has 5 parameters. Parameters: player' data' _plr' _cur' _max
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnSignEvent,The method has 5 parameters. Parameters: player' data' id' x' y
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnLiquidSet,The method has 6 parameters. Parameters: player' data' tilex' tiley' amount' type
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnNPCAddBuff,The method has 5 parameters. Parameters: player' data' id' type' time
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerBuff,The method has 5 parameters. Parameters: player' data' id' type' time
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnUpdateNPCHome,The method has 6 parameters. Parameters: player' data' id' x' y' homeless
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPaintTile,The method has 5 parameters. Parameters: player' data' x' y' t
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPaintWall,The method has 5 parameters. Parameters: player' data' x' y' t
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnTeleport,The method has 6 parameters. Parameters: player' data' id' f' x' y
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlaceObject,The method has 8 parameters. Parameters: player' data' x' y' type' style' alternate' direction
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlaceTileEntity,The method has 5 parameters. Parameters: player' data' x' y' type
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlaceItemFrame,The method has 8 parameters. Parameters: player' data' x' y' itemID' prefix' stack' itemFrame
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerTeleportThroughPortal,The method has 6 parameters. Parameters: sender' targetPlayerIndex' data' position' velocity' colorIndex
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnGemLockToggle,The method has 5 parameters. Parameters: player' data' x' y' on
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnMassWireOperation,The method has 7 parameters. Parameters: player' data' startX' startY' endX' endY' toolMode
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerDamage,The method has 8 parameters. Parameters: player' data' id' dir' dmg' pvp' crit' playerDeathReason
Long Parameter List,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnKillMe,The method has 7 parameters. Parameters: player' data' plr' direction' damage' pvp' playerDeathReason
Long Parameter List,TShockAPI,TSServerPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,SpawnNPC,The method has 7 parameters. Parameters: type' name' amount' startTileX' startTileY' tileXRange' tileYRange
Long Parameter List,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Broadcast,The method has 5 parameters. Parameters: ply' msg' red' green' blue
Long Parameter List,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetRandomClearTileWithInRange,The method has 6 parameters. Parameters: startTileX' startTileY' tileXRange' tileYRange' tileX' tileY
Long Parameter List,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendMessageFromPlayer,The method has 5 parameters. Parameters: msg' red' green' blue' ply
Long Parameter List,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Kick,The method has 5 parameters. Parameters: reason' force' silent' adminUserName' saveSSI
Long Parameter List,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendData,The method has 7 parameters. Parameters: msgType' text' number' number2' number3' number4' number5
Long Parameter List,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendDataFromPlayer,The method has 7 parameters. Parameters: msgType' ply' text' number2' number3' number4' number5
Long Parameter List,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,AddRegion,The method has 8 parameters. Parameters: tx' ty' width' height' regionname' owner' worldid' z
Long Parameter List,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,PositionRegion,The method has 5 parameters. Parameters: regionName' x' y' width' height
Long Parameter List,TShockAPI.DB,Region,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,Region,The method has 7 parameters. Parameters: id' region' name' owner' disablebuild' RegionWorldIDz' z
Long Parameter List,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan,The method has 8 parameters. Parameters: ip' name' uuid' accountName' reason' exceptions' banner' expiration
Long Parameter List,TShockAPI.DB,Ban,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,Ban,The method has 8 parameters. Parameters: ip' name' uuid' accountName' reason' banner' date' exp
Long Parameter List,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,UpdateGroup,The method has 6 parameters. Parameters: name' parentname' permissions' chatcolor' suffix' prefix
Long Parameter List,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccount,The method has 7 parameters. Parameters: name' pass' uuid' group' registered' last' known
Long Parameter List,TShockAPI.Hooks,PlayerHooks,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Hooks\PlayerHooks.cs,OnPlayerCommand,The method has 6 parameters. Parameters: player' cmdName' cmdText' args' commands' cmdPrefix
Long Parameter List,TShockAPI.Sockets,LinuxTcpSocket,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,AsyncSend,The method has 5 parameters. Parameters: data' offset' size' callback' state
Long Parameter List,TShockAPI.Sockets,LinuxTcpSocket,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,AsyncReceive,The method has 5 parameters. Parameters: data' offset' size' callback' state
Long Parameter List,Rests,RestRequestArgs,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,RestRequestArgs,The method has 5 parameters. Parameters: verbs' param' request' tokenData' context
Long Parameter List,Rests,Rest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,ExecuteCommand,The method has 5 parameters. Parameters: cmd' verbs' parms' request' context
Long Parameter List,Rests,SecureRestCommand,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestCommand.cs,Execute,The method has 5 parameters. Parameters: verbs' parameters' tokenData' request' context
Long Parameter List,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,ExecuteCommand,The method has 5 parameters. Parameters: cmd' verbs' parms' request' context
Long Identifier,TShockAPI,ConfigFile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter EnableTokenEndpointAuthentication is 33.
Long Identifier,TShockAPI,ConfigFile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter AllowAllowedGroupsToSpawnBannedItems is 36.
Long Identifier,TShockAPI,ConfigFile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter RESTMaximumRequestsPerInterval is 30.
Long Identifier,TShockAPI,ConfigFile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter RESTRequestBucketDecreaseIntervalMinutes is 40.
Long Statement,TShockAPI,BackupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\BackupManager.cs,DoBackup,The length of the statement  "				Main.ActiveWorldFileData._path = Path.Combine(BackupPath' string.Format("{0}.{1:dd.MM.yy-HH.mm.ss}.bak"' name' DateTime.UtcNow)); " is 129.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix); " is 175.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix); " is 167.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix); " is 163.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix); " is 173.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix); " is 175.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "			NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix); " is 171.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix); " is 185.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix); " is 173.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix); " is 187.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix); " is 183.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix); " is 185.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix); " is 187.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "			NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix); " is 181.
Long Statement,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix); " is 187.
Long Statement,TShockAPI,PaginationTools,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,SendPage,The length of the statement  "					player.SendMessage(string.Format(settings.FooterFormat' pageNumber + 1' pageNumber' pageCount)' settings.FooterTextColor); " is 122.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,HandleCommand,The length of the statement  "					TShock.Utils.SendLogs(string.Format("{0} tried to execute {1}{2}."' player.Name' Specifier' cmdText)' Color.PaleVioletRed' player); " is 131.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,HandleCommand,The length of the statement  "						TShock.Utils.SendLogs(string.Format("{0} executed: {1}{2}."' player.Name' silent ? SilentSpecifier : Specifier' cmdText)' Color.PaleVioletRed' player); " is 151.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The length of the statement  "				args.Player.SendErrorMessage("        {0}login <password> - Logs in using your password and character name"' Specifier); " is 120.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The length of the statement  "				args.Player.SendErrorMessage("        {0}login <username> <password> - Logs in using your username and password"' Specifier); " is 125.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The length of the statement  "							TShock.UserAccounts.SetUserAccountPassword(args.Player.Account' args.Parameters[1]); // SetUserPassword will hash it for you. " is 125.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The length of the statement  "							args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The length of the statement  "					args.Player.SendErrorMessage("Not logged in or invalid syntax! Proper syntax: {0}password <oldpassword> <newpassword>"' Specifier); " is 131.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The length of the statement  "						args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The length of the statement  "						args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The length of the statement  "				if (TShock.UserAccounts.GetUserAccountByName(account.Name) == null && account.Name != TSServerPlayer.AccountName) // Cheap way of checking for existance of a user " is 162.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The length of the statement  "					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The length of the statement  "					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The length of the statement  "					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + "."); " is 120.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,WorldInfo,The length of the statement  "			args.Player.SendInfoMessage("World name: " + (TShock.Config.UseServerName ? TShock.Config.ServerName : Main.worldName)); " is 120.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ViewAccountInfo,The length of the statement  "						args.Player.SendSuccessMessage("{0}'s register date is {1} {2} UTC{3}."' account.Name' Registered.ToShortDateString()' Registered.ToShortTimeString()' Timezone); " is 161.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The length of the statement  "							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name' " is 137.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The length of the statement  "									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s")); " is 126.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The length of the statement  "							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName); " is 123.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ForceHalloween,The length of the statement  "				TSPlayer.All.SendInfoMessage("{0} {1}abled halloween mode!"' args.Player.Name' (TShock.Config.ForceHalloween ? "en" : "dis")); " is 126.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ForceXmas,The length of the statement  "				TSPlayer.All.SendInfoMessage("{0} {1}abled Christmas mode!"' args.Player.Name' (TShock.Config.ForceXmas ? "en" : "dis")); " is 121.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Off,The length of the statement  "			string reason = ((args.Parameters.Count > 0) ? "Server shutting down: " + String.Join(" "' args.Parameters) : "Server shutting down!"); " is 135.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,OffNoSave,The length of the statement  "			string reason = ((args.Parameters.Count > 0) ? "Server shutting down: " + String.Join(" "' args.Parameters) : "Server shutting down!"); " is 135.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ClearAnglerQuests,The length of the statement  "					foreach (TSPlayer ply in TShock.Players.Where(p => p != null && p.Active && p.TPlayer.name.ToLower().Equals(args.Parameters[0].ToLower()))) " is 139.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier); " is 121.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier); " is 127.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix); " is 121.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier); " is 127.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b)) " is 124.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier); " is 121.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The length of the statement  "				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0)); " is 124.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The length of the statement  "							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)' " is 135.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProtectSpawn,The length of the statement  "			TSPlayer.All.SendSuccessMessage(string.Format("Spawn is now {0}."' (TShock.Config.SpawnProtection ? "protected" : "open"))); " is 124.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ListConnectedPlayers,The length of the statement  "			args.Player.SendSuccessMessage("Online Players ({0}/{1})"' TShock.Utils.GetActivePlayerCount()' TShock.Config.MaxSlots); " is 120.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ListConnectedPlayers,The length of the statement  "						players.Add(String.Format("{0} (ID: {1}{2})"' ply.Name' ply.Index' ply.Account != null ? "' ID: " + ply.Account.ID : "")); " is 122.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetupToken,The length of the statement  "				args.Player.SendSuccessMessage("Your new account has been verified' and the {0}setup system has been turned off."' Specifier); " is 126.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetupToken,The length of the statement  "				args.Player.SendSuccessMessage("The setup system will remain disabled as long as a superadmin exists (even if you delete setup.lock)."); " is 136.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetupToken,The length of the statement  "				args.Player.SendSuccessMessage("Share your server' talk with other admins' and more on our forums -- https://tshock.co/"); " is 122.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetupToken,The length of the statement  "			args.Player.SendInfoMessage("If you understand' please {0}login <username> <password> now' and then type {0}setup."' Specifier); " is 128.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Reply,The length of the statement  "				args.Player.SendErrorMessage("You haven't previously received any whispers. Please use {0}whisper to whisper to other people."' Specifier); " is 139.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Aliases,The length of the statement  "						"Aliases of {0}{1}: {0}{2}"' Specifier' matchingCommand.Name' string.Join("' {0}".SFormat(Specifier)' matchingCommand.Names.Skip(1))); " is 134.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Butcher,The length of the statement  "				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC && Main.npc[i].netID != NPCID.TargetDummy) || Main.npc[i].netID == npcId)) " is 137.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The length of the statement  "				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}item <item name/id> [item amount] [prefix id/name]"' Specifier); " is 128.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The length of the statement  "			if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184) " is 133.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The length of the statement  "				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC) || (Main.npc[i].netID == npcId && Main.npc[i].townNPC))) " is 120.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The length of the statement  "						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184) " is 125.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The length of the statement  "				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}gbuff <player> <buff id/name> [time(seconds)]"' Specifier); " is 123.
Long Statement,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ToggleGodMode,The length of the statement  "				args.Player.SendSuccessMessage(string.Format("{0} is {1} in god mode."' playerToGod.Name' playerToGod.GodMode ? "now" : "no longer")); " is 134.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The length of the statement  "				NetMessage.SendData((int)PacketTypes.PlayerInfo' -1' args.Player.Index' NetworkText.FromLiteral(args.Player.Name)' args.Player.Index); " is 134.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleGetSection,The length of the statement  "			NetMessage.SendData((int)PacketTypes.TimeSet' -1' -1' NetworkText.Empty' Main.dayTime ? 1 : 0' (int)Main.time' Main.sunModY' Main.moonModY); " is 140.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The length of the statement  "			if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY))) " is 196.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The length of the statement  "				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1))) " is 188.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The length of the statement  "				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1))) " is 188.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The length of the statement  "				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495) " is 143.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLoadNetModule,The length of the statement  "			// Since this packet is never actually sent to us' every attempt at sending it can be considered as a liquid exploit attempt " is 124.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcTeleportPortal,The length of the statement  "			var projectile = Main.projectile.FirstOrDefault(p => p.position.X == newPosition.X && p.position.Y == newPosition.Y); // Check for projectiles at this location " is 159.
Long Statement,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleOldOnesArmy,The length of the statement  "				TShock.Utils.SendLogs(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' Color.PaleVioletRed' args.Player); " is 130.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The length of the statement  "							args.Player.SendErrorMessage("Disabled. You need to {0}login to load your saved data."' TShock.Config.CommandSpecifier); " is 120.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The length of the statement  "							args.Player.SendErrorMessage("Account needed! Please {0}register or {0}login to play!"' TShock.Config.CommandSpecifier); " is 120.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)) " is 174.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)) " is 185.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.Player.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0) " is 220.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0) " is 139.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj])) " is 148.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes)) " is 186.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					if (action == EditAction.PlaceTile && (editData == TileID.PiggyBank || editData == TileID.Safes) && Main.ServerSideCharacter) " is 125.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope)) " is 156.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0) " is 144.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection)) " is 139.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The length of the statement  "				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] && " is 158.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The length of the statement  "			// IIRC it's because 5 means a 5x5 square which is normal for a tile square' and anything bigger is a non-vanilla tile modification attempt " is 139.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The length of the statement  "							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2)) " is 122.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The length of the statement  "							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2)) " is 146.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The length of the statement  "			if ((stacks > item.maxStack || stacks <= 0) || (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' args.Player) && !args.Player.HasPermission(Permissions.allowdroppingbanneditems))) " is 203.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The length of the statement  "			if ((Main.ServerSideCharacter) && (DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond - args.Player.LoginMS < TShock.ServerSideCharacterConfig.LogonDiscardThreshold)) " is 165.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The length of the statement  "				args.Player.Disable(String.Format("Player does not have permission to create projectile {0}."' type)' DisableFlags.WriteToLogAndConsole); " is 137.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The length of the statement  "				args.Player.Disable(String.Format("Projectile damage is higher than {0}."' TShock.Config.MaxProjDamage)' DisableFlags.WriteToLogAndConsole); " is 140.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The length of the statement  "			if (!TShock.Config.IgnoreProjUpdate && !hasPermission && !args.Player.HasPermission(Permissions.ignoreprojectiledetection)) " is 123.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The length of the statement  "					args.Player.Disable(String.Format("Does not have projectile permission to update projectile. ({0})"' type)' DisableFlags.WriteToLogAndConsole); " is 143.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNPCStrike,The length of the statement  "					args.Player.Disable(String.Format("NPC damage exceeded {0}."' TShock.Config.MaxDamage)' DisableFlags.WriteToLogAndConsole); " is 123.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerPortalTeleport,The length of the statement  "				args.Player.Disable("Malicious portal attempt."' DisableFlags.WriteToLogAndConsole); //Todo: this message is not particularly clear - suggestions wanted " is 152.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerDamage,The length of the statement  "			if (damage > TShock.Config.MaxDamage && !args.Player.HasPermission(Permissions.ignoredamagecap) && id != args.Player.Index) " is 123.
Long Statement,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerDamage,The length of the statement  "					args.Player.Disable(String.Format("Player damage exceeded {0}."' TShock.Config.MaxDamage)' DisableFlags.WriteToLogAndConsole); " is 126.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "				Rest.Register(new RestCommand("/v2/server/status"' (a) => ServerStatusV2(new RestRequestArgs(a.Verbs' a.Parameters' a.Request' SecureRest.TokenData.None' a.Context)))); " is 168.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "				Rest.Register(new RestCommand("/v3/server/motd"' (a) => ServerMotd(new RestRequestArgs(a.Verbs' a.Parameters' a.Request' SecureRest.TokenData.None' a.Context)))); " is 162.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "				Rest.Register(new RestCommand("/v3/server/rules"' (a) => ServerRules(new RestRequestArgs(a.Verbs' a.Parameters' a.Request' SecureRest.TokenData.None' a.Context)))); " is 164.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/users/create"' UserCreateV2' RestPermissions.restmanageusers) { DoLog = false }); " is 122.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/users/update"' UserUpdateV2' RestPermissions.restmanageusers) { DoLog = false }); " is 122.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/world/autosave/state/{state}"' WorldChangeSaveSettings' RestPermissions.restcfg)); " is 123.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/players/ban"' PlayerBanV2' RestPermissions.restban' RestPermissions.restmanagebans)); " is 126.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerOff,The length of the statement  "			var reason = string.IsNullOrWhiteSpace(args.Parameters["message"]) ? "Server is shutting down" : args.Parameters["message"]; " is 124.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerReload,The length of the statement  "			Hooks.GeneralHooks.OnReloadEvent(new TSRestPlayer(args.TokenData.Username' TShock.Groups.GetGroupByName(args.TokenData.UserGroupName))); " is 136.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerReload,The length of the statement  "			return RestResponse("Configuration' permissions' and regions reload complete. Some changes may require a server restart."); " is 123.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerStatusV2,The length of the statement  "					var p = PlayerFilter(tsPlayer' args.Parameters' ((args.TokenData.UserGroupName) != "" && TShock.Groups.GetGroupByName(args.TokenData.UserGroupName).HasPermission(RestPermissions.viewips))); " is 189.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,UserActiveListV2,The length of the statement  "			return new RestObject() { { "activeusers"' string.Join("\t"' TShock.Players.Where(p => null != p && null != p.Account && p.Active).Select(p => p.Account.Name)) } }; " is 164.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,GroupList,The length of the statement  "				groups.Add(new Dictionary<string' object> {{"name"' group.Name}' {"parent"' group.ParentName}' {"chatcolor"' group.ChatColor}}); " is 128.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,GroupUpdate,The length of the statement  "			var chatcolor = (null == args.Parameters["chatcolor"]) ? string.Format("{0}.{1}.{2}"' group.R' group.G' group.B) : args.Parameters["chatcolor"]; " is 144.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "			foreach (var method in rest.GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static).OrderBy(f => f.Name)) " is 162.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "				if (descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) && routeattr != null && !string.IsNullOrWhiteSpace(routeattr.Route)) " is 141.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "							sb.AppendLine("\t{0}({1}) [{2}] - {3}".SFormat(verb.Name' verb.Required ? "Required" : "Optional"' verb.ArgumentType.Name' verb.Description)); " is 142.
Long Statement,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "							sb.AppendLine("\t{0}({1}) [{2}] - {3}".SFormat(noun.Name' noun.Required ? "Required" : "Optional"' noun.ArgumentType.Name' noun.Description)); " is 142.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The length of the statement  "							ServerApi.LogWriter.PluginWriteLine(this' string.Format("Loading dedicated config file: {0}"' cfg)' TraceLevel.Verbose); " is 120.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The length of the statement  "							ServerApi.LogWriter.PluginWriteLine(this' string.Format("World name will be overridden by: {0}"' world)' TraceLevel.Verbose); " is 125.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The length of the statement  "					Log.ConsoleInfo("TShock will now disable the initial setup system and remove setup-code.txt as it is no longer needed."); " is 121.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The length of the statement  "					// This avoids unnecessary database work' which can get ridiculously high on old servers as all users need to be fetched " is 120.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnUpdate,The length of the statement  "			if (Main.ServerSideCharacter && (DateTime.UtcNow - LastSave).TotalMinutes >= ServerSideCharacterConfig.ServerSideCharacterSave) " is 127.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player)) " is 133.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"); " is 120.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once " is 120.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player)) " is 133.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"); " is 120.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnStatueSpawn,The length of the statement  "			if (args.Within200 < Config.StatueSpawn200 && args.Within600 < Config.StatueSpawn600 && args.WorldWide < Config.StatueSpawnWorld) " is 129.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnJoin,The length of the statement  "				player.Kick("Your client sent a blank UUID. Configure it to send one or use a different client."' true' true' null' false); " is 123.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The length of the statement  "				if (tsplr.IsLoggedIn && !tsplr.IsDisabledPendingTrashRemoval && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2)) " is 139.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The length of the statement  "					ply.name = String.Format(Config.ChatAboveHeadsFormat' tsplr.Group.Name' tsplr.Group.Prefix' tsplr.Name' tsplr.Group.Suffix); " is 124.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The length of the statement  "					//Update the player's name to format text nicely. This needs to be done because Terraria automatically formats messages against our will " is 136.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The length of the statement  "					player.SendErrorMessage(String.Format("Server side characters is enabled! Please {0}register or {0}login to play!"' Commands.Specifier)); " is 137.
Long Statement,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The length of the statement  "			if (Config.RememberLeavePos && (RememberedPos.GetLeavePos(player.Name' player.IP) != Vector2.Zero) && !player.LoginHarassed) " is 124.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasHackedItemStacks,The length of the statement  "								SendErrorMessage("Stack cheat detected. Remove piggy-bank item {0} ({1}) and then rejoin."' item.Name' piggy[index].stack); " is 123.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasHackedItemStacks,The length of the statement  "								SendErrorMessage("Stack cheat detected. Remove Defender's Forge item {0} ({1}) and then rejoin."' item.Name' forge[index].stack); " is 129.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasModifiedIceSuccessfully,The length of the statement  "					if (p.X == x && p.Y == y && (Main.tile[p.X' p.Y].type == TileID.Dirt || Main.tile[p.X' p.Y].type == TileID.MagicalIceBlock)) " is 124.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,DamagePlayer,The length of the statement  "			NetMessage.SendPlayerHurt(Index' PlayerDeathReason.LegacyDefault()' damage' (new Random()).Next(-1' 1)' false' false' 0' -1' -1); " is 129.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Kick,The length of the statement  "						TShock.Utils.Broadcast(string.Format("{0} {1}kicked {2} for '{3}'"' adminUserName' verb' Name' reason.ToLower())' Color.Green); " is 127.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendData,The length of the statement  "			NetMessage.SendData((int)msgType' Index' -1' NetworkText.FromLiteral(text)' number' number2' number3' number4' number5); " is 120.
Long Statement,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendDataFromPlayer,The length of the statement  "			NetMessage.SendData((int)msgType' Index' -1' NetworkText.FromFormattable(text)' ply' number2' number3' number4' number5); " is 121.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,Reload,The length of the statement  "						Region r = new Region(id' new Rectangle(X1' Y1' width' height)' name' owner' Protected != 0' Main.worldID.ToString()' z); " is 121.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,Reload,The length of the statement  "							TShock.Log.Error("A lot of things will fail because of this. You must manually delete and re-create the allowed field."); " is 121.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,AddRegion,The length of the statement  "					"INSERT INTO Regions (X1' Y1' width' height' RegionName' WorldID' UserIds' Protected' Groups' Owner' Z) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8' @9' @10);"' " is 159.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,AddRegion,The length of the statement  "				using (QueryResult res = database.QueryReader("SELECT Id FROM Regions WHERE RegionName = @0 AND WorldID = @1"' regionname' worldid)) " is 132.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The length of the statement  "				using (var reader = database.QueryReader("SELECT X1' Y1' height' width FROM Regions WHERE RegionName=@0 AND WorldID=@1"' " is 120.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The length of the statement  "				int q = database.Query("UPDATE Regions SET X1 = @0' Y1 = @1' width = @2' height = @3 WHERE RegionName = @4 AND WorldID=@5"' X' Y' width' " is 136.
Long Statement,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,PositionRegion,The length of the statement  "				if (database.Query("UPDATE Regions SET X1 = @0' Y1 = @1' width = @2' height = @3 WHERE RegionName = @4 AND WorldID = @5"' " is 121.
Long Statement,TShockAPI.DB,Region,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,HasPermissionToBuildInRegion,The length of the statement  "			return ply.HasPermission(Permissions.editregion) || AllowedIDs.Contains(ply.Account.ID) || AllowedGroups.Contains(ply.Group.Name) || Owner == ply.Account.Name; " is 159.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByIp,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetSortedBans,The length of the statement  "						banlist.Add(new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration"))); " is 265.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByName,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByAccountName,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByUUID,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan,The length of the statement  "					return database.Query("UPDATE Bans SET Date = @0' Expiration = @1 WHERE IP = @2"' DateTime.UtcNow.ToString("s")' expiration' ip) == 1; " is 134.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan,The length of the statement  "					return database.Query("INSERT INTO Bans (IP' Name' UUID' Reason' BanningUser' Date' Expiration' AccountName) VALUES (@0' @1' @2' @3' @4' @5' @6' @7);"' ip' name' uuid' reason' banner' DateTime.UtcNow.ToString("s")' expiration' accountName) != 0; " is 245.
Long Statement,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,RemoveBanIfExpired,The length of the statement  "			if (!string.IsNullOrWhiteSpace(ban.Expiration) && (ban.ExpirationDateTime != null) && (DateTime.UtcNow >= ban.ExpirationDateTime)) " is 130.
Long Statement,TShockAPI.DB,BanComparer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,CompareDateTimes,The length of the statement  "			return _method == BanSortMethod.AddedNewestToOldest || _method == BanSortMethod.ExpirationSoonestToLatest ? x.Value.CompareTo(y.Value) " is 134.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,SeedInitialData,The length of the statement  "				database.Query("INSERT INTO tsCharacter (Account' Health' MaxHealth' Mana' MaxMana' Inventory' spawnX' spawnY' questsCompleted) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8);"' " is 174.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						"INSERT INTO tsCharacter (Account' Health' MaxHealth' Mana' MaxMana' Inventory' extraSlot' spawnX' spawnY' skinVariant' hair' hairDye' hairColor' pantsColor' shirtColor' underShirtColor' shoeColor' hideVisuals' skinColor' eyeColor' questsCompleted) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8' @9' @10' @11' @12' @13' @14' @15' @16' @17' @18' @19' @20);"' " is 354.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						player.Account.ID' playerData.health' playerData.maxHealth' playerData.mana' playerData.maxMana' String.Join("~"' playerData.inventory)' playerData.extraSlot' player.TPlayer.SpawnX' player.TPlayer.SpawnY' player.TPlayer.skinVariant' player.TPlayer.hair' player.TPlayer.hairDye' TShock.Utils.EncodeColor(player.TPlayer.hairColor)' TShock.Utils.EncodeColor(player.TPlayer.pantsColor)'TShock.Utils.EncodeColor(player.TPlayer.shirtColor)' TShock.Utils.EncodeColor(player.TPlayer.underShirtColor)' TShock.Utils.EncodeColor(player.TPlayer.shoeColor)' TShock.Utils.EncodeBoolArray(player.TPlayer.hideVisual)' TShock.Utils.EncodeColor(player.TPlayer.skinColor)'TShock.Utils.EncodeColor(player.TPlayer.eyeColor)' player.TPlayer.anglerQuestsFinished); " is 741.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						"UPDATE tsCharacter SET Health = @0' MaxHealth = @1' Mana = @2' MaxMana = @3' Inventory = @4' spawnX = @6' spawnY = @7' hair = @8' hairDye = @9' hairColor = @10' pantsColor = @11' shirtColor = @12' underShirtColor = @13' shoeColor = @14' hideVisuals = @15' skinColor = @16' eyeColor = @17' questsCompleted = @18' skinVariant = @19' extraSlot = @20 WHERE Account = @5;"' " is 369.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						playerData.health' playerData.maxHealth' playerData.mana' playerData.maxMana' String.Join("~"' playerData.inventory)' player.Account.ID' player.TPlayer.SpawnX' player.TPlayer.SpawnY' player.TPlayer.hair' player.TPlayer.hairDye' TShock.Utils.EncodeColor(player.TPlayer.hairColor)' TShock.Utils.EncodeColor(player.TPlayer.pantsColor)' TShock.Utils.EncodeColor(player.TPlayer.shirtColor)' TShock.Utils.EncodeColor(player.TPlayer.underShirtColor)' TShock.Utils.EncodeColor(player.TPlayer.shoeColor)' TShock.Utils.EncodeBoolArray(player.TPlayer.hideVisual)' TShock.Utils.EncodeColor(player.TPlayer.skinColor)' TShock.Utils.EncodeColor(player.TPlayer.eyeColor)' player.TPlayer.anglerQuestsFinished' player.TPlayer.skinVariant' player.TPlayer.extraAccessory ? 1 : 0); " is 760.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertSpecificPlayerData,The length of the statement  "						"INSERT INTO tsCharacter (Account' Health' MaxHealth' Mana' MaxMana' Inventory' extraSlot' spawnX' spawnY' skinVariant' hair' hairDye' hairColor' pantsColor' shirtColor' underShirtColor' shoeColor' hideVisuals' skinColor' eyeColor' questsCompleted) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8' @9' @10' @11' @12' @13' @14' @15' @16' @17' @18' @19' @20);"' " is 354.
Long Statement,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertSpecificPlayerData,The length of the statement  "						"UPDATE tsCharacter SET Health = @0' MaxHealth = @1' Mana = @2' MaxMana = @3' Inventory = @4' spawnX = @6' spawnY = @7' hair = @8' hairDye = @9' hairColor = @10' pantsColor = @11' shirtColor = @12' underShirtColor = @13' shoeColor = @14' hideVisuals = @15' skinColor = @16' eyeColor = @17' questsCompleted = @18' skinVariant = @19' extraSlot = @20 WHERE Account = @5;"' " is 369.
Long Statement,TShockAPI.DB,GenericQueryCreator,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\IQueryBuilder.cs,UpdateValue,The length of the statement  "			return "UPDATE {0} SET {1} {2}".SFormat(EscapeTableName(table)' string.Join("' "' values.Select(v => v.Name + " = " + v.Value))' BuildWhere(wheres)); " is 149.
Long Statement,TShockAPI.DB,DbExt,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Extensions\DbExt.cs,QueryReader,The length of the statement  "				throw new Exception("Fatal TShock initialization exception: failed to connect to MySQL database. See inner exception for details."' ex); " is 136.
Long Statement,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,LoadPermisions,The length of the statement  "							TShock.Log.ConsoleInfo("WARNING: Group \"superadmin\" is defined in the database even though it's a reserved group name."); " is 123.
Long Statement,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,LoadPermisions,The length of the statement  "										"ERROR: Group \"{0}\" is referencing parent group \"{1}\" which is already part of the parent chain. Parent reference removed."' " is 128.
Long Statement,TShockAPI.DB,UserAccountManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,AddUserAccount,The length of the statement  "				ret = _database.Query("INSERT INTO Users (Username' Password' UUID' UserGroup' Registered) VALUES (@0' @1' @2' @3' @4);"' account.Name' " is 135.
Long Statement,TShockAPI.DB,UserAccountManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UpdateLogin,The length of the statement  "				if (_database.Query("UPDATE Users SET LastAccessed = @0' KnownIps = @1 WHERE Username = @2;"' DateTime.UtcNow.ToString("s")' account.KnownIps' account.Name) == 0) " is 162.
Long Statement,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The length of the statement  "				throw new ArgumentOutOfRangeException("password"' "Password must be > " + TShock.Config.MinimumPasswordLength + " characters."); " is 128.
Long Statement,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The length of the statement  "				throw new ArgumentOutOfRangeException("password"' "Password must be > " + TShock.Config.MinimumPasswordLength + " characters."); " is 128.
Long Statement,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,HashPassword,The length of the statement  "				throw new NotSupportedException("Hashing algorithm {0} is not supported".SFormat(TShock.Config.HashAlgorithm.ToLower())); " is 121.
Long Statement,TShockAPI.DB,RememberedPosManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,GetLeavePos,The length of the statement  "				using (var reader = database.QueryReader("SELECT * FROM RememberedPos WHERE Name=@0 AND IP=@1 AND WorldID=@2"' name' IP' Main.worldID.ToString())) " is 146.
Long Statement,TShockAPI.DB,RememberedPosManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,InsertLeavePos,The length of the statement  "					database.Query("INSERT INTO RememberedPos (Name' IP' X' Y' WorldID) VALUES (@0' @1' @2' @3' @4);"' name' IP' X' Y ' Main.worldID.ToString()); " is 141.
Long Statement,TShockAPI.DB,RememberedPosManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,InsertLeavePos,The length of the statement  "					database.Query("UPDATE RememberedPos SET X = @0' Y = @1' IP = @2' WorldID = @3 WHERE Name = @4;"' X' Y' IP' Main.worldID.ToString()' name); " is 139.
Long Statement,TShockAPI.Sockets,LinuxTcpSocket,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,AsyncReceive,The length of the statement  "			this._connection.GetStream().BeginRead(data' offset' size' new AsyncCallback(this.ReadCallback)' new Tuple<SocketReceiveCallback' object>(callback' state)); " is 156.
Long Statement,Rests,Rest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,Start,The length of the statement  "				TShock.Log.ConsoleError("Invalid REST configuration: \nYou may already have a REST service bound to port {0}. \nPlease adjust your configuration and restart the server. \nPress any key to exit."' Port); " is 202.
Long Statement,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "					TShock.Log.ConsoleError("A REST login from {0} was blocked as it currently has {1} tokens"' context.RemoteEndPoint.Address.ToString()' tokens); " is 143.
Long Statement,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "				tokenBucket[context.RemoteEndPoint.Address.ToString()] += 1; // Tokens under limit' increment by one and process request " is 120.
Long Statement,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "				return new RestObject("403") { Error = "Username or password may be incorrect or this account may not have sufficient privileges." }; " is 133.
Long Statement,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "				return new RestObject("403") { Error = "Username or password may be incorrect or this account may not have sufficient privileges." }; " is 133.
Long Statement,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,ExecuteCommand,The length of the statement  "				{ Error = string.Format("Not authorized. User \"{0}\" has no access to use the specified API endpoint."' tokenData.Username) }; " is 127.
Complex Conditional,TShockAPI,HandlerList<T>,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\HandlerList.cs,Invoke,The conditional expression  "hargs == null || !hargs.Handled || (hargs.Handled && handlers[i].GetHandled)"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The conditional expression  "account.VerifyPassword(password) ||  						(usingUUID && account.UUID == args.Player.UUID && !TShock.Config.DisableUUIDLogin &&  						!String.IsNullOrWhiteSpace(args.Player.UUID))"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The conditional expression  "warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add""  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The conditional expression  "parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b)"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The conditional expression  "!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The conditional expression  "args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Butcher,The conditional expression  "Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC && Main.npc[i].netID != NPCID.TargetDummy) || Main.npc[i].netID == npcId)"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The conditional expression  "args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The conditional expression  "Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC) || (Main.npc[i].netID == npcId && Main.npc[i].townNPC))"  is complex.
Complex Conditional,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The conditional expression  "plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerSlot,The conditional expression  "OnPlayerSlot(args.Player' args.Data' plr' slot' stack' prefix' type) || plr != args.Player.Index || slot < 0 ||  			    slot > NetItem.MaxInventory"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerSlot,The conditional expression  "Main.ServerSideCharacter && TShock.Config.DisableLoginBeforeJoin && !bypassTrashCanCheck &&  			         args.Player.HasSentInventory && !args.Player.HasPermission(Permissions.bypassssc)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The conditional expression  "(Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerHp,The conditional expression  "OnPlayerHP(args.Player' args.Data' plr' cur' max) || cur <= 0 || max <= 0 || args.Player.IgnoreSSCPackets"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleDoorUse,The conditional expression  "x >= Main.maxTilesX || y >= Main.maxTilesY || x < 0 || y < 0"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleDoorUse,The conditional expression  "tileType != TileID.ClosedDoor && tileType != TileID.OpenDoor  			                                  && tileType != TileID.TallGateClosed && tileType != TileID.TallGateOpen  			                                  && tileType != TileID.TrapdoorClosed && tileType != TileID.TrapdoorOpen"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The conditional expression  "!args.Player.HasProjectilePermission(index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerMana,The conditional expression  "OnPlayerMana(args.Player' args.Data' plr' cur' max) || cur < 0 || max < 0 || args.Player.IgnoreSSCPackets"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The conditional expression  "Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintTile,The conditional expression  "x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY || t > Main.numTileColors"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintTile,The conditional expression  "args.Player.SelectedItem.type != ItemID.PaintRoller &&  				args.Player.SelectedItem.type != ItemID.PaintScraper &&  				args.Player.SelectedItem.type != ItemID.Paintbrush &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintRoller &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintScraper &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintbrush &&  				!args.Player.Accessories.Any(i => i != null && i.stack > 0 &&  					(i.type == ItemID.PaintSprayer || i.type == ItemID.ArchitectGizmoPack))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintWall,The conditional expression  "x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY || t > Main.numTileColors"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintWall,The conditional expression  "args.Player.SelectedItem.type != ItemID.PaintRoller &&  				args.Player.SelectedItem.type != ItemID.PaintScraper &&  				args.Player.SelectedItem.type != ItemID.Paintbrush &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintRoller &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintScraper &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintbrush &&  				!args.Player.Accessories.Any(i => i != null && i.stack > 0 &&  					(i.type == ItemID.PaintSprayer || i.type == ItemID.ArchitectGizmoPack))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSyncExtraValue,The conditional expression  "position.X < 0 || position.X >= Main.maxTilesX || position.Y < 0 || position.Y >= Main.maxTilesY"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The conditional expression  "npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The conditional expression  "pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.Player.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "(action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData])"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID]))"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "action == EditAction.PlaceTile && (editData == TileID.PiggyBank || editData == TileID.Safes) && Main.ServerSideCharacter"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "(TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The conditional expression  "(action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The conditional expression  "(newtile.Type == TileID.LogicSensor ||  							newtile.Type == TileID.ItemFrame ||  							newtile.Type == TileID.TargetDummy) &&  							!Main.tile[realx' realy].active()"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The conditional expression  "(TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type])"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The conditional expression  "((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The conditional expression  "(tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen || newtile.Type == TileID.TrapdoorClosed))"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The conditional expression  "(stacks > item.maxStack || stacks <= 0) || (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' args.Player) && !args.Player.HasPermission(Permissions.allowdroppingbanneditems))"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The conditional expression  "type == ProjectileID.BlowupSmokeMoonlord  					|| type == ProjectileID.PhantasmalEye  					|| type == ProjectileID.CultistBossIceMist  					|| (type >= ProjectileID.MoonlordBullet && type <= ProjectileID.MoonlordTurretLaser)  					|| type == ProjectileID.DeathLaser || type == ProjectileID.Landmine  					|| type == ProjectileID.BulletDeadeye || type == ProjectileID.BoulderStaffOfEarth  					|| (type > ProjectileID.ConfettiMelee && type < ProjectileID.SpiritHeal)  					|| (type >= ProjectileID.FlamingWood && type <= ProjectileID.GreekFire3)  					|| (type >= ProjectileID.PineNeedleHostile && type <= ProjectileID.Spike)  					|| (type >= ProjectileID.MartianTurretBolt && type <= ProjectileID.RayGunnerLaser)  					|| type == ProjectileID.CultistBossLightningOrb"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The conditional expression  "hasPermission &&  				(type == ProjectileID.Bomb  				|| type == ProjectileID.Dynamite  				|| type == ProjectileID.StickyBomb  				|| type == ProjectileID.StickyDynamite)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The conditional expression  "flag != 0 && flag != 4 // if no container or container2 placement  				&& Main.tile[tileX' tileY].type != TileID.Containers  				&& Main.tile[tileX' tileY].type != TileID.Dressers  				&& Main.tile[tileX' tileY].type != TileID.Containers2  				&& (!TShock.Utils.HasWorldReachedMaxChests() && Main.tile[tileX' tileY].type != TileID.Dirt)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The conditional expression  "(TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Teleporter) ||  					(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Teleporter)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The conditional expression  "args.Zone2[1] || args.Zone2[2] || args.Zone2[3] || args.Zone2[4]"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The conditional expression  "(args.Zone2[1] && !hasSolarTower)  					|| (args.Zone2[2] && !hasVortexTower)  					|| (args.Zone2[3] && !hasNebulaTower)  					|| (args.Zone2[4] && !hasStardustTower)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The conditional expression  "type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNPCAddBuff,The conditional expression  "type != BuffID.Lovestruck && type != BuffID.Stinky && type != BuffID.DryadsWard &&  						type != BuffID.Wet && type != BuffID.Slimed"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The conditional expression  "(type != TileID.Rope  					|| type != TileID.SilkRope  					|| type != TileID.VineRope  					|| type != TileID.WebRope)  					&& !args.Player.IsInRange(x' y)"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerPortalTeleport,The conditional expression  "args.NewPosition.X > Main.maxTilesX || args.NewPosition.X < 0  				|| args.NewPosition.Y > Main.maxTilesY || args.NewPosition.Y < 0"  is complex.
Complex Conditional,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnGemLockToggle,The conditional expression  "args.X < 0 || args.Y < 0 || args.X >= Main.maxTilesX || args.Y >= Main.maxTilesY"  is complex.
Complex Conditional,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,WorldButcher,The conditional expression  "Main.npc[i].active && Main.npc[i].type != 0 && !Main.npc[i].townNPC && (!Main.npc[i].friendly || killFriendly)"  is complex.
Complex Conditional,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The conditional expression  "descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) && routeattr != null && !string.IsNullOrWhiteSpace(routeattr.Route)"  is complex.
Complex Conditional,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,SendLogs,The conditional expression  "player != null && player != excludedPlayer && player.Active && player.HasPermission(Permissions.logs) &&  						player.DisplayLogs && TShock.Config.DisableSpewLogs == false"  is complex.
Complex Conditional,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The conditional expression  "Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+' || str[i] == ' ')"  is complex.
Complex Conditional,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The conditional expression  "(Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnCreep,The conditional expression  "!Config.AllowCrimsonCreep && (tileType == TileID.Dirt || tileType == TileID.FleshWeeds  				|| TileID.Sets.Crimson[tileType])"  is complex.
Complex Conditional,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnCreep,The conditional expression  "!Config.AllowCorruptionCreep && (tileType == TileID.Dirt || tileType == TileID.CorruptThorns  				|| TileID.Sets.Corrupt[tileType])"  is complex.
Complex Conditional,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The conditional expression  "tsplr.IsLoggedIn && !tsplr.IsDisabledPendingTrashRemoval && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The conditional expression  "(player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22"  is complex.
Complex Conditional,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The conditional expression  "e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)"  is complex.
Complex Conditional,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasModifiedIceSuccessfully,The conditional expression  "p.X == x && p.Y == y && (Main.tile[p.X' p.Y].type == TileID.Dirt || Main.tile[p.X' p.Y].type == TileID.MagicalIceBlock)"  is complex.
Complex Conditional,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,GiveItemCheck,The conditional expression  "(TShock.Itembans.ItemIsBanned(name) && TShock.Config.PreventBannedItemSpawn) &&  			    (TShock.Itembans.ItemIsBanned(name' this) || !TShock.Config.AllowAllowedGroupsToSpawnBannedItems)"  is complex.
Empty Catch Block,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetIPv4AddressFromHostname,The method has an empty catch block.
Empty Catch Block,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendTileSquare,The method has an empty catch block.
Empty Catch Block,TShockAPI.Sockets,LinuxTcpSocket,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,ListenLoop,The method has an empty catch block.
Magic Number,TShockAPI,NetItem,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\NetItem.cs,Parse,The following statement contains a magic number: comp.Length != 3
Magic Number,TShockAPI,NetItem,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\NetItem.cs,Parse,The following statement contains a magic number: byte prefixId = Byte.Parse(comp[2]);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(4' -1' -1' NetworkText.FromLiteral(player.Name)' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(42' -1' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(16' -1' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(4' player.Index' -1' NetworkText.FromLiteral(player.Name)' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(42' player.Index' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(16' player.Index' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: k < 22
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(50' -1' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(50' player.Index' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(76' player.Index' -1' NetworkText.Empty' player.Index);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(76' -1' -1' NetworkText.Empty' player.Index);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(39' player.Index' -1' NetworkText.Empty' 400);
Magic Number,TShockAPI,PlayerData,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(39' player.Index' -1' NetworkText.Empty' 400);
Magic Number,TShockAPI,RegionHandler,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\RegionHandler.cs,OnTileEdit,The following statement contains a magic number: player.SendTileSquare(e.X' e.Y' 4);
Magic Number,TShockAPI,RegionHandler,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\RegionHandler.cs,OnTileEdit,The following statement contains a magic number: player.SendTileSquare(e.X' e.Y' 4);
Magic Number,TShockAPI,SqlLog,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\SqlLog.cs,Write,The following statement contains a magic number: var frame = new StackTrace().GetFrame(2);
Magic Number,TShockAPI,TextLog,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TextLog.cs,Write,The following statement contains a magic number: var frame = new StackTrace().GetFrame(2);
Magic Number,TShockAPI,Settings,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,Settings,The following statement contains a magic number: this.maxLinesPerPage = 4;
Magic Number,TShockAPI,SaveManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\SaveManager.cs,SaveWorld,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,InitCommands,The following statement contains a magic number: List<Command> tshockCommands = new List<Command>(100);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The following statement contains a magic number: args.Player.IsLoggedIn && args.Parameters.Count == 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: account.CreateBCryptHash(args.Parameters[2]);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: account.Group = args.Parameters[3];
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: subcmd == "add" && args.Parameters.Count == 4
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TSPlayer.FindByNameOrID(args.Parameters[1]);    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							//Fail fast  							args.Player.SendMultipleMatchError(players.Select(p => p.Name));  							return;  						}  						  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = args.Player is TSServerPlayer;    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (args.Parameters[2] != "0")  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							}   							else   							{  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d 5h 3m 2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan(target.IP' target.Name' target.UUID' target.Account?.Name ?? ""' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1]))  							{  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							}   							else   							{  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: args.Parameters.Count < 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: !TShock.Utils.TryParseTime(args.Parameters[2]' out time)
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: ply[0].tempGroupTimer = new System.Timers.Timer(time * 1000);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: args.Parameters.Count > 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: args.Parameters.Count < 3
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Broadcast,The following statement contains a magic number: TShock.Utils.Broadcast(  				"(Server Broadcast) " + message'  				Convert.ToByte(TShock.Config.BroadcastRGB[0])' Convert.ToByte(TShock.Config.BroadcastRGB[1])'  				Convert.ToByte(TShock.Config.BroadcastRGB[2]));
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(4);  						break;  				}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(4);  						break;  				}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(4);  						break;  				}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ClearAnglerQuests,The following statement contains a magic number: ply.SendData((PacketTypes)74' "");
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: args.Parameters.Count < 1 || args.Parameters.Count > 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: args.Parameters.Count == 2 && (!int.TryParse(args.Parameters[1]' out amount) || amount <= 0)
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: args.Parameters.Count < 1 || args.Parameters.Count > 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: args.Parameters.Count == 2 && !int.TryParse(args.Parameters[1]' out amount)
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Spawn,The following statement contains a magic number: args.Player.Teleport(Main.spawnTileX * 16' (Main.spawnTileY * 16) - 48)
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Spawn,The following statement contains a magic number: args.Player.Teleport(Main.spawnTileX * 16' (Main.spawnTileY * 16) - 48)
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Spawn,The following statement contains a magic number: args.Player.Teleport(Main.spawnTileX * 16' (Main.spawnTileY * 16) - 48)
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TP,The following statement contains a magic number: args.Parameters.Count != 1 && args.Parameters.Count != 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPPos,The following statement contains a magic number: args.Parameters.Count != 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPPos,The following statement contains a magic number: args.Player.Teleport(16 * x' 16 * y);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPPos,The following statement contains a magic number: args.Player.Teleport(16 * x' 16 * y);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetSpawn,The following statement contains a magic number: Main.spawnTileY = args.Player.TileY + 3;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetDungeon,The following statement contains a magic number: Main.dungeonY = args.Player.TileY + 3;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,MaxSpawns,The following statement contains a magic number: TShock.Config.DefaultMaximumSpawns = NPC.defaultMaxSpawns = 5;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnRate,The following statement contains a magic number: TShock.Config.DefaultSpawnRate = NPC.defaultSpawnRate = 600;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: double time = Main.time / 3600.0;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: time += 4.5;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: time += 15.0;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: time = time % 24.0;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0));
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Rain,The following statement contains a magic number: args.Parameters.Count < 1 || args.Parameters.Count > 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Rain,The following statement contains a magic number: args.Parameters.Count == 2 && args.Parameters[0].ToLowerInvariant() == "slime"
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Slap,The following statement contains a magic number: args.Parameters.Count < 1 || args.Parameters.Count > 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Wind,The following statement contains a magic number: !int.TryParse(args.Parameters[0]' out speed) || speed * 100 < 0
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ListConnectedPlayers,The following statement contains a magic number: bool invalidUsage = (args.Parameters.Count > 2);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Whisper,The following statement contains a magic number: args.Parameters.Count < 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Annoy,The following statement contains a magic number: args.Parameters.Count != 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Annoy,The following statement contains a magic number: int annoy = 5;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: args.Parameters.Count != 1 && args.Parameters.Count != 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: int radius = 50;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: args.Parameters.Count == 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "item":  				case "items":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxItems; i++)  						{  							float dX = Main.item[i].position.X - args.Player.X;  							float dY = Main.item[i].position.Y - args.Player.Y;    							if (Main.item[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.item[i].active = false;  								TSPlayer.All.SendData(PacketTypes.ItemDrop' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} items within a radius of {1}."' cleared' radius);  					}  					break;  				case "npc":  				case "npcs":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxNPCs; i++)  						{  							float dX = Main.npc[i].position.X - args.Player.X;  							float dY = Main.npc[i].position.Y - args.Player.Y;    							if (Main.npc[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.npc[i].active = false;  								Main.npc[i].type = 0;  								TSPlayer.All.SendData(PacketTypes.NpcUpdate' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} NPCs within a radius of {1}."' cleared' radius);  					}  					break;  				case "proj":  				case "projectile":  				case "projectiles":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxProjectiles; i++)  						{  							float dX = Main.projectile[i].position.X - args.Player.X;  							float dY = Main.projectile[i].position.Y - args.Player.Y;    							if (Main.projectile[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.projectile[i].active = false;  								Main.projectile[i].type = 0;  								TSPlayer.All.SendData(PacketTypes.ProjectileNew' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} projectiles within a radius of {1}."' cleared' radius);  					}  					break;  				default:  					args.Player.SendErrorMessage("Invalid clear option!");  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "item":  				case "items":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxItems; i++)  						{  							float dX = Main.item[i].position.X - args.Player.X;  							float dY = Main.item[i].position.Y - args.Player.Y;    							if (Main.item[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.item[i].active = false;  								TSPlayer.All.SendData(PacketTypes.ItemDrop' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} items within a radius of {1}."' cleared' radius);  					}  					break;  				case "npc":  				case "npcs":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxNPCs; i++)  						{  							float dX = Main.npc[i].position.X - args.Player.X;  							float dY = Main.npc[i].position.Y - args.Player.Y;    							if (Main.npc[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.npc[i].active = false;  								Main.npc[i].type = 0;  								TSPlayer.All.SendData(PacketTypes.NpcUpdate' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} NPCs within a radius of {1}."' cleared' radius);  					}  					break;  				case "proj":  				case "projectile":  				case "projectiles":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxProjectiles; i++)  						{  							float dX = Main.projectile[i].position.X - args.Player.X;  							float dY = Main.projectile[i].position.Y - args.Player.Y;    							if (Main.projectile[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.projectile[i].active = false;  								Main.projectile[i].type = 0;  								TSPlayer.All.SendData(PacketTypes.ProjectileNew' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} projectiles within a radius of {1}."' cleared' radius);  					}  					break;  				default:  					args.Player.SendErrorMessage("Invalid clear option!");  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "item":  				case "items":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxItems; i++)  						{  							float dX = Main.item[i].position.X - args.Player.X;  							float dY = Main.item[i].position.Y - args.Player.Y;    							if (Main.item[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.item[i].active = false;  								TSPlayer.All.SendData(PacketTypes.ItemDrop' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} items within a radius of {1}."' cleared' radius);  					}  					break;  				case "npc":  				case "npcs":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxNPCs; i++)  						{  							float dX = Main.npc[i].position.X - args.Player.X;  							float dY = Main.npc[i].position.Y - args.Player.Y;    							if (Main.npc[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.npc[i].active = false;  								Main.npc[i].type = 0;  								TSPlayer.All.SendData(PacketTypes.NpcUpdate' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} NPCs within a radius of {1}."' cleared' radius);  					}  					break;  				case "proj":  				case "projectile":  				case "projectiles":  					{  						int cleared = 0;  						for (int i = 0; i < Main.maxProjectiles; i++)  						{  							float dX = Main.projectile[i].position.X - args.Player.X;  							float dY = Main.projectile[i].position.Y - args.Player.Y;    							if (Main.projectile[i].active && dX * dX + dY * dY <= radius * radius * 256f)  							{  								Main.projectile[i].active = false;  								Main.projectile[i].type = 0;  								TSPlayer.All.SendData(PacketTypes.ProjectileNew' ""' i);  								cleared++;  							}  						}  						args.Player.SendSuccessMessage("Deleted {0} projectiles within a radius of {1}."' cleared' radius);  					}  					break;  				default:  					args.Player.SendErrorMessage("Invalid clear option!");  					break;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Butcher,The following statement contains a magic number: TSPlayer.Server.StrikeNPC(i' (int)(Main.npc[i].life + (Main.npc[i].defense * 0.6))' 0' 0);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: args.Parameters.Count != 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: args.Parameters.Count == 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: NetMessage.SendData(56' -1' -1' NetworkText.FromLiteral(args.Parameters[1])' i' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: args.Parameters.Count < 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: args.Parameters.Count < 1 || args.Parameters.Count > 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: int time = 60;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: args.Parameters.Count == 2
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: time = 60;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: args.Player.SetBuff(id' time * 60);
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: args.Parameters.Count < 2 || args.Parameters.Count > 3
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: args.Parameters.Count < 2 || args.Parameters.Count > 3
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: int time = 60;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: var y = args.Player.TileY + 3;
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[20] = 600;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[20] = 600;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[0x18] = 1200;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[0x1f] = 120;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[0x27] = 420;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: bool extraSlot = extra[2];
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: args.Player.TPlayer.hideVisual = new bool[10];
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: i < 8
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: i < 10
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: TShock.Config.HardcoreOnly && difficulty < 2
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerSlot,The following statement contains a magic number: slot == 58
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleConnecting,The following statement contains a magic number: args.Player.State = 2;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleConnecting,The following statement contains a magic number: args.Player.State = 2;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: ((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1))
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: pulley[2]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[5] = false;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.Player.TPlayer.statMana += 20;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.Player.TPlayer.statManaMax += 20;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.Player.PlayerData.maxMana += 20;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[5]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.TPlayer.fallStart = (int)(pos.Y / 16f);
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.TPlayer.pulleyDir = (byte)(pulley[1] ? 2 : 1);
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: pulley[3]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.TPlayer.gravDir = pulley[4] ? 1f : -1f;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[2]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[3]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[4]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[5]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: control[6]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleDoorUse,The following statement contains a magic number: type < 0 || type > 5
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemOwner,The following statement contains a magic number: id < 0 || id > 400
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemOwner,The following statement contains a magic number: id == 400 && owner == 255
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemOwner,The following statement contains a magic number: id == 400 && owner == 255
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The following statement contains a magic number: !args.Player.HasProjectilePermission(index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The following statement contains a magic number: !args.Player.HasProjectilePermission(index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTogglePvp,The following statement contains a magic number: pvpMode == "disabled" || pvpMode == "always" || (DateTime.UtcNow - args.Player.LastPvPTeamChange).TotalSeconds < 5
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleChestActive,The following statement contains a magic number: nameLen != 0 && nameLen <= 20
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePassword,The following statement contains a magic number: args.Player.State = 2;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePassword,The following statement contains a magic number: args.Player.State = 2;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerTeam,The following statement contains a magic number: (DateTime.UtcNow - args.Player.LastPvPTeamChange).TotalSeconds < 5
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149)
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149)
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149)
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149)
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: args.TPlayer.buffTime[i] = 60;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpecial,The following statement contains a magic number: type == 3 & !args.Player.HasPermission(Permissions.usesundial)
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: type = 2;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: flag[2]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: style += 2;
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: flag[3]
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: type == 2
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f
Magic Number,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: args.TPlayer.difficulty == 2 && Main.ServerSideCharacter && args.Player.IsLoggedIn
Magic Number,TShockAPI,SuperAdminGroup,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Group.cs,SuperAdminGroup,The following statement contains a magic number: B = (byte)TShock.Config.SuperAdminChatRGB[2];
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: float distance = Vector2.Distance(new Vector2(pos.X / 16f' pos.Y / 16f)'  					new Vector2(args.Player.LastNetPosition.X / 16f' args.Player.LastNetPosition.Y / 16f));
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: float distance = Vector2.Distance(new Vector2(pos.X / 16f' pos.Y / 16f)'  					new Vector2(args.Player.LastNetPosition.X / 16f' args.Player.LastNetPosition.Y / 16f));
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: float distance = Vector2.Distance(new Vector2(pos.X / 16f' pos.Y / 16f)'  					new Vector2(args.Player.LastNetPosition.X / 16f' args.Player.LastNetPosition.Y / 16f));
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: float distance = Vector2.Distance(new Vector2(pos.X / 16f' pos.Y / 16f)'  					new Vector2(args.Player.LastNetPosition.X / 16f' args.Player.LastNetPosition.Y / 16f));
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerUpdate,The following statement contains a magic number: var lastTileY = args.Player.LastNetPosition.Y - 48;
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnTileEdit,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: size > 5
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: (TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type])
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: (TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type])
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnSendTileSquare,The following statement contains a magic number: ((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The following statement contains a magic number: type < -48 || type >= Main.maxItemTypes
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The following statement contains a magic number: !args.Player.IsInRange((int)(Main.item[id].position.X / 16f)' (int)(Main.item[id].position.Y / 16f))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The following statement contains a magic number: !args.Player.IsInRange((int)(Main.item[id].position.X / 16f)' (int)(Main.item[id].position.Y / 16f))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The following statement contains a magic number: !args.Player.IsInRange((int)(pos.X / 16f)' (int)(pos.Y / 16f))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnItemDrop,The following statement contains a magic number: !args.Player.IsInRange((int)(pos.X / 16f)' (int)(pos.Y / 16f))
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNewProjectile,The following statement contains a magic number: args.Player.RecentFuse = 10;
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNPCStrike,The following statement contains a magic number: TShock.Config.RangeChecks &&  				!args.Player.IsInRange((int)(Main.npc[id].position.X / 16f)' (int)(Main.npc[id].position.Y / 16f)' 128)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNPCStrike,The following statement contains a magic number: TShock.Config.RangeChecks &&  				!args.Player.IsInRange((int)(Main.npc[id].position.X / 16f)' (int)(Main.npc[id].position.Y / 16f)' 128)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnNPCStrike,The following statement contains a magic number: TShock.Config.RangeChecks &&  				!args.Player.IsInRange((int)(Main.npc[id].position.X / 16f)' (int)(Main.npc[id].position.Y / 16f)' 128)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 3);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 3);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: flag != 0 && flag != 4 // if no container or container2 placement  				&& Main.tile[tileX' tileY].type != TileID.Containers  				&& Main.tile[tileX' tileY].type != TileID.Dressers  				&& Main.tile[tileX' tileY].type != TileID.Containers2  				&& (!TShock.Utils.HasWorldReachedMaxChests() && Main.tile[tileX' tileY].type != TileID.Dirt)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 3);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: flag == 2
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 3);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceChest,The following statement contains a magic number: args.Player.SendTileSquare(tileX' tileY' 3);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The following statement contains a magic number: (args.Zone2[1] && !hasSolarTower)  					|| (args.Zone2[2] && !hasVortexTower)  					|| (args.Zone2[3] && !hasNebulaTower)  					|| (args.Zone2[4] && !hasStardustTower)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The following statement contains a magic number: (args.Zone2[1] && !hasSolarTower)  					|| (args.Zone2[2] && !hasVortexTower)  					|| (args.Zone2[3] && !hasNebulaTower)  					|| (args.Zone2[4] && !hasStardustTower)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The following statement contains a magic number: (args.Zone2[1] && !hasSolarTower)  					|| (args.Zone2[2] && !hasVortexTower)  					|| (args.Zone2[3] && !hasNebulaTower)  					|| (args.Zone2[4] && !hasStardustTower)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The following statement contains a magic number: args.Zone2[1] || args.Zone2[2] || args.Zone2[3] || args.Zone2[4]
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The following statement contains a magic number: args.Zone2[1] || args.Zone2[2] || args.Zone2[3] || args.Zone2[4]
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerZone,The following statement contains a magic number: args.Zone2[1] || args.Zone2[2] || args.Zone2[3] || args.Zone2[4]
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The following statement contains a magic number: type == 1 && !(bucket == 2 || bucket == 0)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The following statement contains a magic number: type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The following statement contains a magic number: type == 2 && !(bucket == 3 || bucket == 0)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The following statement contains a magic number: type == 2 && !(bucket == 3 || bucket == 0)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The following statement contains a magic number: type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnLiquidSet,The following statement contains a magic number: !args.Player.IsInRange(tileX' tileY' 16)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerBuff,The following statement contains a magic number: !args.Player.IsInRange(TShock.Players[id].TileX' TShock.Players[id].TileY' 50)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnHealOtherPlayer,The following statement contains a magic number: amount > TShock.Config.MaxDamage * 0.2
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(x' y' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: type == TileID.FakeContainers && (style == 52 || style == 53)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: type == TileID.FakeContainers && (style == 52 || style == 53)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(x' y' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(x' y' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(x' y' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(i' j' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(x' y' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlaceObject,The following statement contains a magic number: args.Player.SendTileSquare(x' y' 4);
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnPlayerDamage,The following statement contains a magic number: !args.Player.IsInRange(TShock.Players[id].TileX' TShock.Players[id].TileY' 100)
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnKillMe,The following statement contains a magic number: damage > 20000
Magic Number,TShockAPI,Bouncer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Bouncer.cs,OnKillMe,The following statement contains a magic number: playerDeathReason.GetDeathText(TShock.Players[id].Name).ToString().Length > 500
Magic Number,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,WorldButcher,The following statement contains a magic number: TSPlayer.Server.StrikeNPC(i' 99999' 90f' 1);
Magic Number,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,WorldButcher,The following statement contains a magic number: TSPlayer.Server.StrikeNPC(i' 99999' 90f' 1);
Magic Number,TShockAPI,RestManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,PlayerKill,The following statement contains a magic number: player.DamagePlayer(999999);
Magic Number,TShockAPI,TSServerPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,SpawnNPC,The following statement contains a magic number: NPC.NewNPC(spawnTileX * 16' spawnTileY * 16' type);
Magic Number,TShockAPI,TSServerPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,SpawnNPC,The following statement contains a magic number: NPC.NewNPC(spawnTileX * 16' spawnTileY * 16' type);
Magic Number,TShockAPI,TSServerPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,RevertTiles,The following statement contains a magic number: All.SendTileSquare((int)coords.X' (int)coords.Y' 3);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetRandomClearTileWithInRange,The following statement contains a magic number: j == 100
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: var sb = new StringBuilder(3);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,SearchProjectile,The following statement contains a magic number: return 1000;
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeColor,The following statement contains a magic number: return new Color(data[0]' data[1]' data[2]' data[3]);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeColor,The following statement contains a magic number: return new Color(data[0]' data[1]' data[2]' data[3]);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeBoolArray,The following statement contains a magic number: bool[] result = new bool[10];
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,EncodeBitsByte,The following statement contains a magic number: i < 8
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeBitsByte,The following statement contains a magic number: i < 8
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_0.txt"' 1' 235);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_1.txt"' 235' 604);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_1.txt"' 235' 604);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_2.txt"' 604' 2749);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_2.txt"' 604' 2749);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_3.txt"' 2749' Main.maxItemTypes);
Magic Number,TShockAPI,Utils,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Utils.cs,StartInvasion,The following statement contains a magic number: invasionSize = 20000000;
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,TShock,The following statement contains a magic number: ServerSideCharacterConfig.StartingInventory.Add(new NetItem(-15' 1' 0));
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,TShock,The following statement contains a magic number: ServerSideCharacterConfig.StartingInventory.Add(new NetItem(-13' 1' 0));
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,TShock,The following statement contains a magic number: ServerSideCharacterConfig.StartingInventory.Add(new NetItem(-16' 1' 0));
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: switch (Config.ForceTime)  				{  					case "day":  						TSPlayer.Server.SetTime(true' 27000.0);  						break;  					case "night":  						TSPlayer.Server.SetTime(false' 16200.0);  						break;  				}
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: switch (Config.ForceTime)  				{  					case "day":  						TSPlayer.Server.SetTime(true' 27000.0);  						break;  					case "night":  						TSPlayer.Server.SetTime(false' 16200.0);  						break;  				}
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: player.Teleport(pos.X * 16' pos.Y * 16);
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: player.Teleport(pos.X * 16' pos.Y * 16);
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: !tsplr.SilentKickInProgress && tsplr.State >= 3
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: tsplr.IsLoggedIn && !tsplr.IsDisabledPendingTrashRemoval && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2)
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: RememberedPos.InsertLeavePos(tsplr.Name' tsplr.IP' (int)(tsplr.X / 16)' (int)(tsplr.Y / 16));
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: RememberedPos.InsertLeavePos(tsplr.Name' tsplr.IP' (int)(tsplr.X / 16)' (int)(tsplr.Y / 16));
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The following statement contains a magic number: args.Text.Length > 500
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: (player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The following statement contains a magic number: player.LastNetPosition = new Vector2(Main.spawnTileX * 16f' Main.spawnTileY * 16f);
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The following statement contains a magic number: player.LastNetPosition = new Vector2(Main.spawnTileX * 16f' Main.spawnTileY * 16f);
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The following statement contains a magic number: player.RPPending = 3;
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,NpcHooks_OnStrikeNpc,The following statement contains a magic number: Main.invasionSize = 20000000;
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,NpcHooks_OnStrikeNpc,The following statement contains a magic number: Main.invasionSize < 10
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 75
Magic Number,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: e.Info == 109
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,IsBouncerThrottled,The following statement contains a magic number: return (DateTime.UtcNow - LastThreat).TotalMilliseconds < 5000;
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasBuildPermission,The following statement contains a magic number: ((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - lastPermissionWarning) < 2000
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Logout,The following statement contains a magic number: !IsDisabledPendingTrashRemoval && (!Dead || TPlayer.difficulty != 2)
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: x = Main.rightWorld - 992;
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: x > Main.rightWorld - 992
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: x = 992;
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: x < 992
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: y = Main.bottomWorld - 992;
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: y > Main.bottomWorld - 992
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: y = 992;
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: y < 992
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: SendTileSquare((int)(x / 16)' (int)(y / 16)' 15);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: SendTileSquare((int)(x / 16)' (int)(y / 16)' 15);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: SendTileSquare((int)(x / 16)' (int)(y / 16)' 15);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendTileSquare,The following statement contains a magic number: int num = (size - 1) / 2;
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendMessage,The following statement contains a magic number: SendData(PacketTypes.SmartTextMessage' msg' 255' red' green' blue' -1);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,KillPlayer,The following statement contains a magic number: NetMessage.SendPlayerDeath(Index' PlayerDeathReason.LegacyDefault()' 99999' (new Random()).Next(-1' 1)' false' -1' -1);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: SetBuff(BuffID.Frozen' 330' true);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: SetBuff(BuffID.Stoned' 330' true);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: SetBuff(BuffID.Webbed' 330' true);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: (DateTime.UtcNow - LastDisableNotification).TotalMilliseconds > 5000
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Whoopie,The following statement contains a magic number: SendData(PacketTypes.NpcSpecial' number: Index' number2: 2f);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Whoopie,The following statement contains a magic number: Thread.Sleep(50);
Magic Number,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SetBuff,The following statement contains a magic number: (DateTime.UtcNow - LastThreat).TotalMilliseconds < 5000 && !bypass
Magic Number,TShockAPI,UpdateManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,UpdateManager,The following statement contains a magic number: _client.Timeout = new TimeSpan(0' 0' 5);
Magic Number,TShockAPI,UpdateManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,UpdateManager,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Sleep for X minutes  					await Task.Delay(1000 * 60 * CheckXMinutes);  					//Then check again  					await CheckForUpdatesAsync(null);  				} while (true);  			})  			{  				Name = "TShock Update Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,UpdateManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,UpdateManager,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Sleep for X minutes  					await Task.Delay(1000 * 60 * CheckXMinutes);  					//Then check again  					await CheckForUpdatesAsync(null);  				} while (true);  			})  			{  				Name = "TShock Update Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,UpdateManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,CheckForUpdatesAsync,The following statement contains a magic number: CheckXMinutes = 30;
Magic Number,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,RegionManager,The following statement contains a magic number: var table = new SqlTable("Regions"'  									 new SqlColumn("Id"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  									 new SqlColumn("X1"' MySqlDbType.Int32)'  									 new SqlColumn("Y1"' MySqlDbType.Int32)'  									 new SqlColumn("width"' MySqlDbType.Int32)'  									 new SqlColumn("height"' MySqlDbType.Int32)'  									 new SqlColumn("RegionName"' MySqlDbType.VarChar' 50) {Unique = true}'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  									 new SqlColumn("UserIds"' MySqlDbType.Text)'  									 new SqlColumn("Protected"' MySqlDbType.Int32)'  									 new SqlColumn("Groups"' MySqlDbType.Text)'  									 new SqlColumn("Owner"' MySqlDbType.VarChar' 50)'  									 new SqlColumn("Z"' MySqlDbType.Int32){ DefaultValue = "0" }  				);
Magic Number,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,RegionManager,The following statement contains a magic number: var table = new SqlTable("Regions"'  									 new SqlColumn("Id"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  									 new SqlColumn("X1"' MySqlDbType.Int32)'  									 new SqlColumn("Y1"' MySqlDbType.Int32)'  									 new SqlColumn("width"' MySqlDbType.Int32)'  									 new SqlColumn("height"' MySqlDbType.Int32)'  									 new SqlColumn("RegionName"' MySqlDbType.VarChar' 50) {Unique = true}'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  									 new SqlColumn("UserIds"' MySqlDbType.Text)'  									 new SqlColumn("Protected"' MySqlDbType.Int32)'  									 new SqlColumn("Groups"' MySqlDbType.Text)'  									 new SqlColumn("Owner"' MySqlDbType.VarChar' 50)'  									 new SqlColumn("Z"' MySqlDbType.Int32){ DefaultValue = "0" }  				);
Magic Number,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,RegionManager,The following statement contains a magic number: var table = new SqlTable("Regions"'  									 new SqlColumn("Id"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  									 new SqlColumn("X1"' MySqlDbType.Int32)'  									 new SqlColumn("Y1"' MySqlDbType.Int32)'  									 new SqlColumn("width"' MySqlDbType.Int32)'  									 new SqlColumn("height"' MySqlDbType.Int32)'  									 new SqlColumn("RegionName"' MySqlDbType.VarChar' 50) {Unique = true}'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  									 new SqlColumn("UserIds"' MySqlDbType.Text)'  									 new SqlColumn("Protected"' MySqlDbType.Int32)'  									 new SqlColumn("Groups"' MySqlDbType.Text)'  									 new SqlColumn("Owner"' MySqlDbType.VarChar' 50)'  									 new SqlColumn("Z"' MySqlDbType.Int32){ DefaultValue = "0" }  				);
Magic Number,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The following statement contains a magic number: switch (direction)  				{  					case 0:  						Y -= addAmount;  						height += addAmount;  						break;  					case 1:  						width += addAmount;  						break;  					case 2:  						height += addAmount;  						break;  					case 3:  						X -= addAmount;  						width += addAmount;  						break;  					default:  						return false;  				}
Magic Number,TShockAPI.DB,RegionManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The following statement contains a magic number: switch (direction)  				{  					case 0:  						Y -= addAmount;  						height += addAmount;  						break;  					case 1:  						width += addAmount;  						break;  					case 2:  						height += addAmount;  						break;  					case 3:  						X -= addAmount;  						width += addAmount;  						break;  					default:  						return false;  				}
Magic Number,TShockAPI.DB,BanManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,BanManager,The following statement contains a magic number: var table = new SqlTable("Bans"'  									new SqlColumn("IP"' MySqlDbType.String' 16) { Primary = true }'  									new SqlColumn("Name"' MySqlDbType.Text)'  									new SqlColumn("UUID"' MySqlDbType.Text)'  									new SqlColumn("Reason"' MySqlDbType.Text)'  									new SqlColumn("BanningUser"' MySqlDbType.Text)'  									new SqlColumn("Date"' MySqlDbType.Text)'  									new SqlColumn("Expiration"' MySqlDbType.Text)'  									new SqlColumn("AccountName"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: inventory.InsertRange(67' new NetItem[2]);
Magic Number,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: inventory.InsertRange(67' new NetItem[2]);
Magic Number,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: inventory.InsertRange(77' new NetItem[2]);
Magic Number,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: inventory.InsertRange(77' new NetItem[2]);
Magic Number,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: inventory.InsertRange(87' new NetItem[2]);
Magic Number,TShockAPI.DB,CharacterManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: inventory.InsertRange(87' new NetItem[2]);
Magic Number,TShockAPI.DB,GenericQueryCreator,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\IQueryBuilder.cs,AlterTable,The following statement contains a magic number: var rstr = rand.NextString(20);
Magic Number,TShockAPI.DB,ItemManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\ItemManager.cs,ItemManager,The following statement contains a magic number: var table = new SqlTable("ItemBans"'  			                         new SqlColumn("ItemName"' MySqlDbType.VarChar' 50) {Primary = true}'  			                         new SqlColumn("AllowedGroups"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,GroupManager,The following statement contains a magic number: var table = new SqlTable("GroupList"'  				new SqlColumn("GroupName"' MySqlDbType.VarChar' 32) { Primary = true }'  				new SqlColumn("Parent"' MySqlDbType.VarChar' 32)'  				new SqlColumn("Commands"' MySqlDbType.Text)'  				new SqlColumn("ChatColor"' MySqlDbType.Text)'  				new SqlColumn("Prefix"' MySqlDbType.Text)'  				new SqlColumn("Suffix"' MySqlDbType.Text)  			);
Magic Number,TShockAPI.DB,GroupManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,GroupManager,The following statement contains a magic number: var table = new SqlTable("GroupList"'  				new SqlColumn("GroupName"' MySqlDbType.VarChar' 32) { Primary = true }'  				new SqlColumn("Parent"' MySqlDbType.VarChar' 32)'  				new SqlColumn("Commands"' MySqlDbType.Text)'  				new SqlColumn("ChatColor"' MySqlDbType.Text)'  				new SqlColumn("Prefix"' MySqlDbType.Text)'  				new SqlColumn("Suffix"' MySqlDbType.Text)  			);
Magic Number,TShockAPI.DB,UserAccountManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccountManager,The following statement contains a magic number: var table = new SqlTable("Users"'  				new SqlColumn("ID"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  				new SqlColumn("Username"' MySqlDbType.VarChar' 32) {Unique = true}'  				new SqlColumn("Password"' MySqlDbType.VarChar' 128)'  				new SqlColumn("UUID"' MySqlDbType.VarChar' 128)'  				new SqlColumn("Usergroup"' MySqlDbType.Text)'  				new SqlColumn("Registered"' MySqlDbType.Text)'  				new SqlColumn("LastAccessed"' MySqlDbType.Text)'  				new SqlColumn("KnownIPs"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,UserAccountManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccountManager,The following statement contains a magic number: var table = new SqlTable("Users"'  				new SqlColumn("ID"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  				new SqlColumn("Username"' MySqlDbType.VarChar' 32) {Unique = true}'  				new SqlColumn("Password"' MySqlDbType.VarChar' 128)'  				new SqlColumn("UUID"' MySqlDbType.VarChar' 128)'  				new SqlColumn("Usergroup"' MySqlDbType.Text)'  				new SqlColumn("Registered"' MySqlDbType.Text)'  				new SqlColumn("LastAccessed"' MySqlDbType.Text)'  				new SqlColumn("KnownIPs"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,UserAccountManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccountManager,The following statement contains a magic number: var table = new SqlTable("Users"'  				new SqlColumn("ID"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  				new SqlColumn("Username"' MySqlDbType.VarChar' 32) {Unique = true}'  				new SqlColumn("Password"' MySqlDbType.VarChar' 128)'  				new SqlColumn("UUID"' MySqlDbType.VarChar' 128)'  				new SqlColumn("Usergroup"' MySqlDbType.Text)'  				new SqlColumn("Registered"' MySqlDbType.Text)'  				new SqlColumn("LastAccessed"' MySqlDbType.Text)'  				new SqlColumn("KnownIPs"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UpgradePasswordWorkFactor,The following statement contains a magic number: currentWorkFactor = Int32.Parse((Password.Split('$')[2]));
Magic Number,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The following statement contains a magic number: password.Trim().Length < Math.Max(4' TShock.Config.MinimumPasswordLength)
Magic Number,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The following statement contains a magic number: password.Trim().Length < Math.Max(4' TShock.Config.MinimumPasswordLength)
Magic Number,TShockAPI.DB,UserAccount,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,GetHashCode,The following statement contains a magic number: return (ID * 397) ^ (Name != null ? Name.GetHashCode() : 0);
Magic Number,TShockAPI.DB,RememberedPosManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,RememberedPosManager,The following statement contains a magic number: var table = new SqlTable("RememberedPos"'  			                         new SqlColumn("Name"' MySqlDbType.VarChar' 50) {Primary = true}'  			                         new SqlColumn("IP"' MySqlDbType.Text)'  			                         new SqlColumn("X"' MySqlDbType.Int32)'  			                         new SqlColumn("Y"' MySqlDbType.Int32)'  			                         new SqlColumn("WorldID"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,WarpManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\WarpsManager.cs,WarpManager,The following statement contains a magic number: var table = new SqlTable("Warps"'  			                         new SqlColumn("Id"' MySqlDbType.Int32){Primary = true' AutoIncrement = true}'  									 new SqlColumn("WarpName"' MySqlDbType.VarChar' 50) {Unique = true}'  			                         new SqlColumn("X"' MySqlDbType.Int32)'  			                         new SqlColumn("Y"' MySqlDbType.Int32)'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  			                         new SqlColumn("Private"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,WarpManager,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\DB\WarpsManager.cs,WarpManager,The following statement contains a magic number: var table = new SqlTable("Warps"'  			                         new SqlColumn("Id"' MySqlDbType.Int32){Primary = true' AutoIncrement = true}'  									 new SqlColumn("WarpName"' MySqlDbType.VarChar' 50) {Unique = true}'  			                         new SqlColumn("X"' MySqlDbType.Int32)'  			                         new SqlColumn("Y"' MySqlDbType.Int32)'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  			                         new SqlColumn("Private"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.Extensions,RandomExt,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Extensions\RandomExt.cs,NextString,The following statement contains a magic number: switch (rand.Next(0' 3))  				{  					case 0:  						sb.Append((char) rand.Next('a'' 'z' + 1));  						break;  					case 1:  						sb.Append((char) rand.Next('A'' 'Z' + 1));  						break;  					case 2:  						sb.Append((char) rand.Next('0'' '9' + 1));  						break;  				}
Magic Number,TShockAPI.Extensions,RandomExt,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Extensions\RandomExt.cs,NextString,The following statement contains a magic number: switch (rand.Next(0' 3))  				{  					case 0:  						sb.Append((char) rand.Next('a'' 'z' + 1));  						break;  					case 1:  						sb.Append((char) rand.Next('A'' 'Z' + 1));  						break;  					case 2:  						sb.Append((char) rand.Next('0'' '9' + 1));  						break;  				}
Magic Number,Rests,SecureRest,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The following statement contains a magic number: var randbytes = new byte[32];
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindIndex,The following statement contains a magic number: return (int) FindCountryCode(0' AddressToLong(ip)' 31);
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: y += 256;
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: num += y << ((3 - i)*8);
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: num += y << ((3 - i)*8);
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: i < 4
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: byte[] buffer = new byte[6];
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: long[] x = new long[2];
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: _geodata.Seek(6*offset' SeekOrigin.Begin);
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: _geodata.Read(buffer' 0' 6);
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: int y = buffer[i*3 + j];
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: y += 256;
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: x[i] += (y << (j*8));
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: j < 3
Magic Number,MaxMind,GeoIPCountry,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: i < 2
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[2] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[3] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[4] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[5] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[6] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[7] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[2] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[3] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[4] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[5] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: bits[6] = true;
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: Slope = flags2[4];
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: Slope2 = flags2[5];
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: Slope3 = flags2[6];
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags2[2]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags2[3]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags[2]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags[3]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags[4]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags[5]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags[6]
Magic Number,TShockAPI.Net,NetTile,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: flags[7]
Duplicate Code,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The method contains a code clone-set at the following line numbers (starting from the method definition): ((37' 62)' (108' 133))
Missing Default,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following switch statement is missing a default case: switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.Utils.StartInvasion(4);  						break;  				}
Missing Default,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Groups.GetGroupByName(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							args.Player.SendMultipleMatchError(items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,Commands,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,GetDataHandlers,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following switch statement is missing a default case: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Missing Default,TShockAPI,TShock,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following switch statement is missing a default case: switch (Config.ForceTime)  				{  					case "day":  						TSPlayer.Server.SetTime(true' 27000.0);  						break;  					case "night":  						TSPlayer.Server.SetTime(false' 16200.0);  						break;  				}
Missing Default,TShockAPI,TSPlayer,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,HasBuildPermission,The following switch statement is missing a default case: switch (failure)  			{  				case BuildPermissionFailPoint.GeneralBuild:  					SendErrorMessage("You lack permission to build on this server.");  					break;  				case BuildPermissionFailPoint.SpawnProtect:  					SendErrorMessage("You lack permission to build in the spawn point.");  					break;  				case BuildPermissionFailPoint.Regions:  					SendErrorMessage("You lack permission to build in this region.");  					break;  			}
Missing Default,TShockAPI.Extensions,RandomExt,C:\research\architectureSmells\repos\NyxStudios_TShock\TShockAPI\Extensions\RandomExt.cs,NextString,The following switch statement is missing a default case: switch (rand.Next(0' 3))  				{  					case 0:  						sb.Append((char) rand.Next('a'' 'z' + 1));  						break;  					case 1:  						sb.Append((char) rand.Next('A'' 'Z' + 1));  						break;  					case 2:  						sb.Append((char) rand.Next('0'' '9' + 1));  						break;  				}
