Implementation smell,Namespace,Class,File,Method,Description
Long Method,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The method has 247 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,InitCommands,The method has 425 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The method has 113 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The method has 127 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The method has 291 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The method has 127 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TP,The method has 119 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The method has 154 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The method has 397 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The method has 184 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The method has 158 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The method has 158 lines of code.
Long Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The method has 541 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The method has 150 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The method has 299 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The method has 193 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The method has 103 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The method has 108 lines of code.
Long Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The method has 103 lines of code.
Long Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,Initialize,The method has 171 lines of code.
Long Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The method has 112 lines of code.
Long Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The method has 215 lines of code.
Long Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The method has 103 lines of code.
Long Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HackedInventory,The method has 185 lines of code.
Long Method,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,GroupManager,The method has 133 lines of code.
Complex Method,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,Cyclomatic complexity of the method is 32
Complex Method,TShockAPI,SqlLog,C:\repos\NyxStudios_TShock\TShockAPI\SqlLog.cs,Write,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,PaginationTools,C:\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,SendPage,Cyclomatic complexity of the method is 19
Complex Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,HandleCommand,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPHere,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,TSCheckNoclip,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleConnecting,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePassword,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,Cyclomatic complexity of the method is 26
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,Cyclomatic complexity of the method is 36
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,Cyclomatic complexity of the method is 17
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,Cyclomatic complexity of the method is 30
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,Cyclomatic complexity of the method is 15
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,Cyclomatic complexity of the method is 17
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerAddBuff,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamage,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamageV2,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcStrike,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,FindPlayer,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetItemByName,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,Initialize,Cyclomatic complexity of the method is 12
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,Cyclomatic complexity of the method is 30
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnJoin,Cyclomatic complexity of the method is 10
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,Cyclomatic complexity of the method is 11
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,Cyclomatic complexity of the method is 9
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,Cyclomatic complexity of the method is 17
Complex Method,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,Cyclomatic complexity of the method is 13
Complex Method,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,LoadPermisions,Cyclomatic complexity of the method is 8
Complex Method,Rests,Rest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,ProcessRequest,Cyclomatic complexity of the method is 10
Complex Method,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,ExecuteCommand,Cyclomatic complexity of the method is 8
Complex Method,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,Cyclomatic complexity of the method is 21
Complex Method,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,Cyclomatic complexity of the method is 11
Long Parameter List,TShockAPI,PaginationTools,C:\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,SendPage,The method has 5 parameters. Parameters: player' pageNumber' dataToPaginate' dataToPaginateCount' settings
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnTileEdit,The method has 7 parameters. Parameters: ply' x' y' action' editDetail' editData' style
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerSlot,The method has 5 parameters. Parameters: _plr' _slot' _stack' _prefix' _type
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerInfo,The method has 5 parameters. Parameters: _plrid' _hair' _style' _difficulty' _name
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerUpdate,The method has 6 parameters. Parameters: player' control' item' position' velocity' pulley
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnNewProjectile,The method has 8 parameters. Parameters: ident' pos' vel' knockback' dmg' owner' type' index
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnChestItemChange,The method has 5 parameters. Parameters: id' slot' stacks' prefix' type
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnItemDrop,The method has 8 parameters. Parameters: player' id' pos' vel' stacks' prefix' noDelay' type
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnPlayerDamage,The method has 5 parameters. Parameters: id' dir' dmg' pvp' crit
Long Parameter List,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,OnNPCStrike,The method has 5 parameters. Parameters: id' dir' dmg' knockback' crit
Long Parameter List,TShockAPI,TSServerPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,SpawnNPC,The method has 7 parameters. Parameters: type' name' amount' startTileX' startTileY' tileXRange' tileYRange
Long Parameter List,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Broadcast,The method has 5 parameters. Parameters: ply' msg' red' green' blue
Long Parameter List,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetRandomClearTileWithInRange,The method has 6 parameters. Parameters: startTileX' startTileY' tileXRange' tileYRange' tileX' tileY
Long Parameter List,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Kick,The method has 6 parameters. Parameters: player' reason' force' silent' adminUserName' saveSSI
Long Parameter List,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The method has 5 parameters. Parameters: player' tileX' tileY' tileType' actionType
Long Parameter List,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,GiveItemCheck,The method has 6 parameters. Parameters: type' name' width' height' stack' prefix
Long Parameter List,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,GiveItem,The method has 6 parameters. Parameters: type' name' width' height' stack' prefix
Long Parameter List,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendMessageFromPlayer,The method has 5 parameters. Parameters: msg' red' green' blue' ply
Long Parameter List,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendData,The method has 7 parameters. Parameters: msgType' text' number' number2' number3' number4' number5
Long Parameter List,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendDataFromPlayer,The method has 7 parameters. Parameters: msgType' ply' text' number2' number3' number4' number5
Long Parameter List,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,AddRegion,The method has 8 parameters. Parameters: tx' ty' width' height' regionname' owner' worldid' z
Long Parameter List,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,PositionRegion,The method has 5 parameters. Parameters: regionName' x' y' width' height
Long Parameter List,TShockAPI.DB,Region,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,Region,The method has 7 parameters. Parameters: id' region' name' owner' disablebuild' RegionWorldIDz' z
Long Parameter List,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan,The method has 7 parameters. Parameters: ip' name' uuid' reason' exceptions' banner' expiration
Long Parameter List,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan2,The method has 8 parameters. Parameters: ip' name' uuid' accountName' reason' exceptions' banner' expiration
Long Parameter List,TShockAPI.DB,Ban,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,Ban,The method has 8 parameters. Parameters: ip' name' uuid' accountName' reason' banner' date' exp
Long Parameter List,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,UpdateGroup,The method has 6 parameters. Parameters: name' parentname' permissions' chatcolor' suffix' prefix
Long Parameter List,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccount,The method has 7 parameters. Parameters: name' pass' uuid' group' registered' last' known
Long Parameter List,TShockAPI.Hooks,PlayerHooks,C:\repos\NyxStudios_TShock\TShockAPI\Hooks\PlayerHooks.cs,OnPlayerCommand,The method has 6 parameters. Parameters: player' cmdName' cmdText' args' commands' cmdPrefix
Long Parameter List,TShockAPI.Sockets,LinuxTcpSocket,C:\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,AsyncSend,The method has 5 parameters. Parameters: data' offset' size' callback' state
Long Parameter List,TShockAPI.Sockets,LinuxTcpSocket,C:\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,AsyncReceive,The method has 5 parameters. Parameters: data' offset' size' callback' state
Long Parameter List,Rests,RestRequestArgs,C:\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,RestRequestArgs,The method has 5 parameters. Parameters: verbs' param' request' tokenData' context
Long Parameter List,Rests,Rest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,ExecuteCommand,The method has 5 parameters. Parameters: cmd' verbs' parms' request' context
Long Parameter List,Rests,SecureRestCommand,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestCommand.cs,Execute,The method has 5 parameters. Parameters: verbs' parameters' tokenData' request' context
Long Parameter List,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,ExecuteCommand,The method has 5 parameters. Parameters: cmd' verbs' parms' request' context
Long Identifier,TShockAPI,ConfigFile,C:\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter EnableTokenEndpointAuthentication is 33.
Long Identifier,TShockAPI,ConfigFile,C:\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter AllowAllowedGroupsToSpawnBannedItems is 36.
Long Identifier,TShockAPI,ConfigFile,C:\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter RESTMaximumRequestsPerInterval is 30.
Long Identifier,TShockAPI,ConfigFile,C:\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter RESTRequestBucketDecreaseIntervalMinutes is 40.
Long Identifier,TShockAPI,ConfigFile,C:\repos\NyxStudios_TShock\TShockAPI\ConfigFile.cs,,The length of the parameter RESTLimitOnlyFailedLoginRequests is 32.
Long Identifier,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,,The length of the parameter IgnoreActionsForClearingTrashCan is 32.
Long Statement,TShockAPI,BackupManager,C:\repos\NyxStudios_TShock\TShockAPI\BackupManager.cs,DoBackup,The length of the statement  "				Main.ActiveWorldFileData._path = Path.Combine(BackupPath' string.Format("{0}.{1:dd.MM.yy-HH.mm.ss}.bak"' name' DateTime.UtcNow)); " is 129.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix); " is 175.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix); " is 167.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix); " is 163.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix); " is 173.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix); " is 175.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "			NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix); " is 171.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix); " is 185.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix); " is 177.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix); " is 173.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix); " is 187.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix); " is 183.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix); " is 185.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix); " is 187.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "			NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix); " is 181.
Long Statement,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The length of the statement  "				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix); " is 187.
Long Statement,TShockAPI,PaginationTools,C:\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,SendPage,The length of the statement  "					player.SendMessage(string.Format(settings.FooterFormat' pageNumber + 1' pageNumber' pageCount)' settings.FooterTextColor); " is 122.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,HandleCommand,The length of the statement  "					TShock.Utils.SendLogs(string.Format("{0} tried to execute {1}{2}."' player.Name' Specifier' cmdText)' Color.PaleVioletRed' player); " is 131.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,HandleCommand,The length of the statement  "						TShock.Utils.SendLogs(string.Format("{0} executed: {1}{2}."' player.Name' silent ? SilentSpecifier : Specifier' cmdText)' Color.PaleVioletRed' player); " is 151.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The length of the statement  "				args.Player.SendErrorMessage("        {0}login <password> - Logs in using your password and character name"' Specifier); " is 120.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The length of the statement  "				args.Player.SendErrorMessage("        {0}login <username> <password> - Logs in using your username and password"' Specifier); " is 125.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The length of the statement  "							TShock.UserAccounts.SetUserAccountPassword(args.Player.Account' args.Parameters[1]); // SetUserPassword will hash it for you. " is 125.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The length of the statement  "							args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The length of the statement  "					args.Player.SendErrorMessage("Not logged in or invalid syntax! Proper syntax: {0}password <oldpassword> <newpassword>"' Specifier); " is 131.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The length of the statement  "						args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The length of the statement  "						args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The length of the statement  "				if (TShock.UserAccounts.GetUserAccountByName(account.Name) == null && account.Name != TSServerPlayer.AccountName) // Cheap way of checking for existance of a user " is 162.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The length of the statement  "					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The length of the statement  "					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters."); " is 130.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The length of the statement  "					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + "."); " is 120.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,WorldInfo,The length of the statement  "			args.Player.SendInfoMessage("World name: " + (TShock.Config.UseServerName ? TShock.Config.ServerName : Main.worldName)); " is 120.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ViewAccountInfo,The length of the statement  "						args.Player.SendSuccessMessage("{0}'s register date is {1} {2} UTC{3}."' account.Name' Registered.ToShortDateString()' Registered.ToShortTimeString()' Timezone); " is 161.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The length of the statement  "							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name' " is 131.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The length of the statement  "									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s")); " is 126.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The length of the statement  "							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName); " is 123.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ForceHalloween,The length of the statement  "				TSPlayer.All.SendInfoMessage("{0} {1}abled halloween mode!"' args.Player.Name' (TShock.Config.ForceHalloween ? "en" : "dis")); " is 126.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ForceXmas,The length of the statement  "				TSPlayer.All.SendInfoMessage("{0} {1}abled Christmas mode!"' args.Player.Name' (TShock.Config.ForceXmas ? "en" : "dis")); " is 121.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Off,The length of the statement  "			string reason = ((args.Parameters.Count > 0) ? "Server shutting down: " + String.Join(" "' args.Parameters) : "Server shutting down!"); " is 135.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,OffNoSave,The length of the statement  "			string reason = ((args.Parameters.Count > 0) ? "Server shutting down: " + String.Join(" "' args.Parameters) : "Server shutting down!"); " is 135.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ClearAnglerQuests,The length of the statement  "					foreach (TSPlayer ply in TShock.Players.Where(p => p != null && p.Active && p.TPlayer.name.ToLower().Equals(args.Parameters[0].ToLower()))) " is 139.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier); " is 121.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier); " is 127.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix); " is 121.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier); " is 127.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b)) " is 124.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The length of the statement  "							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier); " is 121.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The length of the statement  "				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0)); " is 124.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The length of the statement  "							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)' " is 135.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProtectSpawn,The length of the statement  "			TSPlayer.All.SendSuccessMessage(string.Format("Spawn is now {0}."' (TShock.Config.SpawnProtection ? "protected" : "open"))); " is 124.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AuthToken,The length of the statement  "				args.Player.SendSuccessMessage("Your new account has been verified' and the {0}auth system has been turned off."' Specifier); " is 125.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AuthToken,The length of the statement  "				args.Player.SendSuccessMessage("The auth system will remain disabled as long as a superadmin exists (even if you delete auth.lck)."); " is 133.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AuthToken,The length of the statement  "				args.Player.SendSuccessMessage("Share your server' talk with other admins' and more on our forums -- https://tshock.co/"); " is 122.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AuthToken,The length of the statement  "			args.Player.SendInfoMessage("If you understand' please {0}login <username> <password> now' and then type {0}auth."' Specifier); " is 127.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Reply,The length of the statement  "				args.Player.SendErrorMessage("You haven't previously received any whispers. Please use {0}whisper to whisper to other people."' Specifier); " is 139.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Aliases,The length of the statement  "						"Aliases of {0}{1}: {0}{2}"' Specifier' matchingCommand.Name' string.Join("' {0}".SFormat(Specifier)' matchingCommand.Names.Skip(1))); " is 134.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Butcher,The length of the statement  "				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC && Main.npc[i].netID != NPCID.TargetDummy) || Main.npc[i].netID == npcId)) " is 137.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The length of the statement  "				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}item <item name/id> [item amount] [prefix id/name]"' Specifier); " is 128.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The length of the statement  "			if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184) " is 133.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The length of the statement  "				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC) || (Main.npc[i].netID == npcId && Main.npc[i].townNPC))) " is 120.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The length of the statement  "						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184) " is 125.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The length of the statement  "				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}gbuff <player> <buff id/name> [time(seconds)]"' Specifier); " is 123.
Long Statement,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ToggleGodMode,The length of the statement  "				args.Player.SendSuccessMessage(string.Format("{0} is {1} in god mode."' playerToGod.Name' playerToGod.GodMode ? "now" : "no longer")); " is 134.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,TSCheckNoclip,The length of the statement  "					if (Position.X + (float)Width > vector.X && Position.X < vector.X + 16f && Position.Y + (float)Height > vector.Y && Position.Y < vector.Y + 16f) " is 144.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The length of the statement  "				NetMessage.SendData((int)PacketTypes.PlayerInfo' -1' args.Player.Index' NetworkText.FromLiteral(args.Player.Name)' args.Player.Index); " is 134.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleGetSection,The length of the statement  "			NetMessage.SendData((int)PacketTypes.TimeSet' -1' -1' NetworkText.Empty' Main.dayTime ? 1 : 0' (int)Main.time' Main.sunModY' Main.moonModY); " is 140.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The length of the statement  "							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2)) " is 122.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The length of the statement  "							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2)) " is 146.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)) " is 174.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)) " is 185.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0) " is 213.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0) " is 139.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj])) " is 148.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes)) " is 186.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope)) " is 156.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0) " is 144.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection)) " is 139.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The length of the statement  "				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] && " is 158.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The length of the statement  "					TSCheckNoclip(pos' args.TPlayer.width' args.TPlayer.height - (args.TPlayer.mount.Active ? args.Player.TPlayer.mount.HeightBoost : 0)) && !TShock.Config.IgnoreNoClip " is 164.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The length of the statement  "				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495) " is 143.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The length of the statement  "				args.Player.Disable(String.Format("Projectile damage is higher than {0}."' TShock.Config.MaxProjDamage)' DisableFlags.WriteToLogAndConsole); " is 140.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The length of the statement  "			if (!TShock.Config.IgnoreProjUpdate && !hasPermission && !args.Player.HasPermission(Permissions.ignoreprojectiledetection)) " is 123.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The length of the statement  "					args.Player.Disable(String.Format("Does not have projectile permission to update projectile. ({0})"' type)' DisableFlags.WriteToLogAndConsole); " is 143.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The length of the statement  "			/*if (args.Player.Index != Main.projectile[index].owner && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill) // workaround for skeletron prime projectiles " is 165.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The length of the statement  "				args.Player.Disable(String.Format("Owner ({0}) and player ID ({1}) does not match to kill projectile of type: {3}"' Main.projectile[index].owner' args.Player.Index' type)); " is 172.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The length of the statement  "			if (TShock.CheckProjectilePermission(args.Player' index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill) " is 126.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The length of the statement  "			if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY))) " is 196.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The length of the statement  "				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1))) " is 188.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The length of the statement  "				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1))) " is 188.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The length of the statement  "			if (type == 0) //Item removed' let client do this to prevent item duplication client side (but only if it passed the range check) " is 129.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The length of the statement  "				if (TShock.CheckRangePermission(args.Player' (int)(Main.item[id].position.X / 16f)' (int)(Main.item[id].position.Y / 16f))) " is 123.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The length of the statement  "			if (Main.item[id].active && Main.item[id].netID != type) //stop the client from changing the item type of a drop but only if the client isn't picking up the item " is 161.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The length of the statement  "			if ((stacks > item.maxStack || stacks <= 0) || (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' args.Player) && !args.Player.HasPermission(Permissions.allowdroppingbanneditems))) " is 203.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The length of the statement  "			if ((Main.ServerSideCharacter) && (DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond - args.Player.LoginMS < TShock.ServerSideCharacterConfig.LogonDiscardThreshold)) " is 165.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamage,The length of the statement  "			if (dmg > TShock.Config.MaxDamage && !args.Player.HasPermission(Permissions.ignoredamagecap) && id != args.Player.Index) " is 120.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamage,The length of the statement  "					args.Player.Disable(String.Format("Player damage exceeded {0}."' TShock.Config.MaxDamage)' DisableFlags.WriteToLogAndConsole); " is 126.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamageV2,The length of the statement  "			if (dmg > TShock.Config.MaxDamage && !args.Player.HasPermission(Permissions.ignoredamagecap) && id != args.Player.Index) " is 120.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamageV2,The length of the statement  "					args.Player.Disable(String.Format("Player damage exceeded {0}."' TShock.Config.MaxDamage)' DisableFlags.WriteToLogAndConsole); " is 126.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcStrike,The length of the statement  "					args.Player.Disable(String.Format("NPC damage exceeded {0}."' TShock.Config.MaxDamage)' DisableFlags.WriteToLogAndConsole); " is 123.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcStrike,The length of the statement  "				TShock.CheckRangePermission(args.Player' (int)(Main.npc[id].position.X / 16f)' (int)(Main.npc[id].position.Y / 16f)' 128)) " is 122.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcTeleportPortal,The length of the statement  "			var projectile = Main.projectile.FirstOrDefault(p => p.position.X == newPosition.X && p.position.Y == newPosition.Y); // Check for projectiles at this location " is 159.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLoadNetModule,The length of the statement  "			// Since this packet is never actually sent to us' every attempt at sending it can be considered as a liquid exploit attempt " is 124.
Long Statement,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleOldOnesArmy,The length of the statement  "				TShock.Utils.SendLogs(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' Color.PaleVioletRed' args.Player); " is 130.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "				Rest.Register(new RestCommand("/v2/server/status"' (a) => ServerStatusV2(new RestRequestArgs(a.Verbs' a.Parameters' a.Request' SecureRest.TokenData.None' a.Context)))); " is 168.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "				Rest.Register(new RestCommand("/v3/server/motd"' (a) => ServerMotd(new RestRequestArgs(a.Verbs' a.Parameters' a.Request' SecureRest.TokenData.None' a.Context)))); " is 162.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "				Rest.Register(new RestCommand("/v3/server/rules"' (a) => ServerRules(new RestRequestArgs(a.Verbs' a.Parameters' a.Request' SecureRest.TokenData.None' a.Context)))); " is 164.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/users/create"' UserCreateV2' RestPermissions.restmanageusers) { DoLog = false }); " is 122.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/users/update"' UserUpdateV2' RestPermissions.restmanageusers) { DoLog = false }); " is 122.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/world/autosave/state/{state}"' WorldChangeSaveSettings' RestPermissions.restcfg)); " is 123.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,RegisterRestfulCommands,The length of the statement  "			Rest.Register(new SecureRestCommand("/v2/players/ban"' PlayerBanV2' RestPermissions.restban' RestPermissions.restmanagebans)); " is 126.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerOff,The length of the statement  "			var reason = string.IsNullOrWhiteSpace(args.Parameters["message"]) ? "Server is shutting down" : args.Parameters["message"]; " is 124.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerReload,The length of the statement  "			TShock.Utils.Reload(new TSRestPlayer(args.TokenData.Username' TShock.Groups.GetGroupByName(args.TokenData.UserGroupName))); " is 123.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerReload,The length of the statement  "			return RestResponse("Configuration' permissions' and regions reload complete. Some changes may require a server restart."); " is 123.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,ServerStatusV2,The length of the statement  "					var p = PlayerFilter(tsPlayer' args.Parameters' ((args.TokenData.UserGroupName) != "" && TShock.Utils.GetGroup(args.TokenData.UserGroupName).HasPermission(RestPermissions.viewips))); " is 182.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,UserActiveListV2,The length of the statement  "			return new RestObject() { { "activeusers"' string.Join("\t"' TShock.Players.Where(p => null != p && null != p.Account && p.Active).Select(p => p.Account.Name)) } }; " is 164.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,PlayerKickV2,The length of the statement  "			TShock.Utils.ForceKick(player' null == args.Parameters["reason"] ? "Kicked via web" : args.Parameters["reason"]' false' true); " is 126.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,GroupList,The length of the statement  "				groups.Add(new Dictionary<string' object> {{"name"' group.Name}' {"parent"' group.ParentName}' {"chatcolor"' group.ChatColor}}); " is 128.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,GroupUpdate,The length of the statement  "			var chatcolor = (null == args.Parameters["chatcolor"]) ? string.Format("{0}.{1}.{2}"' group.R' group.G' group.B) : args.Parameters["chatcolor"]; " is 144.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "			foreach (var method in rest.GetType().GetMethods(BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static).OrderBy(f => f.Name)) " is 162.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "				if (descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) && routeattr != null && !string.IsNullOrWhiteSpace(routeattr.Route)) " is 141.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "							sb.AppendLine("\t{0}({1}) [{2}] - {3}".SFormat(verb.Name' verb.Required ? "Required" : "Optional"' verb.ArgumentType.Name' verb.Description)); " is 142.
Long Statement,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The length of the statement  "							sb.AppendLine("\t{0}({1}) [{2}] - {3}".SFormat(noun.Name' noun.Required ? "Required" : "Optional"' noun.ArgumentType.Name' noun.Description)); " is 142.
Long Statement,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetLoadedPlugins,The length of the statement  "			plugins = new PluginItem[ServerApi.Plugins.Count]; //Initialize with enough room to store the ammount of plugins loaded. " is 120.
Long Statement,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetLoadedPlugins,The length of the statement  "				var apiAttribute = (ApiVersionAttribute)ServerApi.Plugins[i].Plugin.GetType().GetCustomAttributes(typeof(ApiVersionAttribute)' false).FirstOrDefault(); " is 151.
Long Statement,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetLoadedPlugins,The length of the statement  "				//The current implementation of loading plugins doesn't allow for a plugin to be loaded without an ApiVersion' the UNKNOWN is there incase a change is made to allow it " is 167.
Long Statement,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetPlayers,The length of the statement  "						players.Add(String.Format("{0} (IX: {1}{2})"' ply.Name' ply.Index' ply.Account != null ? "' ID: " + ply.Account.ID : "")); " is 122.
Long Statement,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Kick,The length of the statement  "						Broadcast(string.Format("{0} {1}kicked {2} for '{3}'"' adminUserName' verb' playerName' reason.ToLower())' Color.Green); " is 120.
Long Statement,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,HasBanExpired,The length of the statement  "			if (!string.IsNullOrWhiteSpace(ban.Expiration) && (ban.ExpirationDateTime != null) && (DateTime.UtcNow >= ban.ExpirationDateTime)) " is 130.
Long Statement,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,ReplaceDeprecatedColorCodes,The length of the statement  "				tempString = tempString.Replace(match.Groups[0].Value' String.Format("[c/{0:X2}{1:X2}{2:X2}:{3}]"' Int32.Parse(match.Groups["r"].Value)' Int32.Parse(match.Groups["g"].Value)' Int32.Parse(match.Groups["b"].Value)' match.Groups["text"])); " is 236.
Long Statement,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,UpgradeMotD,The length of the statement  "				File.Copy(FileTools.MotdPath' String.Format("{0}_{1}.backup"' FileTools.MotdPath' DateTime.Now.ToString("ddMMMyy_hhmmss"))); " is 124.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,Initialize,The length of the statement  "					Log.ConsoleError("This machine has less than 2 gigabytes of RAM free. Be advised that it might not be enough to run TShock."); " is 126.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The length of the statement  "							ServerApi.LogWriter.PluginWriteLine(this' string.Format("Loading dedicated config file: {0}"' cfg)' TraceLevel.Verbose); " is 120.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The length of the statement  "							ServerApi.LogWriter.PluginWriteLine(this' string.Format("World name will be overridden by: {0}"' world)' TraceLevel.Verbose); " is 125.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The length of the statement  "					ServerApi.LogWriter.PluginWriteLine(this' "\"-connperip\" is not supported in this version of TShock."' TraceLevel.Verbose); " is 124.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HandleCommandLine,The length of the statement  "					ServerApi.LogWriter.PluginWriteLine(this' "Invalid value given for command line argument \"-connperip\"."' TraceLevel.Warning); " is 127.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The length of the statement  "			if (File.Exists(Path.Combine(SavePath' "auth.lck")) || UserAccounts.GetUserAccounts().Exists(u => u.Group == new SuperAdminGroup().Name)) " is 137.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The length of the statement  "					// This avoids unnecessary database work' which can get ridiculously high on old servers as all users need to be fetched " is 120.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The length of the statement  "				Console.WriteLine("TShock Notice: To become SuperAdmin' join the game and type {0}auth {1}"' Commands.Specifier' AuthToken); " is 124.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The length of the statement  "				Console.WriteLine("TShock Notice: authcode.txt is still present' and the AuthToken located in that file will be used."); " is 120.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnUpdate,The length of the statement  "			if (Main.ServerSideCharacter && (DateTime.UtcNow - LastSave).TotalMinutes >= ServerSideCharacterConfig.ServerSideCharacterSave) " is 127.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player)) " is 133.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"); " is 120.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once " is 120.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player)) " is 133.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The length of the statement  "							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"); " is 120.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnStatueSpawn,The length of the statement  "			if (args.Within200 < Config.StatueSpawn200 && args.Within600 < Config.StatueSpawn600 && args.WorldWide < Config.StatueSpawnWorld) " is 129.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnJoin,The length of the statement  "				Utils.ForceKick(player' "Your client did not send a UUID' this server is not configured to accept such a client."' true); " is 121.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The length of the statement  "				if (tsplr.IsLoggedIn && !tsplr.IgnoreActionsForClearingTrashCan && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2)) " is 142.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The length of the statement  "					ply.name = String.Format(Config.ChatAboveHeadsFormat' tsplr.Group.Name' tsplr.Group.Prefix' tsplr.Name' tsplr.Group.Suffix); " is 124.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The length of the statement  "					//Update the player's name to format text nicely. This needs to be done because Terraria automatically formats messages against our will " is 136.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The length of the statement  "						player.IgnoreActionsForInventory = String.Format("Server side characters is enabled! Please {0}register or {0}login to play!"' Commands.Specifier)); " is 148.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The length of the statement  "			if (Config.RememberLeavePos && (RememberedPos.GetLeavePos(player.Name' player.IP) != Vector2.Zero) && !player.LoginHarassed) " is 124.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,HackedInventory,The length of the statement  "								String.Format("Stack cheat detected. Remove Defender's Forge item {0} ({1}) and then rejoin"' item.Name' forge[index].stack)' " is 125.
Long Statement,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckIgnores,The length of the statement  "			return player.IgnoreActionsForInventory != "none" || player.IgnoreActionsForCheating != "none" || player.IgnoreActionsForDisabledArmor != "none" || player.IgnoreActionsForClearingTrashCan || !player.IsLoggedIn && Config.RequireLogin; " is 233.
Long Statement,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Logout,The length of the statement  "				IgnoreActionsForInventory = $"Server side characters is enabled! Please {Commands.Specifier}register or {Commands.Specifier}login to play!"; " is 140.
Long Statement,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,DamagePlayer,The length of the statement  "			NetMessage.SendPlayerHurt(Index' PlayerDeathReason.LegacyDefault()' damage' (new Random()).Next(-1' 1)' false' false' 0' -1' -1); " is 129.
Long Statement,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendData,The length of the statement  "			NetMessage.SendData((int)msgType' Index' -1' NetworkText.FromLiteral(text)' number' number2' number3' number4' number5); " is 120.
Long Statement,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendDataFromPlayer,The length of the statement  "			NetMessage.SendData((int)msgType' Index' -1' NetworkText.FromFormattable(text)' ply' number2' number3' number4' number5); " is 121.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,Reload,The length of the statement  "						Region r = new Region(id' new Rectangle(X1' Y1' width' height)' name' owner' Protected != 0' Main.worldID.ToString()' z); " is 121.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,Reload,The length of the statement  "							TShock.Log.Error("A lot of things will fail because of this. You must manually delete and re-create the allowed field."); " is 121.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,AddRegion,The length of the statement  "					"INSERT INTO Regions (X1' Y1' width' height' RegionName' WorldID' UserIds' Protected' Groups' Owner' Z) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8' @9' @10);"' " is 159.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,AddRegion,The length of the statement  "				using (QueryResult res = database.QueryReader("SELECT Id FROM Regions WHERE RegionName = @0 AND WorldID = @1"' regionname' worldid)) " is 132.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The length of the statement  "				using (var reader = database.QueryReader("SELECT X1' Y1' height' width FROM Regions WHERE RegionName=@0 AND WorldID=@1"' " is 120.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The length of the statement  "				int q = database.Query("UPDATE Regions SET X1 = @0' Y1 = @1' width = @2' height = @3 WHERE RegionName = @4 AND WorldID=@5"' X' Y' width' " is 136.
Long Statement,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,PositionRegion,The length of the statement  "				if (database.Query("UPDATE Regions SET X1 = @0' Y1 = @1' width = @2' height = @3 WHERE RegionName = @4 AND WorldID = @5"' " is 121.
Long Statement,TShockAPI.DB,Region,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,HasPermissionToBuildInRegion,The length of the statement  "			return ply.HasPermission(Permissions.editregion) || AllowedIDs.Contains(ply.Account.ID) || AllowedGroups.Contains(ply.Group.Name) || Owner == ply.Account.Name; " is 159.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByIp,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetSortedBans,The length of the statement  "						banlist.Add(new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration"))); " is 265.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByName,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByAccountName,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,GetBanByUUID,The length of the statement  "						return new Ban(reader.Get<string>("IP")' reader.Get<string>("Name")' reader.Get<string>("UUID")' reader.Get<string>("AccountName")' reader.Get<string>("Reason")' reader.Get<string>("BanningUser")' reader.Get<string>("Date")' reader.Get<string>("Expiration")); " is 259.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan2,The length of the statement  "					return database.Query("UPDATE Bans SET Date = @0' Expiration = @1 WHERE IP = @2"' DateTime.UtcNow.ToString("s")' expiration' ip) == 1; " is 134.
Long Statement,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,AddBan2,The length of the statement  "					return database.Query("INSERT INTO Bans (IP' Name' UUID' Reason' BanningUser' Date' Expiration' AccountName) VALUES (@0' @1' @2' @3' @4' @5' @6' @7);"' ip' name' uuid' reason' banner' DateTime.UtcNow.ToString("s")' expiration' accountName) != 0; " is 245.
Long Statement,TShockAPI.DB,BanComparer,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,CompareDateTimes,The length of the statement  "			return _method == BanSortMethod.AddedNewestToOldest || _method == BanSortMethod.ExpirationSoonestToLatest ? x.Value.CompareTo(y.Value) " is 134.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,SeedInitialData,The length of the statement  "				database.Query("INSERT INTO tsCharacter (Account' Health' MaxHealth' Mana' MaxMana' Inventory' spawnX' spawnY' questsCompleted) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8);"' " is 174.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						"INSERT INTO tsCharacter (Account' Health' MaxHealth' Mana' MaxMana' Inventory' extraSlot' spawnX' spawnY' skinVariant' hair' hairDye' hairColor' pantsColor' shirtColor' underShirtColor' shoeColor' hideVisuals' skinColor' eyeColor' questsCompleted) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8' @9' @10' @11' @12' @13' @14' @15' @16' @17' @18' @19' @20);"' " is 354.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						player.Account.ID' playerData.health' playerData.maxHealth' playerData.mana' playerData.maxMana' String.Join("~"' playerData.inventory)' playerData.extraSlot' player.TPlayer.SpawnX' player.TPlayer.SpawnY' player.TPlayer.skinVariant' player.TPlayer.hair' player.TPlayer.hairDye' TShock.Utils.EncodeColor(player.TPlayer.hairColor)' TShock.Utils.EncodeColor(player.TPlayer.pantsColor)'TShock.Utils.EncodeColor(player.TPlayer.shirtColor)' TShock.Utils.EncodeColor(player.TPlayer.underShirtColor)' TShock.Utils.EncodeColor(player.TPlayer.shoeColor)' TShock.Utils.EncodeBoolArray(player.TPlayer.hideVisual)' TShock.Utils.EncodeColor(player.TPlayer.skinColor)'TShock.Utils.EncodeColor(player.TPlayer.eyeColor)' player.TPlayer.anglerQuestsFinished); " is 741.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						"UPDATE tsCharacter SET Health = @0' MaxHealth = @1' Mana = @2' MaxMana = @3' Inventory = @4' spawnX = @6' spawnY = @7' hair = @8' hairDye = @9' hairColor = @10' pantsColor = @11' shirtColor = @12' underShirtColor = @13' shoeColor = @14' hideVisuals = @15' skinColor = @16' eyeColor = @17' questsCompleted = @18' skinVariant = @19' extraSlot = @20 WHERE Account = @5;"' " is 369.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertPlayerData,The length of the statement  "						playerData.health' playerData.maxHealth' playerData.mana' playerData.maxMana' String.Join("~"' playerData.inventory)' player.Account.ID' player.TPlayer.SpawnX' player.TPlayer.SpawnY' player.TPlayer.hair' player.TPlayer.hairDye' TShock.Utils.EncodeColor(player.TPlayer.hairColor)' TShock.Utils.EncodeColor(player.TPlayer.pantsColor)' TShock.Utils.EncodeColor(player.TPlayer.shirtColor)' TShock.Utils.EncodeColor(player.TPlayer.underShirtColor)' TShock.Utils.EncodeColor(player.TPlayer.shoeColor)' TShock.Utils.EncodeBoolArray(player.TPlayer.hideVisual)' TShock.Utils.EncodeColor(player.TPlayer.skinColor)' TShock.Utils.EncodeColor(player.TPlayer.eyeColor)' player.TPlayer.anglerQuestsFinished' player.TPlayer.skinVariant' player.TPlayer.extraAccessory ? 1 : 0); " is 760.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertSpecificPlayerData,The length of the statement  "						"INSERT INTO tsCharacter (Account' Health' MaxHealth' Mana' MaxMana' Inventory' extraSlot' spawnX' spawnY' skinVariant' hair' hairDye' hairColor' pantsColor' shirtColor' underShirtColor' shoeColor' hideVisuals' skinColor' eyeColor' questsCompleted) VALUES (@0' @1' @2' @3' @4' @5' @6' @7' @8' @9' @10' @11' @12' @13' @14' @15' @16' @17' @18' @19' @20);"' " is 354.
Long Statement,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,InsertSpecificPlayerData,The length of the statement  "						"UPDATE tsCharacter SET Health = @0' MaxHealth = @1' Mana = @2' MaxMana = @3' Inventory = @4' spawnX = @6' spawnY = @7' hair = @8' hairDye = @9' hairColor = @10' pantsColor = @11' shirtColor = @12' underShirtColor = @13' shoeColor = @14' hideVisuals = @15' skinColor = @16' eyeColor = @17' questsCompleted = @18' skinVariant = @19' extraSlot = @20 WHERE Account = @5;"' " is 369.
Long Statement,TShockAPI.DB,GenericQueryCreator,C:\repos\NyxStudios_TShock\TShockAPI\DB\IQueryBuilder.cs,UpdateValue,The length of the statement  "			return "UPDATE {0} SET {1} {2}".SFormat(EscapeTableName(table)' string.Join("' "' values.Select(v => v.Name + " = " + v.Value))' BuildWhere(wheres)); " is 149.
Long Statement,TShockAPI.DB,DbExt,C:\repos\NyxStudios_TShock\TShockAPI\Extensions\DbExt.cs,QueryReader,The length of the statement  "				throw new Exception("Fatal TShock initialization exception: failed to connect to MySQL database. See inner exception for details."' ex); " is 136.
Long Statement,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,LoadPermisions,The length of the statement  "							TShock.Log.ConsoleInfo("WARNING: Group \"superadmin\" is defined in the database even though it's a reserved group name."); " is 123.
Long Statement,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,LoadPermisions,The length of the statement  "										"ERROR: Group \"{0}\" is referencing parent group \"{1}\" which is already part of the parent chain. Parent reference removed."' " is 128.
Long Statement,TShockAPI.DB,UserAccountManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,AddUserAccount,The length of the statement  "				ret = _database.Query("INSERT INTO Users (Username' Password' UUID' UserGroup' Registered) VALUES (@0' @1' @2' @3' @4);"' account.Name' " is 135.
Long Statement,TShockAPI.DB,UserAccountManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UpdateLogin,The length of the statement  "				if (_database.Query("UPDATE Users SET LastAccessed = @0' KnownIps = @1 WHERE Username = @2;"' DateTime.UtcNow.ToString("s")' account.KnownIps' account.Name) == 0) " is 162.
Long Statement,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The length of the statement  "				throw new ArgumentOutOfRangeException("password"' "Password must be > " + TShock.Config.MinimumPasswordLength + " characters."); " is 128.
Long Statement,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The length of the statement  "				throw new ArgumentOutOfRangeException("password"' "Password must be > " + TShock.Config.MinimumPasswordLength + " characters."); " is 128.
Long Statement,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,HashPassword,The length of the statement  "				throw new NotSupportedException("Hashing algorithm {0} is not supported".SFormat(TShock.Config.HashAlgorithm.ToLower())); " is 121.
Long Statement,TShockAPI.DB,RememberedPosManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,GetLeavePos,The length of the statement  "				using (var reader = database.QueryReader("SELECT * FROM RememberedPos WHERE Name=@0 AND IP=@1 AND WorldID=@2"' name' IP' Main.worldID.ToString())) " is 146.
Long Statement,TShockAPI.DB,RememberedPosManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,InsertLeavePos,The length of the statement  "					database.Query("INSERT INTO RememberedPos (Name' IP' X' Y' WorldID) VALUES (@0' @1' @2' @3' @4);"' name' IP' X' Y ' Main.worldID.ToString()); " is 141.
Long Statement,TShockAPI.DB,RememberedPosManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,InsertLeavePos,The length of the statement  "					database.Query("UPDATE RememberedPos SET X = @0' Y = @1' IP = @2' WorldID = @3 WHERE Name = @4;"' X' Y' IP' Main.worldID.ToString()' name); " is 139.
Long Statement,TShockAPI.Sockets,LinuxTcpSocket,C:\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,AsyncReceive,The length of the statement  "			this._connection.GetStream().BeginRead(data' offset' size' new AsyncCallback(this.ReadCallback)' new Tuple<SocketReceiveCallback' object>(callback' state)); " is 156.
Long Statement,Rests,Rest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\Rest.cs,Start,The length of the statement  "				TShock.Log.ConsoleError("Invalid REST configuration: \nYou may already have a REST service bound to port {0}. \nPlease adjust your configuration and restart the server. \nPress any key to exit."' Port); " is 202.
Long Statement,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "					TShock.Log.ConsoleError("A REST login from {0} was blocked as it currently has {1} tokens"' context.RemoteEndPoint.Address.ToString()' tokens); " is 143.
Long Statement,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "				tokenBucket[context.RemoteEndPoint.Address.ToString()] += 1; // Tokens under limit' increment by one and process request " is 120.
Long Statement,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "				return new RestObject("403") { Error = "Username or password may be incorrect or this account may not have sufficient privileges." }; " is 133.
Long Statement,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The length of the statement  "				return new RestObject("403") { Error = "Username or password may be incorrect or this account may not have sufficient privileges." }; " is 133.
Long Statement,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,ExecuteCommand,The length of the statement  "				{ Error = string.Format("Not authorized. User \"{0}\" has no access to use the specified API endpoint."' tokenData.Username) }; " is 127.
Complex Conditional,TShockAPI,HandlerList<T>,C:\repos\NyxStudios_TShock\TShockAPI\HandlerList.cs,Invoke,The conditional expression  "hargs == null || !hargs.Handled || (hargs.Handled && handlers[i].GetHandled)"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The conditional expression  "account.VerifyPassword(password) ||  						(usingUUID && account.UUID == args.Player.UUID && !TShock.Config.DisableUUIDLogin &&  						!String.IsNullOrWhiteSpace(args.Player.UUID))"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The conditional expression  "warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add""  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The conditional expression  "parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b)"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The conditional expression  "!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The conditional expression  "args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Butcher,The conditional expression  "Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC && Main.npc[i].netID != NPCID.TargetDummy) || Main.npc[i].netID == npcId)"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The conditional expression  "args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The conditional expression  "Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC) || (Main.npc[i].netID == npcId && Main.npc[i].townNPC))"  is complex.
Complex Conditional,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The conditional expression  "plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,TSCheckNoclip,The conditional expression  "Main.tile[i' j] == null || Main.tileSand[Main.tile[i' j].type]  						|| !TShock.Utils.TileSolid(i' j) || !TShock.Utils.TileSolid(i + 1' j) || !TShock.Utils.TileSolid(i - 1' j)  						|| !TShock.Utils.TileSolid(i' j + 1) || !TShock.Utils.TileSolid(i + 1' j + 1) || !TShock.Utils.TileSolid(i - 1' j + 1)  						|| !TShock.Utils.TileSolid(i' j - 1) || !TShock.Utils.TileSolid(i + 1' j - 1) || !TShock.Utils.TileSolid(i - 1' j - 1)  						|| Main.tileSolidTop[(int)Main.tile[i' j].type]"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,TSCheckNoclip,The conditional expression  "Position.X + (float)Width > vector.X && Position.X < vector.X + 16f && Position.Y + (float)Height > vector.Y && Position.Y < vector.Y + 16f"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerSlot,The conditional expression  "OnPlayerSlot(plr' slot' stack' prefix' type) || plr != args.Player.Index || slot < 0 ||  				slot > NetItem.MaxInventory"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerSlot,The conditional expression  "Main.ServerSideCharacter && TShock.Config.DisableLoginBeforeJoin && !bypassTrashCanCheck &&  				args.Player.HasSentInventory && !args.Player.HasPermission(Permissions.bypassssc)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerHp,The conditional expression  "OnPlayerHP(plr' cur' max) || cur <= 0 || max <= 0 || args.Player.IgnoreSSCPackets"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerMana,The conditional expression  "OnPlayerMana(plr' cur' max) || cur < 0 || max < 0 || args.Player.IgnoreSSCPackets"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The conditional expression  "(TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type])"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The conditional expression  "((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The conditional expression  "(tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "(action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData])"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID]))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "(TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The conditional expression  "(action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The conditional expression  "(type != TileID.Rope  					|| type != TileID.SilkRope  					|| type != TileID.VineRope  					|| type != TileID.WebRope)  					&& TShock.CheckRangePermission(args.Player' x' y)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The conditional expression  "pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The conditional expression  "!args.Player.HasPermission(Permissions.ignorenoclipdetection) &&  					TSCheckNoclip(pos' args.TPlayer.width' args.TPlayer.height - (args.TPlayer.mount.Active ? args.Player.TPlayer.mount.HeightBoost : 0)) && !TShock.Config.IgnoreNoClip  					&& !args.TPlayer.tongued"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The conditional expression  "type == ProjectileID.BlowupSmokeMoonlord  					|| type == ProjectileID.PhantasmalEye  					|| type == ProjectileID.CultistBossIceMist  					|| (type >= ProjectileID.MoonlordBullet && type <= ProjectileID.MoonlordTurretLaser)  					|| type == ProjectileID.DeathLaser || type == ProjectileID.Landmine  					|| type == ProjectileID.BulletDeadeye || type == ProjectileID.BoulderStaffOfEarth  					|| (type > ProjectileID.ConfettiMelee && type < ProjectileID.SpiritHeal)  					|| (type >= ProjectileID.FlamingWood && type <= ProjectileID.GreekFire3)  					|| (type >= ProjectileID.PineNeedleHostile && type <= ProjectileID.Spike)  					|| (type >= ProjectileID.MartianTurretBolt && type <= ProjectileID.RayGunnerLaser)  					|| type == ProjectileID.CultistBossLightningOrb"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The conditional expression  "hasPermission &&  				(type == ProjectileID.Bomb  				|| type == ProjectileID.Dynamite  				|| type == ProjectileID.StickyBomb  				|| type == ProjectileID.StickyDynamite)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The conditional expression  "TShock.CheckProjectilePermission(args.Player' index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The conditional expression  "npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The conditional expression  "npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The conditional expression  "type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The conditional expression  "flag != 0 && flag != 4 // if no container or container2 placement  				&& Main.tile[tileX' tileY].type != TileID.Containers  				&& Main.tile[tileX' tileY].type != TileID.Dressers  				&& Main.tile[tileX' tileY].type != TileID.Containers2  				&& (!TShock.Utils.MaxChests() && Main.tile[tileX' tileY].type != TileID.Dirt)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The conditional expression  "(TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Teleporter) ||  					(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Teleporter)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The conditional expression  "(Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The conditional expression  "(stacks > item.maxStack || stacks <= 0) || (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' args.Player) && !args.Player.HasPermission(Permissions.allowdroppingbanneditems))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The conditional expression  "Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149)"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintTile,The conditional expression  "x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY || t > Main.numTileColors"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintTile,The conditional expression  "args.Player.SelectedItem.type != ItemID.PaintRoller &&  				args.Player.SelectedItem.type != ItemID.PaintScraper &&  				args.Player.SelectedItem.type != ItemID.Paintbrush &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintRoller &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintScraper &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintbrush &&  				!args.Player.Accessories.Any(i => i != null && i.stack > 0 &&  					(i.type == ItemID.PaintSprayer || i.type == ItemID.ArchitectGizmoPack))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintWall,The conditional expression  "x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY || t > Main.numTileColors"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintWall,The conditional expression  "args.Player.SelectedItem.type != ItemID.PaintRoller &&  				args.Player.SelectedItem.type != ItemID.PaintScraper &&  				args.Player.SelectedItem.type != ItemID.Paintbrush &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintRoller &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintScraper &&  				args.Player.SelectedItem.type != ItemID.SpectrePaintbrush &&  				!args.Player.Accessories.Any(i => i != null && i.stack > 0 &&  					(i.type == ItemID.PaintSprayer || i.type == ItemID.ArchitectGizmoPack))"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleDoorUse,The conditional expression  "x >= Main.maxTilesX || y >= Main.maxTilesY || x < 0 || y < 0"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleDoorUse,The conditional expression  "tileType != TileID.ClosedDoor && tileType != TileID.OpenDoor  				&& tileType != TileID.TallGateClosed && tileType != TileID.TallGateOpen  				&& tileType != TileID.TrapdoorClosed && tileType != TileID.TrapdoorOpen"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleGemLockToggle,The conditional expression  "x < 0 || y < 0 || x >= Main.maxTilesX || y >= Main.maxTilesY"  is complex.
Complex Conditional,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSyncExtraValue,The conditional expression  "position.X < 0 || position.X >= Main.maxTilesX || position.Y < 0 || position.Y >= Main.maxTilesY"  is complex.
Complex Conditional,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,WorldButcher,The conditional expression  "Main.npc[i].active && Main.npc[i].type != 0 && !Main.npc[i].townNPC && (!Main.npc[i].friendly || killFriendly)"  is complex.
Complex Conditional,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,DumpDescriptions,The conditional expression  "descattr != null && !string.IsNullOrWhiteSpace(descattr.Description) && routeattr != null && !string.IsNullOrWhiteSpace(routeattr.Route)"  is complex.
Complex Conditional,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,SendLogs,The conditional expression  "player != null && player != excludedPlayer && player.Active && player.HasPermission(Permissions.logs) &&  						player.DisplayLogs && TShock.Config.DisableSpewLogs == false"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The conditional expression  "(Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The conditional expression  "!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnCreep,The conditional expression  "!Config.AllowCrimsonCreep && (tileType == TileID.Dirt || tileType == TileID.FleshWeeds  				|| TileID.Sets.Crimson[tileType])"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnCreep,The conditional expression  "!Config.AllowCorruptionCreep && (tileType == TileID.Dirt || tileType == TileID.CorruptThorns  				|| TileID.Sets.Corrupt[tileType])"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The conditional expression  "tsplr.IsLoggedIn && !tsplr.IgnoreActionsForClearingTrashCan && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The conditional expression  "(player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The conditional expression  "e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckProjectilePermission,The conditional expression  "(type == 42 || type == 65 || type == 68) && Itembans.ItemIsBanned("Sandgun"' player)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The conditional expression  "p.X == tileX && p.Y == tileY && (Main.tile[p.X' p.Y].type == 0 || Main.tile[p.X' p.Y].type == 127)"  is complex.
Complex Conditional,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The conditional expression  "(!paint && !player.HasPermission(Permissions.canbuild)) ||  				(paint && !player.HasPermission(Permissions.canpaint))"  is complex.
Complex Conditional,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,GiveItemCheck,The conditional expression  "(TShock.Itembans.ItemIsBanned(name) && TShock.Config.PreventBannedItemSpawn) &&  			    (TShock.Itembans.ItemIsBanned(name' this) || !TShock.Config.AllowAllowedGroupsToSpawnBannedItems)"  is complex.
Complex Conditional,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,GiveItemCheck,The conditional expression  "(TShock.Itembans.ItemIsBanned(name) && TShock.Config.PreventBannedItemSpawn) &&  			    (TShock.Itembans.ItemIsBanned(name' this) || !TShock.Config.AllowAllowedGroupsToSpawnBannedItems)"  is complex.
Empty Catch Block,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetIPv4Address,The method has an empty catch block.
Empty Catch Block,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendTileSquare,The method has an empty catch block.
Empty Catch Block,TShockAPI.Sockets,LinuxTcpSocket,C:\repos\NyxStudios_TShock\TShockAPI\Sockets\LinuxTcpSocket.cs,ListenLoop,The method has an empty catch block.
Magic Number,TShockAPI,NetItem,C:\repos\NyxStudios_TShock\TShockAPI\NetItem.cs,Parse,The following statement contains a magic number: if (comp.Length != 3)  				throw new FormatException("String does not contain three sections.");
Magic Number,TShockAPI,NetItem,C:\repos\NyxStudios_TShock\TShockAPI\NetItem.cs,Parse,The following statement contains a magic number: byte prefixId = Byte.Parse(comp[2]);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.InventorySlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.ArmorSlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.DyeSlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.MiscEquipSlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.MiscDyeSlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.PiggySlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.SafeSlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.ForgeSlots; k++)  			{  				NetMessage.SendData(5' -1' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(4' -1' -1' NetworkText.FromLiteral(player.Name)' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(42' -1' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(16' -1' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.InventorySlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].inventory[k].Name)' player.Index' slot' (float)Main.player[player.Index].inventory[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.ArmorSlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].armor[k].Name)' player.Index' slot' (float)Main.player[player.Index].armor[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.DyeSlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].dye[k].Name)' player.Index' slot' (float)Main.player[player.Index].dye[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.MiscEquipSlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscEquips[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscEquips[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.MiscDyeSlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].miscDyes[k].Name)' player.Index' slot' (float)Main.player[player.Index].miscDyes[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.PiggySlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank.item[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.SafeSlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank2.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank2.item[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].trashItem.Name)' player.Index' slot++' (float)Main.player[player.Index].trashItem.prefix);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < NetItem.ForgeSlots; k++)  			{  				NetMessage.SendData(5' player.Index' -1' NetworkText.FromLiteral(Main.player[player.Index].bank3.item[k].Name)' player.Index' slot' (float)Main.player[player.Index].bank3.item[k].prefix);  				slot++;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(4' player.Index' -1' NetworkText.FromLiteral(player.Name)' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(42' player.Index' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(16' player.Index' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: for (int k = 0; k < 22; k++)  			{  				player.TPlayer.buffType[k] = 0;  			}
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(50' -1' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(50' player.Index' -1' NetworkText.Empty' player.Index' 0f' 0f' 0f' 0);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(76' player.Index' -1' NetworkText.Empty' player.Index);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(76' -1' -1' NetworkText.Empty' player.Index);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(39' player.Index' -1' NetworkText.Empty' 400);
Magic Number,TShockAPI,PlayerData,C:\repos\NyxStudios_TShock\TShockAPI\PlayerData.cs,RestoreCharacter,The following statement contains a magic number: NetMessage.SendData(39' player.Index' -1' NetworkText.Empty' 400);
Magic Number,TShockAPI,SqlLog,C:\repos\NyxStudios_TShock\TShockAPI\SqlLog.cs,Write,The following statement contains a magic number: var frame = new StackTrace().GetFrame(2);
Magic Number,TShockAPI,TextLog,C:\repos\NyxStudios_TShock\TShockAPI\TextLog.cs,Write,The following statement contains a magic number: var frame = new StackTrace().GetFrame(2);
Magic Number,TShockAPI,Settings,C:\repos\NyxStudios_TShock\TShockAPI\PaginationTools.cs,Settings,The following statement contains a magic number: this.maxLinesPerPage = 4;
Magic Number,TShockAPI,SaveManager,C:\repos\NyxStudios_TShock\TShockAPI\SaveManager.cs,SaveWorld,The following statement contains a magic number: while (0 != count)  			{  				Thread.Sleep(50);  				count = saveQueueCount;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,InitCommands,The following statement contains a magic number: List<Command> tshockCommands = new List<Command>(100);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The following statement contains a magic number: if (args.Parameters.Count == 0 && !TShock.Config.DisableUUIDLogin)  			{  				if (PlayerHooks.OnPlayerPreLogin(args.Player' args.Player.Name' ""))  					return;  				usingUUID = true;  			}  			else if (args.Parameters.Count == 1)  			{  				if (PlayerHooks.OnPlayerPreLogin(args.Player' args.Player.Name' args.Parameters[0]))  					return;  				password = args.Parameters[0];  			}  			else if (args.Parameters.Count == 2 && TShock.Config.AllowLoginAnyUsername)  			{  				if (String.IsNullOrEmpty(args.Parameters[0]))  				{  					args.Player.SendErrorMessage("Bad login attempt.");  					return;  				}    				if (PlayerHooks.OnPlayerPreLogin(args.Player' args.Parameters[0]' args.Parameters[1]))  					return;    				account = TShock.UserAccounts.GetUserAccountByName(args.Parameters[0]);  				password = args.Parameters[1];  			}  			else  			{  				args.Player.SendErrorMessage("Syntax: {0}login - Logs in using your UUID and character name"' Specifier);  				args.Player.SendErrorMessage("        {0}login <password> - Logs in using your password and character name"' Specifier);  				args.Player.SendErrorMessage("        {0}login <username> <password> - Logs in using your username and password"' Specifier);  				args.Player.SendErrorMessage("If you forgot your password' there is no way to recover it.");  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The following statement contains a magic number: try  			{  				if (account == null)  				{  					args.Player.SendErrorMessage("A user account by that name does not exist.");  				}  				else if (account.VerifyPassword(password) ||  						(usingUUID && account.UUID == args.Player.UUID && !TShock.Config.DisableUUIDLogin &&  						!String.IsNullOrWhiteSpace(args.Player.UUID)))  				{  					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player' account.ID);    					var group = TShock.Utils.GetGroup(account.Group);    					args.Player.Group = group;  					args.Player.tempGroup = null;  					args.Player.Account = account;  					args.Player.IsLoggedIn = true;  					args.Player.IgnoreActionsForInventory = "none";    					if (Main.ServerSideCharacter)  					{  						if (args.Player.HasPermission(Permissions.bypassssc))  						{  							args.Player.PlayerData.CopyCharacter(args.Player);  							TShock.CharacterDB.InsertPlayerData(args.Player);  						}  						args.Player.PlayerData.RestoreCharacter(args.Player);  					}  					args.Player.LoginFailsBySsi = false;    					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))  						args.Player.IgnoreActionsForCheating = "none";    					if (args.Player.HasPermission(Permissions.usebanneditem))  						args.Player.IgnoreActionsForDisabledArmor = "none";    					args.Player.SendSuccessMessage("Authenticated as " + account.Name + " successfully.");    					TShock.Log.ConsoleInfo(args.Player.Name + " authenticated successfully as user: " + account.Name + ".");  					if ((args.Player.LoginHarassed) && (TShock.Config.RememberLeavePos))  					{  						if (TShock.RememberedPos.GetLeavePos(args.Player.Name' args.Player.IP) != Vector2.Zero)  						{  							Vector2 pos = TShock.RememberedPos.GetLeavePos(args.Player.Name' args.Player.IP);  							args.Player.Teleport((int)pos.X * 16' (int)pos.Y * 16);  						}  						args.Player.LoginHarassed = false;    					}  					TShock.UserAccounts.SetUserAccountUUID(account' args.Player.UUID);    					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);  				}  				else  				{  					if (usingUUID && !TShock.Config.DisableUUIDLogin)  					{  						args.Player.SendErrorMessage("UUID does not match this character!");  					}  					else  					{  						args.Player.SendErrorMessage("Invalid password!");  					}  					TShock.Log.Warn(args.Player.IP + " failed to authenticate as user: " + account.Name + ".");  					args.Player.LoginAttempts++;  				}  			}  			catch (Exception ex)  			{  				args.Player.SendErrorMessage("There was an error processing your request.");  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,AttemptLogin,The following statement contains a magic number: try  			{  				if (account == null)  				{  					args.Player.SendErrorMessage("A user account by that name does not exist.");  				}  				else if (account.VerifyPassword(password) ||  						(usingUUID && account.UUID == args.Player.UUID && !TShock.Config.DisableUUIDLogin &&  						!String.IsNullOrWhiteSpace(args.Player.UUID)))  				{  					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player' account.ID);    					var group = TShock.Utils.GetGroup(account.Group);    					args.Player.Group = group;  					args.Player.tempGroup = null;  					args.Player.Account = account;  					args.Player.IsLoggedIn = true;  					args.Player.IgnoreActionsForInventory = "none";    					if (Main.ServerSideCharacter)  					{  						if (args.Player.HasPermission(Permissions.bypassssc))  						{  							args.Player.PlayerData.CopyCharacter(args.Player);  							TShock.CharacterDB.InsertPlayerData(args.Player);  						}  						args.Player.PlayerData.RestoreCharacter(args.Player);  					}  					args.Player.LoginFailsBySsi = false;    					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))  						args.Player.IgnoreActionsForCheating = "none";    					if (args.Player.HasPermission(Permissions.usebanneditem))  						args.Player.IgnoreActionsForDisabledArmor = "none";    					args.Player.SendSuccessMessage("Authenticated as " + account.Name + " successfully.");    					TShock.Log.ConsoleInfo(args.Player.Name + " authenticated successfully as user: " + account.Name + ".");  					if ((args.Player.LoginHarassed) && (TShock.Config.RememberLeavePos))  					{  						if (TShock.RememberedPos.GetLeavePos(args.Player.Name' args.Player.IP) != Vector2.Zero)  						{  							Vector2 pos = TShock.RememberedPos.GetLeavePos(args.Player.Name' args.Player.IP);  							args.Player.Teleport((int)pos.X * 16' (int)pos.Y * 16);  						}  						args.Player.LoginHarassed = false;    					}  					TShock.UserAccounts.SetUserAccountUUID(account' args.Player.UUID);    					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);  				}  				else  				{  					if (usingUUID && !TShock.Config.DisableUUIDLogin)  					{  						args.Player.SendErrorMessage("UUID does not match this character!");  					}  					else  					{  						args.Player.SendErrorMessage("Invalid password!");  					}  					TShock.Log.Warn(args.Player.IP + " failed to authenticate as user: " + account.Name + ".");  					args.Player.LoginAttempts++;  				}  			}  			catch (Exception ex)  			{  				args.Player.SendErrorMessage("There was an error processing your request.");  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,PasswordUser,The following statement contains a magic number: try  			{  				if (args.Player.IsLoggedIn && args.Parameters.Count == 2)  				{  					string password = args.Parameters[0];  					if (args.Player.Account.VerifyPassword(password))  					{  						try  						{  							args.Player.SendSuccessMessage("You changed your password!");  							TShock.UserAccounts.SetUserAccountPassword(args.Player.Account' args.Parameters[1]); // SetUserPassword will hash it for you.  							TShock.Log.ConsoleInfo(args.Player.IP + " named " + args.Player.Name + " changed the password of account " +  												   args.Player.Account.Name + ".");  						}  						catch (ArgumentOutOfRangeException)  						{  							args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  						}  					}  					else  					{  						args.Player.SendErrorMessage("You failed to change your password!");  						TShock.Log.ConsoleError(args.Player.IP + " named " + args.Player.Name + " failed to change password for account: " +  												args.Player.Account.Name + ".");  					}  				}  				else  				{  					args.Player.SendErrorMessage("Not logged in or invalid syntax! Proper syntax: {0}password <oldpassword> <newpassword>"' Specifier);  				}  			}  			catch (UserAccountManagerException ex)  			{  				args.Player.SendErrorMessage("Sorry' an error occured: " + ex.Message + ".");  				TShock.Log.ConsoleError("PasswordUser returned an error: " + ex);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RegisterUser,The following statement contains a magic number: try  			{  				var account = new UserAccount();  				string echoPassword = "";  				if (args.Parameters.Count == 1)  				{  					account.Name = args.Player.Name;  					echoPassword = args.Parameters[0];  					try  					{  						account.CreateBCryptHash(args.Parameters[0]);  					}  					catch (ArgumentOutOfRangeException)  					{  						args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  						return;  					}  				}  				else if (args.Parameters.Count == 2 && TShock.Config.AllowRegisterAnyUsername)  				{  					account.Name = args.Parameters[0];  					echoPassword = args.Parameters[1];  					try  					{  						account.CreateBCryptHash(args.Parameters[1]);  					}  					catch (ArgumentOutOfRangeException)  					{  						args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  						return;  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}register <password>"' Specifier);  					return;  				}    				account.Group = TShock.Config.DefaultRegistrationGroupName; // FIXME -- we should get this from the DB. --Why?  				account.UUID = args.Player.UUID;    				if (TShock.UserAccounts.GetUserAccountByName(account.Name) == null && account.Name != TSServerPlayer.AccountName) // Cheap way of checking for existance of a user  				{  					args.Player.SendSuccessMessage("Account \"{0}\" has been registered."' account.Name);  					args.Player.SendSuccessMessage("Your password is {0}."' echoPassword);  					TShock.UserAccounts.AddUserAccount(account);  					TShock.Log.ConsoleInfo("{0} registered an account: \"{1}\"."' args.Player.Name' account.Name);  				}  				else  				{  					args.Player.SendErrorMessage("Sorry' " + account.Name + " was already taken by another person.");  					args.Player.SendErrorMessage("Please try a different username.");  					TShock.Log.ConsoleInfo(args.Player.Name + " failed to register an existing account: " + account.Name);  				}  			}  			catch (UserAccountManagerException ex)  			{  				args.Player.SendErrorMessage("Sorry' an error occured: " + ex.Message + ".");  				TShock.Log.ConsoleError("RegisterUser returned an error: " + ex);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ManageUsers,The following statement contains a magic number: if (subcmd == "add" && args.Parameters.Count == 4)  			{  				var account = new UserAccount();    				account.Name = args.Parameters[1];  				try  				{  					account.CreateBCryptHash(args.Parameters[2]);  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  					return;  				}  				account.Group = args.Parameters[3];    				try  				{  					TShock.UserAccounts.AddUserAccount(account);  					args.Player.SendSuccessMessage("Account " + account.Name + " has been added to group " + account.Group + "!");  					TShock.Log.ConsoleInfo(args.Player.Name + " added Account " + account.Name + " to group " + account.Group);  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("Group " + account.Group + " does not exist!");  				}  				catch (UserAccountExistsException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " already exists!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added' check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			// User deletion requires a username  			else if (subcmd == "del" && args.Parameters.Count == 2)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.RemoveUserAccount(account);  					args.Player.SendSuccessMessage("Account removed successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " successfully deleted account: " + args.Parameters[1] + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("The user " + account.Name + " does not exist! Deleted nobody!");  				}  				catch (UserAccountManagerException ex)  				{  					args.Player.SendErrorMessage(ex.Message);  					TShock.Log.ConsoleError(ex.ToString());  				}  			}    			// Password changing requires a username' and a new password to set  			else if (subcmd == "password" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserAccountPassword(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed the password of account " + account.Name);  					args.Player.SendSuccessMessage("Password change succeeded for " + account.Name + ".");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("Password change for " + account.Name + " failed! Check console!");  					TShock.Log.ConsoleError(e.ToString());  				}  				catch (ArgumentOutOfRangeException)  				{  					args.Player.SendErrorMessage("Password must be greater than or equal to " + TShock.Config.MinimumPasswordLength + " characters.");  				}  			}  			// Group changing requires a username or IP address' and a new group to set  			else if (subcmd == "group" && args.Parameters.Count == 3)  			{  				var account = new UserAccount();  				account.Name = args.Parameters[1];    				try  				{  					TShock.UserAccounts.SetUserGroup(account' args.Parameters[2]);  					TShock.Log.ConsoleInfo(args.Player.Name + " changed account " + account.Name + " to group " + args.Parameters[2] + ".");  					args.Player.SendSuccessMessage("Account " + account.Name + " has been changed to group " + args.Parameters[2] + "!");  				}  				catch (GroupNotExistsException)  				{  					args.Player.SendErrorMessage("That group does not exist!");  				}  				catch (UserAccountNotExistException)  				{  					args.Player.SendErrorMessage("User " + account.Name + " does not exist!");  				}  				catch (UserAccountManagerException e)  				{  					args.Player.SendErrorMessage("User " + account.Name + " could not be added. Check console for details.");  					TShock.Log.ConsoleError(e.ToString());  				}  			}  			else if (subcmd == "help")  			{  				args.Player.SendInfoMessage("Use command help:");  				args.Player.SendInfoMessage("{0}user add username password group   -- Adds a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user del username                  -- Removes a specified user"' Specifier);  				args.Player.SendInfoMessage("{0}user password username newpassword -- Changes a user's password"' Specifier);  				args.Player.SendInfoMessage("{0}user group username newgroup       -- Changes a user's group"' Specifier);  			}  			else  			{  				args.Player.SendErrorMessage("Invalid user syntax. Try {0}user help."' Specifier);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Ban,The following statement contains a magic number: switch (subcmd)  			{  				case "add":  					#region Add Ban  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid command. Format: {0}ban add <player> [time] [reason]"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Shank 10d Hacking and cheating"' Specifier);  							args.Player.SendErrorMessage("Example: {0}ban add Ash"' Specifier);  							args.Player.SendErrorMessage("Use the time 0 (zero) for a permanent ban.");  							return;  						}    						// Used only to notify if a ban was successful and who the ban was about  						bool success = false;  						string targetGeneralizedName = "";    						// Effective ban target assignment  						List<TSPlayer> players = TShock.Utils.FindPlayer(args.Parameters[1]);  						UserAccount offlineUserAccount = TShock.UserAccounts.GetUserAccountByName(args.Parameters[1]);    						// Storage variable to determine if the command executor is the server console  						// If it is' we assume they have full control and let them override permission checks  						bool callerIsServerConsole = false;  						  						if (args.Player is TSServerPlayer)  						{  							callerIsServerConsole = true;  						}    						// The ban reason the ban is going to have  						string banReason = "Unknown.";    						// The default ban length  						// 0 is permanent ban' otherwise temp ban  						int banLengthInSeconds = 0;    						// Figure out if param 2 is a time or 0 or garbage  						if (args.Parameters.Count >= 3)  						{  							bool parsedOkay = false;  							if (!(args.Parameters[2] == "0"))  							{  								parsedOkay = TShock.Utils.TryParseTime(args.Parameters[2]' out banLengthInSeconds);  							} else {  								parsedOkay = true;  							}    							if (!parsedOkay)  							{  								args.Player.SendErrorMessage("Invalid time format. Example: 10d+5h+3m-2s.");  								args.Player.SendErrorMessage("Use 0 (zero) for a permanent ban.");  								return;  							}  						}    						// If a reason exists' use the given reason.  						if (args.Parameters.Count > 3)  						{  							banReason = String.Join(" "' args.Parameters.Skip(3));  						}    						// Bad case: Players contains more than 1 person so we can't ban them  						if (players.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  							return;  						}    						// Good case: Online ban for matching character.  						if (players.Count == 1)  						{  							TSPlayer target = players[0];    							if (target.HasPermission(Permissions.immunetoban) && !callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' target.Name);  								return;  							}    							targetGeneralizedName = target.Name;  							success = TShock.Bans.AddBan2(target.IP' target.Name' target.UUID' target.Account.Name' banReason' false' args.Player.Account.Name'  								banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));    							// Since this is an online ban' we need to dc the player and tell them now.  							if (success)  							{  								if (banLengthInSeconds == 0)  								{  									target.Disconnect(String.Format("Permanently banned for {0}"' banReason));  								}  								else  								{  									target.Disconnect(String.Format("Banned for {0} seconds for {1}"' banLengthInSeconds' banReason));  								}  							}  						}    						// Case: Players & user are invalid' could be IP?  						// Note: Order matters. If this method is above the online player check'  						// This enables you to ban an IP even if the player exists in the database as a player.  						// You'll get two bans for the price of one' in theory' because both IP and user named IP will be banned.  						// ??? edge cases are weird' but this is going to happen  						// The only way around this is to either segregate off the IP code or do something else.  						if (players.Count == 0)  						{  							// If the target is a valid IP...  							string pattern = @"^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$";  							Regex r = new Regex(pattern' RegexOptions.IgnoreCase);  							if (r.IsMatch(args.Parameters[1])) {  								targetGeneralizedName = "IP: " + args.Parameters[1];  								success = TShock.Bans.AddBan2(args.Parameters[1]' ""' ""' ""' banReason'  									false' args.Player.Account.Name' banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  								if (success && offlineUserAccount != null)  								{  									args.Player.SendSuccessMessage("Target IP {0} was banned successfully."' targetGeneralizedName);  									args.Player.SendErrorMessage("Note: An account named with this IP address also exists.");  									args.Player.SendErrorMessage("Note: It will also be banned.");  								}  							} else {  								// Apparently there is no way to not IP ban someone  								// This means that where we would normally just ban a "character name" here  								// We can't because it requires some IP as a primary key.  								if (offlineUserAccount == null)  								{  									args.Player.SendErrorMessage("Unable to ban target {0}."' args.Parameters[1]);  									args.Player.SendErrorMessage("Target is not a valid IP address' a valid online player' or a known offline user.");  									return;  								}  							}    						}    						// Case: Offline ban  						if (players.Count == 0 && offlineUserAccount != null)  						{  							// Catch: we don't know an offline player's last login character name  							// This means that we're banning their *user name* on the assumption that  							// user name == character name  							// (which may not be true)  							// This needs to be fixed in a future implementation.  							targetGeneralizedName = offlineUserAccount.Name;    							if (TShock.Groups.GetGroupByName(offlineUserAccount.Group).HasPermission(Permissions.immunetoban) &&   								!callerIsServerConsole)  							{  								args.Player.SendErrorMessage("Permission denied. Target {0} is immune to ban."' targetGeneralizedName);  								return;  							}    							if (offlineUserAccount.KnownIps == null)  							{  								args.Player.SendErrorMessage("Unable to ban target {0} because they have no valid IP to ban."' targetGeneralizedName);  								return;  							}    							string lastIP = JsonConvert.DeserializeObject<List<string>>(offlineUserAccount.KnownIps).Last();    							success =   								TShock.Bans.AddBan2(lastIP'  									""' offlineUserAccount.UUID' offlineUserAccount.Name' banReason' false' args.Player.Account.Name'  									banLengthInSeconds == 0 ? "" : DateTime.UtcNow.AddSeconds(banLengthInSeconds).ToString("s"));  						}    						if (success)  						{  							args.Player.SendSuccessMessage("{0} was successfully banned."' targetGeneralizedName);  							args.Player.SendInfoMessage("Length: {0}"' banLengthInSeconds == 0 ? "Permanent." : banLengthInSeconds + " seconds.");  							args.Player.SendInfoMessage("Reason: {0}"' banReason);  							if (!args.Silent)  							{  								if (banLengthInSeconds == 0)  								{  									TSPlayer.All.SendErrorMessage("{0} was permanently banned by {1} for: {2}"'  										targetGeneralizedName' args.Player.Account.Name' banReason);  								}  								else  								{  									TSPlayer.All.SendErrorMessage("{0} was temp banned for {1} seconds by {2} for: {3}"'  										targetGeneralizedName' banLengthInSeconds' args.Player.Account.Name' banReason);  								}  							}  						}  						else  						{  							args.Player.SendErrorMessage("{0} was NOT banned due to a database error or other system problem."' targetGeneralizedName);  							args.Player.SendErrorMessage("If this player is online' they have NOT been kicked.");  							args.Player.SendErrorMessage("Check the system logs for details.");  						}    						return;  					}  					#endregion  				case "del":  					#region Delete ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban del <player>"' Specifier);  							return;  						}    						string plStr = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByName(plStr' false);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.Name' true))  								args.Player.SendSuccessMessage("Unbanned {0} ({1})."' ban.Name' ban.IP);  							else  								args.Player.SendErrorMessage("Failed to unban {0} ({1})' check logs."' ban.Name' ban.IP);  						}  						else  							args.Player.SendErrorMessage("No bans for {0} exist."' plStr);  					}  					#endregion  					return;  				case "delip":  					#region Delete IP ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}ban delip <ip>"' Specifier);  							return;  						}    						string ip = args.Parameters[1];  						Ban ban = TShock.Bans.GetBanByIp(ip);  						if (ban != null)  						{  							if (TShock.Bans.RemoveBan(ban.IP' false))  								args.Player.SendSuccessMessage("Unbanned IP {0} ({1})."' ban.IP' ban.Name);  							else  								args.Player.SendErrorMessage("Failed to unban IP {0} ({1})' check logs."' ban.IP' ban.Name);  						}  						else  							args.Player.SendErrorMessage("IP {0} is not banned."' ip);  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <target> <time> [reason] - Bans a player or user account if the player is not online."'  							"del <player> - Unbans a player."'  							"delip <ip> - Unbans an IP."'  							"list [page] - Lists all player bans."'  							"listip [page] - Lists all IP bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}ban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var nameBans = from ban in bans  									   where !String.IsNullOrEmpty(ban.Name)  									   select ban.Name;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(nameBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no bans."  							});  					}  					#endregion  					return;  				case "listip":  					#region List IP bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  						{  							return;  						}    						List<Ban> bans = TShock.Bans.GetBans();    						var ipBans = from ban in bans  									 where String.IsNullOrEmpty(ban.Name)  									 select ban.IP;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(ipBans)'  							new PaginationTools.Settings  							{  								HeaderFormat = "IP Bans ({0}/{1}):"'  								FooterFormat = "Type {0}ban listip {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no IP bans."  							});  					}  					#endregion  					return;  				default:  					args.Player.SendErrorMessage("Invalid subcommand! Type {0}ban help for more information."' Specifier);  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count < 2)  			{  				args.Player.SendInfoMessage("Invalid usage");  				args.Player.SendInfoMessage("Usage: {0}tempgroup <username> <new group> [time]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count > 2)  			{  				int time;  				if (!TShock.Utils.TryParseTime(args.Parameters[2]' out time))  				{  					args.Player.SendErrorMessage("Invalid time string! Proper format: _d_h_m_s' with at least one time specifier.");  					args.Player.SendErrorMessage("For example' 1d and 10h-30m+2m are both valid time strings' but 2 is not.");  					return;  				}    				ply[0].tempGroupTimer = new System.Timers.Timer(time * 1000);  				ply[0].tempGroupTimer.Elapsed += ply[0].TempGroupTimerElapsed;  				ply[0].tempGroupTimer.Start();  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count > 2)  			{  				int time;  				if (!TShock.Utils.TryParseTime(args.Parameters[2]' out time))  				{  					args.Player.SendErrorMessage("Invalid time string! Proper format: _d_h_m_s' with at least one time specifier.");  					args.Player.SendErrorMessage("For example' 1d and 10h-30m+2m are both valid time strings' but 2 is not.");  					return;  				}    				ply[0].tempGroupTimer = new System.Timers.Timer(time * 1000);  				ply[0].tempGroupTimer.Elapsed += ply[0].TempGroupTimerElapsed;  				ply[0].tempGroupTimer.Start();  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count > 2)  			{  				int time;  				if (!TShock.Utils.TryParseTime(args.Parameters[2]' out time))  				{  					args.Player.SendErrorMessage("Invalid time string! Proper format: _d_h_m_s' with at least one time specifier.");  					args.Player.SendErrorMessage("For example' 1d and 10h-30m+2m are both valid time strings' but 2 is not.");  					return;  				}    				ply[0].tempGroupTimer = new System.Timers.Timer(time * 1000);  				ply[0].tempGroupTimer.Elapsed += ply[0].TempGroupTimerElapsed;  				ply[0].tempGroupTimer.Start();  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count < 3)  			{  				args.Player.SendSuccessMessage(String.Format("You have changed {0}'s group to {1}"' ply[0].Name' g.Name));  				ply[0].SendSuccessMessage(String.Format("Your group has temporarily been changed to {0}"' g.Name));  			}  			else  			{  				args.Player.SendSuccessMessage(String.Format("You have changed {0}'s group to {1} for {2}"'  					ply[0].Name' g.Name' args.Parameters[2]));  				ply[0].SendSuccessMessage(String.Format("Your group has been changed to {0} for {1}"'  					g.Name' args.Parameters[2]));  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count < 3)  			{  				args.Player.SendSuccessMessage(String.Format("You have changed {0}'s group to {1}"' ply[0].Name' g.Name));  				ply[0].SendSuccessMessage(String.Format("Your group has temporarily been changed to {0}"' g.Name));  			}  			else  			{  				args.Player.SendSuccessMessage(String.Format("You have changed {0}'s group to {1} for {2}"'  					ply[0].Name' g.Name' args.Parameters[2]));  				ply[0].SendSuccessMessage(String.Format("Your group has been changed to {0} for {1}"'  					g.Name' args.Parameters[2]));  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TempGroup,The following statement contains a magic number: if (args.Parameters.Count < 3)  			{  				args.Player.SendSuccessMessage(String.Format("You have changed {0}'s group to {1}"' ply[0].Name' g.Name));  				ply[0].SendSuccessMessage(String.Format("Your group has temporarily been changed to {0}"' g.Name));  			}  			else  			{  				args.Player.SendSuccessMessage(String.Format("You have changed {0}'s group to {1} for {2}"'  					ply[0].Name' g.Name' args.Parameters[2]));  				ply[0].SendSuccessMessage(String.Format("Your group has been changed to {0} for {1}"'  					g.Name' args.Parameters[2]));  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SubstituteUser,The following statement contains a magic number: if (args.Player.tempGroup != null)  			{  				args.Player.tempGroup = null;  				args.Player.tempGroupTimer.Stop();  				args.Player.SendSuccessMessage("Your previous permission set has been restored.");  				return;  			}  			else  			{  				args.Player.tempGroup = new SuperAdminGroup();  				args.Player.tempGroupTimer = new System.Timers.Timer(600 * 1000);  				args.Player.tempGroupTimer.Elapsed += args.Player.TempGroupTimerElapsed;  				args.Player.tempGroupTimer.Start();  				args.Player.SendSuccessMessage("Your account has been elevated to Super Admin for 10 minutes.");  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SubstituteUser,The following statement contains a magic number: if (args.Player.tempGroup != null)  			{  				args.Player.tempGroup = null;  				args.Player.tempGroupTimer.Stop();  				args.Player.SendSuccessMessage("Your previous permission set has been restored.");  				return;  			}  			else  			{  				args.Player.tempGroup = new SuperAdminGroup();  				args.Player.tempGroupTimer = new System.Timers.Timer(600 * 1000);  				args.Player.tempGroupTimer.Elapsed += args.Player.TempGroupTimerElapsed;  				args.Player.tempGroupTimer.Start();  				args.Player.SendSuccessMessage("Your account has been elevated to Super Admin for 10 minutes.");  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Broadcast,The following statement contains a magic number: TShock.Utils.Broadcast(  				"(Server Broadcast) " + message'  				Convert.ToByte(TShock.Config.BroadcastRGB[0])' Convert.ToByte(TShock.Config.BroadcastRGB[1])'  				Convert.ToByte(TShock.Config.BroadcastRGB[2]));
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following statement contains a magic number: if (Main.invasionSize <= 0)  			{  				if (args.Parameters.Count < 1)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}invade <invasion type> [wave]"' Specifier);  					return;  				}    				int wave = 1;  				switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.StartInvasion(4);  						break;  				}  			}  			else if (DD2Event.Ongoing)  			{  				DD2Event.StopInvasion();  				TSPlayer.All.SendInfoMessage("{0} has ended the Old One's Army event."' args.Player.Name);  			}  			else  			{  				TSPlayer.All.SendInfoMessage("{0} has ended the invasion."' args.Player.Name);  				Main.invasionSize = 0;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following statement contains a magic number: if (Main.invasionSize <= 0)  			{  				if (args.Parameters.Count < 1)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}invade <invasion type> [wave]"' Specifier);  					return;  				}    				int wave = 1;  				switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.StartInvasion(4);  						break;  				}  			}  			else if (DD2Event.Ongoing)  			{  				DD2Event.StopInvasion();  				TSPlayer.All.SendInfoMessage("{0} has ended the Old One's Army event."' args.Player.Name);  			}  			else  			{  				TSPlayer.All.SendInfoMessage("{0} has ended the invasion."' args.Player.Name);  				Main.invasionSize = 0;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following statement contains a magic number: if (Main.invasionSize <= 0)  			{  				if (args.Parameters.Count < 1)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}invade <invasion type> [wave]"' Specifier);  					return;  				}    				int wave = 1;  				switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.StartInvasion(4);  						break;  				}  			}  			else if (DD2Event.Ongoing)  			{  				DD2Event.StopInvasion();  				TSPlayer.All.SendInfoMessage("{0} has ended the Old One's Army event."' args.Player.Name);  			}  			else  			{  				TSPlayer.All.SendInfoMessage("{0} has ended the invasion."' args.Player.Name);  				Main.invasionSize = 0;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ClearAnglerQuests,The following statement contains a magic number: if (args.Parameters.Count > 0)  			{  				var result = Main.anglerWhoFinishedToday.RemoveAll(s => s.ToLower().Equals(args.Parameters[0].ToLower()));  				if (result > 0)  				{  					args.Player.SendSuccessMessage("Removed {0} players from the angler quest completion list for today."' result);  					foreach (TSPlayer ply in TShock.Players.Where(p => p != null && p.Active && p.TPlayer.name.ToLower().Equals(args.Parameters[0].ToLower())))  					{  						//this will always tell the client that they have not done the quest today.  						ply.SendData((PacketTypes)74' "");  					}  				}  				else  					args.Player.SendErrorMessage("Failed to find any users by that name on the list.");    			}  			else  			{  				Main.anglerWhoFinishedToday.Clear();  				NetMessage.SendAnglerQuest(-1);  				args.Player.SendSuccessMessage("Cleared all users from the angler quest completion list for today.");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: if (args.Parameters.Count < 1 || args.Parameters.Count > 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}spawnboss <boss type> [amount]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: if (args.Parameters.Count == 2 && (!int.TryParse(args.Parameters[1]' out amount) || amount <= 0))  			{  				args.Player.SendErrorMessage("Invalid boss amount!");  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnBoss,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "*":  				case "all":  					int[] npcIds = { 4' 13' 35' 50' 125' 126' 127' 134' 222' 245' 262' 266' 370' 398 };  					TSPlayer.Server.SetTime(false' 0.0);  					foreach (int i in npcIds)  					{  						npc.SetDefaults(i);  						TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					}  					TSPlayer.All.SendSuccessMessage("{0} has spawned all bosses {1} time(s)."' args.Player.Name' amount);  					return;  				case "brain":  				case "brain of cthulhu":  					npc.SetDefaults(266);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Brain of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "destroyer":  					npc.SetDefaults(134);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Destroyer {1} time(s)."' args.Player.Name' amount);  					return;  				case "duke":  				case "duke fishron":  				case "fishron":  					npc.SetDefaults(370);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Duke Fishron {1} time(s)."' args.Player.Name' amount);  					return;  				case "eater":  				case "eater of worlds":  					npc.SetDefaults(13);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eater of Worlds {1} time(s)."' args.Player.Name' amount);  					return;  				case "eye":  				case "eye of cthulhu":  					npc.SetDefaults(4);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Eye of Cthulhu {1} time(s)."' args.Player.Name' amount);  					return;  				case "golem":  					npc.SetDefaults(245);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Golem {1} time(s)."' args.Player.Name' amount);  					return;  				case "king":  				case "king slime":  					npc.SetDefaults(50);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned King Slime {1} time(s)."' args.Player.Name' amount);  					return;  				case "plantera":  					npc.SetDefaults(262);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Plantera {1} time(s)."' args.Player.Name' amount);  					return;  				case "prime":  				case "skeletron prime":  					npc.SetDefaults(127);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron Prime {1} time(s)."' args.Player.Name' amount);  					return;  				case "queen":  				case "queen bee":  					npc.SetDefaults(222);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Queen Bee {1} time(s)."' args.Player.Name' amount);  					return;  				case "skeletron":  					npc.SetDefaults(35);  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned Skeletron {1} time(s)."' args.Player.Name' amount);  					return;  				case "twins":  					TSPlayer.Server.SetTime(false' 0.0);  					npc.SetDefaults(125);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					npc.SetDefaults(126);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Twins {1} time(s)."' args.Player.Name' amount);  					return;  				case "wof":  				case "wall of flesh":  					if (Main.wof >= 0)  					{  						args.Player.SendErrorMessage("There is already a Wall of Flesh!");  						return;  					}  					if (args.Player.Y / 16f < Main.maxTilesY - 205)  					{  						args.Player.SendErrorMessage("You must spawn the Wall of Flesh in hell!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Wall of Flesh."' args.Player.Name);  					return;  				case "moon":  				case "moon lord":  					npc.SetDefaults(398);  					TSPlayer.Server.SpawnNPC(npc.type' npc.FullName' amount' args.Player.TileX' args.Player.TileY);  					TSPlayer.All.SendSuccessMessage("{0} has spawned the Moon Lord {1} time(s)."' args.Player.Name' amount);  					return;  				default:  					args.Player.SendErrorMessage("Invalid boss type!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (args.Parameters.Count < 1 || args.Parameters.Count > 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}spawnmob <mob type> [amount]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (args.Parameters.Count == 2 && !int.TryParse(args.Parameters[1]' out amount))  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}spawnmob <mob type> [amount]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (npcs.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid mob type!");  			}  			else if (npcs.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  			}  			else  			{  				var npc = npcs[0];  				if (npc.type >= 1 && npc.type < Main.maxNPCTypes && npc.type != 113)  				{  					TSPlayer.Server.SpawnNPC(npc.netID' npc.FullName' amount' args.Player.TileX' args.Player.TileY' 50' 20);  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned {0} {1} time(s)."' npc.FullName' amount);  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned {1} {2} time(s)."' args.Player.Name' npc.FullName' amount);  					}  				}  				else if (npc.type == 113)  				{  					if (Main.wof >= 0 || (args.Player.Y / 16f < (Main.maxTilesY - 205)))  					{  						args.Player.SendErrorMessage("Can't spawn Wall of Flesh!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned Wall of Flesh!");  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned a Wall of Flesh!"' args.Player.Name);  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid mob type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (npcs.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid mob type!");  			}  			else if (npcs.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  			}  			else  			{  				var npc = npcs[0];  				if (npc.type >= 1 && npc.type < Main.maxNPCTypes && npc.type != 113)  				{  					TSPlayer.Server.SpawnNPC(npc.netID' npc.FullName' amount' args.Player.TileX' args.Player.TileY' 50' 20);  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned {0} {1} time(s)."' npc.FullName' amount);  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned {1} {2} time(s)."' args.Player.Name' npc.FullName' amount);  					}  				}  				else if (npc.type == 113)  				{  					if (Main.wof >= 0 || (args.Player.Y / 16f < (Main.maxTilesY - 205)))  					{  						args.Player.SendErrorMessage("Can't spawn Wall of Flesh!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned Wall of Flesh!");  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned a Wall of Flesh!"' args.Player.Name);  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid mob type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (npcs.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid mob type!");  			}  			else if (npcs.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  			}  			else  			{  				var npc = npcs[0];  				if (npc.type >= 1 && npc.type < Main.maxNPCTypes && npc.type != 113)  				{  					TSPlayer.Server.SpawnNPC(npc.netID' npc.FullName' amount' args.Player.TileX' args.Player.TileY' 50' 20);  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned {0} {1} time(s)."' npc.FullName' amount);  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned {1} {2} time(s)."' args.Player.Name' npc.FullName' amount);  					}  				}  				else if (npc.type == 113)  				{  					if (Main.wof >= 0 || (args.Player.Y / 16f < (Main.maxTilesY - 205)))  					{  						args.Player.SendErrorMessage("Can't spawn Wall of Flesh!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned Wall of Flesh!");  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned a Wall of Flesh!"' args.Player.Name);  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid mob type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (npcs.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid mob type!");  			}  			else if (npcs.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  			}  			else  			{  				var npc = npcs[0];  				if (npc.type >= 1 && npc.type < Main.maxNPCTypes && npc.type != 113)  				{  					TSPlayer.Server.SpawnNPC(npc.netID' npc.FullName' amount' args.Player.TileX' args.Player.TileY' 50' 20);  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned {0} {1} time(s)."' npc.FullName' amount);  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned {1} {2} time(s)."' args.Player.Name' npc.FullName' amount);  					}  				}  				else if (npc.type == 113)  				{  					if (Main.wof >= 0 || (args.Player.Y / 16f < (Main.maxTilesY - 205)))  					{  						args.Player.SendErrorMessage("Can't spawn Wall of Flesh!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned Wall of Flesh!");  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned a Wall of Flesh!"' args.Player.Name);  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid mob type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnMob,The following statement contains a magic number: if (npcs.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid mob type!");  			}  			else if (npcs.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  			}  			else  			{  				var npc = npcs[0];  				if (npc.type >= 1 && npc.type < Main.maxNPCTypes && npc.type != 113)  				{  					TSPlayer.Server.SpawnNPC(npc.netID' npc.FullName' amount' args.Player.TileX' args.Player.TileY' 50' 20);  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned {0} {1} time(s)."' npc.FullName' amount);  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned {1} {2} time(s)."' args.Player.Name' npc.FullName' amount);  					}  				}  				else if (npc.type == 113)  				{  					if (Main.wof >= 0 || (args.Player.Y / 16f < (Main.maxTilesY - 205)))  					{  						args.Player.SendErrorMessage("Can't spawn Wall of Flesh!");  						return;  					}  					NPC.SpawnWOF(new Vector2(args.Player.X' args.Player.Y));  					if (args.Silent)  					{  						args.Player.SendSuccessMessage("Spawned Wall of Flesh!");  					}  					else  					{  						TSPlayer.All.SendSuccessMessage("{0} has spawned a Wall of Flesh!"' args.Player.Name);  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid mob type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Spawn,The following statement contains a magic number: if (args.Player.Teleport(Main.spawnTileX * 16' (Main.spawnTileY * 16) - 48))  				args.Player.SendSuccessMessage("Teleported to the map's spawnpoint.");
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Spawn,The following statement contains a magic number: if (args.Player.Teleport(Main.spawnTileX * 16' (Main.spawnTileY * 16) - 48))  				args.Player.SendSuccessMessage("Teleported to the map's spawnpoint.");
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Spawn,The following statement contains a magic number: if (args.Player.Teleport(Main.spawnTileX * 16' (Main.spawnTileY * 16) - 48))  				args.Player.SendSuccessMessage("Teleported to the map's spawnpoint.");
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TP,The following statement contains a magic number: if (args.Parameters.Count != 1 && args.Parameters.Count != 2)  			{  				if (args.Player.HasPermission(Permissions.tpothers))  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tp <player> [player 2]"' Specifier);  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tp <player>"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPPos,The following statement contains a magic number: if (args.Parameters.Count != 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tppos <tile x> <tile y>"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPPos,The following statement contains a magic number: args.Player.Teleport(16 * x' 16 * y);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TPPos,The following statement contains a magic number: args.Player.Teleport(16 * x' 16 * y);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Warp,The following statement contains a magic number: if (args.Parameters[0].Equals("list"))  			{  				#region List warps  				int pageNumber;  				if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  					return;  				IEnumerable<string> warpNames = from warp in TShock.Warps.Warps  												where !warp.IsPrivate  												select warp.Name;  				PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(warpNames)'  					new PaginationTools.Settings  					{  						HeaderFormat = "Warps ({0}/{1}):"'  						FooterFormat = "Type {0}warp list {{0}} for more.".SFormat(Specifier)'  						NothingToDisplayString = "There are currently no warps defined."  					});  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "add" && hasManageWarpPermission)  			{  				#region Add warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (warpName == "list" || warpName == "hide" || warpName == "del" || warpName == "add")  					{  						args.Player.SendErrorMessage("Name reserved' use a different name.");  					}  					else if (TShock.Warps.Add(args.Player.TileX' args.Player.TileY' warpName))  					{  						args.Player.SendSuccessMessage("Warp added: " + warpName);  					}  					else  					{  						args.Player.SendErrorMessage("Warp " + warpName + " already exists.");  					}  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp add [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "del" && hasManageWarpPermission)  			{  				#region Del warp  				if (args.Parameters.Count == 2)  				{  					string warpName = args.Parameters[1];  					if (TShock.Warps.Remove(warpName))  					{  						args.Player.SendSuccessMessage("Warp deleted: " + warpName);  					}  					else  						args.Player.SendErrorMessage("Could not find the specified warp.");  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp del [name]"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "hide" && hasManageWarpPermission)  			{  				#region Hide warp  				if (args.Parameters.Count == 3)  				{  					string warpName = args.Parameters[1];  					bool state = false;  					if (Boolean.TryParse(args.Parameters[2]' out state))  					{  						if (TShock.Warps.Hide(args.Parameters[1]' state))  						{  							if (state)  								args.Player.SendSuccessMessage("Warp " + warpName + " is now private.");  							else  								args.Player.SendSuccessMessage("Warp " + warpName + " is now public.");  						}  						else  							args.Player.SendErrorMessage("Could not find specified warp.");  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				}  				else  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp hide [name] <true/false>"' Specifier);  				#endregion  			}  			else if (args.Parameters[0].ToLower() == "send" && args.Player.HasPermission(Permissions.tpothers))  			{  				#region Warp send  				if (args.Parameters.Count < 3)  				{  					args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}warp send [player] [warpname]"' Specifier);  					return;  				}    				var foundplr = TShock.Utils.FindPlayer(args.Parameters[1]);  				if (foundplr.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid player!");  					return;  				}  				else if (foundplr.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  					return;  				}    				string warpName = args.Parameters[2];  				var warp = TShock.Warps.Find(warpName);  				var plr = foundplr[0];  				if (warp.Position != Point.Zero)  				{  					if (plr.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  					{  						plr.SendSuccessMessage(String.Format("{0} warped you to {1}."' args.Player.Name' warpName));  						args.Player.SendSuccessMessage(String.Format("You warped {0} to {1}."' plr.Name' warpName));  					}  				}  				else  				{  					args.Player.SendErrorMessage("Specified warp not found.");  				}  				#endregion  			}  			else  			{  				string warpName = String.Join(" "' args.Parameters);  				var warp = TShock.Warps.Find(warpName);  				if (warp != null)  				{  					if (args.Player.Teleport(warp.Position.X * 16' warp.Position.Y * 16))  						args.Player.SendSuccessMessage("Warped to " + warpName + ".");  				}  				else  				{  					args.Player.SendErrorMessage("The specified warp was not found.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following statement contains a magic number: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetSpawn,The following statement contains a magic number: Main.spawnTileY = args.Player.TileY + 3;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SetDungeon,The following statement contains a magic number: Main.dungeonY = args.Player.TileY + 3;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,MaxSpawns,The following statement contains a magic number: if (String.Equals(args.Parameters[0]' "default"' StringComparison.CurrentCultureIgnoreCase))  			{  				TShock.Config.DefaultMaximumSpawns = NPC.defaultMaxSpawns = 5;  				if (args.Silent)  				{  					args.Player.SendInfoMessage("Changed the maximum spawns to 5.");  				}  				else  				{  					TSPlayer.All.SendInfoMessage("{0} changed the maximum spawns to 5."' args.Player.Name);  				}  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,SpawnRate,The following statement contains a magic number: if (String.Equals(args.Parameters[0]' "default"' StringComparison.CurrentCultureIgnoreCase))  			{  				TShock.Config.DefaultSpawnRate = NPC.defaultSpawnRate = 600;  				if (args.Silent)  				{  					args.Player.SendInfoMessage("Changed the spawn rate to 600.");  				}  				else  				{  					TSPlayer.All.SendInfoMessage("{0} changed the spawn rate to 600."' args.Player.Name);  				}  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: if (args.Parameters.Count == 0)  			{  				double time = Main.time / 3600.0;  				time += 4.5;  				if (!Main.dayTime)  					time += 15.0;  				time = time % 24.0;  				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0));  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: if (args.Parameters.Count == 0)  			{  				double time = Main.time / 3600.0;  				time += 4.5;  				if (!Main.dayTime)  					time += 15.0;  				time = time % 24.0;  				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0));  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: if (args.Parameters.Count == 0)  			{  				double time = Main.time / 3600.0;  				time += 4.5;  				if (!Main.dayTime)  					time += 15.0;  				time = time % 24.0;  				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0));  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: if (args.Parameters.Count == 0)  			{  				double time = Main.time / 3600.0;  				time += 4.5;  				if (!Main.dayTime)  					time += 15.0;  				time = time % 24.0;  				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0));  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: if (args.Parameters.Count == 0)  			{  				double time = Main.time / 3600.0;  				time += 4.5;  				if (!Main.dayTime)  					time += 15.0;  				time = time % 24.0;  				args.Player.SendInfoMessage("The current time is {0}:{1:D2}."' (int)Math.Floor(time)' (int)Math.Floor((time % 1.0) * 60.0));  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Time,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "day":  					TSPlayer.Server.SetTime(true' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 4:30."' args.Player.Name);  					break;  				case "night":  					TSPlayer.Server.SetTime(false' 0.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 19:30."' args.Player.Name);  					break;  				case "noon":  					TSPlayer.Server.SetTime(true' 27000.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 12:00."' args.Player.Name);  					break;  				case "midnight":  					TSPlayer.Server.SetTime(false' 16200.0);  					TSPlayer.All.SendInfoMessage("{0} set the time to 0:00."' args.Player.Name);  					break;  				default:  					string[] array = args.Parameters[0].Split(':');  					if (array.Length != 2)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					int hours;  					int minutes;  					if (!int.TryParse(array[0]' out hours) || hours < 0 || hours > 23  						|| !int.TryParse(array[1]' out minutes) || minutes < 0 || minutes > 59)  					{  						args.Player.SendErrorMessage("Invalid time string! Proper format: hh:mm' in 24-hour time.");  						return;  					}    					decimal time = hours + (minutes / 60.0m);  					time -= 4.50m;  					if (time < 0.00m)  						time += 24.00m;    					if (time >= 15.00m)  					{  						TSPlayer.Server.SetTime(false' (double)((time - 15.00m) * 3600.0m));  					}  					else  					{  						TSPlayer.Server.SetTime(true' (double)(time * 3600.0m));  					}  					TSPlayer.All.SendInfoMessage("{0} set the time to {1}:{2:D2}."' args.Player.Name' hours' minutes);  					break;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Rain,The following statement contains a magic number: if (args.Parameters.Count < 1 || args.Parameters.Count > 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}rain [slime] <stop/start>"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Rain,The following statement contains a magic number: if (args.Parameters.Count == 2 && args.Parameters[0].ToLowerInvariant() == "slime")  			{  				switchIndex = 1;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Slap,The following statement contains a magic number: if (args.Parameters.Count < 1 || args.Parameters.Count > 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}slap <player> [damage]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Slap,The following statement contains a magic number: if (players.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  			}  			else if (players.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			}  			else  			{  				var plr = players[0];  				int damage = 5;  				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[1]' out damage);  				}  				if (!args.Player.HasPermission(Permissions.kill))  				{  					damage = TShock.Utils.Clamp(damage' 15' 0);  				}  				plr.DamagePlayer(damage);  				TSPlayer.All.SendInfoMessage("{0} slapped {1} for {2} damage."' args.Player.Name' plr.Name' damage);  				TShock.Log.Info("{0} slapped {1} for {2} damage."' args.Player.Name' plr.Name' damage);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Slap,The following statement contains a magic number: if (players.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  			}  			else if (players.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			}  			else  			{  				var plr = players[0];  				int damage = 5;  				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[1]' out damage);  				}  				if (!args.Player.HasPermission(Permissions.kill))  				{  					damage = TShock.Utils.Clamp(damage' 15' 0);  				}  				plr.DamagePlayer(damage);  				TSPlayer.All.SendInfoMessage("{0} slapped {1} for {2} damage."' args.Player.Name' plr.Name' damage);  				TShock.Log.Info("{0} slapped {1} for {2} damage."' args.Player.Name' plr.Name' damage);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Slap,The following statement contains a magic number: if (players.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  			}  			else if (players.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			}  			else  			{  				var plr = players[0];  				int damage = 5;  				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[1]' out damage);  				}  				if (!args.Player.HasPermission(Permissions.kill))  				{  					damage = TShock.Utils.Clamp(damage' 15' 0);  				}  				plr.DamagePlayer(damage);  				TSPlayer.All.SendInfoMessage("{0} slapped {1} for {2} damage."' args.Player.Name' plr.Name' damage);  				TShock.Log.Info("{0} slapped {1} for {2} damage."' args.Player.Name' plr.Name' damage);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Wind,The following statement contains a magic number: if (!int.TryParse(args.Parameters[0]' out speed) || speed * 100 < 0)  			{  				args.Player.SendErrorMessage("Invalid wind speed!");  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Region,The following statement contains a magic number: switch (cmd)  			{  				case "name":  					{  						{  							args.Player.SendInfoMessage("Hit a block to get the name of the region");  							args.Player.AwaitingName = true;  							args.Player.AwaitingNameParameters = args.Parameters.Skip(1).ToArray();  						}  						break;  					}  				case "set":  					{  						int choice = 0;  						if (args.Parameters.Count == 2 &&  							int.TryParse(args.Parameters[1]' out choice) &&  							choice >= 1 && choice <= 2)  						{  							args.Player.SendInfoMessage("Hit a block to Set Point " + choice);  							args.Player.AwaitingTempPoint = choice;  						}  						else  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region set <1/2>");  						}  						break;  					}  				case "define":  					{  						if (args.Parameters.Count > 1)  						{  							if (!args.Player.TempPoints.Any(p => p == Point.Zero))  							{  								string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  								var x = Math.Min(args.Player.TempPoints[0].X' args.Player.TempPoints[1].X);  								var y = Math.Min(args.Player.TempPoints[0].Y' args.Player.TempPoints[1].Y);  								var width = Math.Abs(args.Player.TempPoints[0].X - args.Player.TempPoints[1].X);  								var height = Math.Abs(args.Player.TempPoints[0].Y - args.Player.TempPoints[1].Y);    								if (TShock.Regions.AddRegion(x' y' width' height' regionName' args.Player.Account.Name'  															 Main.worldID.ToString()))  								{  									args.Player.TempPoints[0] = Point.Zero;  									args.Player.TempPoints[1] = Point.Zero;  									args.Player.SendInfoMessage("Set region " + regionName);  								}  								else  								{  									args.Player.SendErrorMessage("Region " + regionName + " already exists");  								}  							}  							else  							{  								args.Player.SendErrorMessage("Points not set up yet");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region define <name>"' Specifier);  						break;  					}  				case "protect":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							if (args.Parameters[2].ToLower() == "true")  							{  								if (TShock.Regions.SetRegionState(regionName' true))  									args.Player.SendInfoMessage("Protected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else if (args.Parameters[2].ToLower() == "false")  							{  								if (TShock.Regions.SetRegionState(regionName' false))  									args.Player.SendInfoMessage("Unprotected region " + regionName);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region protect <name> <true/false>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: /region protect <name> <true/false>"' Specifier);  						break;  					}  				case "delete":  					{  						if (args.Parameters.Count > 1)  						{  							string regionName = String.Join(" "' args.Parameters.GetRange(1' args.Parameters.Count - 1));  							if (TShock.Regions.DeleteRegion(regionName))  							{  								args.Player.SendInfoMessage("Deleted region \"{0}\"."' regionName);  							}  							else  								args.Player.SendErrorMessage("Could not find the specified region!");  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region delete <name>"' Specifier);  						break;  					}  				case "clear":  					{  						args.Player.TempPoints[0] = Point.Zero;  						args.Player.TempPoints[1] = Point.Zero;  						args.Player.SendInfoMessage("Cleared temporary points.");  						args.Player.AwaitingTempPoint = 0;  						break;  					}  				case "allow":  					{  						if (args.Parameters.Count > 2)  						{  							string playerName = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  							{  								if (TShock.Regions.AddNewUser(regionName' playerName))  								{  									args.Player.SendInfoMessage("Added user " + playerName + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Player " + playerName + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allow <name> <region>"' Specifier);  						break;  					}  				case "remove":  					if (args.Parameters.Count > 2)  					{  						string playerName = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.UserAccounts.GetUserAccountByName(playerName) != null)  						{  							if (TShock.Regions.RemoveUser(regionName' playerName))  							{  								args.Player.SendInfoMessage("Removed user " + playerName + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Player " + playerName + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region remove <name> <region>"' Specifier);  					break;  				case "allowg":  					{  						if (args.Parameters.Count > 2)  						{  							string group = args.Parameters[1];  							string regionName = "";    							for (int i = 2; i < args.Parameters.Count; i++)  							{  								if (regionName == "")  								{  									regionName = args.Parameters[2];  								}  								else  								{  									regionName = regionName + " " + args.Parameters[i];  								}  							}  							if (TShock.Groups.GroupExists(group))  							{  								if (TShock.Regions.AllowGroup(regionName' group))  								{  									args.Player.SendInfoMessage("Added group " + group + " to " + regionName);  								}  								else  									args.Player.SendErrorMessage("Region " + regionName + " not found");  							}  							else  							{  								args.Player.SendErrorMessage("Group " + group + " not found");  							}  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region allowg <group> <region>"' Specifier);  						break;  					}  				case "removeg":  					if (args.Parameters.Count > 2)  					{  						string group = args.Parameters[1];  						string regionName = "";    						for (int i = 2; i < args.Parameters.Count; i++)  						{  							if (regionName == "")  							{  								regionName = args.Parameters[2];  							}  							else  							{  								regionName = regionName + " " + args.Parameters[i];  							}  						}  						if (TShock.Groups.GroupExists(group))  						{  							if (TShock.Regions.RemoveGroup(regionName' group))  							{  								args.Player.SendInfoMessage("Removed group " + group + " from " + regionName);  							}  							else  								args.Player.SendErrorMessage("Region " + regionName + " not found");  						}  						else  						{  							args.Player.SendErrorMessage("Group " + group + " not found");  						}  					}  					else  						args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region removeg <group> <region>"' Specifier);  					break;  				case "list":  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						IEnumerable<string> regionNames = from region in TShock.Regions.Regions  														  where region.WorldID == Main.worldID.ToString()  														  select region.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(regionNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Regions ({0}/{1}):"'  								FooterFormat = "Type {0}region list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no regions defined."  							});  						break;  					}  				case "info":  					{  						if (args.Parameters.Count == 1 || args.Parameters.Count > 4)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region info <region> [-d] [page]"' Specifier);  							break;  						}    						string regionName = args.Parameters[1];  						bool displayBoundaries = args.Parameters.Skip(2).Any(  							p => p.Equals("-d"' StringComparison.InvariantCultureIgnoreCase)  						);    						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						int pageNumberIndex = displayBoundaries ? 3 : 2;  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageNumberIndex' args.Player' out pageNumber))  							break;    						List<string> lines = new List<string>  						{  							string.Format("X: {0}; Y: {1}; W: {2}; H: {3}' Z: {4}"' region.Area.X' region.Area.Y' region.Area.Width' region.Area.Height' region.Z)'  							string.Concat("Owner: "' region.Owner)'  							string.Concat("Protected: "' region.DisableBuild.ToString())'  						};    						if (region.AllowedIDs.Count > 0)  						{  							IEnumerable<string> sharedUsersSelector = region.AllowedIDs.Select(userId =>  							{  								UserAccount account = TShock.UserAccounts.GetUserAccountByID(userId);  								if (account != null)  									return account.Name;    								return string.Concat("{ID: "' userId' "}");  							});  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(sharedUsersSelector.Distinct());  							extraLines[0] = "Shared with: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any users.");  						}    						if (region.AllowedGroups.Count > 0)  						{  							List<string> extraLines = PaginationTools.BuildLinesFromTerms(region.AllowedGroups.Distinct());  							extraLines[0] = "Shared with groups: " + extraLines[0];  							lines.AddRange(extraLines);  						}  						else  						{  							lines.Add("Region is not shared with any groups.");  						}    						PaginationTools.SendPage(  							args.Player' pageNumber' lines' new PaginationTools.Settings  							{  								HeaderFormat = string.Format("Information About Region \"{0}\" ({{0}}/{{1}}):"' region.Name)'  								FooterFormat = string.Format("Type {0}region info {1} {{0}} for more information."' Specifier' regionName)  							}  						);    						if (displayBoundaries)  						{  							Rectangle regionArea = region.Area;  							foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  							{  								// Preferring dotted lines as those should easily be distinguishable from actual wires.  								if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  								{  									// Could be improved by sending raw tile data to the client instead but not really  									// worth the effort as chances are very low that overwriting the wire for a few  									// nanoseconds will cause much trouble.  									ITile tile = Main.tile[boundaryPoint.X' boundaryPoint.Y];  									bool oldWireState = tile.wire();  									tile.wire(true);    									try  									{  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);  									}  									finally  									{  										tile.wire(oldWireState);  									}  								}  							}    							Timer boundaryHideTimer = null;  							boundaryHideTimer = new Timer((state) =>  							{  								foreach (Point boundaryPoint in Utils.Instance.EnumerateRegionBoundaries(regionArea))  									if ((boundaryPoint.X + boundaryPoint.Y & 1) == 0)  										args.Player.SendTileSquare(boundaryPoint.X' boundaryPoint.Y' 1);    								Debug.Assert(boundaryHideTimer != null);  								boundaryHideTimer.Dispose();  							}'  								null' 5000' Timeout.Infinite  							);  						}    						break;  					}  				case "z":  					{  						if (args.Parameters.Count == 3)  						{  							string regionName = args.Parameters[1];  							int z = 0;  							if (int.TryParse(args.Parameters[2]' out z))  							{  								if (TShock.Regions.SetZ(regionName' z))  									args.Player.SendInfoMessage("Region's z is now " + z);  								else  									args.Player.SendErrorMessage("Could not find specified region");  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region z <name> <#>"' Specifier);  						break;  					}  				case "resize":  				case "expand":  					{  						if (args.Parameters.Count == 4)  						{  							int direction;  							switch (args.Parameters[2])  							{  								case "u":  								case "up":  									{  										direction = 0;  										break;  									}  								case "r":  								case "right":  									{  										direction = 1;  										break;  									}  								case "d":  								case "down":  									{  										direction = 2;  										break;  									}  								case "l":  								case "left":  									{  										direction = 3;  										break;  									}  								default:  									{  										direction = -1;  										break;  									}  							}  							int addAmount;  							int.TryParse(args.Parameters[3]' out addAmount);  							if (TShock.Regions.ResizeRegion(args.Parameters[1]' addAmount' direction))  							{  								args.Player.SendInfoMessage("Region Resized Successfully!");  								TShock.Regions.Reload();  							}  							else  								args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						}  						else  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region resize <region> <u/d/l/r> <amount>"' Specifier);  						break;  					}  				case "rename":  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region rename <region> <new name>"' Specifier);  							break;  						}  						else  						{  							string oldName = args.Parameters[1];  							string newName = args.Parameters[2];    							if (oldName == newName)  							{  								args.Player.SendErrorMessage("Error: both names are the same.");  								break;  							}    							Region oldRegion = TShock.Regions.GetRegionByName(oldName);    							if (oldRegion == null)  							{  								args.Player.SendErrorMessage("Invalid region \"{0}\"."' oldName);  								break;  							}    							Region newRegion = TShock.Regions.GetRegionByName(newName);    							if (newRegion != null)  							{  								args.Player.SendErrorMessage("Region \"{0}\" already exists."' newName);  								break;  							}  							  							if(TShock.Regions.RenameRegion(oldName' newName))  							{  								args.Player.SendInfoMessage("Region renamed successfully!");  							}  							else  							{  								args.Player.SendErrorMessage("Failed to rename the region.");  							}  						}  						break;  					}  				case "tp":  					{  						if (!args.Player.HasPermission(Permissions.tp))  						{  							args.Player.SendErrorMessage("You don't have the necessary permission to do that.");  							break;  						}  						if (args.Parameters.Count <= 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}region tp <region>."' Specifier);  							break;  						}    						string regionName = string.Join(" "' args.Parameters.Skip(1));  						Region region = TShock.Regions.GetRegionByName(regionName);  						if (region == null)  						{  							args.Player.SendErrorMessage("Region \"{0}\" does not exist."' regionName);  							break;  						}    						args.Player.Teleport(region.Area.Center.X * 16' region.Area.Center.Y * 16);  						break;  					}  				case "help":  				default:  					{  						int pageNumber;  						int pageParamIndex = 0;  						if (args.Parameters.Count > 1)  							pageParamIndex = 1;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' pageParamIndex' args.Player' out pageNumber))  							return;    						List<string> lines = new List<string> {  						  "set <1/2> - Sets the temporary region points."'  						  "clear - Clears the temporary region points."'  						  "define <name> - Defines the region with the given name."'  						  "delete <name> - Deletes the given region."'  						  "name [-u][-z][-p] - Shows the name of the region at the given point."'  						  "rename <region> <new name> - Renames the given region."'  						  "list - Lists all regions."'  						  "resize <region> <u/d/l/r> <amount> - Resizes a region."'  						  "allow <user> <region> - Allows a user to a region."'  						  "remove <user> <region> - Removes a user from a region."'  						  "allowg <group> <region> - Allows a user group to a region."'  						  "removeg <group> <region> - Removes a user group from a region."'  						  "info <region> [-d] - Displays several information about the given region."'  						  "protect <name> <true/false> - Sets whether the tiles inside the region are protected or not."'  						  "z <name> <#> - Sets the z-order of the region."'  						};  						if (args.Player.HasPermission(Permissions.tp))  							lines.Add("tp <region> - Teleports you to the given region's center.");    						PaginationTools.SendPage(  						  args.Player' pageNumber' lines'  						  new PaginationTools.Settings  						  {  							  HeaderFormat = "Available Region Sub-Commands ({0}/{1}):"'  							  FooterFormat = "Type {0}region {{0}} for more sub-commands.".SFormat(Specifier)  						  }  						);  						break;  					}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ListConnectedPlayers,The following statement contains a magic number: bool invalidUsage = (args.Parameters.Count > 2);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ThirdPerson,The following statement contains a magic number: if (args.Player.mute)  				args.Player.SendErrorMessage("You are muted.");  			else  				TSPlayer.All.SendMessage(string.Format("*{0} {1}"' args.Player.Name' String.Join(" "' args.Parameters))' 205' 133' 63);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ThirdPerson,The following statement contains a magic number: if (args.Player.mute)  				args.Player.SendErrorMessage("You are muted.");  			else  				TSPlayer.All.SendMessage(string.Format("*{0} {1}"' args.Player.Name' String.Join(" "' args.Parameters))' 205' 133' 63);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ThirdPerson,The following statement contains a magic number: if (args.Player.mute)  				args.Player.SendErrorMessage("You are muted.");  			else  				TSPlayer.All.SendMessage(string.Format("*{0} {1}"' args.Player.Name' String.Join(" "' args.Parameters))' 205' 133' 63);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Whisper,The following statement contains a magic number: if (args.Parameters.Count < 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}whisper <player> <text>"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Annoy,The following statement contains a magic number: if (args.Parameters.Count != 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}annoy <player> <seconds to annoy>"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Annoy,The following statement contains a magic number: int annoy = 5;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Rocket,The following statement contains a magic number: if (players.Count == 0)  				args.Player.SendErrorMessage("Invalid player!");  			else if (players.Count > 1)  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			else  			{  				var ply = players[0];    				if (ply.IsLoggedIn && Main.ServerSideCharacter)  				{  					ply.TPlayer.velocity.Y = -50;  					TSPlayer.All.SendData(PacketTypes.PlayerUpdate' ""' ply.Index);  					args.Player.SendSuccessMessage("Rocketed {0}."' ply.Name);  				}  				else  				{  					args.Player.SendErrorMessage("Failed to rocket player: Not logged in or not SSC mode.");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,FireWork,The following statement contains a magic number: if (players.Count == 0)  				args.Player.SendErrorMessage("Invalid player!");  			else if (players.Count > 1)  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			else  			{  				int type = 167;  				if (args.Parameters.Count > 1)  				{  					if (args.Parameters[1].ToLower() == "green")  						type = 168;  					else if (args.Parameters[1].ToLower() == "blue")  						type = 169;  					else if (args.Parameters[1].ToLower() == "yellow")  						type = 170;  				}  				var ply = players[0];  				int p = Projectile.NewProjectile(ply.TPlayer.position.X' ply.TPlayer.position.Y - 64f' 0f' -8f' type' 0' (float)0);  				Main.projectile[p].Kill();  				args.Player.SendSuccessMessage("Launched Firework on {0}."' ply.Name);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,FireWork,The following statement contains a magic number: if (players.Count == 0)  				args.Player.SendErrorMessage("Invalid player!");  			else if (players.Count > 1)  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			else  			{  				int type = 167;  				if (args.Parameters.Count > 1)  				{  					if (args.Parameters[1].ToLower() == "green")  						type = 168;  					else if (args.Parameters[1].ToLower() == "blue")  						type = 169;  					else if (args.Parameters[1].ToLower() == "yellow")  						type = 170;  				}  				var ply = players[0];  				int p = Projectile.NewProjectile(ply.TPlayer.position.X' ply.TPlayer.position.Y - 64f' 0f' -8f' type' 0' (float)0);  				Main.projectile[p].Kill();  				args.Player.SendSuccessMessage("Launched Firework on {0}."' ply.Name);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,FireWork,The following statement contains a magic number: if (players.Count == 0)  				args.Player.SendErrorMessage("Invalid player!");  			else if (players.Count > 1)  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			else  			{  				int type = 167;  				if (args.Parameters.Count > 1)  				{  					if (args.Parameters[1].ToLower() == "green")  						type = 168;  					else if (args.Parameters[1].ToLower() == "blue")  						type = 169;  					else if (args.Parameters[1].ToLower() == "yellow")  						type = 170;  				}  				var ply = players[0];  				int p = Projectile.NewProjectile(ply.TPlayer.position.X' ply.TPlayer.position.Y - 64f' 0f' -8f' type' 0' (float)0);  				Main.projectile[p].Kill();  				args.Player.SendSuccessMessage("Launched Firework on {0}."' ply.Name);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,FireWork,The following statement contains a magic number: if (players.Count == 0)  				args.Player.SendErrorMessage("Invalid player!");  			else if (players.Count > 1)  				TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  			else  			{  				int type = 167;  				if (args.Parameters.Count > 1)  				{  					if (args.Parameters[1].ToLower() == "green")  						type = 168;  					else if (args.Parameters[1].ToLower() == "blue")  						type = 169;  					else if (args.Parameters[1].ToLower() == "yellow")  						type = 170;  				}  				var ply = players[0];  				int p = Projectile.NewProjectile(ply.TPlayer.position.X' ply.TPlayer.position.Y - 64f' 0f' -8f' type' 0' (float)0);  				Main.projectile[p].Kill();  				args.Player.SendSuccessMessage("Launched Firework on {0}."' ply.Name);  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: if (args.Parameters.Count != 1 && args.Parameters.Count != 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}clear <item/npc/projectile> [radius]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: int radius = 50;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Clear,The following statement contains a magic number: if (args.Parameters.Count == 2)  			{  				if (!int.TryParse(args.Parameters[1]' out radius) || radius <= 0)  				{  					args.Player.SendErrorMessage("Invalid radius.");  					return;  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Butcher,The following statement contains a magic number: for (int i = 0; i < Main.npc.Length; i++)  			{  				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC && Main.npc[i].netID != NPCID.TargetDummy) || Main.npc[i].netID == npcId))  				{  					TSPlayer.Server.StrikeNPC(i' (int)(Main.npc[i].life + (Main.npc[i].defense * 0.6))' 0' 0);  					kills++;  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  			{  				if (itemAmount == 0 || itemAmount > item.maxStack)  					itemAmount = item.maxStack;    				if (args.Player.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefixId))  				{  					item.prefix = (byte)prefixId;  					args.Player.SendSuccessMessage("Gave {0} {1}(s)."' itemAmount' item.AffixName());  				}  				else  				{  					args.Player.SendErrorMessage("You cannot spawn banned items.");  				}  			}  			else  			{  				args.Player.SendErrorMessage("Your inventory seems full.");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  			{  				if (itemAmount == 0 || itemAmount > item.maxStack)  					itemAmount = item.maxStack;    				if (args.Player.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefixId))  				{  					item.prefix = (byte)prefixId;  					args.Player.SendSuccessMessage("Gave {0} {1}(s)."' itemAmount' item.AffixName());  				}  				else  				{  					args.Player.SendErrorMessage("You cannot spawn banned items.");  				}  			}  			else  			{  				args.Player.SendErrorMessage("Your inventory seems full.");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  			{  				if (itemAmount == 0 || itemAmount > item.maxStack)  					itemAmount = item.maxStack;    				if (args.Player.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefixId))  				{  					item.prefix = (byte)prefixId;  					args.Player.SendSuccessMessage("Gave {0} {1}(s)."' itemAmount' item.AffixName());  				}  				else  				{  					args.Player.SendErrorMessage("You cannot spawn banned items.");  				}  			}  			else  			{  				args.Player.SendErrorMessage("Your inventory seems full.");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Item,The following statement contains a magic number: if (args.Player.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  			{  				if (itemAmount == 0 || itemAmount > item.maxStack)  					itemAmount = item.maxStack;    				if (args.Player.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefixId))  				{  					item.prefix = (byte)prefixId;  					args.Player.SendSuccessMessage("Gave {0} {1}(s)."' itemAmount' item.AffixName());  				}  				else  				{  					args.Player.SendErrorMessage("You cannot spawn banned items.");  				}  			}  			else  			{  				args.Player.SendErrorMessage("Your inventory seems full.");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: if (args.Parameters.Count != 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}renameNPC <guide' nurse' etc.> <newname>"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: if (args.Parameters.Count == 2)  			{  				List<NPC> npcs = TShock.Utils.GetNPCByIdOrName(args.Parameters[0]);  				if (npcs.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid mob type!");  					return;  				}  				else if (npcs.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  					return;  				}  				else if (args.Parameters[1].Length > 200)  				{  					args.Player.SendErrorMessage("New name is too large!");  					return;  				}  				else  				{  					npcId = npcs[0].netID;  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: if (args.Parameters.Count == 2)  			{  				List<NPC> npcs = TShock.Utils.GetNPCByIdOrName(args.Parameters[0]);  				if (npcs.Count == 0)  				{  					args.Player.SendErrorMessage("Invalid mob type!");  					return;  				}  				else if (npcs.Count > 1)  				{  					TShock.Utils.SendMultipleMatchError(args.Player' npcs.Select(n => $"{n.FullName}({n.type})"));  					return;  				}  				else if (args.Parameters[1].Length > 200)  				{  					args.Player.SendErrorMessage("New name is too large!");  					return;  				}  				else  				{  					npcId = npcs[0].netID;  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,RenameNPC,The following statement contains a magic number: for (int i = 0; i < Main.npc.Length; i++)  			{  				if (Main.npc[i].active && ((npcId == 0 && !Main.npc[i].townNPC) || (Main.npc[i].netID == npcId && Main.npc[i].townNPC)))  				{  					Main.npc[i].GivenName = args.Parameters[1];  					NetMessage.SendData(56' -1' -1' NetworkText.FromLiteral(args.Parameters[1])' i' 0f' 0f' 0f' 0);  					done++;  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: if (args.Parameters.Count < 2)  			{  				args.Player.SendErrorMessage(  					"Invalid syntax! Proper syntax: {0}give <item type/id> <player> [item amount] [prefix id/name]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: if (items.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid item type!");  			}  			else if (items.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  			}  			else  			{  				var item = items[0];    				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[0]' out itemAmount);  					var prefixIds = TShock.Utils.GetPrefixByIdOrName(args.Parameters[1]);  					if (item.accessory && prefixIds.Contains(PrefixID.Quick))  					{  						prefixIds.Remove(PrefixID.Quick);  						prefixIds.Remove(PrefixID.Quick2);  						prefixIds.Add(PrefixID.Quick2);  					}  					else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))  						prefixIds.Remove(PrefixID.Quick2);  					if (prefixIds.Count == 1)  						prefix = prefixIds[0];  				}    				if (item.type >= 1 && item.type < Main.maxItemTypes)  				{  					var players = TShock.Utils.FindPlayer(plStr);  					if (players.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid player!");  					}  					else if (players.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  					}  					else  					{  						var plr = players[0];  						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  						{  							if (itemAmount == 0 || itemAmount > item.maxStack)  								itemAmount = item.maxStack;  							if (plr.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefix))  							{  								args.Player.SendSuccessMessage(string.Format("Gave {0} {1} {2}(s)."' plr.Name' itemAmount' item.Name));  								plr.SendSuccessMessage(string.Format("{0} gave you {1} {2}(s)."' args.Player.Name' itemAmount' item.Name));  							}  							else  							{  								args.Player.SendErrorMessage("You cannot spawn banned items.");  							}    						}  						else  						{  							args.Player.SendErrorMessage("Player does not have free slots!");  						}  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid item type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: if (items.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid item type!");  			}  			else if (items.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  			}  			else  			{  				var item = items[0];    				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[0]' out itemAmount);  					var prefixIds = TShock.Utils.GetPrefixByIdOrName(args.Parameters[1]);  					if (item.accessory && prefixIds.Contains(PrefixID.Quick))  					{  						prefixIds.Remove(PrefixID.Quick);  						prefixIds.Remove(PrefixID.Quick2);  						prefixIds.Add(PrefixID.Quick2);  					}  					else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))  						prefixIds.Remove(PrefixID.Quick2);  					if (prefixIds.Count == 1)  						prefix = prefixIds[0];  				}    				if (item.type >= 1 && item.type < Main.maxItemTypes)  				{  					var players = TShock.Utils.FindPlayer(plStr);  					if (players.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid player!");  					}  					else if (players.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  					}  					else  					{  						var plr = players[0];  						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  						{  							if (itemAmount == 0 || itemAmount > item.maxStack)  								itemAmount = item.maxStack;  							if (plr.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefix))  							{  								args.Player.SendSuccessMessage(string.Format("Gave {0} {1} {2}(s)."' plr.Name' itemAmount' item.Name));  								plr.SendSuccessMessage(string.Format("{0} gave you {1} {2}(s)."' args.Player.Name' itemAmount' item.Name));  							}  							else  							{  								args.Player.SendErrorMessage("You cannot spawn banned items.");  							}    						}  						else  						{  							args.Player.SendErrorMessage("Player does not have free slots!");  						}  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid item type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: if (items.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid item type!");  			}  			else if (items.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  			}  			else  			{  				var item = items[0];    				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[0]' out itemAmount);  					var prefixIds = TShock.Utils.GetPrefixByIdOrName(args.Parameters[1]);  					if (item.accessory && prefixIds.Contains(PrefixID.Quick))  					{  						prefixIds.Remove(PrefixID.Quick);  						prefixIds.Remove(PrefixID.Quick2);  						prefixIds.Add(PrefixID.Quick2);  					}  					else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))  						prefixIds.Remove(PrefixID.Quick2);  					if (prefixIds.Count == 1)  						prefix = prefixIds[0];  				}    				if (item.type >= 1 && item.type < Main.maxItemTypes)  				{  					var players = TShock.Utils.FindPlayer(plStr);  					if (players.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid player!");  					}  					else if (players.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  					}  					else  					{  						var plr = players[0];  						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  						{  							if (itemAmount == 0 || itemAmount > item.maxStack)  								itemAmount = item.maxStack;  							if (plr.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefix))  							{  								args.Player.SendSuccessMessage(string.Format("Gave {0} {1} {2}(s)."' plr.Name' itemAmount' item.Name));  								plr.SendSuccessMessage(string.Format("{0} gave you {1} {2}(s)."' args.Player.Name' itemAmount' item.Name));  							}  							else  							{  								args.Player.SendErrorMessage("You cannot spawn banned items.");  							}    						}  						else  						{  							args.Player.SendErrorMessage("Player does not have free slots!");  						}  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid item type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: if (items.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid item type!");  			}  			else if (items.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  			}  			else  			{  				var item = items[0];    				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[0]' out itemAmount);  					var prefixIds = TShock.Utils.GetPrefixByIdOrName(args.Parameters[1]);  					if (item.accessory && prefixIds.Contains(PrefixID.Quick))  					{  						prefixIds.Remove(PrefixID.Quick);  						prefixIds.Remove(PrefixID.Quick2);  						prefixIds.Add(PrefixID.Quick2);  					}  					else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))  						prefixIds.Remove(PrefixID.Quick2);  					if (prefixIds.Count == 1)  						prefix = prefixIds[0];  				}    				if (item.type >= 1 && item.type < Main.maxItemTypes)  				{  					var players = TShock.Utils.FindPlayer(plStr);  					if (players.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid player!");  					}  					else if (players.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  					}  					else  					{  						var plr = players[0];  						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  						{  							if (itemAmount == 0 || itemAmount > item.maxStack)  								itemAmount = item.maxStack;  							if (plr.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefix))  							{  								args.Player.SendSuccessMessage(string.Format("Gave {0} {1} {2}(s)."' plr.Name' itemAmount' item.Name));  								plr.SendSuccessMessage(string.Format("{0} gave you {1} {2}(s)."' args.Player.Name' itemAmount' item.Name));  							}  							else  							{  								args.Player.SendErrorMessage("You cannot spawn banned items.");  							}    						}  						else  						{  							args.Player.SendErrorMessage("Player does not have free slots!");  						}  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid item type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Give,The following statement contains a magic number: if (items.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid item type!");  			}  			else if (items.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  			}  			else  			{  				var item = items[0];    				if (args.Parameters.Count == 2)  				{  					int.TryParse(args.Parameters[0]' out itemAmount);  					var prefixIds = TShock.Utils.GetPrefixByIdOrName(args.Parameters[1]);  					if (item.accessory && prefixIds.Contains(PrefixID.Quick))  					{  						prefixIds.Remove(PrefixID.Quick);  						prefixIds.Remove(PrefixID.Quick2);  						prefixIds.Add(PrefixID.Quick2);  					}  					else if (!item.accessory && prefixIds.Contains(PrefixID.Quick))  						prefixIds.Remove(PrefixID.Quick2);  					if (prefixIds.Count == 1)  						prefix = prefixIds[0];  				}    				if (item.type >= 1 && item.type < Main.maxItemTypes)  				{  					var players = TShock.Utils.FindPlayer(plStr);  					if (players.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid player!");  					}  					else if (players.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' players.Select(p => p.Name));  					}  					else  					{  						var plr = players[0];  						if (plr.InventorySlotAvailable || (item.type > 70 && item.type < 75) || item.ammo > 0 || item.type == 58 || item.type == 184)  						{  							if (itemAmount == 0 || itemAmount > item.maxStack)  								itemAmount = item.maxStack;  							if (plr.GiveItemCheck(item.type' EnglishLanguage.GetItemNameById(item.type)' itemAmount' prefix))  							{  								args.Player.SendSuccessMessage(string.Format("Gave {0} {1} {2}(s)."' plr.Name' itemAmount' item.Name));  								plr.SendSuccessMessage(string.Format("{0} gave you {1} {2}(s)."' args.Player.Name' itemAmount' item.Name));  							}  							else  							{  								args.Player.SendErrorMessage("You cannot spawn banned items.");  							}    						}  						else  						{  							args.Player.SendErrorMessage("Player does not have free slots!");  						}  					}  				}  				else  				{  					args.Player.SendErrorMessage("Invalid item type!");  				}  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: if (args.Parameters.Count < 1 || args.Parameters.Count > 2)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}buff <buff id/name> [time(seconds)]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: int time = 60;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: if (args.Parameters.Count == 2)  				int.TryParse(args.Parameters[1]' out time);
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: if (id > 0 && id < Main.maxBuffTypes)  			{  				if (time < 0 || time > short.MaxValue)  					time = 60;  				args.Player.SetBuff(id' time * 60);  				args.Player.SendSuccessMessage(string.Format("You have buffed yourself with {0}({1}) for {2} seconds!"'  													  TShock.Utils.GetBuffName(id)' TShock.Utils.GetBuffDescription(id)' (time)));  			}  			else  				args.Player.SendErrorMessage("Invalid buff ID!");
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Buff,The following statement contains a magic number: if (id > 0 && id < Main.maxBuffTypes)  			{  				if (time < 0 || time > short.MaxValue)  					time = 60;  				args.Player.SetBuff(id' time * 60);  				args.Player.SendSuccessMessage(string.Format("You have buffed yourself with {0}({1}) for {2} seconds!"'  													  TShock.Utils.GetBuffName(id)' TShock.Utils.GetBuffDescription(id)' (time)));  			}  			else  				args.Player.SendErrorMessage("Invalid buff ID!");
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}gbuff <player> <buff id/name> [time(seconds)]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  			{  				args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}gbuff <player> <buff id/name> [time(seconds)]"' Specifier);  				return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: int time = 60;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: if (foundplr.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  				return;  			}  			else if (foundplr.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  				return;  			}  			else  			{  				if (!int.TryParse(args.Parameters[1]' out id))  				{  					var found = TShock.Utils.GetBuffByName(args.Parameters[1]);  					if (found.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid buff name!");  						return;  					}  					else if (found.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' found.Select(b => Lang.GetBuffName(b)));  						return;  					}  					id = found[0];  				}  				if (args.Parameters.Count == 3)  					int.TryParse(args.Parameters[2]' out time);  				if (id > 0 && id < Main.maxBuffTypes)  				{  					if (time < 0 || time > short.MaxValue)  						time = 60;  					foundplr[0].SetBuff(id' time * 60);  					args.Player.SendSuccessMessage(string.Format("You have buffed {0} with {1}({2}) for {3} seconds!"'  														  foundplr[0].Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  					foundplr[0].SendSuccessMessage(string.Format("{0} has buffed you with {1}({2}) for {3} seconds!"'  														  args.Player.Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  				}  				else  					args.Player.SendErrorMessage("Invalid buff ID!");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: if (foundplr.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  				return;  			}  			else if (foundplr.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  				return;  			}  			else  			{  				if (!int.TryParse(args.Parameters[1]' out id))  				{  					var found = TShock.Utils.GetBuffByName(args.Parameters[1]);  					if (found.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid buff name!");  						return;  					}  					else if (found.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' found.Select(b => Lang.GetBuffName(b)));  						return;  					}  					id = found[0];  				}  				if (args.Parameters.Count == 3)  					int.TryParse(args.Parameters[2]' out time);  				if (id > 0 && id < Main.maxBuffTypes)  				{  					if (time < 0 || time > short.MaxValue)  						time = 60;  					foundplr[0].SetBuff(id' time * 60);  					args.Player.SendSuccessMessage(string.Format("You have buffed {0} with {1}({2}) for {3} seconds!"'  														  foundplr[0].Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  					foundplr[0].SendSuccessMessage(string.Format("{0} has buffed you with {1}({2}) for {3} seconds!"'  														  args.Player.Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  				}  				else  					args.Player.SendErrorMessage("Invalid buff ID!");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: if (foundplr.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  				return;  			}  			else if (foundplr.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  				return;  			}  			else  			{  				if (!int.TryParse(args.Parameters[1]' out id))  				{  					var found = TShock.Utils.GetBuffByName(args.Parameters[1]);  					if (found.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid buff name!");  						return;  					}  					else if (found.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' found.Select(b => Lang.GetBuffName(b)));  						return;  					}  					id = found[0];  				}  				if (args.Parameters.Count == 3)  					int.TryParse(args.Parameters[2]' out time);  				if (id > 0 && id < Main.maxBuffTypes)  				{  					if (time < 0 || time > short.MaxValue)  						time = 60;  					foundplr[0].SetBuff(id' time * 60);  					args.Player.SendSuccessMessage(string.Format("You have buffed {0} with {1}({2}) for {3} seconds!"'  														  foundplr[0].Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  					foundplr[0].SendSuccessMessage(string.Format("{0} has buffed you with {1}({2}) for {3} seconds!"'  														  args.Player.Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  				}  				else  					args.Player.SendErrorMessage("Invalid buff ID!");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,GBuff,The following statement contains a magic number: if (foundplr.Count == 0)  			{  				args.Player.SendErrorMessage("Invalid player!");  				return;  			}  			else if (foundplr.Count > 1)  			{  				TShock.Utils.SendMultipleMatchError(args.Player' foundplr.Select(p => p.Name));  				return;  			}  			else  			{  				if (!int.TryParse(args.Parameters[1]' out id))  				{  					var found = TShock.Utils.GetBuffByName(args.Parameters[1]);  					if (found.Count == 0)  					{  						args.Player.SendErrorMessage("Invalid buff name!");  						return;  					}  					else if (found.Count > 1)  					{  						TShock.Utils.SendMultipleMatchError(args.Player' found.Select(b => Lang.GetBuffName(b)));  						return;  					}  					id = found[0];  				}  				if (args.Parameters.Count == 3)  					int.TryParse(args.Parameters[2]' out time);  				if (id > 0 && id < Main.maxBuffTypes)  				{  					if (time < 0 || time > short.MaxValue)  						time = 60;  					foundplr[0].SetBuff(id' time * 60);  					args.Player.SendSuccessMessage(string.Format("You have buffed {0} with {1}({2}) for {3} seconds!"'  														  foundplr[0].Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  					foundplr[0].SendSuccessMessage(string.Format("{0} has buffed you with {1}({2}) for {3} seconds!"'  														  args.Player.Name' TShock.Utils.GetBuffName(id)'  														  TShock.Utils.GetBuffDescription(id)' (time)));  				}  				else  					args.Player.SendErrorMessage("Invalid buff ID!");  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: var y = args.Player.TileY + 3;
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Grow,The following statement contains a magic number: switch (args.Parameters[0].ToLower())  			{  				case "tree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowTree(x' y);  					name = "Tree";  					break;  				case "epictree":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 2;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					Main.tile[x' y - 1].liquid = 0;  					Main.tile[x' y - 1].active(true);  					WorldGen.GrowEpicTree(x' y);  					name = "Epic Tree";  					break;  				case "mushroom":  					for (int i = x - 1; i < x + 2; i++)  					{  						Main.tile[i' y].active(true);  						Main.tile[i' y].type = 70;  						Main.tile[i' y].wall = 0;  					}  					Main.tile[x' y - 1].wall = 0;  					WorldGen.GrowShroom(x' y);  					name = "Mushroom";  					break;  				case "cactus":  					Main.tile[x' y].type = 53;  					WorldGen.GrowCactus(x' y);  					name = "Cactus";  					break;  				case "herb":  					Main.tile[x' y].active(true);  					Main.tile[x' y].frameX = 36;  					Main.tile[x' y].type = 83;  					WorldGen.GrowAlch(x' y);  					name = "Herb";  					break;  				default:  					args.Player.SendErrorMessage("Unknown plant!");  					return;  			}
Magic Number,TShockAPI,FileTools,C:\repos\NyxStudios_TShock\TShockAPI\FileTools.cs,SetupConfig,The following statement contains a magic number: if (File.Exists(ServerSideCharacterConfigPath))  			{  				TShock.ServerSideCharacterConfig = ServerSideConfig.Read(ServerSideCharacterConfigPath);  				// Add all the missing config properties in the json file  			}  			else  			{  				TShock.ServerSideCharacterConfig = new ServerSideConfig  				{  					StartingInventory =  						new List<NetItem>  						{  							new NetItem(-15' 1' 0)'  							new NetItem(-13' 1' 0)'  							new NetItem(-16' 1' 0)  						}  				};  			}
Magic Number,TShockAPI,FileTools,C:\repos\NyxStudios_TShock\TShockAPI\FileTools.cs,SetupConfig,The following statement contains a magic number: if (File.Exists(ServerSideCharacterConfigPath))  			{  				TShock.ServerSideCharacterConfig = ServerSideConfig.Read(ServerSideCharacterConfigPath);  				// Add all the missing config properties in the json file  			}  			else  			{  				TShock.ServerSideCharacterConfig = new ServerSideConfig  				{  					StartingInventory =  						new List<NetItem>  						{  							new NetItem(-15' 1' 0)'  							new NetItem(-13' 1' 0)'  							new NetItem(-16' 1' 0)  						}  				};  			}
Magic Number,TShockAPI,FileTools,C:\repos\NyxStudios_TShock\TShockAPI\FileTools.cs,SetupConfig,The following statement contains a magic number: if (File.Exists(ServerSideCharacterConfigPath))  			{  				TShock.ServerSideCharacterConfig = ServerSideConfig.Read(ServerSideCharacterConfigPath);  				// Add all the missing config properties in the json file  			}  			else  			{  				TShock.ServerSideCharacterConfig = new ServerSideConfig  				{  					StartingInventory =  						new List<NetItem>  						{  							new NetItem(-15' 1' 0)'  							new NetItem(-13' 1' 0)'  							new NetItem(-16' 1' 0)  						}  				};  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,TSCheckNoclip,The following statement contains a magic number: for (int i = num; i < num2; i++)  			{  				for (int j = num3; j < num4; j++)  				{  					if (Main.tile[i' j] == null || Main.tileSand[Main.tile[i' j].type]  						|| !TShock.Utils.TileSolid(i' j) || !TShock.Utils.TileSolid(i + 1' j) || !TShock.Utils.TileSolid(i - 1' j)  						|| !TShock.Utils.TileSolid(i' j + 1) || !TShock.Utils.TileSolid(i + 1' j + 1) || !TShock.Utils.TileSolid(i - 1' j + 1)  						|| !TShock.Utils.TileSolid(i' j - 1) || !TShock.Utils.TileSolid(i + 1' j - 1) || !TShock.Utils.TileSolid(i - 1' j - 1)  						|| Main.tileSolidTop[(int)Main.tile[i' j].type])  					{  						continue;  					}    					Vector2 vector;  					vector.X = (float)(i * 16);  					vector.Y = (float)(j * 16);  					if (Position.X + (float)Width > vector.X && Position.X < vector.X + 16f && Position.Y + (float)Height > vector.Y && Position.Y < vector.Y + 16f)  					{  						return true;  					}  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,TSCheckNoclip,The following statement contains a magic number: for (int i = num; i < num2; i++)  			{  				for (int j = num3; j < num4; j++)  				{  					if (Main.tile[i' j] == null || Main.tileSand[Main.tile[i' j].type]  						|| !TShock.Utils.TileSolid(i' j) || !TShock.Utils.TileSolid(i + 1' j) || !TShock.Utils.TileSolid(i - 1' j)  						|| !TShock.Utils.TileSolid(i' j + 1) || !TShock.Utils.TileSolid(i + 1' j + 1) || !TShock.Utils.TileSolid(i - 1' j + 1)  						|| !TShock.Utils.TileSolid(i' j - 1) || !TShock.Utils.TileSolid(i + 1' j - 1) || !TShock.Utils.TileSolid(i - 1' j - 1)  						|| Main.tileSolidTop[(int)Main.tile[i' j].type])  					{  						continue;  					}    					Vector2 vector;  					vector.X = (float)(i * 16);  					vector.Y = (float)(j * 16);  					if (Position.X + (float)Width > vector.X && Position.X < vector.X + 16f && Position.Y + (float)Height > vector.Y && Position.Y < vector.Y + 16f)  					{  						return true;  					}  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[20] = 600;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[20] = 600;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[0x18] = 1200;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[0x1f] = 120;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,InitGetDataHandler,The following statement contains a magic number: WhitelistBuffMaxTime[0x27] = 420;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleHealOther,The following statement contains a magic number: if (amount > TShock.Config.MaxDamage * 0.2)  			{  				args.Player.Disable("HealOtherPlayer cheat attempt!"' DisableFlags.WriteToLogAndConsole);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleHealOther,The following statement contains a magic number: if (TShock.CheckIgnores(args.Player) || (DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerSlot,The following statement contains a magic number: if (slot == 58) //this is the hand  			{  				item.stack = stack;  				args.Player.ItemInHand = item;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: if (extra[0])  			{  				difficulty++;  			}  			else if (extra[1])  			{  				difficulty += 2;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: bool extraSlot = extra[2];
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: if (args.Player.ReceivedInfo)  			{  				// Since Terraria 1.2.3 these character properties can change ingame.  				args.Player.TPlayer.hair = hair;  				args.Player.TPlayer.hairColor = hairColor;  				args.Player.TPlayer.hairDye = hairDye;  				args.Player.TPlayer.skinVariant = skinVariant;  				args.Player.TPlayer.skinColor = skinColor;  				args.Player.TPlayer.eyeColor = eyeColor;  				args.Player.TPlayer.pantsColor = pantsColor;  				args.Player.TPlayer.shirtColor = shirtColor;  				args.Player.TPlayer.underShirtColor = underShirtColor;  				args.Player.TPlayer.shoeColor = shoeColor;  				args.Player.TPlayer.hideVisual = new bool[10];  				for (int i = 0; i < 8; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual[i];  				for (int i = 8; i < 10; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual2[i];  				args.Player.TPlayer.hideMisc = hideMisc;  				args.Player.TPlayer.extraAccessory = extraSlot;  				NetMessage.SendData((int)PacketTypes.PlayerInfo' -1' args.Player.Index' NetworkText.FromLiteral(args.Player.Name)' args.Player.Index);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: if (args.Player.ReceivedInfo)  			{  				// Since Terraria 1.2.3 these character properties can change ingame.  				args.Player.TPlayer.hair = hair;  				args.Player.TPlayer.hairColor = hairColor;  				args.Player.TPlayer.hairDye = hairDye;  				args.Player.TPlayer.skinVariant = skinVariant;  				args.Player.TPlayer.skinColor = skinColor;  				args.Player.TPlayer.eyeColor = eyeColor;  				args.Player.TPlayer.pantsColor = pantsColor;  				args.Player.TPlayer.shirtColor = shirtColor;  				args.Player.TPlayer.underShirtColor = underShirtColor;  				args.Player.TPlayer.shoeColor = shoeColor;  				args.Player.TPlayer.hideVisual = new bool[10];  				for (int i = 0; i < 8; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual[i];  				for (int i = 8; i < 10; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual2[i];  				args.Player.TPlayer.hideMisc = hideMisc;  				args.Player.TPlayer.extraAccessory = extraSlot;  				NetMessage.SendData((int)PacketTypes.PlayerInfo' -1' args.Player.Index' NetworkText.FromLiteral(args.Player.Name)' args.Player.Index);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: if (args.Player.ReceivedInfo)  			{  				// Since Terraria 1.2.3 these character properties can change ingame.  				args.Player.TPlayer.hair = hair;  				args.Player.TPlayer.hairColor = hairColor;  				args.Player.TPlayer.hairDye = hairDye;  				args.Player.TPlayer.skinVariant = skinVariant;  				args.Player.TPlayer.skinColor = skinColor;  				args.Player.TPlayer.eyeColor = eyeColor;  				args.Player.TPlayer.pantsColor = pantsColor;  				args.Player.TPlayer.shirtColor = shirtColor;  				args.Player.TPlayer.underShirtColor = underShirtColor;  				args.Player.TPlayer.shoeColor = shoeColor;  				args.Player.TPlayer.hideVisual = new bool[10];  				for (int i = 0; i < 8; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual[i];  				for (int i = 8; i < 10; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual2[i];  				args.Player.TPlayer.hideMisc = hideMisc;  				args.Player.TPlayer.extraAccessory = extraSlot;  				NetMessage.SendData((int)PacketTypes.PlayerInfo' -1' args.Player.Index' NetworkText.FromLiteral(args.Player.Name)' args.Player.Index);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: if (args.Player.ReceivedInfo)  			{  				// Since Terraria 1.2.3 these character properties can change ingame.  				args.Player.TPlayer.hair = hair;  				args.Player.TPlayer.hairColor = hairColor;  				args.Player.TPlayer.hairDye = hairDye;  				args.Player.TPlayer.skinVariant = skinVariant;  				args.Player.TPlayer.skinColor = skinColor;  				args.Player.TPlayer.eyeColor = eyeColor;  				args.Player.TPlayer.pantsColor = pantsColor;  				args.Player.TPlayer.shirtColor = shirtColor;  				args.Player.TPlayer.underShirtColor = underShirtColor;  				args.Player.TPlayer.shoeColor = shoeColor;  				args.Player.TPlayer.hideVisual = new bool[10];  				for (int i = 0; i < 8; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual[i];  				for (int i = 8; i < 10; i++)  					args.Player.TPlayer.hideVisual[i] = hideVisual2[i];  				args.Player.TPlayer.hideMisc = hideMisc;  				args.Player.TPlayer.extraAccessory = extraSlot;  				NetMessage.SendData((int)PacketTypes.PlayerInfo' -1' args.Player.Index' NetworkText.FromLiteral(args.Player.Name)' args.Player.Index);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerInfo,The following statement contains a magic number: if (TShock.Config.HardcoreOnly && difficulty < 2)  			{  				TShock.Utils.ForceKick(args.Player' "Server is set to hardcore characters only!"' true);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleConnecting,The following statement contains a magic number: if (account != null && !TShock.Config.DisableUUIDLogin)  			{  				if (account.UUID == args.Player.UUID)  				{  					if (args.Player.State == 1)  						args.Player.State = 2;  					NetMessage.SendData((int)PacketTypes.WorldInfo' args.Player.Index);    					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player' account.ID);    					var group = TShock.Utils.GetGroup(account.Group);    					args.Player.Group = group;  					args.Player.tempGroup = null;  					args.Player.Account = account;  					args.Player.IsLoggedIn = true;  					args.Player.IgnoreActionsForInventory = "none";    					if (Main.ServerSideCharacter)  					{  						if (args.Player.HasPermission(Permissions.bypassssc))  						{  							args.Player.PlayerData.CopyCharacter(args.Player);  							TShock.CharacterDB.InsertPlayerData(args.Player);  						}  						args.Player.PlayerData.RestoreCharacter(args.Player);  					}  					args.Player.LoginFailsBySsi = false;    					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))  						args.Player.IgnoreActionsForCheating = "none";    					if (args.Player.HasPermission(Permissions.usebanneditem))  						args.Player.IgnoreActionsForDisabledArmor = "none";    					args.Player.SendSuccessMessage("Authenticated as " + account.Name + " successfully.");  					TShock.Log.ConsoleInfo(args.Player.Name + " authenticated successfully as user " + args.Player.Name + ".");  					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);  					return true;  				}  			}  			else if (account != null && !TShock.Config.DisableLoginBeforeJoin)  			{  				args.Player.RequiresPassword = true;  				NetMessage.SendData((int)PacketTypes.PasswordRequired' args.Player.Index);  				return true;  			}  			else if (!string.IsNullOrEmpty(TShock.Config.ServerPassword))  			{  				args.Player.RequiresPassword = true;  				NetMessage.SendData((int)PacketTypes.PasswordRequired' args.Player.Index);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleConnecting,The following statement contains a magic number: if (args.Player.State == 1)  				args.Player.State = 2;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePassword,The following statement contains a magic number: if (account != null && !TShock.Config.DisableLoginBeforeJoin)  			{  				if (account.VerifyPassword(password))  				{  					args.Player.RequiresPassword = false;  					args.Player.PlayerData = TShock.CharacterDB.GetPlayerData(args.Player' account.ID);    					if (args.Player.State == 1)  						args.Player.State = 2;  					NetMessage.SendData((int)PacketTypes.WorldInfo' args.Player.Index);    					var group = TShock.Utils.GetGroup(account.Group);    					args.Player.Group = group;  					args.Player.tempGroup = null;  					args.Player.Account = account;  					args.Player.IsLoggedIn = true;  					args.Player.IgnoreActionsForInventory = "none";    					if (Main.ServerSideCharacter)  					{  						if (args.Player.HasPermission(Permissions.bypassssc))  						{  							args.Player.PlayerData.CopyCharacter(args.Player);  							TShock.CharacterDB.InsertPlayerData(args.Player);  						}  						args.Player.PlayerData.RestoreCharacter(args.Player);  					}  					args.Player.LoginFailsBySsi = false;    					if (args.Player.HasPermission(Permissions.ignorestackhackdetection))  						args.Player.IgnoreActionsForCheating = "none";    					if (args.Player.HasPermission(Permissions.usebanneditem))  						args.Player.IgnoreActionsForDisabledArmor = "none";      					args.Player.SendMessage("Authenticated as " + args.Player.Name + " successfully."' Color.LimeGreen);  					TShock.Log.ConsoleInfo(args.Player.Name + " authenticated successfully as user " + args.Player.Name + ".");  					TShock.UserAccounts.SetUserAccountUUID(account' args.Player.UUID);  					Hooks.PlayerHooks.OnPlayerPostLogin(args.Player);  					return true;  				}  				TShock.Utils.ForceKick(args.Player' "Invalid user account password."' true);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePassword,The following statement contains a magic number: if (!string.IsNullOrEmpty(TShock.Config.ServerPassword))  			{  				if (TShock.Config.ServerPassword == password)  				{  					args.Player.RequiresPassword = false;  					if (args.Player.State == 1)  						args.Player.State = 2;  					NetMessage.SendData((int)PacketTypes.WorldInfo' args.Player.Index);  					return true;  				}  				TShock.Utils.ForceKick(args.Player' "Incorrect server password"' true);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: if (size > 5)  				return true;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendTileSquare(tileX' tileY' size);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSendTileSquare,The following statement contains a magic number: try  			{  				var tiles = new NetTile[size' size];  				for (int x = 0; x < size; x++)  				{  					for (int y = 0; y < size; y++)  					{  						tiles[x' y] = new NetTile(args.Data);  					}  				}    				bool changed = false;  				for (int x = 0; x < size; x++)  				{  					int realx = tileX + x;  					if (realx < 0 || realx >= Main.maxTilesX)  						continue;    					for (int y = 0; y < size; y++)  					{  						int realy = tileY + y;  						if (realy < 0 || realy >= Main.maxTilesY)  							continue;    						var tile = Main.tile[realx' realy];  						var newtile = tiles[x' y];  						if (TShock.CheckTilePermission(args.Player' realx' realy) ||  							TShock.CheckRangePermission(args.Player' realx' realy))  						{  							continue;  						}    						// Fixes the Flower Boots not creating flowers issue  						if (size == 1 && args.Player.Accessories.Any(i => i.active && i.netID == ItemID.FlowerBoots))  						{  							if (Main.tile[realx' realy + 1].type == TileID.Grass && (newtile.Type == TileID.Plants || newtile.Type == TileID.Plants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.HallowedGrass && (newtile.Type == TileID.HallowedPlants || newtile.Type == TileID.HallowedPlants2))  							{  								return false;  							}    							if (Main.tile[realx' realy + 1].type == TileID.JungleGrass && newtile.Type == TileID.JunglePlants2)  							{  								return false;  							}  						}    						// Junction Box  						if (tile.type == TileID.WirePipe)  							return false;    						// Orientable tiles  						if (tile.type == newtile.Type && orientableTiles.Contains(tile.type))  						{  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							changed = true;  						}  						// Landmine  						if (tile.type == TileID.LandMine && !newtile.Active)  						{  							Main.tile[realx' realy].active(false);  							changed = true;  						}  						// Sensors  						if(newtile.Type == TileID.LogicSensor && !Main.tile[realx' realy].active())  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(true);  							changed = true;  						}    						if (tile.active() && newtile.Active && tile.type != newtile.Type)  						{  							// Grass <-> Grass  							if ((TileID.Sets.Conversion.Grass[tile.type] && TileID.Sets.Conversion.Grass[newtile.Type]) ||  								// Dirt <-> Dirt  								((tile.type == 0 || tile.type == 59) &&  								(newtile.Type == 0 || newtile.Type == 59)) ||  								// Ice <-> Ice  								(TileID.Sets.Conversion.Ice[tile.type] && TileID.Sets.Conversion.Ice[newtile.Type]) ||  								// Stone <-> Stone  								((TileID.Sets.Conversion.Stone[tile.type] || Main.tileMoss[tile.type]) &&  								(TileID.Sets.Conversion.Stone[newtile.Type] || Main.tileMoss[newtile.Type])) ||  								// Sand <-> Sand  								(TileID.Sets.Conversion.Sand[tile.type] && TileID.Sets.Conversion.Sand[newtile.Type]) ||  								// Sandstone <-> Sandstone  								(TileID.Sets.Conversion.Sandstone[tile.type] && TileID.Sets.Conversion.Sandstone[newtile.Type]) ||  								// Hardened Sand <-> Hardened Sand  								(TileID.Sets.Conversion.HardenedSand[tile.type] && TileID.Sets.Conversion.HardenedSand[newtile.Type]))  							{  								Main.tile[realx' realy].type = newtile.Type;  								changed = true;  							}  						}  						// Stone wall <-> Stone wall  						if (((tile.wall == 1 || tile.wall == 3 || tile.wall == 28 || tile.wall == 83) &&  							(newtile.Wall == 1 || newtile.Wall == 3 || newtile.Wall == 28 || newtile.Wall == 83)) ||  							// Leaf wall <-> Leaf wall  							(((tile.wall >= 63 && tile.wall <= 70) || tile.wall == 81) &&  							((newtile.Wall >= 63 && newtile.Wall <= 70) || newtile.Wall == 81)))  						{  							Main.tile[realx' realy].wall = newtile.Wall;  							changed = true;  						}    						if ((tile.type == TileID.TrapdoorClosed && (newtile.Type == TileID.TrapdoorOpen || !newtile.Active)) ||  							(tile.type == TileID.TrapdoorOpen && (newtile.Type == TileID.TrapdoorClosed || !newtile.Active)) ||  							(!tile.active() && newtile.Active && (newtile.Type == TileID.TrapdoorOpen||newtile.Type == TileID.TrapdoorClosed)))  						{  							Main.tile[realx' realy].type = newtile.Type;  							Main.tile[realx' realy].frameX = newtile.FrameX;  							Main.tile[realx' realy].frameY = newtile.FrameY;  							Main.tile[realx' realy].active(newtile.Active);  							changed = true;  						}  					}  				}    				if (changed)  				{  					TSPlayer.All.SendTileSquare(tileX' tileY' size + 1);  					WorldGen.RangeFrame(tileX' tileY' tileX + size' tileY + size);  				}  				else  				{  					args.Player.SendTileSquare(tileX' tileY' size);  				}  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' size);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTile,The following statement contains a magic number: try  			{  				var editData = args.Data.ReadInt16();  				EditType type = (action == EditAction.KillTile || action == EditAction.KillWall ||  								 action == EditAction.KillTileNoItem)  								? EditType.Fail  								: (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  									? EditType.Type  									: EditType.Slope;    				var style = args.Data.ReadInt8();    				if (editData < 0)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (OnTileEdit(args.Player' tileX' tileY' action' type' editData' style))  					return true;  				if (!TShock.Utils.TilePlacementValid(tileX' tileY))  					return true;  				if (action == EditAction.KillTile && Main.tile[tileX' tileY].type == TileID.MagicalIceBlock)  					return false;  				if (args.Player.Dead && TShock.Config.PreventDeadModification)  					return true;    				if (args.Player.AwaitingName)  				{  					Debug.Assert(args.Player.AwaitingNameParameters != null);    					bool includeUnprotected = false;  					bool includeZIndexes = false;  					bool persistentMode = false;  					foreach (string parameter in args.Player.AwaitingNameParameters)  					{  						if (parameter.Equals("-u"' StringComparison.InvariantCultureIgnoreCase))  							includeUnprotected = true;  						if (parameter.Equals("-z"' StringComparison.InvariantCultureIgnoreCase))  							includeZIndexes = true;  						if (parameter.Equals("-p"' StringComparison.InvariantCultureIgnoreCase))  							persistentMode = true;  					}    					List<string> outputRegions = new List<string>();  					foreach (Region region in TShock.Regions.Regions.OrderBy(r => r.Z).Reverse())  					{  						if (!includeUnprotected && !region.DisableBuild)  							continue;  						if (tileX < region.Area.Left || tileX > region.Area.Right)  							continue;  						if (tileY < region.Area.Top || tileY > region.Area.Bottom)  							continue;    						string format = "{1}";  						if (includeZIndexes)  							format = "{1} (z:{0})";    						outputRegions.Add(string.Format(format' region.Z' region.Name));  					}    					if (outputRegions.Count == 0)  					{  						if (includeUnprotected)  							args.Player.SendInfoMessage("There are no regions at this point.");  						else  							args.Player.SendInfoMessage("There are no regions at this point or they are not protected.");  					}  					else  					{  						if (includeUnprotected)  							args.Player.SendSuccessMessage("Regions at this point:");  						else  							args.Player.SendSuccessMessage("Protected regions at this point:");    						foreach (string line in PaginationTools.BuildLinesFromTerms(outputRegions))  							args.Player.SendMessage(line' Color.White);  					}    					if (!persistentMode)  					{  						args.Player.AwaitingName = false;  						args.Player.AwaitingNameParameters = null;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.AwaitingTempPoint > 0)  				{  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].X = tileX;  					args.Player.TempPoints[args.Player.AwaitingTempPoint - 1].Y = tileY;  					args.Player.SendInfoMessage("Set temp point {0}."' args.Player.AwaitingTempPoint);  					args.Player.SendTileSquare(tileX' tileY' 4);  					args.Player.AwaitingTempPoint = 0;  					return true;  				}    				Item selectedItem = args.Player.SelectedItem;  				int lastKilledProj = args.Player.LastKilledProjectile;  				ITile tile = Main.tile[tileX' tileY];    				if (action == EditAction.PlaceTile)  				{  					if (TShock.TileBans.TileIsBanned(editData' args.Player))  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place this tile.");  						return true;  					}  				}    				if (action == EditAction.KillTile && !Main.tileCut[tile.type] && !breakableTiles.Contains(tile.type))  				{  					//TPlayer.mount.Type 8 => Drill Containment Unit.    					// If the tile is an axe tile and they aren't selecting an axe' they're hacking.  					if (Main.tileAxe[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.axe == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a hammer tile and they aren't selecting a hammer' they're hacking.  					else if (Main.tileHammer[tile.type] && ((args.Player.TPlayer.mount.Type != 8 && selectedItem.hammer == 0) && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					// If the tile is a pickaxe tile and they aren't selecting a pickaxe' they're hacking.  					// Item frames can be modified without pickaxe tile.  					else if (tile.type != TileID.ItemFrame  						&& !Main.tileAxe[tile.type] && !Main.tileHammer[tile.type] && tile.wall == 0 && args.TPlayer.mount.Type != 8 && selectedItem.pick == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  				}  				else if (action == EditAction.KillWall)  				{  					// If they aren't selecting a hammer' they could be hacking.  					if (selectedItem.hammer == 0 && !ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0 && selectedItem.createWall == 0)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceTile && (projectileCreatesTile.ContainsKey(lastKilledProj) && editData == projectileCreatesTile[lastKilledProj]))  				{  					args.Player.LastKilledProjectile = 0;  				}  				else if (action == EditAction.PlaceTile || action == EditAction.PlaceWall)  				{  					if ((action == EditAction.PlaceTile && TShock.Config.PreventInvalidPlaceStyle) &&  						(MaxPlaceStyles.ContainsKey(editData) && style > MaxPlaceStyles[editData]) &&  						(ExtraneousPlaceStyles.ContainsKey(editData) && style > ExtraneousPlaceStyles[editData]))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// If they aren't selecting the item which creates the tile or wall' they're hacking.  					if (!(selectedItem.netID == ItemID.IceRod && editData == TileID.MagicalIceBlock) &&  						(editData != (action == EditAction.PlaceTile ? selectedItem.createTile : selectedItem.createWall) &&  						!(ropeCoilPlacements.ContainsKey(selectedItem.netID) && editData == ropeCoilPlacements[selectedItem.netID])))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}    					// Using the actuation accessory can lead to actuator hacking  					if (TShock.Itembans.ItemIsBanned("Actuator"' args.Player) && args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						args.Player.SendErrorMessage("You do not have permission to place actuators.");  						return true;  					}  					if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(selectedItem.netID)' args.Player) || editData >= (action == EditAction.PlaceTile ? Main.maxTileSets : Main.maxWallTypes))  					{  						args.Player.SendTileSquare(tileX' tileY' 4);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == 29 || editData == 97) && Main.ServerSideCharacter)  					{  						args.Player.SendErrorMessage("You cannot place this tile because server side characters are enabled.");  						args.Player.SendTileSquare(tileX' tileY' 3);  						return true;  					}  					if (action == EditAction.PlaceTile && (editData == TileID.Containers || editData == TileID.Containers2))  					{  						if (TShock.Utils.MaxChests())  						{  							args.Player.SendErrorMessage("The world's chest limit has been reached - unable to place more.");  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  						if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Boulder) ||  							(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Boulder))  						{  							args.Player.SendTileSquare(tileX' tileY' 3);  							return true;  						}  					}  				}  				else if (action == EditAction.PlaceWire || action == EditAction.PlaceWire2 || action == EditAction.PlaceWire3)  				{  					// If they aren't selecting a wrench' they're hacking.  					// WireKite = The Grand Design  					if (selectedItem.type != ItemID.Wrench  						&& selectedItem.type != ItemID.BlueWrench  						&& selectedItem.type != ItemID.GreenWrench  						&& selectedItem.type != ItemID.YellowWrench  						&& selectedItem.type != ItemID.MulticolorWrench  						&& selectedItem.type != ItemID.WireKite)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.KillActuator || action == EditAction.KillWire ||  					action == EditAction.KillWire2 || action == EditAction.KillWire3)  				{  					// If they aren't selecting the wire cutter' they're hacking.  					if (selectedItem.type != ItemID.WireCutter  						&& selectedItem.type != ItemID.WireKite  						&& selectedItem.type != ItemID.MulticolorWrench)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				else if (action == EditAction.PlaceActuator)  				{  					// If they aren't selecting the actuator and don't have the Presserator equipped' they're hacking.  					if (selectedItem.type != ItemID.Actuator && !args.Player.TPlayer.autoActuator)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  				}  				if (TShock.Config.AllowCutTilesAndBreakables && Main.tileCut[tile.type])  				{  					if (action == EditAction.KillWall)  					{  						args.Player.SendTileSquare(tileX' tileY' 1);  						return true;  					}  					return false;  				}    				if (TShock.CheckIgnores(args.Player))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckTilePermission(args.Player' tileX' tileY' editData' action))  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (TShock.CheckRangePermission(args.Player' tileX' tileY))  				{  					if (action == EditAction.PlaceTile && (editData == TileID.Rope || editData == TileID.SilkRope || editData == TileID.VineRope || editData == TileID.WebRope))  					{  						return false;  					}    					if (action == EditAction.KillTile || action == EditAction.KillWall && ItemID.Sets.Explosives[selectedItem.netID] && args.Player.RecentFuse == 0)  					{  						return false;  					}    					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TileKillThreshold >= TShock.Config.TileKillThreshold)  				{  					args.Player.Disable("Reached TileKill threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  				{  					args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  				{  					args.Player.SendTileSquare(tileX' tileY' 4);  					return true;  				}    				if ((action == EditAction.PlaceTile || action == EditAction.PlaceWall) && !args.Player.HasPermission(Permissions.ignoreplacetiledetection))  				{  					args.Player.TilePlaceThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesCreated)  						if (!args.Player.TilesCreated.ContainsKey(coords))  							args.Player.TilesCreated.Add(coords' Main.tile[tileX' tileY]);  				}    				if ((action == EditAction.KillTile || action == EditAction.KillTileNoItem || action == EditAction.KillWall) && Main.tileSolid[Main.tile[tileX' tileY].type] &&  					!args.Player.HasPermission(Permissions.ignorekilltiledetection))  				{  					args.Player.TileKillThreshold++;  					var coords = new Vector2(tileX' tileY);  					lock (args.Player.TilesDestroyed)  						if (!args.Player.TilesDestroyed.ContainsKey(coords))  							args.Player.TilesDestroyed.Add(coords' Main.tile[tileX' tileY]);  				}  				return false;  			}  			catch  			{  				args.Player.SendTileSquare(tileX' tileY' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if (type == TileID.FakeContainers && (style == 52 || style == 53))  			{  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if (type == TileID.FakeContainers && (style == 52 || style == 53))  			{  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if (type == TileID.FakeContainers && (style == 52 || style == 53))  			{  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if (TShock.CheckIgnores(args.Player))  			{  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if (type != args.TPlayer.inventory[args.TPlayer.selectedItem].createTile)  			{  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: for (int i = x; i < x + tileData.Width; i++)  			{  				for (int j = y; j < y + tileData.Height; j++)  				{  					if (TShock.CheckTilePermission(args.Player' i' j' type' EditAction.PlaceTile))  					{  						args.Player.SendTileSquare(i' j' 4);  						return true;  					}  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if ((type != TileID.Rope  					|| type != TileID.SilkRope  					|| type != TileID.VineRope  					|| type != TileID.WebRope)  					&& TShock.CheckRangePermission(args.Player' x' y))  			{  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlaceObject,The following statement contains a magic number: if (args.Player.TilePlaceThreshold >= TShock.Config.TilePlaceThreshold)  			{  				args.Player.Disable("Reached TilePlace threshold."' DisableFlags.WriteToLogAndConsole);  				args.Player.SendTileSquare(x' y' 4);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTogglePvp,The following statement contains a magic number: if (pvpMode == "disabled" || pvpMode == "always" || (DateTime.UtcNow - args.Player.LastPvPTeamChange).TotalSeconds < 5)  			{  				args.Player.SendData(PacketTypes.TogglePvp' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerTeam,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastPvPTeamChange).TotalSeconds < 5)  			{  				args.Player.SendData(PacketTypes.PlayerTeam' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pulley[2])  				vel = new Vector2(args.Data.ReadSingle()' args.Data.ReadSingle());
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pos.X < 0 || pos.Y < 0 || pos.X >= Main.maxTilesX * 16 - 16 || pos.Y >= Main.maxTilesY * 16 - 16)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (!pos.Equals(args.Player.LastNetPosition))  			{  				float distance = Vector2.Distance(new Vector2(pos.X / 16f' pos.Y / 16f)'  													new Vector2(args.Player.LastNetPosition.X / 16f' args.Player.LastNetPosition.Y / 16f));  				if (TShock.CheckIgnores(args.Player))  				{  					if (distance > TShock.Config.MaxRangeForDisabled)  					{  						if (args.Player.IgnoreActionsForCheating != "none")  						{  							args.Player.SendErrorMessage("Disabled for cheating: " + args.Player.IgnoreActionsForCheating);  						}  						else if (args.Player.IgnoreActionsForDisabledArmor != "none")  						{  							args.Player.SendErrorMessage("Disabled for banned armor: " + args.Player.IgnoreActionsForDisabledArmor);  						}  						else if (args.Player.IgnoreActionsForInventory != "none")  						{  							args.Player.SendErrorMessage("Disabled for Server Side Inventory: " + args.Player.IgnoreActionsForInventory);  						}  						else if (TShock.Config.RequireLogin && !args.Player.IsLoggedIn)  						{  							args.Player.SendErrorMessage("Please /register or /login to play!");  						}  						else if (args.Player.IgnoreActionsForClearingTrashCan)  						{  							args.Player.SendErrorMessage("You need to rejoin to ensure your trash can is cleared!");  						}  						var lastTileX = args.Player.LastNetPosition.X;  						var lastTileY = args.Player.LastNetPosition.Y - 48;  						if (!args.Player.Teleport(lastTileX' lastTileY))  						{  							args.Player.Spawn();  						}  						return true;  					}  					return true;  				}    				if (args.Player.Dead)  				{  					return true;  				}    				if (!args.Player.HasPermission(Permissions.ignorenoclipdetection) &&  					TSCheckNoclip(pos' args.TPlayer.width' args.TPlayer.height - (args.TPlayer.mount.Active ? args.Player.TPlayer.mount.HeightBoost : 0)) && !TShock.Config.IgnoreNoClip  					&& !args.TPlayer.tongued)  				{  					var lastTileX = args.Player.LastNetPosition.X;  					var lastTileY = args.Player.LastNetPosition.Y;  					if (!args.Player.Teleport(lastTileX' lastTileY))  					{  						args.Player.SendErrorMessage("You got stuck in a solid object' Sent to spawn point.");  						args.Player.Spawn();  					}  					return true;  				}  				args.Player.LastNetPosition = pos;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				string itemName = args.TPlayer.inventory[item].Name;  				if (TShock.Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(args.TPlayer.inventory[item].netID)' args.Player))  				{  					control[5] = false;  					args.Player.Disable("using a banned item ({0})".SFormat(itemName)' DisableFlags.WriteToLogAndConsole);  					args.Player.SendErrorMessage("You cannot use {0} on this server. Your actions are being ignored."' itemName);  				}    				if (args.TPlayer.inventory[item].Name == "Mana Crystal" && args.Player.TPlayer.statManaMax <= 180)  				{  					args.Player.TPlayer.statMana += 20;  					args.Player.TPlayer.statManaMax += 20;  					args.Player.PlayerData.maxMana += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Crystal" && args.Player.TPlayer.statLifeMax <= 380)  				{  					args.TPlayer.statLife += 20;  					args.TPlayer.statLifeMax += 20;  					args.Player.PlayerData.maxHealth += 20;  				}  				else if (args.TPlayer.inventory[item].Name == "Life Fruit" && args.Player.TPlayer.statLifeMax >= 400 && args.Player.TPlayer.statLifeMax <= 495)  				{  					args.TPlayer.statLife += 5;  					args.TPlayer.statLifeMax += 5;  					args.Player.PlayerData.maxHealth += 5;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pulley[0])  				args.TPlayer.pulleyDir = (byte)(pulley[1] ? 2 : 1);
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (pulley[3])  				args.TPlayer.vortexStealthActive = true;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: args.TPlayer.gravDir = pulley[4] ? 1f : -1f;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[2])  			{  				args.TPlayer.controlLeft = true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[3])  			{  				args.TPlayer.controlRight = true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[4])  			{  				args.TPlayer.controlJump = true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[5])  			{  				args.TPlayer.controlUseItem = true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerUpdate,The following statement contains a magic number: if (control[6])  			{  				args.TPlayer.direction = 1;  			}  			else  			{  				args.TPlayer.direction = -1;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.RemoveProjectile(ident' owner);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileNew,The following statement contains a magic number: if (hasPermission &&  				(type == ProjectileID.Bomb  				|| type == ProjectileID.Dynamite  				|| type == ProjectileID.StickyBomb  				|| type == ProjectileID.StickyDynamite))  			{  				//  Denotes that the player has recently set a fuse - used for cheat detection.  				args.Player.RecentFuse = 10;  				//return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The following statement contains a magic number: if (TShock.CheckProjectilePermission(args.Player' index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill)  			{  				args.Player.Disable("Does not have projectile permission to kill projectile."' DisableFlags.WriteToLogAndConsole);  				args.Player.RemoveProjectile(ident' owner);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The following statement contains a magic number: if (TShock.CheckProjectilePermission(args.Player' index' type) && type != 102 && type != 100 && !TShock.Config.IgnoreProjKill)  			{  				args.Player.Disable("Does not have projectile permission to kill projectile."' DisableFlags.WriteToLogAndConsole);  				args.Player.RemoveProjectile(ident' owner);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleProjectileKill,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.RemoveProjectile(ident' owner);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: if (dmg > 20000) //Abnormal values have the potential to cause infinite loops in the server.  			{  				TShock.Utils.ForceKick(args.Player' "Crash Exploit Attempt"' true);  				TShock.Log.ConsoleError("Death Exploit Attempt: Damage {0}"' dmg);  				return false;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: if (text.Length > 500)  			{  				TShock.Utils.Kick(TShock.Players[id]' "Crash attempt"' true);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: foreach (NPC npc in Main.npc)  			{  				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)  				{  					args.Player.RespawnTimer = TShock.Config.RespawnBossSeconds;  					break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: foreach (NPC npc in Main.npc)  			{  				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)  				{  					args.Player.RespawnTimer = TShock.Config.RespawnBossSeconds;  					break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: foreach (NPC npc in Main.npc)  			{  				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)  				{  					args.Player.RespawnTimer = TShock.Config.RespawnBossSeconds;  					break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: if (args.TPlayer.difficulty == 2 && (TShock.Config.KickOnHardcoreDeath || TShock.Config.BanOnHardcoreDeath))  			{  				if (TShock.Config.BanOnHardcoreDeath)  				{  					if (!TShock.Utils.Ban(args.Player' TShock.Config.HardcoreBanReason' false' "hardcore-death"))  						TShock.Utils.ForceKick(args.Player' "Death results in a ban' but you are immune to bans."' true);  				}  				else  				{  					TShock.Utils.ForceKick(args.Player' TShock.Config.HardcoreKickReason' true' false);  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMe,The following statement contains a magic number: if (args.TPlayer.difficulty == 2 && Main.ServerSideCharacter && args.Player.IsLoggedIn)  			{  				if (TShock.CharacterDB.RemovePlayer(args.Player.Account.ID))  				{  					TShock.CharacterDB.SeedInitialData(args.Player.Account);  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: if (dmg > 20000) //Abnormal values have the potential to cause infinite loops in the server.  			{  				TShock.Utils.ForceKick(args.Player' "Crash Exploit Attempt"' true);  				TShock.Log.ConsoleError("Death Exploit Attempt: Damage {0}"' dmg);  				return false;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: if (playerDeathReason.GetDeathText(TShock.Players[id].Name).ToString().Length > 500)  			{  				TShock.Utils.Kick(TShock.Players[id]' "Crash attempt"' true);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: foreach (NPC npc in Main.npc)  			{  				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)  				{  					args.Player.RespawnTimer = TShock.Config.RespawnBossSeconds;  					break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: foreach (NPC npc in Main.npc)  			{  				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)  				{  					args.Player.RespawnTimer = TShock.Config.RespawnBossSeconds;  					break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: foreach (NPC npc in Main.npc)  			{  				if (npc.active && (npc.boss || npc.type == 13 || npc.type == 14 || npc.type == 15) &&  					Math.Abs(args.TPlayer.Center.X - npc.Center.X) + Math.Abs(args.TPlayer.Center.Y - npc.Center.Y) < 4000f)  				{  					args.Player.RespawnTimer = TShock.Config.RespawnBossSeconds;  					break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: if (args.TPlayer.difficulty == 2 && (TShock.Config.KickOnHardcoreDeath || TShock.Config.BanOnHardcoreDeath))  			{  				if (TShock.Config.BanOnHardcoreDeath)  				{  					if (!TShock.Utils.Ban(args.Player' TShock.Config.HardcoreBanReason' false' "hardcore-death"))  						TShock.Utils.ForceKick(args.Player' "Death results in a ban' but you are immune to bans."' true);  				}  				else  				{  					TShock.Utils.ForceKick(args.Player' TShock.Config.HardcoreKickReason' true' false);  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerKillMeV2,The following statement contains a magic number: if (args.TPlayer.difficulty == 2 && Main.ServerSideCharacter && args.Player.IsLoggedIn)  			{  				if (TShock.CharacterDB.RemovePlayer(args.Player.Account.ID))  				{  					TShock.CharacterDB.SeedInitialData(args.Player.Account);  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (amount != 0)  			{  				int bucket = -1;  				if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 205)  				{  					bucket = 0;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 206)  				{  					bucket = 1;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 207)  				{  					bucket = 2;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 1128)  				{  					bucket = 3;  				}  				else if (args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3031 ||  					args.TPlayer.inventory[args.TPlayer.selectedItem].type == 3032)  				{  					bucket = 4;  				}    				if (type == 1 && !(bucket == 2 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading lava without holding a lava bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 1 && TShock.Itembans.ItemIsBanned("Lava Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned lava bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && !(bucket == 1 || bucket == 0 || bucket == 4))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading water without holding a water bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 0 && TShock.Itembans.ItemIsBanned("Water Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned water bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && !(bucket == 3 || bucket == 0))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Spreading honey without holding a honey bucket"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}    				if (type == 2 && TShock.Itembans.ItemIsBanned("Honey Bucket"' args.Player))  				{  					args.Player.SendErrorMessage("You do not have permission to perform this action.");  					args.Player.Disable("Using banned honey bucket without permissions"' DisableFlags.WriteToLogAndConsole);  					args.Player.SendTileSquare(tileX' tileY' 1);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if (TShock.CheckRangePermission(args.Player' tileX' tileY' 16))  			{  				args.Player.SendTileSquare(tileX' tileY' 1);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleLiquidSet,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendTileSquare(tileX' tileY' 1);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (TShock.CheckIgnores(args.Player))  			{  				args.Player.SendTileSquare(tileX' tileY' 3);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (flag != 0 && flag != 4 // if no container or container2 placement  				&& Main.tile[tileX' tileY].type != TileID.Containers  				&& Main.tile[tileX' tileY].type != TileID.Dressers  				&& Main.tile[tileX' tileY].type != TileID.Containers2  				&& (!TShock.Utils.MaxChests() && Main.tile[tileX' tileY].type != TileID.Dirt)) //Chest  			{  				args.Player.SendTileSquare(tileX' tileY' 3);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (flag != 0 && flag != 4 // if no container or container2 placement  				&& Main.tile[tileX' tileY].type != TileID.Containers  				&& Main.tile[tileX' tileY].type != TileID.Dressers  				&& Main.tile[tileX' tileY].type != TileID.Containers2  				&& (!TShock.Utils.MaxChests() && Main.tile[tileX' tileY].type != TileID.Dirt)) //Chest  			{  				args.Player.SendTileSquare(tileX' tileY' 3);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (flag == 2) //place dresser  			{  				if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Teleporter) ||  					(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Teleporter))  				{  					//Prevent a dresser from being placed on a teleporter' as this can cause client and server crashes.  					args.Player.SendTileSquare(tileX' tileY' 3);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (flag == 2) //place dresser  			{  				if ((TShock.Utils.TilePlacementValid(tileX' tileY + 1) && Main.tile[tileX' tileY + 1].type == TileID.Teleporter) ||  					(TShock.Utils.TilePlacementValid(tileX + 1' tileY + 1) && Main.tile[tileX + 1' tileY + 1].type == TileID.Teleporter))  				{  					//Prevent a dresser from being placed on a teleporter' as this can cause client and server crashes.  					args.Player.SendTileSquare(tileX' tileY' 3);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (TShock.CheckTilePermission(args.Player' tileX' tileY))  			{  				args.Player.SendTileSquare(tileX' tileY' 3);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTileKill,The following statement contains a magic number: if (TShock.CheckRangePermission(args.Player' tileX' tileY))  			{  				args.Player.SendTileSquare(tileX' tileY' 3);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if (args.Player.InitSpawn && args.TPlayer.inventory[args.TPlayer.selectedItem].type != 50)  			{  				if (args.TPlayer.difficulty == 1 && (TShock.Config.KickOnMediumcoreDeath || TShock.Config.BanOnMediumcoreDeath))  				{  					if (args.TPlayer.selectedItem != 50)  					{  						if (TShock.Config.BanOnMediumcoreDeath)  						{  							if (!TShock.Utils.Ban(args.Player' TShock.Config.MediumcoreBanReason' false' "mediumcore-death"))  								TShock.Utils.ForceKick(args.Player' "Death results in a ban' but you are immune to bans."' true);  						}  						else  						{  							TShock.Utils.ForceKick(args.Player' TShock.Config.MediumcoreKickReason' true' false);  						}  						return true;  					}  				}  			}  			else  				args.Player.InitSpawn = true;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if (args.Player.InitSpawn && args.TPlayer.inventory[args.TPlayer.selectedItem].type != 50)  			{  				if (args.TPlayer.difficulty == 1 && (TShock.Config.KickOnMediumcoreDeath || TShock.Config.BanOnMediumcoreDeath))  				{  					if (args.TPlayer.selectedItem != 50)  					{  						if (TShock.Config.BanOnMediumcoreDeath)  						{  							if (!TShock.Utils.Ban(args.Player' TShock.Config.MediumcoreBanReason' false' "mediumcore-death"))  								TShock.Utils.ForceKick(args.Player' "Death results in a ban' but you are immune to bans."' true);  						}  						else  						{  							TShock.Utils.ForceKick(args.Player' TShock.Config.MediumcoreKickReason' true' false);  						}  						return true;  					}  				}  			}  			else  				args.Player.InitSpawn = true;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawn,The following statement contains a magic number: if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0) && (args.TPlayer.SpawnX > 0) && ((args.TPlayer.SpawnX != args.Player.sX) && (args.TPlayer.SpawnY != args.Player.sY)))  			{    				args.Player.sX = args.TPlayer.SpawnX;  				args.Player.sY = args.TPlayer.SpawnY;    				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}    			else if ((Main.ServerSideCharacter) && (args.Player.sX > 0) && (args.Player.sY > 0))  			{  				if (((Main.tile[args.Player.sX' args.Player.sY - 1].active() && Main.tile[args.Player.sX' args.Player.sY - 1].type == 79)) && (WorldGen.StartRoomCheck(args.Player.sX' args.Player.sY - 1)))  					args.Player.Teleport(args.Player.sX * 16' (args.Player.sY * 16) - 48);  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleChestActive,The following statement contains a magic number: if (nameLen != 0 && nameLen <= 20)  				args.Data.ReadString();
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerAddBuff,The following statement contains a magic number: if (TShock.CheckRangePermission(args.Player' TShock.Players[id].TileX' TShock.Players[id].TileY' 50))  			{  				args.Player.SendData(PacketTypes.PlayerAddBuff' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerAddBuff,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendData(PacketTypes.PlayerAddBuff' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemDrop,The following statement contains a magic number: if (type < -48 || type >= Main.maxItemTypes)  			{  				// Causes item duplications. Will be re added later if necessary  				//args.Player.SendData(PacketTypes.ItemDrop' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemOwner,The following statement contains a magic number: if (id < 0 || id > 400)  				return true;
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemOwner,The following statement contains a magic number: if (id == 400 && owner == 255)  			{  				args.Player.IgnoreSSCPackets = false;  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleItemOwner,The following statement contains a magic number: if (id == 400 && owner == 255)  			{  				args.Player.IgnoreSSCPackets = false;  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamage,The following statement contains a magic number: if (TShock.CheckRangePermission(args.Player' TShock.Players[id].TileX' TShock.Players[id].TileY' 100))  			{  				args.Player.SendData(PacketTypes.PlayerHp' ""' id);  				args.Player.SendData(PacketTypes.PlayerUpdate' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamage,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendData(PacketTypes.PlayerHp' ""' id);  				args.Player.SendData(PacketTypes.PlayerUpdate' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamageV2,The following statement contains a magic number: if (TShock.CheckRangePermission(args.Player' TShock.Players[id].TileX' TShock.Players[id].TileY' 100))  			{  				args.Player.SendData(PacketTypes.PlayerHp' ""' id);  				args.Player.SendData(PacketTypes.PlayerUpdate' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerDamageV2,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendData(PacketTypes.PlayerHp' ""' id);  				args.Player.SendData(PacketTypes.PlayerUpdate' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcStrike,The following statement contains a magic number: if (TShock.Config.RangeChecks &&  				TShock.CheckRangePermission(args.Player' (int)(Main.npc[id].position.X / 16f)' (int)(Main.npc[id].position.Y / 16f)' 128))  			{  				args.Player.SendData(PacketTypes.NpcUpdate' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleNpcStrike,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendData(PacketTypes.NpcUpdate' ""' id);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpecial,The following statement contains a magic number: if (type == 3 & !args.Player.HasPermission(Permissions.usesundial))  			{  				args.Player.SendErrorMessage("You do not have permission to use the Enchanted Sundial!");  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerAnimation,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				args.Player.SendData(PacketTypes.PlayerAnimation' ""' args.Player.Index);  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: for (int i = 0; i < Terraria.Player.maxBuffs; i++)  			{  				var buff = args.Data.ReadInt8();    				/*if (TShock.Itembans.ItemBans.Any(s =>  				{  					Item item = new Item();  					item.SetDefaults(s.Name);  					return item.buffType == buff;  				}))  				{  					buff = 0;  				}*/    				if (buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile)  					buff = 0;    				if (Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149))  					buff = 0;    				args.TPlayer.buffType[i] = buff;  				if (args.TPlayer.buffType[i] > 0)  				{  					args.TPlayer.buffTime[i] = 60;  				}  				else  				{  					args.TPlayer.buffTime[i] = 0;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: for (int i = 0; i < Terraria.Player.maxBuffs; i++)  			{  				var buff = args.Data.ReadInt8();    				/*if (TShock.Itembans.ItemBans.Any(s =>  				{  					Item item = new Item();  					item.SetDefaults(s.Name);  					return item.buffType == buff;  				}))  				{  					buff = 0;  				}*/    				if (buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile)  					buff = 0;    				if (Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149))  					buff = 0;    				args.TPlayer.buffType[i] = buff;  				if (args.TPlayer.buffType[i] > 0)  				{  					args.TPlayer.buffTime[i] = 60;  				}  				else  				{  					args.TPlayer.buffTime[i] = 0;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: for (int i = 0; i < Terraria.Player.maxBuffs; i++)  			{  				var buff = args.Data.ReadInt8();    				/*if (TShock.Itembans.ItemBans.Any(s =>  				{  					Item item = new Item();  					item.SetDefaults(s.Name);  					return item.buffType == buff;  				}))  				{  					buff = 0;  				}*/    				if (buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile)  					buff = 0;    				if (Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149))  					buff = 0;    				args.TPlayer.buffType[i] = buff;  				if (args.TPlayer.buffType[i] > 0)  				{  					args.TPlayer.buffTime[i] = 60;  				}  				else  				{  					args.TPlayer.buffTime[i] = 0;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: for (int i = 0; i < Terraria.Player.maxBuffs; i++)  			{  				var buff = args.Data.ReadInt8();    				/*if (TShock.Itembans.ItemBans.Any(s =>  				{  					Item item = new Item();  					item.SetDefaults(s.Name);  					return item.buffType == buff;  				}))  				{  					buff = 0;  				}*/    				if (buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile)  					buff = 0;    				if (Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149))  					buff = 0;    				args.TPlayer.buffType[i] = buff;  				if (args.TPlayer.buffType[i] > 0)  				{  					args.TPlayer.buffTime[i] = 60;  				}  				else  				{  					args.TPlayer.buffTime[i] = 0;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: for (int i = 0; i < Terraria.Player.maxBuffs; i++)  			{  				var buff = args.Data.ReadInt8();    				/*if (TShock.Itembans.ItemBans.Any(s =>  				{  					Item item = new Item();  					item.SetDefaults(s.Name);  					return item.buffType == buff;  				}))  				{  					buff = 0;  				}*/    				if (buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile)  					buff = 0;    				if (Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149))  					buff = 0;    				args.TPlayer.buffType[i] = buff;  				if (args.TPlayer.buffType[i] > 0)  				{  					args.TPlayer.buffTime[i] = 60;  				}  				else  				{  					args.TPlayer.buffTime[i] = 0;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePlayerBuffList,The following statement contains a magic number: for (int i = 0; i < Terraria.Player.maxBuffs; i++)  			{  				var buff = args.Data.ReadInt8();    				/*if (TShock.Itembans.ItemBans.Any(s =>  				{  					Item item = new Item();  					item.SetDefaults(s.Name);  					return item.buffType == buff;  				}))  				{  					buff = 0;  				}*/    				if (buff == 10 && TShock.Config.DisableInvisPvP && args.TPlayer.hostile)  					buff = 0;    				if (Netplay.Clients[args.TPlayer.whoAmI].State < 2 && (buff == 156 || buff == 47 || buff == 149))  					buff = 0;    				args.TPlayer.buffType[i] = buff;  				if (args.TPlayer.buffType[i] > 0)  				{  					args.TPlayer.buffTime[i] = 60;  				}  				else  				{  					args.TPlayer.buffTime[i] = 0;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (!spawnboss)  			{  				switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: switch (Type)  			{  				case -8:  					boss = "a Moon Lord";  					break;  				case -7:  					boss = "a Martian invasion";  					break;  				case -6:  					boss = "an eclipse";  					break;  				case -5:  					boss = "a frost moon";  					break;  				case -4:  					boss = "a pumpkin moon";  					break;  				case -3:  					boss = "the Pirates";  					break;  				case -2:  					boss = "the Snow Legion";  					break;  				case -1:  					boss = "a Goblin Invasion";  					break;  				default:  					boss = String.Format("the {0}"' npc.FullName);  					break;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (TShock.Config.AnonymousBossInvasions)  				TShock.Utils.SendLogs(string.Format("{0} summoned {1}!"' args.Player.Name' boss)' Color.PaleVioletRed' args.Player);  			else  				TShock.Utils.Broadcast(String.Format("{0} summoned {1}!"' args.Player.Name' boss)' 175' 75' 255);
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (TShock.Config.AnonymousBossInvasions)  				TShock.Utils.SendLogs(string.Format("{0} summoned {1}!"' args.Player.Name' boss)' Color.PaleVioletRed' args.Player);  			else  				TShock.Utils.Broadcast(String.Format("{0} summoned {1}!"' args.Player.Name' boss)' 175' 75' 255);
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following statement contains a magic number: if (TShock.Config.AnonymousBossInvasions)  				TShock.Utils.SendLogs(string.Format("{0} summoned {1}!"' args.Player.Name' boss)' Color.PaleVioletRed' args.Player);  			else  				TShock.Utils.Broadcast(String.Format("{0} summoned {1}!"' args.Player.Name' boss)' 175' 75' 255);
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintTile,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000 ||  				TShock.CheckTilePermission(args.Player' x' y' true) ||  				TShock.CheckRangePermission(args.Player' x' y))  			{  				args.Player.SendData(PacketTypes.PaintTile' ""' x' y' Main.tile[x' y].color());  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandlePaintWall,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000 ||  				TShock.CheckTilePermission(args.Player' x' y' true) ||  				TShock.CheckRangePermission(args.Player' x' y))  			{  				args.Player.SendData(PacketTypes.PaintWall' ""' x' y' Main.tile[x' y].wallColor());  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: if (flag[1])  			{  				type = 2;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: if (flag[2])  			{  				style++;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: if (flag[3])  			{  				style += 2;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: if (flag[3])  			{  				style += 2;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleTeleport,The following statement contains a magic number: if (type == 2)  			{  				if (id >= Main.maxPlayers || Main.player[id] == null || TShock.Players[id] == null)  				{  					return true;  				}    				if (!args.Player.HasPermission(Permissions.wormhole))  				{  					args.Player.SendErrorMessage("You do not have permission to teleport.");  					args.Player.Teleport(args.TPlayer.position.X' args.TPlayer.position.Y);  					return true;  				}  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleDoorUse,The following statement contains a magic number: if (type < 0 || type > 5)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleOldOnesArmy,The following statement contains a magic number: if ((DateTime.UtcNow - args.Player.LastThreat).TotalMilliseconds < 5000)  			{  				return true;  			}
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleOldOnesArmy,The following statement contains a magic number: if (TShock.Config.AnonymousBossInvasions)  				TShock.Utils.SendLogs(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' Color.PaleVioletRed' args.Player);  			else  				TShock.Utils.Broadcast(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' 175' 75' 255);
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleOldOnesArmy,The following statement contains a magic number: if (TShock.Config.AnonymousBossInvasions)  				TShock.Utils.SendLogs(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' Color.PaleVioletRed' args.Player);  			else  				TShock.Utils.Broadcast(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' 175' 75' 255);
Magic Number,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleOldOnesArmy,The following statement contains a magic number: if (TShock.Config.AnonymousBossInvasions)  				TShock.Utils.SendLogs(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' Color.PaleVioletRed' args.Player);  			else  				TShock.Utils.Broadcast(string.Format("{0} started the Old One's Army event!"' args.Player.Name)' 175' 75' 255);
Magic Number,TShockAPI,SuperAdminGroup,C:\repos\NyxStudios_TShock\TShockAPI\Group.cs,SuperAdminGroup,The following statement contains a magic number: B = (byte)TShock.Config.SuperAdminChatRGB[2];
Magic Number,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,WorldButcher,The following statement contains a magic number: for (int i = 0; i < Main.npc.Length; i++)  			{  				if (Main.npc[i].active && Main.npc[i].type != 0 && !Main.npc[i].townNPC && (!Main.npc[i].friendly || killFriendly))  				{  					TSPlayer.Server.StrikeNPC(i' 99999' 90f' 1);  					killcount++;  				}  			}
Magic Number,TShockAPI,RestManager,C:\repos\NyxStudios_TShock\TShockAPI\Rest\RestManager.cs,PlayerKill,The following statement contains a magic number: player.DamagePlayer(999999);
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,Start,The following statement contains a magic number: _client = new HttpClient()  			{  				Timeout = new TimeSpan(0' 0' 5)  			};
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,Start,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Wait 5 minutes  					await Task.Delay(1000 * 60 * 5);  					//Then update again  					await SendUpdateAsync();  				} while (true);  			})  			{  				Name = "TShock Stat Tracker Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,Start,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Wait 5 minutes  					await Task.Delay(1000 * 60 * 5);  					//Then update again  					await SendUpdateAsync();  				} while (true);  			})  			{  				Name = "TShock Stat Tracker Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,Start,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Wait 5 minutes  					await Task.Delay(1000 * 60 * 5);  					//Then update again  					await SendUpdateAsync();  				} while (true);  			})  			{  				Name = "TShock Stat Tracker Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetFreeSystemRam,The following statement contains a magic number: if (mono)  			{  				//Temporary in case mono won't work  				if (File.Exists("/proc/meminfo"))  				{  					var l = File.ReadAllLines("/proc/meminfo");  					foreach (string s in l)  					{  						if (s.StartsWith("MemFree:"))  						{  							var m = Regex.Match(s' "MemFree:(\\s*)(\\d*) kB");  							if (m.Success)  							{  								long val;  								if (long.TryParse(m.Groups[2].Value' out val))  								{  									return val / 1024;  								}  							}  						}  					}  				}  				return -1;  			}  			else  			{  				var pc = new PerformanceCounter("Memory"' "Available MBytes");  				return pc.RawValue;  			}
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetFreeSystemRam,The following statement contains a magic number: if (mono)  			{  				//Temporary in case mono won't work  				if (File.Exists("/proc/meminfo"))  				{  					var l = File.ReadAllLines("/proc/meminfo");  					foreach (string s in l)  					{  						if (s.StartsWith("MemFree:"))  						{  							var m = Regex.Match(s' "MemFree:(\\s*)(\\d*) kB");  							if (m.Success)  							{  								long val;  								if (long.TryParse(m.Groups[2].Value' out val))  								{  									return val / 1024;  								}  							}  						}  					}  				}  				return -1;  			}  			else  			{  				var pc = new PerformanceCounter("Memory"' "Available MBytes");  				return pc.RawValue;  			}
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetTotalSystemRam,The following statement contains a magic number: if (isMono) //Set totalMem so it can be returned later  			{  				var pc = new PerformanceCounter("Mono Memory"' "Total Physical Memory");  				totalMem = (pc.RawValue / 1024 / 1024 / 1024);  			}  			else  			{  				GetPhysicallyInstalledSystemMemory(out totalMem);  				totalMem = (totalMem / 1024 / 1024); // Super hardcore maths to convert to Gb from Kb  			}
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetTotalSystemRam,The following statement contains a magic number: if (isMono) //Set totalMem so it can be returned later  			{  				var pc = new PerformanceCounter("Mono Memory"' "Total Physical Memory");  				totalMem = (pc.RawValue / 1024 / 1024 / 1024);  			}  			else  			{  				GetPhysicallyInstalledSystemMemory(out totalMem);  				totalMem = (totalMem / 1024 / 1024); // Super hardcore maths to convert to Gb from Kb  			}
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetTotalSystemRam,The following statement contains a magic number: if (isMono) //Set totalMem so it can be returned later  			{  				var pc = new PerformanceCounter("Mono Memory"' "Total Physical Memory");  				totalMem = (pc.RawValue / 1024 / 1024 / 1024);  			}  			else  			{  				GetPhysicallyInstalledSystemMemory(out totalMem);  				totalMem = (totalMem / 1024 / 1024); // Super hardcore maths to convert to Gb from Kb  			}
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetTotalSystemRam,The following statement contains a magic number: if (isMono) //Set totalMem so it can be returned later  			{  				var pc = new PerformanceCounter("Mono Memory"' "Total Physical Memory");  				totalMem = (pc.RawValue / 1024 / 1024 / 1024);  			}  			else  			{  				GetPhysicallyInstalledSystemMemory(out totalMem);  				totalMem = (totalMem / 1024 / 1024); // Super hardcore maths to convert to Gb from Kb  			}
Magic Number,TShockAPI,StatTracker,C:\repos\NyxStudios_TShock\TShockAPI\StatTracker.cs,GetTotalSystemRam,The following statement contains a magic number: if (isMono) //Set totalMem so it can be returned later  			{  				var pc = new PerformanceCounter("Mono Memory"' "Total Physical Memory");  				totalMem = (pc.RawValue / 1024 / 1024 / 1024);  			}  			else  			{  				GetPhysicallyInstalledSystemMemory(out totalMem);  				totalMem = (totalMem / 1024 / 1024); // Super hardcore maths to convert to Gb from Kb  			}
Magic Number,TShockAPI,TSServerPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,SpawnNPC,The following statement contains a magic number: for (int i = 0; i < amount; i++)  			{  				int spawnTileX;  				int spawnTileY;  				TShock.Utils.GetRandomClearTileWithInRange(startTileX' startTileY' tileXRange' tileYRange' out spawnTileX'  															 out spawnTileY);  				NPC.NewNPC(spawnTileX * 16' spawnTileY * 16' type);  			}
Magic Number,TShockAPI,TSServerPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,SpawnNPC,The following statement contains a magic number: for (int i = 0; i < amount; i++)  			{  				int spawnTileX;  				int spawnTileY;  				TShock.Utils.GetRandomClearTileWithInRange(startTileX' startTileY' tileXRange' tileYRange' out spawnTileX'  															 out spawnTileY);  				NPC.NewNPC(spawnTileX * 16' spawnTileY * 16' type);  			}
Magic Number,TShockAPI,TSServerPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSServerPlayer.cs,RevertTiles,The following statement contains a magic number: foreach (Vector2 coords in tiles.Keys)  			{  				All.SendTileSquare((int)coords.X' (int)coords.Y' 3);  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetRandomClearTileWithInRange,The following statement contains a magic number: do  			{  				if (j == 100)  				{  					tileX = startTileX;  					tileY = startTileY;  					break;  				}  				tileX = startTileX + r.Next(tileXRange*-1' tileXRange);  				tileY = startTileY + r.Next(tileYRange*-1' tileYRange);  				j++;  			} while (TilePlacementValid(tileX' tileY) && TileSolid(tileX' tileY));
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,GetNPCByName,The following statement contains a magic number: for (int i = -17; i < Main.maxNPCTypes; i++)  			{  				string englishName = EnglishLanguage.GetNpcNameById(i).ToLowerInvariant();    				npc.SetDefaults(i);  				if (npc.FullName.ToLowerInvariant() == nameLower || npc.TypeName.ToLowerInvariant() == nameLower  					|| nameLower == englishName)  					return new List<NPC> { npc };  				if (npc.FullName.ToLowerInvariant().StartsWith(nameLower) || npc.TypeName.ToLowerInvariant().StartsWith(nameLower)  					|| englishName?.StartsWith(nameLower) == true)  					found.Add((NPC)npc.Clone());  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: var sb = new StringBuilder(3);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)  			{  				if (Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+'))  					sb.Append(str[i]);  				else  				{  					int num;  					if (!int.TryParse(sb.ToString()' out num))  						return false;    					sb.Clear();  					switch (str[i])  					{  						case 's':  							seconds += num;  							break;  						case 'm':  							seconds += num * 60;  							break;  						case 'h':  							seconds += num * 60 * 60;  							break;  						case 'd':  							seconds += num * 60 * 60 * 24;  							break;  						default:  							return false;  					}  				}  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)  			{  				if (Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+'))  					sb.Append(str[i]);  				else  				{  					int num;  					if (!int.TryParse(sb.ToString()' out num))  						return false;    					sb.Clear();  					switch (str[i])  					{  						case 's':  							seconds += num;  							break;  						case 'm':  							seconds += num * 60;  							break;  						case 'h':  							seconds += num * 60 * 60;  							break;  						case 'd':  							seconds += num * 60 * 60 * 24;  							break;  						default:  							return false;  					}  				}  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)  			{  				if (Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+'))  					sb.Append(str[i]);  				else  				{  					int num;  					if (!int.TryParse(sb.ToString()' out num))  						return false;    					sb.Clear();  					switch (str[i])  					{  						case 's':  							seconds += num;  							break;  						case 'm':  							seconds += num * 60;  							break;  						case 'h':  							seconds += num * 60 * 60;  							break;  						case 'd':  							seconds += num * 60 * 60 * 24;  							break;  						default:  							return false;  					}  				}  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)  			{  				if (Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+'))  					sb.Append(str[i]);  				else  				{  					int num;  					if (!int.TryParse(sb.ToString()' out num))  						return false;    					sb.Clear();  					switch (str[i])  					{  						case 's':  							seconds += num;  							break;  						case 'm':  							seconds += num * 60;  							break;  						case 'h':  							seconds += num * 60 * 60;  							break;  						case 'd':  							seconds += num * 60 * 60 * 24;  							break;  						default:  							return false;  					}  				}  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)  			{  				if (Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+'))  					sb.Append(str[i]);  				else  				{  					int num;  					if (!int.TryParse(sb.ToString()' out num))  						return false;    					sb.Clear();  					switch (str[i])  					{  						case 's':  							seconds += num;  							break;  						case 'm':  							seconds += num * 60;  							break;  						case 'h':  							seconds += num * 60 * 60;  							break;  						case 'd':  							seconds += num * 60 * 60 * 24;  							break;  						default:  							return false;  					}  				}  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,TryParseTime,The following statement contains a magic number: for (int i = 0; i < str.Length; i++)  			{  				if (Char.IsDigit(str[i]) || (str[i] == '-' || str[i] == '+'))  					sb.Append(str[i]);  				else  				{  					int num;  					if (!int.TryParse(sb.ToString()' out num))  						return false;    					sb.Clear();  					switch (str[i])  					{  						case 's':  							seconds += num;  							break;  						case 'm':  							seconds += num * 60;  							break;  						case 'h':  							seconds += num * 60 * 60;  							break;  						case 'd':  							seconds += num * 60 * 60 * 24;  							break;  						default:  							return false;  					}  				}  			}
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,SearchProjectile,The following statement contains a magic number: return 1000;
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeColor,The following statement contains a magic number: return new Color(data[0]' data[1]' data[2]' data[3]);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeColor,The following statement contains a magic number: return new Color(data[0]' data[1]' data[2]' data[3]);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeBoolArray,The following statement contains a magic number: bool[] result = new bool[10];
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,EncodeBitsByte,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				if (bitsByte.Value[i])  					result |= (byte)(1 << i);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DecodeBitsByte,The following statement contains a magic number: for (int i = 0; i < 8; i++)  				result[i] = (encodedBitsByte & 1 << i) != 0;
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_0.txt"' 1' 235);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_1.txt"' 235' 604);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_1.txt"' 235' 604);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_2.txt"' 604' 2749);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_2.txt"' 604' 2749);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,Dump,The following statement contains a magic number: DumpItems("Items-1_3.txt"' 2749' Main.maxItemTypes);
Magic Number,TShockAPI,Utils,C:\repos\NyxStudios_TShock\TShockAPI\Utils.cs,DumpNPCs,The following statement contains a magic number: for (int i = -65; i < Main.maxNPCTypes; i++)  			{  				NPC npc = new NPC();  				npc.SetDefaults(i);  				if (!String.IsNullOrEmpty(npc.FullName))  				{  					object[] element = new object[] { i' npc.FullName' npc.TypeName };  					elements.Add(element);  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,TShock,The following statement contains a magic number: ServerSideCharacterConfig.StartingInventory.Add(new NetItem(-15' 1' 0));
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,TShock,The following statement contains a magic number: ServerSideCharacterConfig.StartingInventory.Add(new NetItem(-13' 1' 0));
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,TShock,The following statement contains a magic number: ServerSideCharacterConfig.StartingInventory.Add(new NetItem(-16' 1' 0));
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,Initialize,The following statement contains a magic number: try  			{  				if (Config.StorageType.ToLower() == "sqlite")  				{  					string sql = Path.Combine(SavePath' "tshock.sqlite");  					DB = new SqliteConnection(string.Format("uri=file://{0}'Version=3"' sql));  				}  				else if (Config.StorageType.ToLower() == "mysql")  				{  					try  					{  						var hostport = Config.MySqlHost.Split(':');  						DB = new MySqlConnection();  						DB.ConnectionString =  							String.Format("Server={0}; Port={1}; Database={2}; Uid={3}; Pwd={4};"'  								hostport[0]'  								hostport.Length > 1 ? hostport[1] : "3306"'  								Config.MySqlDbName'  								Config.MySqlUsername'  								Config.MySqlPassword  								);  					}  					catch (MySqlException ex)  					{  						ServerApi.LogWriter.PluginWriteLine(this' ex.ToString()' TraceLevel.Error);  						throw new Exception("MySql not setup correctly");  					}  				}  				else  				{  					throw new Exception("Invalid storage type");  				}    				if (Config.UseSqlLogs)  					Log = new SqlLog(DB' logFilename' LogClear);  				else  					Log = new TextLog(logFilename' LogClear);    				if (File.Exists(Path.Combine(SavePath' "tshock.pid")))  				{  					Log.ConsoleInfo(  						"TShock was improperly shut down. Please use the exit command in the future to prevent this.");  					File.Delete(Path.Combine(SavePath' "tshock.pid"));  				}  				File.WriteAllText(Path.Combine(SavePath' "tshock.pid")'  					Process.GetCurrentProcess().Id.ToString(CultureInfo.InvariantCulture));    				CliParser.Reset();  				HandleCommandLinePostConfigLoad(Environment.GetCommandLineArgs());    				Backups = new BackupManager(Path.Combine(SavePath' "backups"));  				Backups.KeepFor = Config.BackupKeepFor;  				Backups.Interval = Config.BackupInterval;  				Bans = new BanManager(DB);  				Warps = new WarpManager(DB);  				Regions = new RegionManager(DB);  				UserAccounts = new UserAccountManager(DB);  				Groups = new GroupManager(DB);  				Itembans = new ItemManager(DB);  				ProjectileBans = new ProjectileManagager(DB);  				TileBans = new TileManager(DB);  				RememberedPos = new RememberedPosManager(DB);  				CharacterDB = new CharacterManager(DB);  				RestApi = new SecureRest(Netplay.ServerIP' Config.RestApiPort);  				RestManager = new RestManager(RestApi);  				RestManager.RegisterRestfulCommands();    				var geoippath = "GeoIP.dat";  				if (Config.EnableGeoIP && File.Exists(geoippath))  					Geo = new GeoIPCountry(geoippath);    				Log.ConsoleInfo("TShock {0} ({1}) now running."' Version' VersionCodename);    				var systemRam = StatTracker.GetFreeSystemRam(ServerApi.RunningMono);  				if (systemRam > -1 && systemRam < 2048)  				{  					Log.ConsoleError("This machine has less than 2 gigabytes of RAM free. Be advised that it might not be enough to run TShock.");  				}    				ServerApi.Hooks.GamePostInitialize.Register(this' OnPostInit);  				ServerApi.Hooks.GameUpdate.Register(this' OnUpdate);  				ServerApi.Hooks.GameHardmodeTileUpdate.Register(this' OnHardUpdate);  				ServerApi.Hooks.GameStatueSpawn.Register(this' OnStatueSpawn);  				ServerApi.Hooks.ServerConnect.Register(this' OnConnect);  				ServerApi.Hooks.ServerJoin.Register(this' OnJoin);  				ServerApi.Hooks.ServerLeave.Register(this' OnLeave);  				ServerApi.Hooks.ServerChat.Register(this' OnChat);  				ServerApi.Hooks.ServerCommand.Register(this' ServerHooks_OnCommand);  				ServerApi.Hooks.NetGetData.Register(this' OnGetData);  				ServerApi.Hooks.NetSendData.Register(this' NetHooks_SendData);  				ServerApi.Hooks.NetGreetPlayer.Register(this' OnGreetPlayer);  				ServerApi.Hooks.NpcStrike.Register(this' NpcHooks_OnStrikeNpc);  				ServerApi.Hooks.ProjectileSetDefaults.Register(this' OnProjectileSetDefaults);  				ServerApi.Hooks.WorldStartHardMode.Register(this' OnStartHardMode);  				ServerApi.Hooks.WorldSave.Register(this' SaveManager.Instance.OnSaveWorld);  				ServerApi.Hooks.WorldChristmasCheck.Register(this' OnXmasCheck);  				ServerApi.Hooks.WorldHalloweenCheck.Register(this' OnHalloweenCheck);  				ServerApi.Hooks.NetNameCollision.Register(this' NetHooks_NameCollision);  				ServerApi.Hooks.ItemForceIntoChest.Register(this' OnItemForceIntoChest);  				ServerApi.Hooks.WorldGrassSpread.Register(this' OnWorldGrassSpread);  				Hooks.PlayerHooks.PlayerPreLogin += OnPlayerPreLogin;  				Hooks.PlayerHooks.PlayerPostLogin += OnPlayerLogin;  				Hooks.AccountHooks.AccountDelete += OnAccountDelete;  				Hooks.AccountHooks.AccountCreate += OnAccountCreate;    				GetDataHandlers.InitGetDataHandler();  				Commands.InitCommands();    				EnglishLanguage.Initialize();    				if (Config.RestApiEnabled)  					RestApi.Start();    				Log.ConsoleInfo("AutoSave " + (Config.AutoSave ? "Enabled" : "Disabled"));  				Log.ConsoleInfo("Backups " + (Backups.Interval > 0 ? "Enabled" : "Disabled"));    				if (Initialized != null)  					Initialized();    				Log.ConsoleInfo("Welcome to TShock for Terraria!");  				Log.ConsoleInfo("TShock comes with no warranty & is free software.");  				Log.ConsoleInfo("You can modify & distribute it under the terms of the GNU GPLv3.");  			}  			catch (Exception ex)  			{  				Log.Error("Fatal Startup Exception");  				Log.Error(ex.ToString());  				Environment.Exit(1);  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPlayerLogin,The following statement contains a magic number: if (KnownIps.Count == 0)  			{  				KnownIps.Add(args.Player.IP);  			}  			else  			{  				bool last = KnownIps.Last() == args.Player.IP;  				if (!last)  				{  					if (KnownIps.Count == 100)  					{  						KnownIps.RemoveAt(0);  					}    					KnownIps.Add(args.Player.IP);  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The following statement contains a magic number: if (File.Exists(Path.Combine(SavePath' "auth.lck")) || UserAccounts.GetUserAccounts().Exists(u => u.Group == new SuperAdminGroup().Name))  			{  				AuthToken = 0;    				if (File.Exists(Path.Combine(SavePath' "authcode.txt")))  				{  					Log.ConsoleInfo("A superadmin account has been detected in the user database' but authcode.txt is still present.");  					Log.ConsoleInfo("TShock will now disable the auth system and remove authcode.txt as it is no longer needed.");  					File.Delete(Path.Combine(SavePath' "authcode.txt"));  				}    				if (!File.Exists(Path.Combine(SavePath' "auth.lck")))  				{  					// This avoids unnecessary database work' which can get ridiculously high on old servers as all users need to be fetched  					File.Create(Path.Combine(SavePath' "auth.lck"));  				}  			}  			else if (!File.Exists(Path.Combine(SavePath' "authcode.txt")))  			{  				var r = new Random((int)DateTime.Now.ToBinary());  				AuthToken = r.Next(100000' 10000000);  				Console.ForegroundColor = ConsoleColor.Yellow;  				Console.WriteLine("TShock Notice: To become SuperAdmin' join the game and type {0}auth {1}"' Commands.Specifier' AuthToken);  				Console.WriteLine("This token will display until disabled by verification. ({0}auth)"' Commands.Specifier);  				Console.ResetColor();  				File.WriteAllText(Path.Combine(SavePath' "authcode.txt")' AuthToken.ToString());  			}  			else  			{  				AuthToken = Convert.ToInt32(File.ReadAllText(Path.Combine(SavePath' "authcode.txt")));  				Console.ForegroundColor = ConsoleColor.Yellow;  				Console.WriteLine("TShock Notice: authcode.txt is still present' and the AuthToken located in that file will be used.");  				Console.WriteLine("To become superadmin' join the game and type {0}auth {1}"' Commands.Specifier' AuthToken);  				Console.WriteLine("This token will display until disabled by verification. ({0}auth)"' Commands.Specifier);  				Console.ResetColor();  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnPostInit,The following statement contains a magic number: if (File.Exists(Path.Combine(SavePath' "auth.lck")) || UserAccounts.GetUserAccounts().Exists(u => u.Group == new SuperAdminGroup().Name))  			{  				AuthToken = 0;    				if (File.Exists(Path.Combine(SavePath' "authcode.txt")))  				{  					Log.ConsoleInfo("A superadmin account has been detected in the user database' but authcode.txt is still present.");  					Log.ConsoleInfo("TShock will now disable the auth system and remove authcode.txt as it is no longer needed.");  					File.Delete(Path.Combine(SavePath' "authcode.txt"));  				}    				if (!File.Exists(Path.Combine(SavePath' "auth.lck")))  				{  					// This avoids unnecessary database work' which can get ridiculously high on old servers as all users need to be fetched  					File.Create(Path.Combine(SavePath' "auth.lck"));  				}  			}  			else if (!File.Exists(Path.Combine(SavePath' "authcode.txt")))  			{  				var r = new Random((int)DateTime.Now.ToBinary());  				AuthToken = r.Next(100000' 10000000);  				Console.ForegroundColor = ConsoleColor.Yellow;  				Console.WriteLine("TShock Notice: To become SuperAdmin' join the game and type {0}auth {1}"' Commands.Specifier' AuthToken);  				Console.WriteLine("This token will display until disabled by verification. ({0}auth)"' Commands.Specifier);  				Console.ResetColor();  				File.WriteAllText(Path.Combine(SavePath' "authcode.txt")' AuthToken.ToString());  			}  			else  			{  				AuthToken = Convert.ToInt32(File.ReadAllText(Path.Combine(SavePath' "authcode.txt")));  				Console.ForegroundColor = ConsoleColor.Yellow;  				Console.WriteLine("TShock Notice: authcode.txt is still present' and the AuthToken located in that file will be used.");  				Console.WriteLine("To become superadmin' join the game and type {0}auth {1}"' Commands.Specifier' AuthToken);  				Console.WriteLine("This token will display until disabled by verification. ({0}auth)"' Commands.Specifier);  				Console.ResetColor();  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: if (Config.ForceTime != "normal")  			{  				switch (Config.ForceTime)  				{  					case "day":  						TSPlayer.Server.SetTime(true' 27000.0);  						break;  					case "night":  						TSPlayer.Server.SetTime(false' 16200.0);  						break;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: if (Config.ForceTime != "normal")  			{  				switch (Config.ForceTime)  				{  					case "day":  						TSPlayer.Server.SetTime(true' 27000.0);  						break;  					case "night":  						TSPlayer.Server.SetTime(false' 16200.0);  						break;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following statement contains a magic number: foreach (TSPlayer player in Players)  			{  				if (player != null && player.Active)  				{  					if (player.TilesDestroyed != null)  					{  						if (player.TileKillThreshold >= Config.TileKillThreshold)  						{  							player.Disable("Reached TileKill threshold."' flags);  							TSPlayer.Server.RevertTiles(player.TilesDestroyed);  							player.TilesDestroyed.Clear();  						}  					}  					if (player.TileKillThreshold > 0)  					{  						player.TileKillThreshold = 0;  						//We don't want to revert the entire map in case of a disable.  						lock (player.TilesDestroyed)  							player.TilesDestroyed.Clear();  					}    					if (player.TilesCreated != null)  					{  						if (player.TilePlaceThreshold >= Config.TilePlaceThreshold)  						{  							player.Disable("Reached TilePlace threshold"' flags);  							lock (player.TilesCreated)  							{  								TSPlayer.Server.RevertTiles(player.TilesCreated);  								player.TilesCreated.Clear();  							}  						}  					}  					if (player.TilePlaceThreshold > 0)  					{  						player.TilePlaceThreshold = 0;  					}    					if (player.RecentFuse > 0)  						player.RecentFuse--;    					if ((Main.ServerSideCharacter) && (player.TPlayer.SpawnX > 0) && (player.sX != player.TPlayer.SpawnX))  					{  						player.sX = player.TPlayer.SpawnX;  						player.sY = player.TPlayer.SpawnY;  					}    					if ((Main.ServerSideCharacter) && (player.sX > 0) && (player.sY > 0) && (player.TPlayer.SpawnX < 0))  					{  						player.TPlayer.SpawnX = player.sX;  						player.TPlayer.SpawnY = player.sY;  					}    					if (player.RPPending > 0)  					{  						if (player.RPPending == 1)  						{  							var pos = RememberedPos.GetLeavePos(player.Name' player.IP);  							player.Teleport(pos.X * 16' pos.Y * 16);  							player.RPPending = 0;  						}  						else  						{  							player.RPPending--;  						}  					}    					if (player.TileLiquidThreshold >= Config.TileLiquidThreshold)  					{  						player.Disable("Reached TileLiquid threshold"' flags);  					}  					if (player.TileLiquidThreshold > 0)  					{  						player.TileLiquidThreshold = 0;  					}    					if (player.ProjectileThreshold >= Config.ProjectileThreshold)  					{  						player.Disable("Reached projectile threshold"' flags);  					}  					if (player.ProjectileThreshold > 0)  					{  						player.ProjectileThreshold = 0;  					}    					if (player.PaintThreshold >= Config.TilePaintThreshold)  					{  						player.Disable("Reached paint threshold"' flags);  					}  					if (player.PaintThreshold > 0)  					{  						player.PaintThreshold = 0;  					}    					if (player.HealOtherThreshold >= TShock.Config.HealOtherThreshold)  					{  						player.Disable("Reached HealOtherPlayer threshold"' flags);  					}  					if (player.HealOtherThreshold > 0)  					{  						player.HealOtherThreshold = 0;  					}    					if (player.RespawnTimer > 0 && --player.RespawnTimer == 0 && player.Difficulty != 2)  					{  						player.Spawn();  					}    					if (Main.ServerSideCharacter && !player.IsLoggedIn)  					{  						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}  					else if (!Main.ServerSideCharacter || (Main.ServerSideCharacter && player.IsLoggedIn))  					{  						string check = "none";  						foreach (Item item in player.TPlayer.inventory)  						{  							if (!player.HasPermission(Permissions.ignorestackhackdetection) && (item.stack > item.maxStack || item.stack < 0) &&  								item.type != 0)  							{  								check = "Remove item " + item.Name + " (" + item.stack + ") exceeds max stack of " + item.maxStack;  								player.SendErrorMessage(check);  								break;  							}  						}  						player.IgnoreActionsForCheating = check;  						check = "none";  						// Please don't remove this for the time being; without it' players wearing banned equipment will only get debuffed once  						foreach (Item item in player.TPlayer.armor)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove armor/accessory " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.dye)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscEquips)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc equip " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						foreach (Item item in player.TPlayer.miscDyes)  						{  							if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(item.type)' player))  							{  								player.SetBuff(BuffID.Frozen' 330' true);  								player.SetBuff(BuffID.Stoned' 330' true);  								player.SetBuff(BuffID.Webbed' 330' true);  								check = "Remove misc dye " + item.Name;    								player.SendErrorMessage("You are wearing banned equipment. {0}"' check);  								break;  							}  						}  						player.IgnoreActionsForDisabledArmor = check;    						if (CheckIgnores(player))  						{  							player.Disable(flags: flags);  						}  						else if (Itembans.ItemIsBanned(EnglishLanguage.GetItemNameById(player.TPlayer.inventory[player.TPlayer.selectedItem].netID)' player))  						{  							player.Disable($"holding banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}"' flags);  							player.SendErrorMessage($"You are holding a banned item: {player.TPlayer.inventory[player.TPlayer.selectedItem].Name}");  						}  					}    					var oldRegion = player.CurrentRegion;  					player.CurrentRegion = Regions.GetTopRegion(Regions.InAreaRegion(player.TileX' player.TileY));    					if (oldRegion != player.CurrentRegion)  					{  						if (oldRegion != null)  						{  							RegionHooks.OnRegionLeft(player' oldRegion);  						}    						if (player.CurrentRegion != null)  						{  							RegionHooks.OnRegionEntered(player' player.CurrentRegion);  						}  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnJoin,The following statement contains a magic number: if (ban != null)  			{  				if (!Utils.HasBanExpired(ban))  				{  					DateTime exp;  					if (!DateTime.TryParse(ban.Expiration' out exp))  					{  						player.Disconnect("Permanently banned for: " + ban.Reason);  					}  					else  					{  						TimeSpan ts = exp - DateTime.UtcNow;  						int months = ts.Days / 30;  						if (months > 0)  						{  							player.Disconnect(String.Format("You are banned for {0} month{1} and {2} day{3}: {4}"'  								months' months == 1 ? "" : "s"' ts.Days' ts.Days == 1 ? "" : "s"' ban.Reason));  						}  						else if (ts.Days > 0)  						{  							player.Disconnect(String.Format("You are banned for {0} day{1} and {2} hour{3}: {4}"'  								ts.Days' ts.Days == 1 ? "" : "s"' ts.Hours' ts.Hours == 1 ? "" : "s"' ban.Reason));  						}  						else if (ts.Hours > 0)  						{  							player.Disconnect(String.Format("You are banned for {0} hour{1} and {2} minute{3}: {4}"'  								ts.Hours' ts.Hours == 1 ? "" : "s"' ts.Minutes' ts.Minutes == 1 ? "" : "s"' ban.Reason));  						}  						else if (ts.Minutes > 0)  						{  							player.Disconnect(String.Format("You are banned for {0} minute{1} and {2} second{3}: {4}"'  								ts.Minutes' ts.Minutes == 1 ? "" : "s"' ts.Seconds' ts.Seconds == 1 ? "" : "s"' ban.Reason));  						}  						else  						{  							player.Disconnect(String.Format("You are banned for {0} second{1}: {2}"'  								ts.Seconds' ts.Seconds == 1 ? "" : "s"' ban.Reason));  						}  					}  					args.Handled = true;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: if (tsplr.ReceivedInfo)  			{  				if (!tsplr.SilentKickInProgress && tsplr.State >= 3)  					Utils.Broadcast(tsplr.Name + " has left."' Color.Yellow);  				Log.Info("{0} disconnected."' tsplr.Name);    				if (tsplr.IsLoggedIn && !tsplr.IgnoreActionsForClearingTrashCan && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2))  				{  					tsplr.PlayerData.CopyCharacter(tsplr);  					CharacterDB.InsertPlayerData(tsplr);  				}    				if (Config.RememberLeavePos && !tsplr.LoginHarassed)  				{  					RememberedPos.InsertLeavePos(tsplr.Name' tsplr.IP' (int)(tsplr.X / 16)' (int)(tsplr.Y / 16));  				}    				if (tsplr.tempGroupTimer != null)  				{  					tsplr.tempGroupTimer.Stop();  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: if (tsplr.ReceivedInfo)  			{  				if (!tsplr.SilentKickInProgress && tsplr.State >= 3)  					Utils.Broadcast(tsplr.Name + " has left."' Color.Yellow);  				Log.Info("{0} disconnected."' tsplr.Name);    				if (tsplr.IsLoggedIn && !tsplr.IgnoreActionsForClearingTrashCan && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2))  				{  					tsplr.PlayerData.CopyCharacter(tsplr);  					CharacterDB.InsertPlayerData(tsplr);  				}    				if (Config.RememberLeavePos && !tsplr.LoginHarassed)  				{  					RememberedPos.InsertLeavePos(tsplr.Name' tsplr.IP' (int)(tsplr.X / 16)' (int)(tsplr.Y / 16));  				}    				if (tsplr.tempGroupTimer != null)  				{  					tsplr.tempGroupTimer.Stop();  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: if (tsplr.ReceivedInfo)  			{  				if (!tsplr.SilentKickInProgress && tsplr.State >= 3)  					Utils.Broadcast(tsplr.Name + " has left."' Color.Yellow);  				Log.Info("{0} disconnected."' tsplr.Name);    				if (tsplr.IsLoggedIn && !tsplr.IgnoreActionsForClearingTrashCan && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2))  				{  					tsplr.PlayerData.CopyCharacter(tsplr);  					CharacterDB.InsertPlayerData(tsplr);  				}    				if (Config.RememberLeavePos && !tsplr.LoginHarassed)  				{  					RememberedPos.InsertLeavePos(tsplr.Name' tsplr.IP' (int)(tsplr.X / 16)' (int)(tsplr.Y / 16));  				}    				if (tsplr.tempGroupTimer != null)  				{  					tsplr.tempGroupTimer.Stop();  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnLeave,The following statement contains a magic number: if (tsplr.ReceivedInfo)  			{  				if (!tsplr.SilentKickInProgress && tsplr.State >= 3)  					Utils.Broadcast(tsplr.Name + " has left."' Color.Yellow);  				Log.Info("{0} disconnected."' tsplr.Name);    				if (tsplr.IsLoggedIn && !tsplr.IgnoreActionsForClearingTrashCan && Main.ServerSideCharacter && (!tsplr.Dead || tsplr.TPlayer.difficulty != 2))  				{  					tsplr.PlayerData.CopyCharacter(tsplr);  					CharacterDB.InsertPlayerData(tsplr);  				}    				if (Config.RememberLeavePos && !tsplr.LoginHarassed)  				{  					RememberedPos.InsertLeavePos(tsplr.Name' tsplr.IP' (int)(tsplr.X / 16)' (int)(tsplr.Y / 16));  				}    				if (tsplr.tempGroupTimer != null)  				{  					tsplr.tempGroupTimer.Stop();  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnChat,The following statement contains a magic number: if (args.Text.Length > 500)  			{  				Utils.Kick(tsplr' "Crash attempt via long chat packet."' true);  				args.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGetData,The following statement contains a magic number: if ((player.State < 10 || player.Dead) && (int)type > 12 && (int)type != 16 && (int)type != 42 && (int)type != 50 &&  				(int)type != 38 && (int)type != 21 && (int)type != 22)  			{  				e.Handled = true;  				return;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnGreetPlayer,The following statement contains a magic number: if (Config.RememberLeavePos && (RememberedPos.GetLeavePos(player.Name' player.IP) != Vector2.Zero) && !player.LoginHarassed)  			{  				player.RPPending = 3;  				player.SendInfoMessage("You will be teleported to your last known location...");  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,NpcHooks_OnStrikeNpc,The following statement contains a magic number: if (Config.InfiniteInvasion)  			{  				if (Main.invasionSize < 10)  				{  					Main.invasionSize = 20000000;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,NpcHooks_OnStrikeNpc,The following statement contains a magic number: if (Config.InfiniteInvasion)  			{  				if (Main.invasionSize < 10)  				{  					Main.invasionSize = 20000000;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531))  				if (Config.DisableTombstones)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531))  				if (Config.DisableTombstones)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531))  				if (Config.DisableTombstones)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531))  				if (Config.DisableTombstones)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 43 || (e.Info >= 201 && e.Info <= 205) || (e.Info >= 527 && e.Info <= 531))  				if (Config.DisableTombstones)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 75)  				if (Config.DisableClownBombs)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnProjectileSetDefaults,The following statement contains a magic number: if (e.Info == 109)  				if (Config.DisableSnowBalls)  					e.Object.SetDefaults(0);
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,StartInvasion,The following statement contains a magic number: if (Config.InfiniteInvasion)  			{  				invasionSize = 20000000;  			}  			else  			{  				invasionSize = 100 + (Config.InvasionMultiplier * Utils.ActivePlayers());  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,StartInvasion,The following statement contains a magic number: if (Config.InfiniteInvasion)  			{  				invasionSize = 20000000;  			}  			else  			{  				invasionSize = 100 + (Config.InvasionMultiplier * Utils.ActivePlayers());  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckProjectilePermission,The following statement contains a magic number: if (type == 43)  			{  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckProjectilePermission,The following statement contains a magic number: if (type == 17 && Itembans.ItemIsBanned("Dirt Rod"' player))  			//Dirt Rod Projectile  			{  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckProjectilePermission,The following statement contains a magic number: if ((type == 42 || type == 65 || type == 68) && Itembans.ItemIsBanned("Sandgun"' player)) //Sandgun Projectiles  			{  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckProjectilePermission,The following statement contains a magic number: if ((type == 42 || type == 65 || type == 68) && Itembans.ItemIsBanned("Sandgun"' player)) //Sandgun Projectiles  			{  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckProjectilePermission,The following statement contains a magic number: if ((type == 42 || type == 65 || type == 68) && Itembans.ItemIsBanned("Sandgun"' player)) //Sandgun Projectiles  			{  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (!player.HasPermission(Permissions.canbuild))  			{  				if (TShock.Config.AllowIce && actionType != GetDataHandlers.EditAction.PlaceTile)  				{  					foreach (Point p in player.IceTiles)  					{  						if (p.X == tileX && p.Y == tileY && (Main.tile[p.X' p.Y].type == 0 || Main.tile[p.X' p.Y].type == 127))  						{  							player.IceTiles.Remove(p);  							return false;  						}  					}    					if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  					{  						player.SendErrorMessage("You do not have permission to build!");  						player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  					}  					return true;  				}    				if (TShock.Config.AllowIce && actionType == GetDataHandlers.EditAction.PlaceTile && tileType == 127)  				{  					player.IceTiles.Add(new Point(tileX' tileY));  					return false;  				}    				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  				{  					player.SendErrorMessage("You do not have permission to build!");  					player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (!player.HasPermission(Permissions.canbuild))  			{  				if (TShock.Config.AllowIce && actionType != GetDataHandlers.EditAction.PlaceTile)  				{  					foreach (Point p in player.IceTiles)  					{  						if (p.X == tileX && p.Y == tileY && (Main.tile[p.X' p.Y].type == 0 || Main.tile[p.X' p.Y].type == 127))  						{  							player.IceTiles.Remove(p);  							return false;  						}  					}    					if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  					{  						player.SendErrorMessage("You do not have permission to build!");  						player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  					}  					return true;  				}    				if (TShock.Config.AllowIce && actionType == GetDataHandlers.EditAction.PlaceTile && tileType == 127)  				{  					player.IceTiles.Add(new Point(tileX' tileY));  					return false;  				}    				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  				{  					player.SendErrorMessage("You do not have permission to build!");  					player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (!player.HasPermission(Permissions.canbuild))  			{  				if (TShock.Config.AllowIce && actionType != GetDataHandlers.EditAction.PlaceTile)  				{  					foreach (Point p in player.IceTiles)  					{  						if (p.X == tileX && p.Y == tileY && (Main.tile[p.X' p.Y].type == 0 || Main.tile[p.X' p.Y].type == 127))  						{  							player.IceTiles.Remove(p);  							return false;  						}  					}    					if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  					{  						player.SendErrorMessage("You do not have permission to build!");  						player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  					}  					return true;  				}    				if (TShock.Config.AllowIce && actionType == GetDataHandlers.EditAction.PlaceTile && tileType == 127)  				{  					player.IceTiles.Add(new Point(tileX' tileY));  					return false;  				}    				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  				{  					player.SendErrorMessage("You do not have permission to build!");  					player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (!player.HasPermission(Permissions.canbuild))  			{  				if (TShock.Config.AllowIce && actionType != GetDataHandlers.EditAction.PlaceTile)  				{  					foreach (Point p in player.IceTiles)  					{  						if (p.X == tileX && p.Y == tileY && (Main.tile[p.X' p.Y].type == 0 || Main.tile[p.X' p.Y].type == 127))  						{  							player.IceTiles.Remove(p);  							return false;  						}  					}    					if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  					{  						player.SendErrorMessage("You do not have permission to build!");  						player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  					}  					return true;  				}    				if (TShock.Config.AllowIce && actionType == GetDataHandlers.EditAction.PlaceTile && tileType == 127)  				{  					player.IceTiles.Add(new Point(tileX' tileY));  					return false;  				}    				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  				{  					player.SendErrorMessage("You do not have permission to build!");  					player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (!Regions.CanBuild(tileX' tileY' player))  			{  				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.RPm) > 2000)  				{  					player.SendErrorMessage("This region is protected from changes.");  					player.RPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (Config.DisableBuild)  			{  				if (!player.HasPermission(Permissions.antibuild))  				{  					if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.WPm) > 2000)  					{  						player.SendErrorMessage("The world is protected from changes.");  						player.WPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  					}  					return true;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (Config.SpawnProtection)  			{  				if (!player.HasPermission(Permissions.editspawn))  				{  					if (CheckSpawn(tileX' tileY))  					{  						if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.SPm) > 2000)  						{  							player.SendErrorMessage("Spawn is protected from changes.");  							player.SPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  						}  						return true;  					}  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if ((!paint && !player.HasPermission(Permissions.canbuild)) ||  				(paint && !player.HasPermission(Permissions.canpaint)))  			{  				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.BPm) > 2000)  				{  					if (paint)  					{  						player.SendErrorMessage("You do not have permission to paint!");  					}  					else  					{  						player.SendErrorMessage("You do not have permission to build!");  					}  					player.BPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (!Regions.CanBuild(tileX' tileY' player))  			{  				if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.RPm) > 2000)  				{  					player.SendErrorMessage("This region is protected from changes.");  					player.RPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  				}  				return true;  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (Config.DisableBuild)  			{  				if (!player.HasPermission(Permissions.antibuild))  				{  					if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.WPm) > 2000)  					{  						player.SendErrorMessage("The world is protected from changes.");  						player.WPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  					}  					return true;  				}  			}
Magic Number,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,CheckTilePermission,The following statement contains a magic number: if (Config.SpawnProtection)  			{  				if (!player.HasPermission(Permissions.editspawn))  				{  					if (CheckSpawn(tileX' tileY))  					{  						if (((DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond) - player.SPm) > 1000)  						{  							player.SendErrorMessage("Spawn is protected from changes.");  							player.SPm = DateTime.Now.Ticks / TimeSpan.TicksPerMillisecond;  						}  						return true;  					}  				}  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Logout,The following statement contains a magic number: if (Main.ServerSideCharacter)  			{  				IgnoreActionsForInventory = $"Server side characters is enabled! Please {Commands.Specifier}register or {Commands.Specifier}login to play!";  				if (!IgnoreActionsForClearingTrashCan && (!Dead || TPlayer.difficulty != 2))  				{  					PlayerData.CopyCharacter(this);  					TShock.CharacterDB.InsertPlayerData(this);  				}  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (x > Main.rightWorld - 992)  			{  				x = Main.rightWorld - 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (x > Main.rightWorld - 992)  			{  				x = Main.rightWorld - 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (x < 992)  			{  				x = 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (x < 992)  			{  				x = 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (y > Main.bottomWorld - 992)  			{  				y = Main.bottomWorld - 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (y > Main.bottomWorld - 992)  			{  				y = Main.bottomWorld - 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (y < 992)  			{  				y = 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: if (y < 992)  			{  				y = 992;  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: SendTileSquare((int)(x / 16)' (int)(y / 16)' 15);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: SendTileSquare((int)(x / 16)' (int)(y / 16)' 15);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Teleport,The following statement contains a magic number: SendTileSquare((int)(x / 16)' (int)(y / 16)' 15);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendTileSquare,The following statement contains a magic number: try  			{  				int num = (size - 1) / 2;  				int m_x = 0;  				int m_y = 0;    				if (x - num < 0)  				{  					m_x = 0;  				}  				else  				{  					m_x = x - num;  				}    				if (y - num < 0)  				{  					m_y = 0;  				}  				else  				{  					m_y = y - num;  				}    				if (m_x + size > Main.maxTilesX)  				{  					m_x = Main.maxTilesX - size;  				}    				if (m_y + size > Main.maxTilesY)  				{  					m_y = Main.maxTilesY - size;  				}    				SendData(PacketTypes.TileSendSquare' ""' size' m_x' m_y);  				return true;  			}  			catch (IndexOutOfRangeException)  			{  				// This is expected if square exceeds array.  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SendMessage,The following statement contains a magic number: SendData(PacketTypes.SmartTextMessage' msg' 255' red' green' blue' -1);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,KillPlayer,The following statement contains a magic number: NetMessage.SendPlayerDeath(Index' PlayerDeathReason.LegacyDefault()' 99999' (new Random()).Next(-1' 1)' false' -1' -1);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: SetBuff(BuffID.Frozen' 330' true);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: SetBuff(BuffID.Stoned' 330' true);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: SetBuff(BuffID.Webbed' 330' true);
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Disable,The following statement contains a magic number: if (!string.IsNullOrEmpty(reason))  			{  				if ((DateTime.UtcNow - LastDisableNotification).TotalMilliseconds > 5000)  				{  					if (flags.HasFlag(DisableFlags.WriteToConsole))  					{  						if (flags.HasFlag(DisableFlags.WriteToLog))  						{  							TShock.Log.ConsoleInfo("Player {0} has been disabled for {1}."' Name' reason);  						}  						else  						{  							Server.SendInfoMessage("Player {0} has been disabled for {1}."' Name' reason);  						}  					}    					LastDisableNotification = DateTime.UtcNow;  				}  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,Whoopie,The following statement contains a magic number: while ((DateTime.UtcNow - launch).TotalSeconds < time2 && startname == Name)  			{  				SendData(PacketTypes.NpcSpecial' number: Index' number2: 2f);  				Thread.Sleep(50);  			}
Magic Number,TShockAPI,TSPlayer,C:\repos\NyxStudios_TShock\TShockAPI\TSPlayer.cs,SetBuff,The following statement contains a magic number: if ((DateTime.UtcNow - LastThreat).TotalMilliseconds < 5000 && !bypass)  				return;
Magic Number,TShockAPI,UpdateManager,C:\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,UpdateManager,The following statement contains a magic number: _client.Timeout = new TimeSpan(0' 0' 5);
Magic Number,TShockAPI,UpdateManager,C:\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,UpdateManager,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Sleep for X minutes  					await Task.Delay(1000 * 60 * CheckXMinutes);  					//Then check again  					await CheckForUpdatesAsync(null);  				} while (true);  			})  			{  				Name = "TShock Update Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,UpdateManager,C:\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,UpdateManager,The following statement contains a magic number: Thread t = new Thread(async () =>  			{  				do  				{  					//Sleep for X minutes  					await Task.Delay(1000 * 60 * CheckXMinutes);  					//Then check again  					await CheckForUpdatesAsync(null);  				} while (true);  			})  			{  				Name = "TShock Update Thread"'  				IsBackground = true  			};
Magic Number,TShockAPI,UpdateManager,C:\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,CheckForUpdatesAsync,The following statement contains a magic number: try  			{  				CheckXMinutes = 30;  				await UpdateCheckAsync(state);  			}  			catch (Exception ex)  			{  				// Skip this run and check more frequently...    				string msg = ex.BuildExceptionString();  				//Give the console a brief  				Console.ForegroundColor = ConsoleColor.Yellow;  				Console.WriteLine($"UpdateManager warning: {msg}");  				Console.ForegroundColor = ConsoleColor.Gray;  				//And log the full exception  				TShock.Log.Warn($"UpdateManager warning: {ex.ToString()}");  				TShock.Log.ConsoleError("Retrying in 5 minutes.");  				CheckXMinutes = 5;  			}
Magic Number,TShockAPI,UpdateManager,C:\repos\NyxStudios_TShock\TShockAPI\UpdateManager.cs,CheckForUpdatesAsync,The following statement contains a magic number: try  			{  				CheckXMinutes = 30;  				await UpdateCheckAsync(state);  			}  			catch (Exception ex)  			{  				// Skip this run and check more frequently...    				string msg = ex.BuildExceptionString();  				//Give the console a brief  				Console.ForegroundColor = ConsoleColor.Yellow;  				Console.WriteLine($"UpdateManager warning: {msg}");  				Console.ForegroundColor = ConsoleColor.Gray;  				//And log the full exception  				TShock.Log.Warn($"UpdateManager warning: {ex.ToString()}");  				TShock.Log.ConsoleError("Retrying in 5 minutes.");  				CheckXMinutes = 5;  			}
Magic Number,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,RegionManager,The following statement contains a magic number: var table = new SqlTable("Regions"'  									 new SqlColumn("Id"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  									 new SqlColumn("X1"' MySqlDbType.Int32)'  									 new SqlColumn("Y1"' MySqlDbType.Int32)'  									 new SqlColumn("width"' MySqlDbType.Int32)'  									 new SqlColumn("height"' MySqlDbType.Int32)'  									 new SqlColumn("RegionName"' MySqlDbType.VarChar' 50) {Unique = true}'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  									 new SqlColumn("UserIds"' MySqlDbType.Text)'  									 new SqlColumn("Protected"' MySqlDbType.Int32)'  									 new SqlColumn("Groups"' MySqlDbType.Text)'  									 new SqlColumn("Owner"' MySqlDbType.VarChar' 50)'  									 new SqlColumn("Z"' MySqlDbType.Int32){ DefaultValue = "0" }  				);
Magic Number,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,RegionManager,The following statement contains a magic number: var table = new SqlTable("Regions"'  									 new SqlColumn("Id"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  									 new SqlColumn("X1"' MySqlDbType.Int32)'  									 new SqlColumn("Y1"' MySqlDbType.Int32)'  									 new SqlColumn("width"' MySqlDbType.Int32)'  									 new SqlColumn("height"' MySqlDbType.Int32)'  									 new SqlColumn("RegionName"' MySqlDbType.VarChar' 50) {Unique = true}'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  									 new SqlColumn("UserIds"' MySqlDbType.Text)'  									 new SqlColumn("Protected"' MySqlDbType.Int32)'  									 new SqlColumn("Groups"' MySqlDbType.Text)'  									 new SqlColumn("Owner"' MySqlDbType.VarChar' 50)'  									 new SqlColumn("Z"' MySqlDbType.Int32){ DefaultValue = "0" }  				);
Magic Number,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,RegionManager,The following statement contains a magic number: var table = new SqlTable("Regions"'  									 new SqlColumn("Id"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  									 new SqlColumn("X1"' MySqlDbType.Int32)'  									 new SqlColumn("Y1"' MySqlDbType.Int32)'  									 new SqlColumn("width"' MySqlDbType.Int32)'  									 new SqlColumn("height"' MySqlDbType.Int32)'  									 new SqlColumn("RegionName"' MySqlDbType.VarChar' 50) {Unique = true}'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  									 new SqlColumn("UserIds"' MySqlDbType.Text)'  									 new SqlColumn("Protected"' MySqlDbType.Int32)'  									 new SqlColumn("Groups"' MySqlDbType.Text)'  									 new SqlColumn("Owner"' MySqlDbType.VarChar' 50)'  									 new SqlColumn("Z"' MySqlDbType.Int32){ DefaultValue = "0" }  				);
Magic Number,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT X1' Y1' height' width FROM Regions WHERE RegionName=@0 AND WorldID=@1"'  													  regionName' Main.worldID.ToString()))  				{  					if (reader.Read())  					{  						X = reader.Get<int>("X1");  						width = reader.Get<int>("width");  						Y = reader.Get<int>("Y1");  						height = reader.Get<int>("height");  					}  				}  				switch (direction)  				{  					case 0:  						Y -= addAmount;  						height += addAmount;  						break;  					case 1:  						width += addAmount;  						break;  					case 2:  						height += addAmount;  						break;  					case 3:  						X -= addAmount;  						width += addAmount;  						break;  					default:  						return false;  				}  				  				foreach (var region in Regions.Where(r => r.Name == regionName))  					region.Area = new Rectangle(X' Y' width' height);  				int q = database.Query("UPDATE Regions SET X1 = @0' Y1 = @1' width = @2' height = @3 WHERE RegionName = @4 AND WorldID=@5"' X' Y' width'  						height' regionName' Main.worldID.ToString());  				if (q > 0)  					return true;  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,RegionManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RegionManager.cs,ResizeRegion,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT X1' Y1' height' width FROM Regions WHERE RegionName=@0 AND WorldID=@1"'  													  regionName' Main.worldID.ToString()))  				{  					if (reader.Read())  					{  						X = reader.Get<int>("X1");  						width = reader.Get<int>("width");  						Y = reader.Get<int>("Y1");  						height = reader.Get<int>("height");  					}  				}  				switch (direction)  				{  					case 0:  						Y -= addAmount;  						height += addAmount;  						break;  					case 1:  						width += addAmount;  						break;  					case 2:  						height += addAmount;  						break;  					case 3:  						X -= addAmount;  						width += addAmount;  						break;  					default:  						return false;  				}  				  				foreach (var region in Regions.Where(r => r.Name == regionName))  					region.Area = new Rectangle(X' Y' width' height);  				int q = database.Query("UPDATE Regions SET X1 = @0' Y1 = @1' width = @2' height = @3 WHERE RegionName = @4 AND WorldID=@5"' X' Y' width'  						height' regionName' Main.worldID.ToString());  				if (q > 0)  					return true;  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,BanManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\BanManager.cs,BanManager,The following statement contains a magic number: var table = new SqlTable("Bans"'  									new SqlColumn("IP"' MySqlDbType.String' 16) { Primary = true }'  									new SqlColumn("Name"' MySqlDbType.Text)'  									new SqlColumn("UUID"' MySqlDbType.Text)'  									new SqlColumn("Reason"' MySqlDbType.Text)'  									new SqlColumn("BanningUser"' MySqlDbType.Text)'  									new SqlColumn("Date"' MySqlDbType.Text)'  									new SqlColumn("Expiration"' MySqlDbType.Text)'  									new SqlColumn("AccountName"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0"' acctid))  				{  					if (reader.Read())  					{  						playerData.exists = true;  						playerData.health = reader.Get<int>("Health");  						playerData.maxHealth = reader.Get<int>("MaxHealth");  						playerData.mana = reader.Get<int>("Mana");  						playerData.maxMana = reader.Get<int>("MaxMana");  						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();  						if (inventory.Count < NetItem.MaxInventory)  						{  							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers  							//Set new armour slots empty  							inventory.InsertRange(67' new NetItem[2]);  							//Set new vanity slots empty  							inventory.InsertRange(77' new NetItem[2]);  							//Set new dye slots empty  							inventory.InsertRange(87' new NetItem[2]);  							//Set the rest of the new slots empty  							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);  						}  						playerData.inventory = inventory.ToArray();  						playerData.extraSlot = reader.Get<int>("extraSlot");  						playerData.spawnX = reader.Get<int>("spawnX");  						playerData.spawnY = reader.Get<int>("spawnY");  						playerData.skinVariant = reader.Get<int?>("skinVariant");  						playerData.hair = reader.Get<int?>("hair");  						playerData.hairDye = (byte)reader.Get<int>("hairDye");  						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));  						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));  						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));  						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));  						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));  						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));  						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));  						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));  						playerData.questsCompleted = reader.Get<int>("questsCompleted");  						return playerData;  					}  				}  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0"' acctid))  				{  					if (reader.Read())  					{  						playerData.exists = true;  						playerData.health = reader.Get<int>("Health");  						playerData.maxHealth = reader.Get<int>("MaxHealth");  						playerData.mana = reader.Get<int>("Mana");  						playerData.maxMana = reader.Get<int>("MaxMana");  						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();  						if (inventory.Count < NetItem.MaxInventory)  						{  							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers  							//Set new armour slots empty  							inventory.InsertRange(67' new NetItem[2]);  							//Set new vanity slots empty  							inventory.InsertRange(77' new NetItem[2]);  							//Set new dye slots empty  							inventory.InsertRange(87' new NetItem[2]);  							//Set the rest of the new slots empty  							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);  						}  						playerData.inventory = inventory.ToArray();  						playerData.extraSlot = reader.Get<int>("extraSlot");  						playerData.spawnX = reader.Get<int>("spawnX");  						playerData.spawnY = reader.Get<int>("spawnY");  						playerData.skinVariant = reader.Get<int?>("skinVariant");  						playerData.hair = reader.Get<int?>("hair");  						playerData.hairDye = (byte)reader.Get<int>("hairDye");  						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));  						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));  						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));  						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));  						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));  						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));  						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));  						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));  						playerData.questsCompleted = reader.Get<int>("questsCompleted");  						return playerData;  					}  				}  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0"' acctid))  				{  					if (reader.Read())  					{  						playerData.exists = true;  						playerData.health = reader.Get<int>("Health");  						playerData.maxHealth = reader.Get<int>("MaxHealth");  						playerData.mana = reader.Get<int>("Mana");  						playerData.maxMana = reader.Get<int>("MaxMana");  						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();  						if (inventory.Count < NetItem.MaxInventory)  						{  							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers  							//Set new armour slots empty  							inventory.InsertRange(67' new NetItem[2]);  							//Set new vanity slots empty  							inventory.InsertRange(77' new NetItem[2]);  							//Set new dye slots empty  							inventory.InsertRange(87' new NetItem[2]);  							//Set the rest of the new slots empty  							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);  						}  						playerData.inventory = inventory.ToArray();  						playerData.extraSlot = reader.Get<int>("extraSlot");  						playerData.spawnX = reader.Get<int>("spawnX");  						playerData.spawnY = reader.Get<int>("spawnY");  						playerData.skinVariant = reader.Get<int?>("skinVariant");  						playerData.hair = reader.Get<int?>("hair");  						playerData.hairDye = (byte)reader.Get<int>("hairDye");  						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));  						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));  						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));  						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));  						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));  						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));  						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));  						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));  						playerData.questsCompleted = reader.Get<int>("questsCompleted");  						return playerData;  					}  				}  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0"' acctid))  				{  					if (reader.Read())  					{  						playerData.exists = true;  						playerData.health = reader.Get<int>("Health");  						playerData.maxHealth = reader.Get<int>("MaxHealth");  						playerData.mana = reader.Get<int>("Mana");  						playerData.maxMana = reader.Get<int>("MaxMana");  						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();  						if (inventory.Count < NetItem.MaxInventory)  						{  							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers  							//Set new armour slots empty  							inventory.InsertRange(67' new NetItem[2]);  							//Set new vanity slots empty  							inventory.InsertRange(77' new NetItem[2]);  							//Set new dye slots empty  							inventory.InsertRange(87' new NetItem[2]);  							//Set the rest of the new slots empty  							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);  						}  						playerData.inventory = inventory.ToArray();  						playerData.extraSlot = reader.Get<int>("extraSlot");  						playerData.spawnX = reader.Get<int>("spawnX");  						playerData.spawnY = reader.Get<int>("spawnY");  						playerData.skinVariant = reader.Get<int?>("skinVariant");  						playerData.hair = reader.Get<int?>("hair");  						playerData.hairDye = (byte)reader.Get<int>("hairDye");  						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));  						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));  						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));  						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));  						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));  						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));  						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));  						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));  						playerData.questsCompleted = reader.Get<int>("questsCompleted");  						return playerData;  					}  				}  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0"' acctid))  				{  					if (reader.Read())  					{  						playerData.exists = true;  						playerData.health = reader.Get<int>("Health");  						playerData.maxHealth = reader.Get<int>("MaxHealth");  						playerData.mana = reader.Get<int>("Mana");  						playerData.maxMana = reader.Get<int>("MaxMana");  						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();  						if (inventory.Count < NetItem.MaxInventory)  						{  							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers  							//Set new armour slots empty  							inventory.InsertRange(67' new NetItem[2]);  							//Set new vanity slots empty  							inventory.InsertRange(77' new NetItem[2]);  							//Set new dye slots empty  							inventory.InsertRange(87' new NetItem[2]);  							//Set the rest of the new slots empty  							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);  						}  						playerData.inventory = inventory.ToArray();  						playerData.extraSlot = reader.Get<int>("extraSlot");  						playerData.spawnX = reader.Get<int>("spawnX");  						playerData.spawnY = reader.Get<int>("spawnY");  						playerData.skinVariant = reader.Get<int?>("skinVariant");  						playerData.hair = reader.Get<int?>("hair");  						playerData.hairDye = (byte)reader.Get<int>("hairDye");  						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));  						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));  						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));  						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));  						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));  						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));  						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));  						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));  						playerData.questsCompleted = reader.Get<int>("questsCompleted");  						return playerData;  					}  				}  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,CharacterManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\CharacterManager.cs,GetPlayerData,The following statement contains a magic number: try  			{  				using (var reader = database.QueryReader("SELECT * FROM tsCharacter WHERE Account=@0"' acctid))  				{  					if (reader.Read())  					{  						playerData.exists = true;  						playerData.health = reader.Get<int>("Health");  						playerData.maxHealth = reader.Get<int>("MaxHealth");  						playerData.mana = reader.Get<int>("Mana");  						playerData.maxMana = reader.Get<int>("MaxMana");  						List<NetItem> inventory = reader.Get<string>("Inventory").Split('~').Select(NetItem.Parse).ToList();  						if (inventory.Count < NetItem.MaxInventory)  						{  							//TODO: unhardcode this - stop using magic numbers and use NetItem numbers  							//Set new armour slots empty  							inventory.InsertRange(67' new NetItem[2]);  							//Set new vanity slots empty  							inventory.InsertRange(77' new NetItem[2]);  							//Set new dye slots empty  							inventory.InsertRange(87' new NetItem[2]);  							//Set the rest of the new slots empty  							inventory.AddRange(new NetItem[NetItem.MaxInventory - inventory.Count]);  						}  						playerData.inventory = inventory.ToArray();  						playerData.extraSlot = reader.Get<int>("extraSlot");  						playerData.spawnX = reader.Get<int>("spawnX");  						playerData.spawnY = reader.Get<int>("spawnY");  						playerData.skinVariant = reader.Get<int?>("skinVariant");  						playerData.hair = reader.Get<int?>("hair");  						playerData.hairDye = (byte)reader.Get<int>("hairDye");  						playerData.hairColor = TShock.Utils.DecodeColor(reader.Get<int?>("hairColor"));  						playerData.pantsColor = TShock.Utils.DecodeColor(reader.Get<int?>("pantsColor"));  						playerData.shirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("shirtColor"));  						playerData.underShirtColor = TShock.Utils.DecodeColor(reader.Get<int?>("underShirtColor"));  						playerData.shoeColor = TShock.Utils.DecodeColor(reader.Get<int?>("shoeColor"));  						playerData.hideVisuals = TShock.Utils.DecodeBoolArray(reader.Get<int?>("hideVisuals"));  						playerData.skinColor = TShock.Utils.DecodeColor(reader.Get<int?>("skinColor"));  						playerData.eyeColor = TShock.Utils.DecodeColor(reader.Get<int?>("eyeColor"));  						playerData.questsCompleted = reader.Get<int>("questsCompleted");  						return playerData;  					}  				}  			}  			catch (Exception ex)  			{  				TShock.Log.Error(ex.ToString());  			}
Magic Number,TShockAPI.DB,GenericQueryCreator,C:\repos\NyxStudios_TShock\TShockAPI\DB\IQueryBuilder.cs,AlterTable,The following statement contains a magic number: var rstr = rand.NextString(20);
Magic Number,TShockAPI.DB,ItemManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\ItemManager.cs,ItemManager,The following statement contains a magic number: var table = new SqlTable("ItemBans"'  			                         new SqlColumn("ItemName"' MySqlDbType.VarChar' 50) {Primary = true}'  			                         new SqlColumn("AllowedGroups"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,GroupManager,The following statement contains a magic number: var table = new SqlTable("GroupList"'  				new SqlColumn("GroupName"' MySqlDbType.VarChar' 32) { Primary = true }'  				new SqlColumn("Parent"' MySqlDbType.VarChar' 32)'  				new SqlColumn("Commands"' MySqlDbType.Text)'  				new SqlColumn("ChatColor"' MySqlDbType.Text)'  				new SqlColumn("Prefix"' MySqlDbType.Text)'  				new SqlColumn("Suffix"' MySqlDbType.Text)  			);
Magic Number,TShockAPI.DB,GroupManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\GroupManager.cs,GroupManager,The following statement contains a magic number: var table = new SqlTable("GroupList"'  				new SqlColumn("GroupName"' MySqlDbType.VarChar' 32) { Primary = true }'  				new SqlColumn("Parent"' MySqlDbType.VarChar' 32)'  				new SqlColumn("Commands"' MySqlDbType.Text)'  				new SqlColumn("ChatColor"' MySqlDbType.Text)'  				new SqlColumn("Prefix"' MySqlDbType.Text)'  				new SqlColumn("Suffix"' MySqlDbType.Text)  			);
Magic Number,TShockAPI.DB,UserAccountManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccountManager,The following statement contains a magic number: var table = new SqlTable("Users"'  				new SqlColumn("ID"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  				new SqlColumn("Username"' MySqlDbType.VarChar' 32) {Unique = true}'  				new SqlColumn("Password"' MySqlDbType.VarChar' 128)'  				new SqlColumn("UUID"' MySqlDbType.VarChar' 128)'  				new SqlColumn("Usergroup"' MySqlDbType.Text)'  				new SqlColumn("Registered"' MySqlDbType.Text)'  				new SqlColumn("LastAccessed"' MySqlDbType.Text)'  				new SqlColumn("KnownIPs"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,UserAccountManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccountManager,The following statement contains a magic number: var table = new SqlTable("Users"'  				new SqlColumn("ID"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  				new SqlColumn("Username"' MySqlDbType.VarChar' 32) {Unique = true}'  				new SqlColumn("Password"' MySqlDbType.VarChar' 128)'  				new SqlColumn("UUID"' MySqlDbType.VarChar' 128)'  				new SqlColumn("Usergroup"' MySqlDbType.Text)'  				new SqlColumn("Registered"' MySqlDbType.Text)'  				new SqlColumn("LastAccessed"' MySqlDbType.Text)'  				new SqlColumn("KnownIPs"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,UserAccountManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UserAccountManager,The following statement contains a magic number: var table = new SqlTable("Users"'  				new SqlColumn("ID"' MySqlDbType.Int32) {Primary = true' AutoIncrement = true}'  				new SqlColumn("Username"' MySqlDbType.VarChar' 32) {Unique = true}'  				new SqlColumn("Password"' MySqlDbType.VarChar' 128)'  				new SqlColumn("UUID"' MySqlDbType.VarChar' 128)'  				new SqlColumn("Usergroup"' MySqlDbType.Text)'  				new SqlColumn("Registered"' MySqlDbType.Text)'  				new SqlColumn("LastAccessed"' MySqlDbType.Text)'  				new SqlColumn("KnownIPs"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,UpgradePasswordWorkFactor,The following statement contains a magic number: try  			{  				currentWorkFactor = Int32.Parse((Password.Split('$')[2]));  			}  			catch (FormatException)  			{  				TShock.Log.ConsoleError("Warning: Not upgrading work factor because bcrypt hash in an invalid format.");  				return;  			}
Magic Number,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The following statement contains a magic number: if (password.Trim().Length < Math.Max(4' TShock.Config.MinimumPasswordLength))  			{  				throw new ArgumentOutOfRangeException("password"' "Password must be > " + TShock.Config.MinimumPasswordLength + " characters.");  			}
Magic Number,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,CreateBCryptHash,The following statement contains a magic number: if (password.Trim().Length < Math.Max(4' TShock.Config.MinimumPasswordLength))  			{  				throw new ArgumentOutOfRangeException("password"' "Password must be > " + TShock.Config.MinimumPasswordLength + " characters.");  			}
Magic Number,TShockAPI.DB,UserAccount,C:\repos\NyxStudios_TShock\TShockAPI\DB\UserManager.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				return (ID * 397) ^ (Name != null ? Name.GetHashCode() : 0);  			}
Magic Number,TShockAPI.DB,RememberedPosManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\RememberedPosManager.cs,RememberedPosManager,The following statement contains a magic number: var table = new SqlTable("RememberedPos"'  			                         new SqlColumn("Name"' MySqlDbType.VarChar' 50) {Primary = true}'  			                         new SqlColumn("IP"' MySqlDbType.Text)'  			                         new SqlColumn("X"' MySqlDbType.Int32)'  			                         new SqlColumn("Y"' MySqlDbType.Int32)'  			                         new SqlColumn("WorldID"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,WarpManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\WarpsManager.cs,WarpManager,The following statement contains a magic number: var table = new SqlTable("Warps"'  			                         new SqlColumn("Id"' MySqlDbType.Int32){Primary = true' AutoIncrement = true}'  									 new SqlColumn("WarpName"' MySqlDbType.VarChar' 50) {Unique = true}'  			                         new SqlColumn("X"' MySqlDbType.Int32)'  			                         new SqlColumn("Y"' MySqlDbType.Int32)'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  			                         new SqlColumn("Private"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.DB,WarpManager,C:\repos\NyxStudios_TShock\TShockAPI\DB\WarpsManager.cs,WarpManager,The following statement contains a magic number: var table = new SqlTable("Warps"'  			                         new SqlColumn("Id"' MySqlDbType.Int32){Primary = true' AutoIncrement = true}'  									 new SqlColumn("WarpName"' MySqlDbType.VarChar' 50) {Unique = true}'  			                         new SqlColumn("X"' MySqlDbType.Int32)'  			                         new SqlColumn("Y"' MySqlDbType.Int32)'  									 new SqlColumn("WorldID"' MySqlDbType.VarChar' 50) { Unique = true }'  			                         new SqlColumn("Private"' MySqlDbType.Text)  				);
Magic Number,TShockAPI.Extensions,RandomExt,C:\repos\NyxStudios_TShock\TShockAPI\Extensions\RandomExt.cs,NextString,The following statement contains a magic number: for (int i = 0; i < length; i++)  			{  				switch (rand.Next(0' 3))  				{  					case 0:  						sb.Append((char) rand.Next('a'' 'z' + 1));  						break;  					case 1:  						sb.Append((char) rand.Next('A'' 'Z' + 1));  						break;  					case 2:  						sb.Append((char) rand.Next('0'' '9' + 1));  						break;  				}  			}
Magic Number,TShockAPI.Extensions,RandomExt,C:\repos\NyxStudios_TShock\TShockAPI\Extensions\RandomExt.cs,NextString,The following statement contains a magic number: for (int i = 0; i < length; i++)  			{  				switch (rand.Next(0' 3))  				{  					case 0:  						sb.Append((char) rand.Next('a'' 'z' + 1));  						break;  					case 1:  						sb.Append((char) rand.Next('A'' 'Z' + 1));  						break;  					case 2:  						sb.Append((char) rand.Next('0'' '9' + 1));  						break;  				}  			}
Magic Number,TShockAPI.Localization,EnglishLanguage,C:\repos\NyxStudios_TShock\TShockAPI\Localization\EnglishLanguage.cs,Initialize,The following statement contains a magic number: try  			{  				if (!skip)  				{  					LanguageManager.Instance.SetLanguage(GameCulture.English);  				}    				for (var i = -48; i < Main.maxItemTypes; i++)  				{  					ItemNames.Add(i' Lang.GetItemNameValue(i));  				}    				for (var i = -17; i < Main.maxNPCTypes; i++)  				{  					NpcNames.Add(i' Lang.GetNPCNameValue(i));  				}    				foreach (var field in typeof(Main).Assembly.GetType("Terraria.ID.PrefixID")  							.GetFields().Where(f => !f.Name.Equals("Count"' StringComparison.Ordinal)))  				{  					Prefixs.Add((int) field.GetValue(null)' field.Name);  				}  			}  			finally  			{  				if (!skip)  				{  					LanguageManager.Instance.SetLanguage(culture);  				}  			}
Magic Number,TShockAPI.Localization,EnglishLanguage,C:\repos\NyxStudios_TShock\TShockAPI\Localization\EnglishLanguage.cs,Initialize,The following statement contains a magic number: try  			{  				if (!skip)  				{  					LanguageManager.Instance.SetLanguage(GameCulture.English);  				}    				for (var i = -48; i < Main.maxItemTypes; i++)  				{  					ItemNames.Add(i' Lang.GetItemNameValue(i));  				}    				for (var i = -17; i < Main.maxNPCTypes; i++)  				{  					NpcNames.Add(i' Lang.GetNPCNameValue(i));  				}    				foreach (var field in typeof(Main).Assembly.GetType("Terraria.ID.PrefixID")  							.GetFields().Where(f => !f.Name.Equals("Count"' StringComparison.Ordinal)))  				{  					Prefixs.Add((int) field.GetValue(null)' field.Name);  				}  			}  			finally  			{  				if (!skip)  				{  					LanguageManager.Instance.SetLanguage(culture);  				}  			}
Magic Number,Rests,SecureRest,C:\repos\NyxStudios_TShock\TShockAPI\Rest\SecureRest.cs,NewTokenInternal,The following statement contains a magic number: var randbytes = new byte[32];
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindIndex,The following statement contains a magic number: return (int) FindCountryCode(0' AddressToLong(ip)' 31);
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				long y = bytes[i];  				if (y < 0)  					y += 256;  				num += y << ((3 - i)*8);  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				long y = bytes[i];  				if (y < 0)  					y += 256;  				num += y << ((3 - i)*8);  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				long y = bytes[i];  				if (y < 0)  					y += 256;  				num += y << ((3 - i)*8);  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,AddressToLong,The following statement contains a magic number: for (int i = 0; i < 4; ++i)  			{  				long y = bytes[i];  				if (y < 0)  					y += 256;  				num += y << ((3 - i)*8);  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: byte[] buffer = new byte[6];
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: long[] x = new long[2];
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: _geodata.Seek(6*offset' SeekOrigin.Begin);
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: _geodata.Read(buffer' 0' 6);
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: for (int i = 0; i < 2; i++)  			{  				x[i] = 0;  				for (int j = 0; j < 3; j++)  				{  					int y = buffer[i*3 + j];  					if (y < 0)  						y += 256;  					x[i] += (y << (j*8));  				}  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: for (int i = 0; i < 2; i++)  			{  				x[i] = 0;  				for (int j = 0; j < 3; j++)  				{  					int y = buffer[i*3 + j];  					if (y < 0)  						y += 256;  					x[i] += (y << (j*8));  				}  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: for (int i = 0; i < 2; i++)  			{  				x[i] = 0;  				for (int j = 0; j < 3; j++)  				{  					int y = buffer[i*3 + j];  					if (y < 0)  						y += 256;  					x[i] += (y << (j*8));  				}  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: for (int i = 0; i < 2; i++)  			{  				x[i] = 0;  				for (int j = 0; j < 3; j++)  				{  					int y = buffer[i*3 + j];  					if (y < 0)  						y += 256;  					x[i] += (y << (j*8));  				}  			}
Magic Number,MaxMind,GeoIPCountry,C:\repos\NyxStudios_TShock\TShockAPI\GeoIPCountry.cs,FindCountryCode,The following statement contains a magic number: for (int i = 0; i < 2; i++)  			{  				x[i] = 0;  				for (int j = 0; j < 3; j++)  				{  					int y = buffer[i*3 + j];  					if (y < 0)  						y += 256;  					x[i] += (y << (j*8));  				}  			}
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (HasWall)  				bits[2] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (HasLiquid)  				bits[3] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (Wire)  				bits[4] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (IsHalf)  				bits[5] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (IsActuator)  				bits[6] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (Inactive)  			{  				bits[7] = true;  			}
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (HasColor)  				bits[2] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (HasWallColor)  				bits[3] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (Slope)  				bits[4] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (Slope2)  				bits[5] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Pack,The following statement contains a magic number: if (Slope3)  				bits[6] = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: Slope = flags2[4];
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: Slope2 = flags2[5];
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: Slope3 = flags2[6];
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags2[2])  			{  				TileColor = stream.ReadInt8();  			}
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags2[3])  			{  				WallColor = stream.ReadInt8();  			}
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags[2])  			{  				Wall = stream.ReadInt8();  			}
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags[3])  			{  				Liquid = stream.ReadInt8();  				LiquidType = stream.ReadInt8();  			}
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags[4])  				Wire = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags[5])  				IsHalf = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags[6])  				IsActuator = true;
Magic Number,TShockAPI.Net,NetTile,C:\repos\NyxStudios_TShock\TShockAPI\Net\NetTile.cs,Unpack,The following statement contains a magic number: if (flags[7])  			{  				Inactive = true;  				Active = false;  			}
Duplicate Code,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The method contains a code clone-set at the following line numbers (starting from the method definition): ((37' 62)' (108' 133))
Missing Default,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Invade,The following switch statement is missing a default case: switch (args.Parameters[0].ToLower())  				{  					case "goblin":  					case "goblins":  						TSPlayer.All.SendInfoMessage("{0} has started a goblin army invasion."' args.Player.Name);  						TShock.StartInvasion(1);  						break;    					case "snowman":  					case "snowmen":  						TSPlayer.All.SendInfoMessage("{0} has started a snow legion invasion."' args.Player.Name);  						TShock.StartInvasion(2);  						break;    					case "pirate":  					case "pirates":  						TSPlayer.All.SendInfoMessage("{0} has started a pirate invasion."' args.Player.Name);  						TShock.StartInvasion(3);  						break;    					case "pumpkin":  					case "pumpkinmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								break;  							}  						}    						TSPlayer.Server.SetPumpkinMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the pumpkin moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "frost":  					case "frostmoon":  						if (args.Parameters.Count > 1)  						{  							if (!int.TryParse(args.Parameters[1]' out wave) || wave <= 0)  							{  								args.Player.SendErrorMessage("Invalid wave!");  								return;  							}  						}    						TSPlayer.Server.SetFrostMoon(true);  						Main.bloodMoon = false;  						NPC.waveKills = 0f;  						NPC.waveNumber = wave;  						TSPlayer.All.SendInfoMessage("{0} started the frost moon at wave {1}!"' args.Player.Name' wave);  						break;    					case "martian":  					case "martians":  						TSPlayer.All.SendInfoMessage("{0} has started a martian invasion."' args.Player.Name);  						TShock.StartInvasion(4);  						break;  				}
Missing Default,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,Group,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add group  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group add <group name> [permissions]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						string permissions = String.Join("'"' args.Parameters);    						try  						{  							TShock.Groups.AddGroup(groupName' null' permissions' TShockAPI.Group.defaultChatColor);  							args.Player.SendSuccessMessage("The group was added successfully!");  						}  						catch (GroupExistsException)  						{  							args.Player.SendErrorMessage("That group already exists!");  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "addperm":  					#region Add permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group addperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.AddPermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.AddPermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <name> <permissions...> - Adds a new group."'  							"addperm <group> <permissions...> - Adds permissions to a group."'  							"color <group> <rrr'ggg'bbb> - Changes a group's chat color."'  							"rename <group> <new name> - Changes a group's name."'  							"del <group> - Deletes a group."'  							"delperm <group> <permissions...> - Removes permissions from a group."'  							"list [page] - Lists groups."'  							"listperm <group> [page] - Lists a group's permissions."'  							"parent <group> <parent group> - Changes a group's parent group."'  							"prefix <group> <prefix> - Changes a group's prefix."'  							"suffix <group> <suffix> - Changes a group's suffix."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Group Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}group help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "parent":  					#region Parent  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group parent <group name> [new parent group name]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newParentGroupName = string.Join(" "' args.Parameters.Skip(2));  							if (!string.IsNullOrWhiteSpace(newParentGroupName) && !TShock.Groups.GroupExists(newParentGroupName))  							{  								args.Player.SendErrorMessage("No such group \"{0}\"."' newParentGroupName);  								return;  							}    							try  							{  								TShock.Groups.UpdateGroup(groupName' newParentGroupName' group.Permissions' group.ChatColor' group.Suffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newParentGroupName))  									args.Player.SendSuccessMessage("Parent of group \"{0}\" set to \"{1}\"."' groupName' newParentGroupName);  								else  									args.Player.SendSuccessMessage("Removed parent of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (group.Parent != null)  								args.Player.SendSuccessMessage("Parent of \"{0}\" is \"{1}\"."' group.Name' group.Parent.Name);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no parent."' group.Name);  						}  					}  					#endregion  					return;  				case "suffix":  					#region Suffix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group suffix <group name> [new suffix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newSuffix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' newSuffix' group.Prefix);    								if (!string.IsNullOrWhiteSpace(newSuffix))  									args.Player.SendSuccessMessage("Suffix of group \"{0}\" set to \"{1}\"."' groupName' newSuffix);  								else  									args.Player.SendSuccessMessage("Removed suffix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Suffix))  								args.Player.SendSuccessMessage("Suffix of \"{0}\" is \"{1}\"."' group.Name' group.Suffix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no suffix."' group.Name);  						}  					}  					#endregion  					return;  				case "prefix":  					#region Prefix  					{  						if (args.Parameters.Count < 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group prefix <group name> [new prefix]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count > 2)  						{  							string newPrefix = string.Join(" "' args.Parameters.Skip(2));    							try  							{  								TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' group.ChatColor' group.Suffix' newPrefix);    								if (!string.IsNullOrWhiteSpace(newPrefix))  									args.Player.SendSuccessMessage("Prefix of group \"{0}\" set to \"{1}\"."' groupName' newPrefix);  								else  									args.Player.SendSuccessMessage("Removed prefix of group \"{0}\"."' groupName);  							}  							catch (GroupManagerException ex)  							{  								args.Player.SendErrorMessage(ex.Message);  							}  						}  						else  						{  							if (!string.IsNullOrWhiteSpace(group.Prefix))  								args.Player.SendSuccessMessage("Prefix of \"{0}\" is \"{1}\"."' group.Name' group.Prefix);  							else  								args.Player.SendSuccessMessage("Group \"{0}\" has no prefix."' group.Name);  						}  					}  					#endregion  					return;  				case "color":  					#region Color  					{  						if (args.Parameters.Count < 2 || args.Parameters.Count > 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group color <group name> [new color(000'000'000)]"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						Group group = TShock.Groups.GetGroupByName(groupName);  						if (group == null)  						{  							args.Player.SendErrorMessage("No such group \"{0}\"."' groupName);  							return;  						}    						if (args.Parameters.Count == 3)  						{  							string newColor = args.Parameters[2];    							String[] parts = newColor.Split(''');  							byte r;  							byte g;  							byte b;  							if (parts.Length == 3 && byte.TryParse(parts[0]' out r) && byte.TryParse(parts[1]' out g) && byte.TryParse(parts[2]' out b))  							{  								try  								{  									TShock.Groups.UpdateGroup(groupName' group.ParentName' group.Permissions' newColor' group.Suffix' group.Prefix);    									args.Player.SendSuccessMessage("Color of group \"{0}\" set to \"{1}\"."' groupName' newColor);  								}  								catch (GroupManagerException ex)  								{  									args.Player.SendErrorMessage(ex.Message);  								}  							}  							else  							{  								args.Player.SendErrorMessage("Invalid syntax for color' expected \"rrr'ggg'bbb\"");  							}  						}  						else  						{  							args.Player.SendSuccessMessage("Color of \"{0}\" is \"{1}\"."' group.Name' group.ChatColor);  						}  					}  					#endregion  					return;  				case "rename":  					#region Rename group  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group rename <group> <new name>"' Specifier);  							return;  						}    						string group = args.Parameters[1];  						string newName = args.Parameters[2];  						try  						{  							string response = TShock.Groups.RenameGroup(group' newName);  							args.Player.SendSuccessMessage(response);  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.Message);  						}  					}  					#endregion  					return;  				case "del":  					#region Delete group  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group del <group name>"' Specifier);  							return;  						}    						try  						{  							string response = TShock.Groups.DeleteGroup(args.Parameters[1]);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "delperm":  					#region Delete permissions  					{  						if (args.Parameters.Count < 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group delperm <group name> <permissions...>"' Specifier);  							return;  						}    						string groupName = args.Parameters[1];  						args.Parameters.RemoveRange(0' 2);  						if (groupName == "*")  						{  							foreach (Group g in TShock.Groups)  							{  								TShock.Groups.DeletePermissions(g.Name' args.Parameters);  							}  							args.Player.SendSuccessMessage("Modified all groups.");  							return;  						}  						try  						{  							string response = TShock.Groups.DeletePermissions(groupName' args.Parameters);  							if (response.Length > 0)  							{  								args.Player.SendSuccessMessage(response);  							}  							return;  						}  						catch (GroupManagerException ex)  						{  							args.Player.SendErrorMessage(ex.ToString());  						}  					}  					#endregion  					return;  				case "list":  					#region List groups  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						var groupNames = from grp in TShock.Groups.groups  										 select grp.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(groupNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Groups ({0}/{1}):"'  								FooterFormat = "Type {0}group list {{0}} for more.".SFormat(Specifier)  							});  					}  					#endregion  					return;  				case "listperm":  					#region List permissions  					{  						if (args.Parameters.Count == 1)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}group listperm <group name> [page]"' Specifier);  							return;  						}  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 2' args.Player' out pageNumber))  							return;    						if (!TShock.Groups.GroupExists(args.Parameters[1]))  						{  							args.Player.SendErrorMessage("Invalid group.");  							return;  						}  						Group grp = TShock.Utils.GetGroup(args.Parameters[1]);  						List<string> permissions = grp.TotalPermissions;    						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(permissions)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Permissions for " + grp.Name + " ({0}/{1}):"'  								FooterFormat = "Type {0}group listperm {1} {{0}} for more.".SFormat(Specifier' grp.Name)'  								NothingToDisplayString = "There are currently no permissions for " + grp.Name + "."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ItemBan,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban add <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.AddNewBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Banned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "allow":  					#region Allow group to item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban allow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.AllowGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already allowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "del":  					#region Delete item  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban del <item name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							TShock.Itembans.RemoveBan(EnglishLanguage.GetItemNameById(items[0].type));  							args.Player.SendSuccessMessage("Unbanned " + items[0].Name + ".");  						}  					}  					#endregion  					return;  				case "disallow":  					#region Disllow group from item  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}itemban disallow <item name> <group name>"' Specifier);  							return;  						}    						List<Item> items = TShock.Utils.GetItemByIdOrName(args.Parameters[1]);  						if (items.Count == 0)  						{  							args.Player.SendErrorMessage("Invalid item.");  						}  						else if (items.Count > 1)  						{  							TShock.Utils.SendMultipleMatchError(args.Player' items.Select(i => $"{i.Name}({i.netID})"));  						}  						else  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ItemBan ban = TShock.Itembans.GetItemBanByName(EnglishLanguage.GetItemNameById(items[0].type));  							if (ban == null)  							{  								args.Player.SendErrorMessage("{0} is not banned."' items[0].Name);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.Itembans.RemoveGroup(EnglishLanguage.GetItemNameById(items[0].type)' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  							else  							{  								args.Player.SendWarningMessage("{0} is already disallowed to use {1}."' args.Parameters[2]' items[0].Name);  							}  						}  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <item> - Adds an item ban."'  							"allow <item> <group> - Allows a group to use an item."'  							"del <item> - Deletes an item ban."'  							"disallow <item> <group> - Disallows a group from using an item."'  							"list [page] - Lists all item bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}itemban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List items  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<string> itemNames = from itemBan in TShock.Itembans.ItemBans  														select itemBan.Name;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(itemNames)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Item bans ({0}/{1}):"'  								FooterFormat = "Type {0}itemban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned items."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,ProjectileBan,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban add <proj id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned projectile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to use projectile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to use projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete projectile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							TShock.ProjectileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned projectile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from projectile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}projban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id > 0 && id < Main.maxProjectileTypes)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							ProjectileBan ban = TShock.ProjectileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Projectile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.ProjectileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from using projectile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from using projectile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid projectile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <projectile ID> - Adds a projectile ban."'  							"allow <projectile ID> <group> - Allows a group to use a projectile."'  							"del <projectile ID> - Deletes an projectile ban."'  							"disallow <projectile ID> <group> - Disallows a group from using a projectile."'  							"list [page] - Lists all projectile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}projban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List projectiles  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> projectileIds = from projectileBan in TShock.ProjectileBans.ProjectileBans  														   select projectileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(projectileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Projectile bans ({0}/{1}):"'  								FooterFormat = "Type {0}projban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned projectiles."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,Commands,C:\repos\NyxStudios_TShock\TShockAPI\Commands.cs,TileBan,The following switch statement is missing a default case: switch (subCmd)  			{  				case "add":  					#region Add tile  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban add <tile id>"' Specifier);  							return;  						}  						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.AddNewBan(id);  							args.Player.SendSuccessMessage("Banned tile {0}."' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "allow":  					#region Allow group to place tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban allow <id> <group>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (!ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.AllowGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been allowed to place tile {1}."' args.Parameters[2]' id);  							}  							else  								args.Player.SendWarningMessage("{0} is already allowed to place tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "del":  					#region Delete tile ban  					{  						if (args.Parameters.Count != 2)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban del <id>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							TShock.TileBans.RemoveBan(id);  							args.Player.SendSuccessMessage("Unbanned tile {0}."' id);  							return;  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "disallow":  					#region Disallow group from placing tile  					{  						if (args.Parameters.Count != 3)  						{  							args.Player.SendErrorMessage("Invalid syntax! Proper syntax: {0}tileban disallow <id> <group name>"' Specifier);  							return;  						}    						short id;  						if (Int16.TryParse(args.Parameters[1]' out id) && id >= 0 && id < Main.maxTileSets)  						{  							if (!TShock.Groups.GroupExists(args.Parameters[2]))  							{  								args.Player.SendErrorMessage("Invalid group.");  								return;  							}    							TileBan ban = TShock.TileBans.GetBanById(id);  							if (ban == null)  							{  								args.Player.SendErrorMessage("Tile {0} is not banned."' id);  								return;  							}  							if (ban.AllowedGroups.Contains(args.Parameters[2]))  							{  								TShock.TileBans.RemoveGroup(id' args.Parameters[2]);  								args.Player.SendSuccessMessage("{0} has been disallowed from placing tile {1}."' args.Parameters[2]' id);  								return;  							}  							else  								args.Player.SendWarningMessage("{0} is already prevented from placing tile {1}."' args.Parameters[2]' id);  						}  						else  							args.Player.SendErrorMessage("Invalid tile ID!");  					}  					#endregion  					return;  				case "help":  					#region Help  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;    						var lines = new List<string>  						{  							"add <tile ID> - Adds a tile ban."'  							"allow <tile ID> <group> - Allows a group to place a tile."'  							"del <tile ID> - Deletes a tile ban."'  							"disallow <tile ID> <group> - Disallows a group from place a tile."'  							"list [page] - Lists all tile bans."  						};    						PaginationTools.SendPage(args.Player' pageNumber' lines'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile Ban Sub-Commands ({0}/{1}):"'  								FooterFormat = "Type {0}tileban help {{0}} for more sub-commands.".SFormat(Specifier)  							}  						);  					}  					#endregion  					return;  				case "list":  					#region List tile bans  					{  						int pageNumber;  						if (!PaginationTools.TryParsePageNumber(args.Parameters' 1' args.Player' out pageNumber))  							return;  						IEnumerable<Int16> tileIds = from tileBan in TShock.TileBans.TileBans  													 select tileBan.ID;  						PaginationTools.SendPage(args.Player' pageNumber' PaginationTools.BuildLinesFromTerms(tileIds)'  							new PaginationTools.Settings  							{  								HeaderFormat = "Tile bans ({0}/{1}):"'  								FooterFormat = "Type {0}tileban list {{0}} for more.".SFormat(Specifier)'  								NothingToDisplayString = "There are currently no banned tiles."  							});  					}  					#endregion  					return;  			}
Missing Default,TShockAPI,GetDataHandlers,C:\repos\NyxStudios_TShock\TShockAPI\GetDataHandlers.cs,HandleSpawnBoss,The following switch statement is missing a default case: switch (Type)  				{  					case -1:  					case -2:  					case -3:  					case -4:  					case -5:  					case -6:  					case -7:  					case -8:  						invasion = true;  						break;  					case 4:  					case 13:  					case 50:  					case 75:  					case 125:  					case 126:  					case 127:  					case 128:  					case 129:  					case 130:  					case 131:  					case 134:  					case 222:  					case 245:  					case 266:  					case 370:  					case 398:  					case 422:  					case 439:  					case 493:  					case 507:  					case 517:  						spawnboss = true;  						break;  				}
Missing Default,TShockAPI,TShock,C:\repos\NyxStudios_TShock\TShockAPI\TShock.cs,OnSecondUpdate,The following switch statement is missing a default case: switch (Config.ForceTime)  				{  					case "day":  						TSPlayer.Server.SetTime(true' 27000.0);  						break;  					case "night":  						TSPlayer.Server.SetTime(false' 16200.0);  						break;  				}
Missing Default,TShockAPI.Extensions,RandomExt,C:\repos\NyxStudios_TShock\TShockAPI\Extensions\RandomExt.cs,NextString,The following switch statement is missing a default case: switch (rand.Next(0' 3))  				{  					case 0:  						sb.Append((char) rand.Next('a'' 'z' + 1));  						break;  					case 1:  						sb.Append((char) rand.Next('A'' 'Z' + 1));  						break;  					case 2:  						sb.Append((char) rand.Next('0'' '9' + 1));  						break;  				}
